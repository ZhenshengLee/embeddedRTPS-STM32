
embedded_rtps_stm32.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00010600  08000200  08000200  00010200  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000166c  08010800  08010800  00020800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000454  08011e6c  08011e6c  00021e6c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM          00000558  080122c0  080122c0  000222c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .init_array   00000004  08012818  08012818  00022818  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .fini_array   00000004  0801281c  0801281c  0002281c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .data         00000080  20000000  08012820  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          0000b71c  20000080  080128a0  00030080  2**2
                  ALLOC
  9 ._user_heap_stack 00000604  2000b79c  080128a0  0003b79c  2**0
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  00030080  2**0
                  CONTENTS, READONLY
 11 .debug_info   000be77f  00000000  00000000  000300ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000f636  00000000  00000000  000ee82d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00027ee6  00000000  00000000  000fde63  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00002bd0  00000000  00000000  00125d50  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00003a28  00000000  00000000  00128920  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  0004182d  00000000  00000000  0012c348  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00043c45  00000000  00000000  0016db75  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0012faab  00000000  00000000  001b17ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  002e1265  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000093e8  00000000  00000000  002e12e0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000200 <__do_global_dtors_aux>:
 8000200:	b510      	push	{r4, lr}
 8000202:	4c05      	ldr	r4, [pc, #20]	; (8000218 <__do_global_dtors_aux+0x18>)
 8000204:	7823      	ldrb	r3, [r4, #0]
 8000206:	b933      	cbnz	r3, 8000216 <__do_global_dtors_aux+0x16>
 8000208:	4b04      	ldr	r3, [pc, #16]	; (800021c <__do_global_dtors_aux+0x1c>)
 800020a:	b113      	cbz	r3, 8000212 <__do_global_dtors_aux+0x12>
 800020c:	4804      	ldr	r0, [pc, #16]	; (8000220 <__do_global_dtors_aux+0x20>)
 800020e:	f3af 8000 	nop.w
 8000212:	2301      	movs	r3, #1
 8000214:	7023      	strb	r3, [r4, #0]
 8000216:	bd10      	pop	{r4, pc}
 8000218:	20000080 	.word	0x20000080
 800021c:	00000000 	.word	0x00000000
 8000220:	080107e8 	.word	0x080107e8

08000224 <frame_dummy>:
 8000224:	b508      	push	{r3, lr}
 8000226:	4b03      	ldr	r3, [pc, #12]	; (8000234 <frame_dummy+0x10>)
 8000228:	b11b      	cbz	r3, 8000232 <frame_dummy+0xe>
 800022a:	4903      	ldr	r1, [pc, #12]	; (8000238 <frame_dummy+0x14>)
 800022c:	4803      	ldr	r0, [pc, #12]	; (800023c <frame_dummy+0x18>)
 800022e:	f3af 8000 	nop.w
 8000232:	bd08      	pop	{r3, pc}
 8000234:	00000000 	.word	0x00000000
 8000238:	20000084 	.word	0x20000084
 800023c:	080107e8 	.word	0x080107e8

08000240 <strcmp>:
 8000240:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000244:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000248:	2a01      	cmp	r2, #1
 800024a:	bf28      	it	cs
 800024c:	429a      	cmpcs	r2, r3
 800024e:	d0f7      	beq.n	8000240 <strcmp>
 8000250:	1ad0      	subs	r0, r2, r3
 8000252:	4770      	bx	lr

08000254 <strlen>:
 8000254:	4603      	mov	r3, r0
 8000256:	f813 2b01 	ldrb.w	r2, [r3], #1
 800025a:	2a00      	cmp	r2, #0
 800025c:	d1fb      	bne.n	8000256 <strlen+0x2>
 800025e:	1a18      	subs	r0, r3, r0
 8000260:	3801      	subs	r0, #1
 8000262:	4770      	bx	lr
	...

08000270 <memchr>:
 8000270:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000274:	2a10      	cmp	r2, #16
 8000276:	db2b      	blt.n	80002d0 <memchr+0x60>
 8000278:	f010 0f07 	tst.w	r0, #7
 800027c:	d008      	beq.n	8000290 <memchr+0x20>
 800027e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000282:	3a01      	subs	r2, #1
 8000284:	428b      	cmp	r3, r1
 8000286:	d02d      	beq.n	80002e4 <memchr+0x74>
 8000288:	f010 0f07 	tst.w	r0, #7
 800028c:	b342      	cbz	r2, 80002e0 <memchr+0x70>
 800028e:	d1f6      	bne.n	800027e <memchr+0xe>
 8000290:	b4f0      	push	{r4, r5, r6, r7}
 8000292:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000296:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800029a:	f022 0407 	bic.w	r4, r2, #7
 800029e:	f07f 0700 	mvns.w	r7, #0
 80002a2:	2300      	movs	r3, #0
 80002a4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 80002a8:	3c08      	subs	r4, #8
 80002aa:	ea85 0501 	eor.w	r5, r5, r1
 80002ae:	ea86 0601 	eor.w	r6, r6, r1
 80002b2:	fa85 f547 	uadd8	r5, r5, r7
 80002b6:	faa3 f587 	sel	r5, r3, r7
 80002ba:	fa86 f647 	uadd8	r6, r6, r7
 80002be:	faa5 f687 	sel	r6, r5, r7
 80002c2:	b98e      	cbnz	r6, 80002e8 <memchr+0x78>
 80002c4:	d1ee      	bne.n	80002a4 <memchr+0x34>
 80002c6:	bcf0      	pop	{r4, r5, r6, r7}
 80002c8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80002cc:	f002 0207 	and.w	r2, r2, #7
 80002d0:	b132      	cbz	r2, 80002e0 <memchr+0x70>
 80002d2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80002d6:	3a01      	subs	r2, #1
 80002d8:	ea83 0301 	eor.w	r3, r3, r1
 80002dc:	b113      	cbz	r3, 80002e4 <memchr+0x74>
 80002de:	d1f8      	bne.n	80002d2 <memchr+0x62>
 80002e0:	2000      	movs	r0, #0
 80002e2:	4770      	bx	lr
 80002e4:	3801      	subs	r0, #1
 80002e6:	4770      	bx	lr
 80002e8:	2d00      	cmp	r5, #0
 80002ea:	bf06      	itte	eq
 80002ec:	4635      	moveq	r5, r6
 80002ee:	3803      	subeq	r0, #3
 80002f0:	3807      	subne	r0, #7
 80002f2:	f015 0f01 	tst.w	r5, #1
 80002f6:	d107      	bne.n	8000308 <memchr+0x98>
 80002f8:	3001      	adds	r0, #1
 80002fa:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002fe:	bf02      	ittt	eq
 8000300:	3001      	addeq	r0, #1
 8000302:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000306:	3001      	addeq	r0, #1
 8000308:	bcf0      	pop	{r4, r5, r6, r7}
 800030a:	3801      	subs	r0, #1
 800030c:	4770      	bx	lr
 800030e:	bf00      	nop

08000310 <__aeabi_uldivmod>:
 8000310:	b953      	cbnz	r3, 8000328 <__aeabi_uldivmod+0x18>
 8000312:	b94a      	cbnz	r2, 8000328 <__aeabi_uldivmod+0x18>
 8000314:	2900      	cmp	r1, #0
 8000316:	bf08      	it	eq
 8000318:	2800      	cmpeq	r0, #0
 800031a:	bf1c      	itt	ne
 800031c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000320:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000324:	f001 b8f8 	b.w	8001518 <__aeabi_idiv0>
 8000328:	f1ad 0c08 	sub.w	ip, sp, #8
 800032c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000330:	f000 f806 	bl	8000340 <__udivmoddi4>
 8000334:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000338:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800033c:	b004      	add	sp, #16
 800033e:	4770      	bx	lr

08000340 <__udivmoddi4>:
 8000340:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000344:	9e08      	ldr	r6, [sp, #32]
 8000346:	4604      	mov	r4, r0
 8000348:	4688      	mov	r8, r1
 800034a:	2b00      	cmp	r3, #0
 800034c:	d14b      	bne.n	80003e6 <__udivmoddi4+0xa6>
 800034e:	428a      	cmp	r2, r1
 8000350:	4615      	mov	r5, r2
 8000352:	d967      	bls.n	8000424 <__udivmoddi4+0xe4>
 8000354:	fab2 f282 	clz	r2, r2
 8000358:	b14a      	cbz	r2, 800036e <__udivmoddi4+0x2e>
 800035a:	f1c2 0720 	rsb	r7, r2, #32
 800035e:	fa01 f302 	lsl.w	r3, r1, r2
 8000362:	fa20 f707 	lsr.w	r7, r0, r7
 8000366:	4095      	lsls	r5, r2
 8000368:	ea47 0803 	orr.w	r8, r7, r3
 800036c:	4094      	lsls	r4, r2
 800036e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000372:	0c23      	lsrs	r3, r4, #16
 8000374:	fbb8 f7fe 	udiv	r7, r8, lr
 8000378:	fa1f fc85 	uxth.w	ip, r5
 800037c:	fb0e 8817 	mls	r8, lr, r7, r8
 8000380:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000384:	fb07 f10c 	mul.w	r1, r7, ip
 8000388:	4299      	cmp	r1, r3
 800038a:	d909      	bls.n	80003a0 <__udivmoddi4+0x60>
 800038c:	18eb      	adds	r3, r5, r3
 800038e:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 8000392:	f080 811b 	bcs.w	80005cc <__udivmoddi4+0x28c>
 8000396:	4299      	cmp	r1, r3
 8000398:	f240 8118 	bls.w	80005cc <__udivmoddi4+0x28c>
 800039c:	3f02      	subs	r7, #2
 800039e:	442b      	add	r3, r5
 80003a0:	1a5b      	subs	r3, r3, r1
 80003a2:	b2a4      	uxth	r4, r4
 80003a4:	fbb3 f0fe 	udiv	r0, r3, lr
 80003a8:	fb0e 3310 	mls	r3, lr, r0, r3
 80003ac:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80003b0:	fb00 fc0c 	mul.w	ip, r0, ip
 80003b4:	45a4      	cmp	ip, r4
 80003b6:	d909      	bls.n	80003cc <__udivmoddi4+0x8c>
 80003b8:	192c      	adds	r4, r5, r4
 80003ba:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80003be:	f080 8107 	bcs.w	80005d0 <__udivmoddi4+0x290>
 80003c2:	45a4      	cmp	ip, r4
 80003c4:	f240 8104 	bls.w	80005d0 <__udivmoddi4+0x290>
 80003c8:	3802      	subs	r0, #2
 80003ca:	442c      	add	r4, r5
 80003cc:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 80003d0:	eba4 040c 	sub.w	r4, r4, ip
 80003d4:	2700      	movs	r7, #0
 80003d6:	b11e      	cbz	r6, 80003e0 <__udivmoddi4+0xa0>
 80003d8:	40d4      	lsrs	r4, r2
 80003da:	2300      	movs	r3, #0
 80003dc:	e9c6 4300 	strd	r4, r3, [r6]
 80003e0:	4639      	mov	r1, r7
 80003e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003e6:	428b      	cmp	r3, r1
 80003e8:	d909      	bls.n	80003fe <__udivmoddi4+0xbe>
 80003ea:	2e00      	cmp	r6, #0
 80003ec:	f000 80eb 	beq.w	80005c6 <__udivmoddi4+0x286>
 80003f0:	2700      	movs	r7, #0
 80003f2:	e9c6 0100 	strd	r0, r1, [r6]
 80003f6:	4638      	mov	r0, r7
 80003f8:	4639      	mov	r1, r7
 80003fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003fe:	fab3 f783 	clz	r7, r3
 8000402:	2f00      	cmp	r7, #0
 8000404:	d147      	bne.n	8000496 <__udivmoddi4+0x156>
 8000406:	428b      	cmp	r3, r1
 8000408:	d302      	bcc.n	8000410 <__udivmoddi4+0xd0>
 800040a:	4282      	cmp	r2, r0
 800040c:	f200 80fa 	bhi.w	8000604 <__udivmoddi4+0x2c4>
 8000410:	1a84      	subs	r4, r0, r2
 8000412:	eb61 0303 	sbc.w	r3, r1, r3
 8000416:	2001      	movs	r0, #1
 8000418:	4698      	mov	r8, r3
 800041a:	2e00      	cmp	r6, #0
 800041c:	d0e0      	beq.n	80003e0 <__udivmoddi4+0xa0>
 800041e:	e9c6 4800 	strd	r4, r8, [r6]
 8000422:	e7dd      	b.n	80003e0 <__udivmoddi4+0xa0>
 8000424:	b902      	cbnz	r2, 8000428 <__udivmoddi4+0xe8>
 8000426:	deff      	udf	#255	; 0xff
 8000428:	fab2 f282 	clz	r2, r2
 800042c:	2a00      	cmp	r2, #0
 800042e:	f040 808f 	bne.w	8000550 <__udivmoddi4+0x210>
 8000432:	1b49      	subs	r1, r1, r5
 8000434:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000438:	fa1f f885 	uxth.w	r8, r5
 800043c:	2701      	movs	r7, #1
 800043e:	fbb1 fcfe 	udiv	ip, r1, lr
 8000442:	0c23      	lsrs	r3, r4, #16
 8000444:	fb0e 111c 	mls	r1, lr, ip, r1
 8000448:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800044c:	fb08 f10c 	mul.w	r1, r8, ip
 8000450:	4299      	cmp	r1, r3
 8000452:	d907      	bls.n	8000464 <__udivmoddi4+0x124>
 8000454:	18eb      	adds	r3, r5, r3
 8000456:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 800045a:	d202      	bcs.n	8000462 <__udivmoddi4+0x122>
 800045c:	4299      	cmp	r1, r3
 800045e:	f200 80cd 	bhi.w	80005fc <__udivmoddi4+0x2bc>
 8000462:	4684      	mov	ip, r0
 8000464:	1a59      	subs	r1, r3, r1
 8000466:	b2a3      	uxth	r3, r4
 8000468:	fbb1 f0fe 	udiv	r0, r1, lr
 800046c:	fb0e 1410 	mls	r4, lr, r0, r1
 8000470:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 8000474:	fb08 f800 	mul.w	r8, r8, r0
 8000478:	45a0      	cmp	r8, r4
 800047a:	d907      	bls.n	800048c <__udivmoddi4+0x14c>
 800047c:	192c      	adds	r4, r5, r4
 800047e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000482:	d202      	bcs.n	800048a <__udivmoddi4+0x14a>
 8000484:	45a0      	cmp	r8, r4
 8000486:	f200 80b6 	bhi.w	80005f6 <__udivmoddi4+0x2b6>
 800048a:	4618      	mov	r0, r3
 800048c:	eba4 0408 	sub.w	r4, r4, r8
 8000490:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000494:	e79f      	b.n	80003d6 <__udivmoddi4+0x96>
 8000496:	f1c7 0c20 	rsb	ip, r7, #32
 800049a:	40bb      	lsls	r3, r7
 800049c:	fa22 fe0c 	lsr.w	lr, r2, ip
 80004a0:	ea4e 0e03 	orr.w	lr, lr, r3
 80004a4:	fa01 f407 	lsl.w	r4, r1, r7
 80004a8:	fa20 f50c 	lsr.w	r5, r0, ip
 80004ac:	fa21 f30c 	lsr.w	r3, r1, ip
 80004b0:	ea4f 481e 	mov.w	r8, lr, lsr #16
 80004b4:	4325      	orrs	r5, r4
 80004b6:	fbb3 f9f8 	udiv	r9, r3, r8
 80004ba:	0c2c      	lsrs	r4, r5, #16
 80004bc:	fb08 3319 	mls	r3, r8, r9, r3
 80004c0:	fa1f fa8e 	uxth.w	sl, lr
 80004c4:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 80004c8:	fb09 f40a 	mul.w	r4, r9, sl
 80004cc:	429c      	cmp	r4, r3
 80004ce:	fa02 f207 	lsl.w	r2, r2, r7
 80004d2:	fa00 f107 	lsl.w	r1, r0, r7
 80004d6:	d90b      	bls.n	80004f0 <__udivmoddi4+0x1b0>
 80004d8:	eb1e 0303 	adds.w	r3, lr, r3
 80004dc:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 80004e0:	f080 8087 	bcs.w	80005f2 <__udivmoddi4+0x2b2>
 80004e4:	429c      	cmp	r4, r3
 80004e6:	f240 8084 	bls.w	80005f2 <__udivmoddi4+0x2b2>
 80004ea:	f1a9 0902 	sub.w	r9, r9, #2
 80004ee:	4473      	add	r3, lr
 80004f0:	1b1b      	subs	r3, r3, r4
 80004f2:	b2ad      	uxth	r5, r5
 80004f4:	fbb3 f0f8 	udiv	r0, r3, r8
 80004f8:	fb08 3310 	mls	r3, r8, r0, r3
 80004fc:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000500:	fb00 fa0a 	mul.w	sl, r0, sl
 8000504:	45a2      	cmp	sl, r4
 8000506:	d908      	bls.n	800051a <__udivmoddi4+0x1da>
 8000508:	eb1e 0404 	adds.w	r4, lr, r4
 800050c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000510:	d26b      	bcs.n	80005ea <__udivmoddi4+0x2aa>
 8000512:	45a2      	cmp	sl, r4
 8000514:	d969      	bls.n	80005ea <__udivmoddi4+0x2aa>
 8000516:	3802      	subs	r0, #2
 8000518:	4474      	add	r4, lr
 800051a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800051e:	fba0 8902 	umull	r8, r9, r0, r2
 8000522:	eba4 040a 	sub.w	r4, r4, sl
 8000526:	454c      	cmp	r4, r9
 8000528:	46c2      	mov	sl, r8
 800052a:	464b      	mov	r3, r9
 800052c:	d354      	bcc.n	80005d8 <__udivmoddi4+0x298>
 800052e:	d051      	beq.n	80005d4 <__udivmoddi4+0x294>
 8000530:	2e00      	cmp	r6, #0
 8000532:	d069      	beq.n	8000608 <__udivmoddi4+0x2c8>
 8000534:	ebb1 050a 	subs.w	r5, r1, sl
 8000538:	eb64 0403 	sbc.w	r4, r4, r3
 800053c:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000540:	40fd      	lsrs	r5, r7
 8000542:	40fc      	lsrs	r4, r7
 8000544:	ea4c 0505 	orr.w	r5, ip, r5
 8000548:	e9c6 5400 	strd	r5, r4, [r6]
 800054c:	2700      	movs	r7, #0
 800054e:	e747      	b.n	80003e0 <__udivmoddi4+0xa0>
 8000550:	f1c2 0320 	rsb	r3, r2, #32
 8000554:	fa20 f703 	lsr.w	r7, r0, r3
 8000558:	4095      	lsls	r5, r2
 800055a:	fa01 f002 	lsl.w	r0, r1, r2
 800055e:	fa21 f303 	lsr.w	r3, r1, r3
 8000562:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000566:	4338      	orrs	r0, r7
 8000568:	0c01      	lsrs	r1, r0, #16
 800056a:	fbb3 f7fe 	udiv	r7, r3, lr
 800056e:	fa1f f885 	uxth.w	r8, r5
 8000572:	fb0e 3317 	mls	r3, lr, r7, r3
 8000576:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800057a:	fb07 f308 	mul.w	r3, r7, r8
 800057e:	428b      	cmp	r3, r1
 8000580:	fa04 f402 	lsl.w	r4, r4, r2
 8000584:	d907      	bls.n	8000596 <__udivmoddi4+0x256>
 8000586:	1869      	adds	r1, r5, r1
 8000588:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 800058c:	d22f      	bcs.n	80005ee <__udivmoddi4+0x2ae>
 800058e:	428b      	cmp	r3, r1
 8000590:	d92d      	bls.n	80005ee <__udivmoddi4+0x2ae>
 8000592:	3f02      	subs	r7, #2
 8000594:	4429      	add	r1, r5
 8000596:	1acb      	subs	r3, r1, r3
 8000598:	b281      	uxth	r1, r0
 800059a:	fbb3 f0fe 	udiv	r0, r3, lr
 800059e:	fb0e 3310 	mls	r3, lr, r0, r3
 80005a2:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80005a6:	fb00 f308 	mul.w	r3, r0, r8
 80005aa:	428b      	cmp	r3, r1
 80005ac:	d907      	bls.n	80005be <__udivmoddi4+0x27e>
 80005ae:	1869      	adds	r1, r5, r1
 80005b0:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 80005b4:	d217      	bcs.n	80005e6 <__udivmoddi4+0x2a6>
 80005b6:	428b      	cmp	r3, r1
 80005b8:	d915      	bls.n	80005e6 <__udivmoddi4+0x2a6>
 80005ba:	3802      	subs	r0, #2
 80005bc:	4429      	add	r1, r5
 80005be:	1ac9      	subs	r1, r1, r3
 80005c0:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 80005c4:	e73b      	b.n	800043e <__udivmoddi4+0xfe>
 80005c6:	4637      	mov	r7, r6
 80005c8:	4630      	mov	r0, r6
 80005ca:	e709      	b.n	80003e0 <__udivmoddi4+0xa0>
 80005cc:	4607      	mov	r7, r0
 80005ce:	e6e7      	b.n	80003a0 <__udivmoddi4+0x60>
 80005d0:	4618      	mov	r0, r3
 80005d2:	e6fb      	b.n	80003cc <__udivmoddi4+0x8c>
 80005d4:	4541      	cmp	r1, r8
 80005d6:	d2ab      	bcs.n	8000530 <__udivmoddi4+0x1f0>
 80005d8:	ebb8 0a02 	subs.w	sl, r8, r2
 80005dc:	eb69 020e 	sbc.w	r2, r9, lr
 80005e0:	3801      	subs	r0, #1
 80005e2:	4613      	mov	r3, r2
 80005e4:	e7a4      	b.n	8000530 <__udivmoddi4+0x1f0>
 80005e6:	4660      	mov	r0, ip
 80005e8:	e7e9      	b.n	80005be <__udivmoddi4+0x27e>
 80005ea:	4618      	mov	r0, r3
 80005ec:	e795      	b.n	800051a <__udivmoddi4+0x1da>
 80005ee:	4667      	mov	r7, ip
 80005f0:	e7d1      	b.n	8000596 <__udivmoddi4+0x256>
 80005f2:	4681      	mov	r9, r0
 80005f4:	e77c      	b.n	80004f0 <__udivmoddi4+0x1b0>
 80005f6:	3802      	subs	r0, #2
 80005f8:	442c      	add	r4, r5
 80005fa:	e747      	b.n	800048c <__udivmoddi4+0x14c>
 80005fc:	f1ac 0c02 	sub.w	ip, ip, #2
 8000600:	442b      	add	r3, r5
 8000602:	e72f      	b.n	8000464 <__udivmoddi4+0x124>
 8000604:	4638      	mov	r0, r7
 8000606:	e708      	b.n	800041a <__udivmoddi4+0xda>
 8000608:	4637      	mov	r7, r6
 800060a:	e6e9      	b.n	80003e0 <__udivmoddi4+0xa0>

0800060c <selfrel_offset31>:
 800060c:	6803      	ldr	r3, [r0, #0]
 800060e:	005a      	lsls	r2, r3, #1
 8000610:	bf4c      	ite	mi
 8000612:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 8000616:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
 800061a:	4418      	add	r0, r3
 800061c:	4770      	bx	lr
 800061e:	bf00      	nop

08000620 <search_EIT_table>:
 8000620:	b361      	cbz	r1, 800067c <search_EIT_table+0x5c>
 8000622:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000626:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
 800062a:	4690      	mov	r8, r2
 800062c:	4606      	mov	r6, r0
 800062e:	46d1      	mov	r9, sl
 8000630:	2700      	movs	r7, #0
 8000632:	eb07 0409 	add.w	r4, r7, r9
 8000636:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
 800063a:	1064      	asrs	r4, r4, #1
 800063c:	00e5      	lsls	r5, r4, #3
 800063e:	1971      	adds	r1, r6, r5
 8000640:	4608      	mov	r0, r1
 8000642:	f7ff ffe3 	bl	800060c <selfrel_offset31>
 8000646:	45a2      	cmp	sl, r4
 8000648:	4683      	mov	fp, r0
 800064a:	f105 0008 	add.w	r0, r5, #8
 800064e:	4430      	add	r0, r6
 8000650:	d009      	beq.n	8000666 <search_EIT_table+0x46>
 8000652:	f7ff ffdb 	bl	800060c <selfrel_offset31>
 8000656:	45c3      	cmp	fp, r8
 8000658:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 800065c:	d805      	bhi.n	800066a <search_EIT_table+0x4a>
 800065e:	4540      	cmp	r0, r8
 8000660:	d209      	bcs.n	8000676 <search_EIT_table+0x56>
 8000662:	1c67      	adds	r7, r4, #1
 8000664:	e7e5      	b.n	8000632 <search_EIT_table+0x12>
 8000666:	45c3      	cmp	fp, r8
 8000668:	d905      	bls.n	8000676 <search_EIT_table+0x56>
 800066a:	42a7      	cmp	r7, r4
 800066c:	d002      	beq.n	8000674 <search_EIT_table+0x54>
 800066e:	f104 39ff 	add.w	r9, r4, #4294967295	; 0xffffffff
 8000672:	e7de      	b.n	8000632 <search_EIT_table+0x12>
 8000674:	2100      	movs	r1, #0
 8000676:	4608      	mov	r0, r1
 8000678:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800067c:	4608      	mov	r0, r1
 800067e:	4770      	bx	lr

08000680 <__gnu_unwind_get_pr_addr>:
 8000680:	2801      	cmp	r0, #1
 8000682:	d007      	beq.n	8000694 <__gnu_unwind_get_pr_addr+0x14>
 8000684:	2802      	cmp	r0, #2
 8000686:	d007      	beq.n	8000698 <__gnu_unwind_get_pr_addr+0x18>
 8000688:	4b04      	ldr	r3, [pc, #16]	; (800069c <__gnu_unwind_get_pr_addr+0x1c>)
 800068a:	2800      	cmp	r0, #0
 800068c:	bf0c      	ite	eq
 800068e:	4618      	moveq	r0, r3
 8000690:	2000      	movne	r0, #0
 8000692:	4770      	bx	lr
 8000694:	4802      	ldr	r0, [pc, #8]	; (80006a0 <__gnu_unwind_get_pr_addr+0x20>)
 8000696:	4770      	bx	lr
 8000698:	4802      	ldr	r0, [pc, #8]	; (80006a4 <__gnu_unwind_get_pr_addr+0x24>)
 800069a:	4770      	bx	lr
 800069c:	08000d6d 	.word	0x08000d6d
 80006a0:	08000d71 	.word	0x08000d71
 80006a4:	08000d75 	.word	0x08000d75

080006a8 <get_eit_entry>:
 80006a8:	b530      	push	{r4, r5, lr}
 80006aa:	4b25      	ldr	r3, [pc, #148]	; (8000740 <get_eit_entry+0x98>)
 80006ac:	b083      	sub	sp, #12
 80006ae:	4604      	mov	r4, r0
 80006b0:	1e8d      	subs	r5, r1, #2
 80006b2:	b34b      	cbz	r3, 8000708 <get_eit_entry+0x60>
 80006b4:	a901      	add	r1, sp, #4
 80006b6:	4628      	mov	r0, r5
 80006b8:	f3af 8000 	nop.w
 80006bc:	b1f0      	cbz	r0, 80006fc <get_eit_entry+0x54>
 80006be:	9901      	ldr	r1, [sp, #4]
 80006c0:	462a      	mov	r2, r5
 80006c2:	f7ff ffad 	bl	8000620 <search_EIT_table>
 80006c6:	4601      	mov	r1, r0
 80006c8:	b1c0      	cbz	r0, 80006fc <get_eit_entry+0x54>
 80006ca:	f7ff ff9f 	bl	800060c <selfrel_offset31>
 80006ce:	684b      	ldr	r3, [r1, #4]
 80006d0:	64a0      	str	r0, [r4, #72]	; 0x48
 80006d2:	2b01      	cmp	r3, #1
 80006d4:	d02e      	beq.n	8000734 <get_eit_entry+0x8c>
 80006d6:	2b00      	cmp	r3, #0
 80006d8:	f101 0004 	add.w	r0, r1, #4
 80006dc:	db26      	blt.n	800072c <get_eit_entry+0x84>
 80006de:	f7ff ff95 	bl	800060c <selfrel_offset31>
 80006e2:	2300      	movs	r3, #0
 80006e4:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
 80006e8:	6803      	ldr	r3, [r0, #0]
 80006ea:	2b00      	cmp	r3, #0
 80006ec:	db12      	blt.n	8000714 <get_eit_entry+0x6c>
 80006ee:	f7ff ff8d 	bl	800060c <selfrel_offset31>
 80006f2:	2300      	movs	r3, #0
 80006f4:	6120      	str	r0, [r4, #16]
 80006f6:	4618      	mov	r0, r3
 80006f8:	b003      	add	sp, #12
 80006fa:	bd30      	pop	{r4, r5, pc}
 80006fc:	2300      	movs	r3, #0
 80006fe:	6123      	str	r3, [r4, #16]
 8000700:	2309      	movs	r3, #9
 8000702:	4618      	mov	r0, r3
 8000704:	b003      	add	sp, #12
 8000706:	bd30      	pop	{r4, r5, pc}
 8000708:	490e      	ldr	r1, [pc, #56]	; (8000744 <get_eit_entry+0x9c>)
 800070a:	480f      	ldr	r0, [pc, #60]	; (8000748 <get_eit_entry+0xa0>)
 800070c:	1a09      	subs	r1, r1, r0
 800070e:	10c9      	asrs	r1, r1, #3
 8000710:	9101      	str	r1, [sp, #4]
 8000712:	e7d5      	b.n	80006c0 <get_eit_entry+0x18>
 8000714:	f3c3 6003 	ubfx	r0, r3, #24, #4
 8000718:	f7ff ffb2 	bl	8000680 <__gnu_unwind_get_pr_addr>
 800071c:	2800      	cmp	r0, #0
 800071e:	bf14      	ite	ne
 8000720:	2300      	movne	r3, #0
 8000722:	2309      	moveq	r3, #9
 8000724:	6120      	str	r0, [r4, #16]
 8000726:	4618      	mov	r0, r3
 8000728:	b003      	add	sp, #12
 800072a:	bd30      	pop	{r4, r5, pc}
 800072c:	2301      	movs	r3, #1
 800072e:	e9c4 0313 	strd	r0, r3, [r4, #76]	; 0x4c
 8000732:	e7d9      	b.n	80006e8 <get_eit_entry+0x40>
 8000734:	2300      	movs	r3, #0
 8000736:	6123      	str	r3, [r4, #16]
 8000738:	2305      	movs	r3, #5
 800073a:	4618      	mov	r0, r3
 800073c:	b003      	add	sp, #12
 800073e:	bd30      	pop	{r4, r5, pc}
 8000740:	00000000 	.word	0x00000000
 8000744:	08012818 	.word	0x08012818
 8000748:	080122c0 	.word	0x080122c0

0800074c <restore_non_core_regs>:
 800074c:	6803      	ldr	r3, [r0, #0]
 800074e:	07da      	lsls	r2, r3, #31
 8000750:	b510      	push	{r4, lr}
 8000752:	4604      	mov	r4, r0
 8000754:	d406      	bmi.n	8000764 <restore_non_core_regs+0x18>
 8000756:	079b      	lsls	r3, r3, #30
 8000758:	f100 0048 	add.w	r0, r0, #72	; 0x48
 800075c:	d509      	bpl.n	8000772 <restore_non_core_regs+0x26>
 800075e:	f000 fc5f 	bl	8001020 <__gnu_Unwind_Restore_VFP_D>
 8000762:	6823      	ldr	r3, [r4, #0]
 8000764:	0759      	lsls	r1, r3, #29
 8000766:	d509      	bpl.n	800077c <restore_non_core_regs+0x30>
 8000768:	071a      	lsls	r2, r3, #28
 800076a:	d50e      	bpl.n	800078a <restore_non_core_regs+0x3e>
 800076c:	06db      	lsls	r3, r3, #27
 800076e:	d513      	bpl.n	8000798 <restore_non_core_regs+0x4c>
 8000770:	bd10      	pop	{r4, pc}
 8000772:	f000 fc4d 	bl	8001010 <__gnu_Unwind_Restore_VFP>
 8000776:	6823      	ldr	r3, [r4, #0]
 8000778:	0759      	lsls	r1, r3, #29
 800077a:	d4f5      	bmi.n	8000768 <restore_non_core_regs+0x1c>
 800077c:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8000780:	f000 fc56 	bl	8001030 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 8000784:	6823      	ldr	r3, [r4, #0]
 8000786:	071a      	lsls	r2, r3, #28
 8000788:	d4f0      	bmi.n	800076c <restore_non_core_regs+0x20>
 800078a:	f504 70a8 	add.w	r0, r4, #336	; 0x150
 800078e:	f000 fc57 	bl	8001040 <__gnu_Unwind_Restore_WMMXD>
 8000792:	6823      	ldr	r3, [r4, #0]
 8000794:	06db      	lsls	r3, r3, #27
 8000796:	d4eb      	bmi.n	8000770 <restore_non_core_regs+0x24>
 8000798:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
 800079c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80007a0:	f000 bc92 	b.w	80010c8 <__gnu_Unwind_Restore_WMMXC>

080007a4 <_Unwind_decode_typeinfo_ptr.isra.0>:
 80007a4:	6803      	ldr	r3, [r0, #0]
 80007a6:	b103      	cbz	r3, 80007aa <_Unwind_decode_typeinfo_ptr.isra.0+0x6>
 80007a8:	4403      	add	r3, r0
 80007aa:	4618      	mov	r0, r3
 80007ac:	4770      	bx	lr
 80007ae:	bf00      	nop

080007b0 <__gnu_unwind_24bit.isra.1>:
 80007b0:	2009      	movs	r0, #9
 80007b2:	4770      	bx	lr

080007b4 <_Unwind_DebugHook>:
 80007b4:	4770      	bx	lr
 80007b6:	bf00      	nop

080007b8 <unwind_phase2>:
 80007b8:	b570      	push	{r4, r5, r6, lr}
 80007ba:	4604      	mov	r4, r0
 80007bc:	460d      	mov	r5, r1
 80007be:	e008      	b.n	80007d2 <unwind_phase2+0x1a>
 80007c0:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80007c2:	6163      	str	r3, [r4, #20]
 80007c4:	462a      	mov	r2, r5
 80007c6:	6923      	ldr	r3, [r4, #16]
 80007c8:	4621      	mov	r1, r4
 80007ca:	2001      	movs	r0, #1
 80007cc:	4798      	blx	r3
 80007ce:	2808      	cmp	r0, #8
 80007d0:	d108      	bne.n	80007e4 <unwind_phase2+0x2c>
 80007d2:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80007d4:	4620      	mov	r0, r4
 80007d6:	f7ff ff67 	bl	80006a8 <get_eit_entry>
 80007da:	4606      	mov	r6, r0
 80007dc:	2800      	cmp	r0, #0
 80007de:	d0ef      	beq.n	80007c0 <unwind_phase2+0x8>
 80007e0:	f00e fe0b 	bl	800f3fa <abort>
 80007e4:	2807      	cmp	r0, #7
 80007e6:	d1fb      	bne.n	80007e0 <unwind_phase2+0x28>
 80007e8:	4630      	mov	r0, r6
 80007ea:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80007ec:	f7ff ffe2 	bl	80007b4 <_Unwind_DebugHook>
 80007f0:	1d28      	adds	r0, r5, #4
 80007f2:	f000 fc01 	bl	8000ff8 <__restore_core_regs>
 80007f6:	bf00      	nop

080007f8 <unwind_phase2_forced>:
 80007f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80007fc:	1d0c      	adds	r4, r1, #4
 80007fe:	4605      	mov	r5, r0
 8000800:	4617      	mov	r7, r2
 8000802:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000804:	f5ad 7d72 	sub.w	sp, sp, #968	; 0x3c8
 8000808:	ae03      	add	r6, sp, #12
 800080a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800080c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800080e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000810:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000812:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000814:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8000818:	ac02      	add	r4, sp, #8
 800081a:	f8d5 800c 	ldr.w	r8, [r5, #12]
 800081e:	f8d5 9018 	ldr.w	r9, [r5, #24]
 8000822:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
 8000826:	2300      	movs	r3, #0
 8000828:	6023      	str	r3, [r4, #0]
 800082a:	e021      	b.n	8000870 <unwind_phase2_forced+0x78>
 800082c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800082e:	616b      	str	r3, [r5, #20]
 8000830:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8000834:	4621      	mov	r1, r4
 8000836:	a87a      	add	r0, sp, #488	; 0x1e8
 8000838:	f00e fe25 	bl	800f486 <memcpy>
 800083c:	692b      	ldr	r3, [r5, #16]
 800083e:	aa7a      	add	r2, sp, #488	; 0x1e8
 8000840:	4629      	mov	r1, r5
 8000842:	4630      	mov	r0, r6
 8000844:	4798      	blx	r3
 8000846:	9b88      	ldr	r3, [sp, #544]	; 0x220
 8000848:	e9cd 4900 	strd	r4, r9, [sp]
 800084c:	4682      	mov	sl, r0
 800084e:	6463      	str	r3, [r4, #68]	; 0x44
 8000850:	4631      	mov	r1, r6
 8000852:	462b      	mov	r3, r5
 8000854:	462a      	mov	r2, r5
 8000856:	2001      	movs	r0, #1
 8000858:	47c0      	blx	r8
 800085a:	4607      	mov	r7, r0
 800085c:	b9f8      	cbnz	r0, 800089e <unwind_phase2_forced+0xa6>
 800085e:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8000862:	a97a      	add	r1, sp, #488	; 0x1e8
 8000864:	4620      	mov	r0, r4
 8000866:	f00e fe0e 	bl	800f486 <memcpy>
 800086a:	f1ba 0f08 	cmp.w	sl, #8
 800086e:	d11c      	bne.n	80008aa <unwind_phase2_forced+0xb2>
 8000870:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8000872:	4628      	mov	r0, r5
 8000874:	f7ff ff18 	bl	80006a8 <get_eit_entry>
 8000878:	2f00      	cmp	r7, #0
 800087a:	bf08      	it	eq
 800087c:	2609      	moveq	r6, #9
 800087e:	4607      	mov	r7, r0
 8000880:	bf18      	it	ne
 8000882:	260a      	movne	r6, #10
 8000884:	2800      	cmp	r0, #0
 8000886:	d0d1      	beq.n	800082c <unwind_phase2_forced+0x34>
 8000888:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800088a:	f046 0110 	orr.w	r1, r6, #16
 800088e:	e9cd 4900 	strd	r4, r9, [sp]
 8000892:	462a      	mov	r2, r5
 8000894:	6463      	str	r3, [r4, #68]	; 0x44
 8000896:	2001      	movs	r0, #1
 8000898:	462b      	mov	r3, r5
 800089a:	47c0      	blx	r8
 800089c:	b100      	cbz	r0, 80008a0 <unwind_phase2_forced+0xa8>
 800089e:	2709      	movs	r7, #9
 80008a0:	4638      	mov	r0, r7
 80008a2:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
 80008a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80008aa:	f1ba 0f07 	cmp.w	sl, #7
 80008ae:	d1f6      	bne.n	800089e <unwind_phase2_forced+0xa6>
 80008b0:	4638      	mov	r0, r7
 80008b2:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80008b4:	f7ff ff7e 	bl	80007b4 <_Unwind_DebugHook>
 80008b8:	a803      	add	r0, sp, #12
 80008ba:	f000 fb9d 	bl	8000ff8 <__restore_core_regs>
 80008be:	bf00      	nop

080008c0 <_Unwind_GetCFA>:
 80008c0:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80008c2:	4770      	bx	lr

080008c4 <__gnu_Unwind_RaiseException>:
 80008c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80008c6:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 80008c8:	640b      	str	r3, [r1, #64]	; 0x40
 80008ca:	1d0d      	adds	r5, r1, #4
 80008cc:	460f      	mov	r7, r1
 80008ce:	4606      	mov	r6, r0
 80008d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80008d2:	b0f9      	sub	sp, #484	; 0x1e4
 80008d4:	ac01      	add	r4, sp, #4
 80008d6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80008d8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80008da:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80008dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80008de:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80008e0:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80008e4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 80008e8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80008ec:	9500      	str	r5, [sp, #0]
 80008ee:	e006      	b.n	80008fe <__gnu_Unwind_RaiseException+0x3a>
 80008f0:	6933      	ldr	r3, [r6, #16]
 80008f2:	466a      	mov	r2, sp
 80008f4:	4631      	mov	r1, r6
 80008f6:	4798      	blx	r3
 80008f8:	2808      	cmp	r0, #8
 80008fa:	4604      	mov	r4, r0
 80008fc:	d108      	bne.n	8000910 <__gnu_Unwind_RaiseException+0x4c>
 80008fe:	9910      	ldr	r1, [sp, #64]	; 0x40
 8000900:	4630      	mov	r0, r6
 8000902:	f7ff fed1 	bl	80006a8 <get_eit_entry>
 8000906:	2800      	cmp	r0, #0
 8000908:	d0f2      	beq.n	80008f0 <__gnu_Unwind_RaiseException+0x2c>
 800090a:	2009      	movs	r0, #9
 800090c:	b079      	add	sp, #484	; 0x1e4
 800090e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000910:	4668      	mov	r0, sp
 8000912:	f7ff ff1b 	bl	800074c <restore_non_core_regs>
 8000916:	2c06      	cmp	r4, #6
 8000918:	d1f7      	bne.n	800090a <__gnu_Unwind_RaiseException+0x46>
 800091a:	4639      	mov	r1, r7
 800091c:	4630      	mov	r0, r6
 800091e:	f7ff ff4b 	bl	80007b8 <unwind_phase2>
 8000922:	bf00      	nop

08000924 <__gnu_Unwind_ForcedUnwind>:
 8000924:	b430      	push	{r4, r5}
 8000926:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8000928:	60c1      	str	r1, [r0, #12]
 800092a:	6182      	str	r2, [r0, #24]
 800092c:	4619      	mov	r1, r3
 800092e:	641d      	str	r5, [r3, #64]	; 0x40
 8000930:	2200      	movs	r2, #0
 8000932:	bc30      	pop	{r4, r5}
 8000934:	e760      	b.n	80007f8 <unwind_phase2_forced>
 8000936:	bf00      	nop

08000938 <__gnu_Unwind_Resume>:
 8000938:	b570      	push	{r4, r5, r6, lr}
 800093a:	68c6      	ldr	r6, [r0, #12]
 800093c:	6943      	ldr	r3, [r0, #20]
 800093e:	640b      	str	r3, [r1, #64]	; 0x40
 8000940:	b9be      	cbnz	r6, 8000972 <__gnu_Unwind_Resume+0x3a>
 8000942:	6903      	ldr	r3, [r0, #16]
 8000944:	460a      	mov	r2, r1
 8000946:	4604      	mov	r4, r0
 8000948:	460d      	mov	r5, r1
 800094a:	4601      	mov	r1, r0
 800094c:	2002      	movs	r0, #2
 800094e:	4798      	blx	r3
 8000950:	2807      	cmp	r0, #7
 8000952:	d007      	beq.n	8000964 <__gnu_Unwind_Resume+0x2c>
 8000954:	2808      	cmp	r0, #8
 8000956:	d103      	bne.n	8000960 <__gnu_Unwind_Resume+0x28>
 8000958:	4629      	mov	r1, r5
 800095a:	4620      	mov	r0, r4
 800095c:	f7ff ff2c 	bl	80007b8 <unwind_phase2>
 8000960:	f00e fd4b 	bl	800f3fa <abort>
 8000964:	4630      	mov	r0, r6
 8000966:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8000968:	f7ff ff24 	bl	80007b4 <_Unwind_DebugHook>
 800096c:	1d28      	adds	r0, r5, #4
 800096e:	f000 fb43 	bl	8000ff8 <__restore_core_regs>
 8000972:	2201      	movs	r2, #1
 8000974:	f7ff ff40 	bl	80007f8 <unwind_phase2_forced>
 8000978:	f00e fd3f 	bl	800f3fa <abort>

0800097c <__gnu_Unwind_Resume_or_Rethrow>:
 800097c:	68c2      	ldr	r2, [r0, #12]
 800097e:	b11a      	cbz	r2, 8000988 <__gnu_Unwind_Resume_or_Rethrow+0xc>
 8000980:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 8000982:	640a      	str	r2, [r1, #64]	; 0x40
 8000984:	2200      	movs	r2, #0
 8000986:	e737      	b.n	80007f8 <unwind_phase2_forced>
 8000988:	e79c      	b.n	80008c4 <__gnu_Unwind_RaiseException>
 800098a:	bf00      	nop

0800098c <_Unwind_Complete>:
 800098c:	4770      	bx	lr
 800098e:	bf00      	nop

08000990 <_Unwind_DeleteException>:
 8000990:	6883      	ldr	r3, [r0, #8]
 8000992:	b113      	cbz	r3, 800099a <_Unwind_DeleteException+0xa>
 8000994:	4601      	mov	r1, r0
 8000996:	2001      	movs	r0, #1
 8000998:	4718      	bx	r3
 800099a:	4770      	bx	lr

0800099c <_Unwind_VRS_Get>:
 800099c:	2904      	cmp	r1, #4
 800099e:	d807      	bhi.n	80009b0 <_Unwind_VRS_Get+0x14>
 80009a0:	e8df f001 	tbb	[pc, r1]
 80009a4:	08060803 	.word	0x08060803
 80009a8:	08          	.byte	0x08
 80009a9:	00          	.byte	0x00
 80009aa:	b90b      	cbnz	r3, 80009b0 <_Unwind_VRS_Get+0x14>
 80009ac:	2a0f      	cmp	r2, #15
 80009ae:	d903      	bls.n	80009b8 <_Unwind_VRS_Get+0x1c>
 80009b0:	2002      	movs	r0, #2
 80009b2:	4770      	bx	lr
 80009b4:	2001      	movs	r0, #1
 80009b6:	4770      	bx	lr
 80009b8:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80009bc:	4618      	mov	r0, r3
 80009be:	6853      	ldr	r3, [r2, #4]
 80009c0:	9a00      	ldr	r2, [sp, #0]
 80009c2:	6013      	str	r3, [r2, #0]
 80009c4:	4770      	bx	lr
 80009c6:	bf00      	nop

080009c8 <_Unwind_GetGR>:
 80009c8:	b510      	push	{r4, lr}
 80009ca:	b084      	sub	sp, #16
 80009cc:	2300      	movs	r3, #0
 80009ce:	ac03      	add	r4, sp, #12
 80009d0:	460a      	mov	r2, r1
 80009d2:	9400      	str	r4, [sp, #0]
 80009d4:	4619      	mov	r1, r3
 80009d6:	f7ff ffe1 	bl	800099c <_Unwind_VRS_Get>
 80009da:	9803      	ldr	r0, [sp, #12]
 80009dc:	b004      	add	sp, #16
 80009de:	bd10      	pop	{r4, pc}

080009e0 <_Unwind_VRS_Set>:
 80009e0:	2904      	cmp	r1, #4
 80009e2:	d807      	bhi.n	80009f4 <_Unwind_VRS_Set+0x14>
 80009e4:	e8df f001 	tbb	[pc, r1]
 80009e8:	08060803 	.word	0x08060803
 80009ec:	08          	.byte	0x08
 80009ed:	00          	.byte	0x00
 80009ee:	b90b      	cbnz	r3, 80009f4 <_Unwind_VRS_Set+0x14>
 80009f0:	2a0f      	cmp	r2, #15
 80009f2:	d903      	bls.n	80009fc <_Unwind_VRS_Set+0x1c>
 80009f4:	2002      	movs	r0, #2
 80009f6:	4770      	bx	lr
 80009f8:	2001      	movs	r0, #1
 80009fa:	4770      	bx	lr
 80009fc:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 8000a00:	9a00      	ldr	r2, [sp, #0]
 8000a02:	6812      	ldr	r2, [r2, #0]
 8000a04:	6042      	str	r2, [r0, #4]
 8000a06:	4618      	mov	r0, r3
 8000a08:	4770      	bx	lr
 8000a0a:	bf00      	nop

08000a0c <_Unwind_SetGR>:
 8000a0c:	b510      	push	{r4, lr}
 8000a0e:	b084      	sub	sp, #16
 8000a10:	ac04      	add	r4, sp, #16
 8000a12:	2300      	movs	r3, #0
 8000a14:	f844 2d04 	str.w	r2, [r4, #-4]!
 8000a18:	460a      	mov	r2, r1
 8000a1a:	9400      	str	r4, [sp, #0]
 8000a1c:	4619      	mov	r1, r3
 8000a1e:	f7ff ffdf 	bl	80009e0 <_Unwind_VRS_Set>
 8000a22:	b004      	add	sp, #16
 8000a24:	bd10      	pop	{r4, pc}
 8000a26:	bf00      	nop

08000a28 <__gnu_Unwind_Backtrace>:
 8000a28:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a2a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000a2c:	6413      	str	r3, [r2, #64]	; 0x40
 8000a2e:	1d15      	adds	r5, r2, #4
 8000a30:	4607      	mov	r7, r0
 8000a32:	460e      	mov	r6, r1
 8000a34:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000a36:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
 8000a3a:	ac17      	add	r4, sp, #92	; 0x5c
 8000a3c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000a3e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000a40:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000a42:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000a44:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000a46:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8000a4a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8000a4e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8000a52:	9516      	str	r5, [sp, #88]	; 0x58
 8000a54:	e010      	b.n	8000a78 <__gnu_Unwind_Backtrace+0x50>
 8000a56:	a816      	add	r0, sp, #88	; 0x58
 8000a58:	f7ff ffd8 	bl	8000a0c <_Unwind_SetGR>
 8000a5c:	4631      	mov	r1, r6
 8000a5e:	a816      	add	r0, sp, #88	; 0x58
 8000a60:	47b8      	blx	r7
 8000a62:	aa16      	add	r2, sp, #88	; 0x58
 8000a64:	4669      	mov	r1, sp
 8000a66:	b978      	cbnz	r0, 8000a88 <__gnu_Unwind_Backtrace+0x60>
 8000a68:	9b04      	ldr	r3, [sp, #16]
 8000a6a:	2008      	movs	r0, #8
 8000a6c:	4798      	blx	r3
 8000a6e:	2805      	cmp	r0, #5
 8000a70:	4604      	mov	r4, r0
 8000a72:	d00a      	beq.n	8000a8a <__gnu_Unwind_Backtrace+0x62>
 8000a74:	2809      	cmp	r0, #9
 8000a76:	d007      	beq.n	8000a88 <__gnu_Unwind_Backtrace+0x60>
 8000a78:	9926      	ldr	r1, [sp, #152]	; 0x98
 8000a7a:	4668      	mov	r0, sp
 8000a7c:	f7ff fe14 	bl	80006a8 <get_eit_entry>
 8000a80:	466a      	mov	r2, sp
 8000a82:	210c      	movs	r1, #12
 8000a84:	2800      	cmp	r0, #0
 8000a86:	d0e6      	beq.n	8000a56 <__gnu_Unwind_Backtrace+0x2e>
 8000a88:	2409      	movs	r4, #9
 8000a8a:	a816      	add	r0, sp, #88	; 0x58
 8000a8c:	f7ff fe5e 	bl	800074c <restore_non_core_regs>
 8000a90:	4620      	mov	r0, r4
 8000a92:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
 8000a96:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000a98 <__gnu_unwind_pr_common>:
 8000a98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000a9c:	460d      	mov	r5, r1
 8000a9e:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
 8000aa0:	b089      	sub	sp, #36	; 0x24
 8000aa2:	1d0c      	adds	r4, r1, #4
 8000aa4:	4616      	mov	r6, r2
 8000aa6:	f000 0b03 	and.w	fp, r0, #3
 8000aaa:	680a      	ldr	r2, [r1, #0]
 8000aac:	9406      	str	r4, [sp, #24]
 8000aae:	461f      	mov	r7, r3
 8000ab0:	2b00      	cmp	r3, #0
 8000ab2:	d068      	beq.n	8000b86 <__gnu_unwind_pr_common+0xee>
 8000ab4:	0c13      	lsrs	r3, r2, #16
 8000ab6:	b2d9      	uxtb	r1, r3
 8000ab8:	0412      	lsls	r2, r2, #16
 8000aba:	f88d 301d 	strb.w	r3, [sp, #29]
 8000abe:	2302      	movs	r3, #2
 8000ac0:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8000ac4:	9205      	str	r2, [sp, #20]
 8000ac6:	f88d 301c 	strb.w	r3, [sp, #28]
 8000aca:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8000acc:	f1bb 0f02 	cmp.w	fp, #2
 8000ad0:	bf08      	it	eq
 8000ad2:	6bac      	ldreq	r4, [r5, #56]	; 0x38
 8000ad4:	f013 0301 	ands.w	r3, r3, #1
 8000ad8:	d146      	bne.n	8000b68 <__gnu_unwind_pr_common+0xd0>
 8000ada:	9301      	str	r3, [sp, #4]
 8000adc:	f000 0308 	and.w	r3, r0, #8
 8000ae0:	9300      	str	r3, [sp, #0]
 8000ae2:	f8d4 9000 	ldr.w	r9, [r4]
 8000ae6:	f1b9 0f00 	cmp.w	r9, #0
 8000aea:	f000 80f3 	beq.w	8000cd4 <__gnu_unwind_pr_common+0x23c>
 8000aee:	2f02      	cmp	r7, #2
 8000af0:	d045      	beq.n	8000b7e <__gnu_unwind_pr_common+0xe6>
 8000af2:	f8b4 9000 	ldrh.w	r9, [r4]
 8000af6:	f8b4 8002 	ldrh.w	r8, [r4, #2]
 8000afa:	3404      	adds	r4, #4
 8000afc:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000afe:	f028 0a01 	bic.w	sl, r8, #1
 8000b02:	210f      	movs	r1, #15
 8000b04:	4630      	mov	r0, r6
 8000b06:	449a      	add	sl, r3
 8000b08:	f7ff ff5e 	bl	80009c8 <_Unwind_GetGR>
 8000b0c:	4582      	cmp	sl, r0
 8000b0e:	d834      	bhi.n	8000b7a <__gnu_unwind_pr_common+0xe2>
 8000b10:	f029 0301 	bic.w	r3, r9, #1
 8000b14:	4453      	add	r3, sl
 8000b16:	4283      	cmp	r3, r0
 8000b18:	bf94      	ite	ls
 8000b1a:	2000      	movls	r0, #0
 8000b1c:	2001      	movhi	r0, #1
 8000b1e:	ea4f 0848 	mov.w	r8, r8, lsl #1
 8000b22:	f008 0802 	and.w	r8, r8, #2
 8000b26:	f009 0901 	and.w	r9, r9, #1
 8000b2a:	ea48 0809 	orr.w	r8, r8, r9
 8000b2e:	f1b8 0f01 	cmp.w	r8, #1
 8000b32:	d03a      	beq.n	8000baa <__gnu_unwind_pr_common+0x112>
 8000b34:	d331      	bcc.n	8000b9a <__gnu_unwind_pr_common+0x102>
 8000b36:	f1b8 0f02 	cmp.w	r8, #2
 8000b3a:	d11a      	bne.n	8000b72 <__gnu_unwind_pr_common+0xda>
 8000b3c:	6823      	ldr	r3, [r4, #0]
 8000b3e:	f023 4a00 	bic.w	sl, r3, #2147483648	; 0x80000000
 8000b42:	f1bb 0f00 	cmp.w	fp, #0
 8000b46:	d166      	bne.n	8000c16 <__gnu_unwind_pr_common+0x17e>
 8000b48:	b130      	cbz	r0, 8000b58 <__gnu_unwind_pr_common+0xc0>
 8000b4a:	9a00      	ldr	r2, [sp, #0]
 8000b4c:	2a00      	cmp	r2, #0
 8000b4e:	d06c      	beq.n	8000c2a <__gnu_unwind_pr_common+0x192>
 8000b50:	f1ba 0f00 	cmp.w	sl, #0
 8000b54:	f000 8090 	beq.w	8000c78 <__gnu_unwind_pr_common+0x1e0>
 8000b58:	2b00      	cmp	r3, #0
 8000b5a:	da00      	bge.n	8000b5e <__gnu_unwind_pr_common+0xc6>
 8000b5c:	3404      	adds	r4, #4
 8000b5e:	f10a 0301 	add.w	r3, sl, #1
 8000b62:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8000b66:	e7bc      	b.n	8000ae2 <__gnu_unwind_pr_common+0x4a>
 8000b68:	4630      	mov	r0, r6
 8000b6a:	a905      	add	r1, sp, #20
 8000b6c:	f000 fb46 	bl	80011fc <__gnu_unwind_execute>
 8000b70:	b178      	cbz	r0, 8000b92 <__gnu_unwind_pr_common+0xfa>
 8000b72:	2009      	movs	r0, #9
 8000b74:	b009      	add	sp, #36	; 0x24
 8000b76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b7a:	2000      	movs	r0, #0
 8000b7c:	e7cf      	b.n	8000b1e <__gnu_unwind_pr_common+0x86>
 8000b7e:	f8d4 8004 	ldr.w	r8, [r4, #4]
 8000b82:	3408      	adds	r4, #8
 8000b84:	e7ba      	b.n	8000afc <__gnu_unwind_pr_common+0x64>
 8000b86:	0212      	lsls	r2, r2, #8
 8000b88:	2303      	movs	r3, #3
 8000b8a:	9205      	str	r2, [sp, #20]
 8000b8c:	f8ad 301c 	strh.w	r3, [sp, #28]
 8000b90:	e79b      	b.n	8000aca <__gnu_unwind_pr_common+0x32>
 8000b92:	2008      	movs	r0, #8
 8000b94:	b009      	add	sp, #36	; 0x24
 8000b96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b9a:	f1bb 0f00 	cmp.w	fp, #0
 8000b9e:	d002      	beq.n	8000ba6 <__gnu_unwind_pr_common+0x10e>
 8000ba0:	2800      	cmp	r0, #0
 8000ba2:	f040 80b4 	bne.w	8000d0e <__gnu_unwind_pr_common+0x276>
 8000ba6:	3404      	adds	r4, #4
 8000ba8:	e79b      	b.n	8000ae2 <__gnu_unwind_pr_common+0x4a>
 8000baa:	f1bb 0f00 	cmp.w	fp, #0
 8000bae:	d118      	bne.n	8000be2 <__gnu_unwind_pr_common+0x14a>
 8000bb0:	b1a8      	cbz	r0, 8000bde <__gnu_unwind_pr_common+0x146>
 8000bb2:	e9d4 2300 	ldrd	r2, r3, [r4]
 8000bb6:	1c99      	adds	r1, r3, #2
 8000bb8:	ea4f 72d2 	mov.w	r2, r2, lsr #31
 8000bbc:	d0d9      	beq.n	8000b72 <__gnu_unwind_pr_common+0xda>
 8000bbe:	f105 0158 	add.w	r1, r5, #88	; 0x58
 8000bc2:	3301      	adds	r3, #1
 8000bc4:	9104      	str	r1, [sp, #16]
 8000bc6:	f000 80b5 	beq.w	8000d34 <__gnu_unwind_pr_common+0x29c>
 8000bca:	1d20      	adds	r0, r4, #4
 8000bcc:	f7ff fdea 	bl	80007a4 <_Unwind_decode_typeinfo_ptr.isra.0>
 8000bd0:	ab04      	add	r3, sp, #16
 8000bd2:	4601      	mov	r1, r0
 8000bd4:	4628      	mov	r0, r5
 8000bd6:	f00d ff23 	bl	800ea20 <__cxa_type_match>
 8000bda:	2800      	cmp	r0, #0
 8000bdc:	d167      	bne.n	8000cae <__gnu_unwind_pr_common+0x216>
 8000bde:	3408      	adds	r4, #8
 8000be0:	e77f      	b.n	8000ae2 <__gnu_unwind_pr_common+0x4a>
 8000be2:	210d      	movs	r1, #13
 8000be4:	4630      	mov	r0, r6
 8000be6:	f8d5 8020 	ldr.w	r8, [r5, #32]
 8000bea:	f7ff feed 	bl	80009c8 <_Unwind_GetGR>
 8000bee:	4580      	cmp	r8, r0
 8000bf0:	d1f5      	bne.n	8000bde <__gnu_unwind_pr_common+0x146>
 8000bf2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000bf4:	429c      	cmp	r4, r3
 8000bf6:	d1f2      	bne.n	8000bde <__gnu_unwind_pr_common+0x146>
 8000bf8:	4620      	mov	r0, r4
 8000bfa:	f7ff fd07 	bl	800060c <selfrel_offset31>
 8000bfe:	210f      	movs	r1, #15
 8000c00:	4602      	mov	r2, r0
 8000c02:	4630      	mov	r0, r6
 8000c04:	f7ff ff02 	bl	8000a0c <_Unwind_SetGR>
 8000c08:	4630      	mov	r0, r6
 8000c0a:	462a      	mov	r2, r5
 8000c0c:	2100      	movs	r1, #0
 8000c0e:	f7ff fefd 	bl	8000a0c <_Unwind_SetGR>
 8000c12:	2007      	movs	r0, #7
 8000c14:	e7ae      	b.n	8000b74 <__gnu_unwind_pr_common+0xdc>
 8000c16:	210d      	movs	r1, #13
 8000c18:	4630      	mov	r0, r6
 8000c1a:	f8d5 8020 	ldr.w	r8, [r5, #32]
 8000c1e:	f7ff fed3 	bl	80009c8 <_Unwind_GetGR>
 8000c22:	4580      	cmp	r8, r0
 8000c24:	d032      	beq.n	8000c8c <__gnu_unwind_pr_common+0x1f4>
 8000c26:	6823      	ldr	r3, [r4, #0]
 8000c28:	e796      	b.n	8000b58 <__gnu_unwind_pr_common+0xc0>
 8000c2a:	f1ba 0f00 	cmp.w	sl, #0
 8000c2e:	d023      	beq.n	8000c78 <__gnu_unwind_pr_common+0x1e0>
 8000c30:	f105 0358 	add.w	r3, r5, #88	; 0x58
 8000c34:	f104 0804 	add.w	r8, r4, #4
 8000c38:	f8cd b008 	str.w	fp, [sp, #8]
 8000c3c:	f8dd 9000 	ldr.w	r9, [sp]
 8000c40:	9703      	str	r7, [sp, #12]
 8000c42:	46a3      	mov	fp, r4
 8000c44:	461c      	mov	r4, r3
 8000c46:	e002      	b.n	8000c4e <__gnu_unwind_pr_common+0x1b6>
 8000c48:	4557      	cmp	r7, sl
 8000c4a:	46b9      	mov	r9, r7
 8000c4c:	d040      	beq.n	8000cd0 <__gnu_unwind_pr_common+0x238>
 8000c4e:	4640      	mov	r0, r8
 8000c50:	9404      	str	r4, [sp, #16]
 8000c52:	f7ff fda7 	bl	80007a4 <_Unwind_decode_typeinfo_ptr.isra.0>
 8000c56:	ab04      	add	r3, sp, #16
 8000c58:	4601      	mov	r1, r0
 8000c5a:	2200      	movs	r2, #0
 8000c5c:	4628      	mov	r0, r5
 8000c5e:	f00d fedf 	bl	800ea20 <__cxa_type_match>
 8000c62:	f109 0701 	add.w	r7, r9, #1
 8000c66:	f108 0804 	add.w	r8, r8, #4
 8000c6a:	2800      	cmp	r0, #0
 8000c6c:	d0ec      	beq.n	8000c48 <__gnu_unwind_pr_common+0x1b0>
 8000c6e:	45d1      	cmp	r9, sl
 8000c70:	465c      	mov	r4, fp
 8000c72:	e9dd b702 	ldrd	fp, r7, [sp, #8]
 8000c76:	d1d6      	bne.n	8000c26 <__gnu_unwind_pr_common+0x18e>
 8000c78:	4630      	mov	r0, r6
 8000c7a:	210d      	movs	r1, #13
 8000c7c:	f7ff fea4 	bl	80009c8 <_Unwind_GetGR>
 8000c80:	9b04      	ldr	r3, [sp, #16]
 8000c82:	6228      	str	r0, [r5, #32]
 8000c84:	e9c5 3409 	strd	r3, r4, [r5, #36]	; 0x24
 8000c88:	2006      	movs	r0, #6
 8000c8a:	e773      	b.n	8000b74 <__gnu_unwind_pr_common+0xdc>
 8000c8c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000c8e:	429c      	cmp	r4, r3
 8000c90:	d1c9      	bne.n	8000c26 <__gnu_unwind_pr_common+0x18e>
 8000c92:	2204      	movs	r2, #4
 8000c94:	f04f 0800 	mov.w	r8, #0
 8000c98:	18a3      	adds	r3, r4, r2
 8000c9a:	e9c5 a80a 	strd	sl, r8, [r5, #40]	; 0x28
 8000c9e:	e9c5 230c 	strd	r2, r3, [r5, #48]	; 0x30
 8000ca2:	6823      	ldr	r3, [r4, #0]
 8000ca4:	4543      	cmp	r3, r8
 8000ca6:	db4d      	blt.n	8000d44 <__gnu_unwind_pr_common+0x2ac>
 8000ca8:	2301      	movs	r3, #1
 8000caa:	9301      	str	r3, [sp, #4]
 8000cac:	e757      	b.n	8000b5e <__gnu_unwind_pr_common+0xc6>
 8000cae:	4680      	mov	r8, r0
 8000cb0:	210d      	movs	r1, #13
 8000cb2:	4630      	mov	r0, r6
 8000cb4:	f7ff fe88 	bl	80009c8 <_Unwind_GetGR>
 8000cb8:	f1b8 0f02 	cmp.w	r8, #2
 8000cbc:	6228      	str	r0, [r5, #32]
 8000cbe:	d13e      	bne.n	8000d3e <__gnu_unwind_pr_common+0x2a6>
 8000cc0:	462b      	mov	r3, r5
 8000cc2:	9a04      	ldr	r2, [sp, #16]
 8000cc4:	f843 2f2c 	str.w	r2, [r3, #44]!
 8000cc8:	626b      	str	r3, [r5, #36]	; 0x24
 8000cca:	62ac      	str	r4, [r5, #40]	; 0x28
 8000ccc:	2006      	movs	r0, #6
 8000cce:	e751      	b.n	8000b74 <__gnu_unwind_pr_common+0xdc>
 8000cd0:	465c      	mov	r4, fp
 8000cd2:	e7d1      	b.n	8000c78 <__gnu_unwind_pr_common+0x1e0>
 8000cd4:	a905      	add	r1, sp, #20
 8000cd6:	4630      	mov	r0, r6
 8000cd8:	f000 fa90 	bl	80011fc <__gnu_unwind_execute>
 8000cdc:	2800      	cmp	r0, #0
 8000cde:	f47f af48 	bne.w	8000b72 <__gnu_unwind_pr_common+0xda>
 8000ce2:	9b01      	ldr	r3, [sp, #4]
 8000ce4:	2b00      	cmp	r3, #0
 8000ce6:	f43f af54 	beq.w	8000b92 <__gnu_unwind_pr_common+0xfa>
 8000cea:	210f      	movs	r1, #15
 8000cec:	4630      	mov	r0, r6
 8000cee:	f7ff fe6b 	bl	80009c8 <_Unwind_GetGR>
 8000cf2:	210e      	movs	r1, #14
 8000cf4:	4602      	mov	r2, r0
 8000cf6:	4630      	mov	r0, r6
 8000cf8:	f7ff fe88 	bl	8000a0c <_Unwind_SetGR>
 8000cfc:	4630      	mov	r0, r6
 8000cfe:	4a1a      	ldr	r2, [pc, #104]	; (8000d68 <__gnu_unwind_pr_common+0x2d0>)
 8000d00:	210f      	movs	r1, #15
 8000d02:	f7ff fe83 	bl	8000a0c <_Unwind_SetGR>
 8000d06:	2007      	movs	r0, #7
 8000d08:	b009      	add	sp, #36	; 0x24
 8000d0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000d0e:	4620      	mov	r0, r4
 8000d10:	f7ff fc7c 	bl	800060c <selfrel_offset31>
 8000d14:	3404      	adds	r4, #4
 8000d16:	4607      	mov	r7, r0
 8000d18:	63ac      	str	r4, [r5, #56]	; 0x38
 8000d1a:	4628      	mov	r0, r5
 8000d1c:	f00d fede 	bl	800eadc <__cxa_begin_cleanup>
 8000d20:	2800      	cmp	r0, #0
 8000d22:	f43f af26 	beq.w	8000b72 <__gnu_unwind_pr_common+0xda>
 8000d26:	4630      	mov	r0, r6
 8000d28:	463a      	mov	r2, r7
 8000d2a:	210f      	movs	r1, #15
 8000d2c:	f7ff fe6e 	bl	8000a0c <_Unwind_SetGR>
 8000d30:	2007      	movs	r0, #7
 8000d32:	e71f      	b.n	8000b74 <__gnu_unwind_pr_common+0xdc>
 8000d34:	4630      	mov	r0, r6
 8000d36:	210d      	movs	r1, #13
 8000d38:	f7ff fe46 	bl	80009c8 <_Unwind_GetGR>
 8000d3c:	6228      	str	r0, [r5, #32]
 8000d3e:	9b04      	ldr	r3, [sp, #16]
 8000d40:	626b      	str	r3, [r5, #36]	; 0x24
 8000d42:	e7c2      	b.n	8000cca <__gnu_unwind_pr_common+0x232>
 8000d44:	f10a 0001 	add.w	r0, sl, #1
 8000d48:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8000d4c:	f7ff fc5e 	bl	800060c <selfrel_offset31>
 8000d50:	210f      	movs	r1, #15
 8000d52:	4602      	mov	r2, r0
 8000d54:	4630      	mov	r0, r6
 8000d56:	f7ff fe59 	bl	8000a0c <_Unwind_SetGR>
 8000d5a:	4630      	mov	r0, r6
 8000d5c:	462a      	mov	r2, r5
 8000d5e:	4641      	mov	r1, r8
 8000d60:	f7ff fe54 	bl	8000a0c <_Unwind_SetGR>
 8000d64:	2007      	movs	r0, #7
 8000d66:	e705      	b.n	8000b74 <__gnu_unwind_pr_common+0xdc>
 8000d68:	0800f345 	.word	0x0800f345

08000d6c <__aeabi_unwind_cpp_pr0>:
 8000d6c:	2300      	movs	r3, #0
 8000d6e:	e693      	b.n	8000a98 <__gnu_unwind_pr_common>

08000d70 <__aeabi_unwind_cpp_pr1>:
 8000d70:	2301      	movs	r3, #1
 8000d72:	e691      	b.n	8000a98 <__gnu_unwind_pr_common>

08000d74 <__aeabi_unwind_cpp_pr2>:
 8000d74:	2302      	movs	r3, #2
 8000d76:	e68f      	b.n	8000a98 <__gnu_unwind_pr_common>

08000d78 <_Unwind_VRS_Pop>:
 8000d78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000d7c:	4605      	mov	r5, r0
 8000d7e:	b0c4      	sub	sp, #272	; 0x110
 8000d80:	2904      	cmp	r1, #4
 8000d82:	d806      	bhi.n	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000d84:	e8df f001 	tbb	[pc, r1]
 8000d88:	03052b4d 	.word	0x03052b4d
 8000d8c:	09          	.byte	0x09
 8000d8d:	00          	.byte	0x00
 8000d8e:	2b03      	cmp	r3, #3
 8000d90:	d05f      	beq.n	8000e52 <_Unwind_VRS_Pop+0xda>
 8000d92:	2002      	movs	r0, #2
 8000d94:	b044      	add	sp, #272	; 0x110
 8000d96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000d9a:	2b00      	cmp	r3, #0
 8000d9c:	d1f9      	bne.n	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000d9e:	2a10      	cmp	r2, #16
 8000da0:	d8f7      	bhi.n	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000da2:	682b      	ldr	r3, [r5, #0]
 8000da4:	06dc      	lsls	r4, r3, #27
 8000da6:	f100 80f4 	bmi.w	8000f92 <_Unwind_VRS_Pop+0x21a>
 8000daa:	ac22      	add	r4, sp, #136	; 0x88
 8000dac:	4620      	mov	r0, r4
 8000dae:	9201      	str	r2, [sp, #4]
 8000db0:	f000 f994 	bl	80010dc <__gnu_Unwind_Save_WMMXC>
 8000db4:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8000db6:	9a01      	ldr	r2, [sp, #4]
 8000db8:	2300      	movs	r3, #0
 8000dba:	2601      	movs	r6, #1
 8000dbc:	fa06 f103 	lsl.w	r1, r6, r3
 8000dc0:	4211      	tst	r1, r2
 8000dc2:	d003      	beq.n	8000dcc <_Unwind_VRS_Pop+0x54>
 8000dc4:	6801      	ldr	r1, [r0, #0]
 8000dc6:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 8000dca:	3004      	adds	r0, #4
 8000dcc:	3301      	adds	r3, #1
 8000dce:	2b04      	cmp	r3, #4
 8000dd0:	d1f4      	bne.n	8000dbc <_Unwind_VRS_Pop+0x44>
 8000dd2:	63a8      	str	r0, [r5, #56]	; 0x38
 8000dd4:	4620      	mov	r0, r4
 8000dd6:	f000 f977 	bl	80010c8 <__gnu_Unwind_Restore_WMMXC>
 8000dda:	2000      	movs	r0, #0
 8000ddc:	e7da      	b.n	8000d94 <_Unwind_VRS_Pop+0x1c>
 8000dde:	2b01      	cmp	r3, #1
 8000de0:	ea4f 4612 	mov.w	r6, r2, lsr #16
 8000de4:	b297      	uxth	r7, r2
 8000de6:	d052      	beq.n	8000e8e <_Unwind_VRS_Pop+0x116>
 8000de8:	2b05      	cmp	r3, #5
 8000dea:	d1d2      	bne.n	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000dec:	eb06 0807 	add.w	r8, r6, r7
 8000df0:	f1b8 0f20 	cmp.w	r8, #32
 8000df4:	d8cd      	bhi.n	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000df6:	2e0f      	cmp	r6, #15
 8000df8:	f240 8099 	bls.w	8000f2e <_Unwind_VRS_Pop+0x1b6>
 8000dfc:	46b8      	mov	r8, r7
 8000dfe:	2f00      	cmp	r7, #0
 8000e00:	f040 80db 	bne.w	8000fba <_Unwind_VRS_Pop+0x242>
 8000e04:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000e06:	63aa      	str	r2, [r5, #56]	; 0x38
 8000e08:	2e0f      	cmp	r6, #15
 8000e0a:	f240 80be 	bls.w	8000f8a <_Unwind_VRS_Pop+0x212>
 8000e0e:	f1b8 0f00 	cmp.w	r8, #0
 8000e12:	d002      	beq.n	8000e1a <_Unwind_VRS_Pop+0xa2>
 8000e14:	a802      	add	r0, sp, #8
 8000e16:	f000 f90b 	bl	8001030 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 8000e1a:	2000      	movs	r0, #0
 8000e1c:	b044      	add	sp, #272	; 0x110
 8000e1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000e22:	2b00      	cmp	r3, #0
 8000e24:	d1b5      	bne.n	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000e26:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8000e28:	b297      	uxth	r7, r2
 8000e2a:	1d28      	adds	r0, r5, #4
 8000e2c:	2601      	movs	r6, #1
 8000e2e:	fa06 f103 	lsl.w	r1, r6, r3
 8000e32:	4239      	tst	r1, r7
 8000e34:	f103 0301 	add.w	r3, r3, #1
 8000e38:	d002      	beq.n	8000e40 <_Unwind_VRS_Pop+0xc8>
 8000e3a:	6821      	ldr	r1, [r4, #0]
 8000e3c:	6001      	str	r1, [r0, #0]
 8000e3e:	3404      	adds	r4, #4
 8000e40:	2b10      	cmp	r3, #16
 8000e42:	f100 0004 	add.w	r0, r0, #4
 8000e46:	d1f2      	bne.n	8000e2e <_Unwind_VRS_Pop+0xb6>
 8000e48:	f412 5000 	ands.w	r0, r2, #8192	; 0x2000
 8000e4c:	d1e5      	bne.n	8000e1a <_Unwind_VRS_Pop+0xa2>
 8000e4e:	63ac      	str	r4, [r5, #56]	; 0x38
 8000e50:	e7a0      	b.n	8000d94 <_Unwind_VRS_Pop+0x1c>
 8000e52:	0c16      	lsrs	r6, r2, #16
 8000e54:	b297      	uxth	r7, r2
 8000e56:	19f3      	adds	r3, r6, r7
 8000e58:	2b10      	cmp	r3, #16
 8000e5a:	d89a      	bhi.n	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000e5c:	682b      	ldr	r3, [r5, #0]
 8000e5e:	071a      	lsls	r2, r3, #28
 8000e60:	d45d      	bmi.n	8000f1e <_Unwind_VRS_Pop+0x1a6>
 8000e62:	ac22      	add	r4, sp, #136	; 0x88
 8000e64:	4620      	mov	r0, r4
 8000e66:	f000 f90d 	bl	8001084 <__gnu_Unwind_Save_WMMXD>
 8000e6a:	eb04 01c6 	add.w	r1, r4, r6, lsl #3
 8000e6e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8000e70:	b13f      	cbz	r7, 8000e82 <_Unwind_VRS_Pop+0x10a>
 8000e72:	eb03 02c7 	add.w	r2, r3, r7, lsl #3
 8000e76:	6818      	ldr	r0, [r3, #0]
 8000e78:	f841 0b04 	str.w	r0, [r1], #4
 8000e7c:	3304      	adds	r3, #4
 8000e7e:	4293      	cmp	r3, r2
 8000e80:	d1f9      	bne.n	8000e76 <_Unwind_VRS_Pop+0xfe>
 8000e82:	4620      	mov	r0, r4
 8000e84:	63ab      	str	r3, [r5, #56]	; 0x38
 8000e86:	f000 f8db 	bl	8001040 <__gnu_Unwind_Restore_WMMXD>
 8000e8a:	2000      	movs	r0, #0
 8000e8c:	e782      	b.n	8000d94 <_Unwind_VRS_Pop+0x1c>
 8000e8e:	19f2      	adds	r2, r6, r7
 8000e90:	2a10      	cmp	r2, #16
 8000e92:	f63f af7e 	bhi.w	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000e96:	2e0f      	cmp	r6, #15
 8000e98:	f63f af7b 	bhi.w	8000d92 <_Unwind_VRS_Pop+0x1a>
 8000e9c:	682a      	ldr	r2, [r5, #0]
 8000e9e:	07d1      	lsls	r1, r2, #31
 8000ea0:	d508      	bpl.n	8000eb4 <_Unwind_VRS_Pop+0x13c>
 8000ea2:	4628      	mov	r0, r5
 8000ea4:	f022 0203 	bic.w	r2, r2, #3
 8000ea8:	f840 2b48 	str.w	r2, [r0], #72
 8000eac:	9301      	str	r3, [sp, #4]
 8000eae:	f000 f8b3 	bl	8001018 <__gnu_Unwind_Save_VFP>
 8000eb2:	9b01      	ldr	r3, [sp, #4]
 8000eb4:	9301      	str	r3, [sp, #4]
 8000eb6:	ac22      	add	r4, sp, #136	; 0x88
 8000eb8:	4620      	mov	r0, r4
 8000eba:	f000 f8ad 	bl	8001018 <__gnu_Unwind_Save_VFP>
 8000ebe:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8000ec0:	9b01      	ldr	r3, [sp, #4]
 8000ec2:	2f00      	cmp	r7, #0
 8000ec4:	f000 8095 	beq.w	8000ff2 <_Unwind_VRS_Pop+0x27a>
 8000ec8:	007f      	lsls	r7, r7, #1
 8000eca:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
 8000ece:	f04f 0800 	mov.w	r8, #0
 8000ed2:	3c04      	subs	r4, #4
 8000ed4:	eb01 0287 	add.w	r2, r1, r7, lsl #2
 8000ed8:	f851 0b04 	ldr.w	r0, [r1], #4
 8000edc:	f844 0f04 	str.w	r0, [r4, #4]!
 8000ee0:	4291      	cmp	r1, r2
 8000ee2:	d1f9      	bne.n	8000ed8 <_Unwind_VRS_Pop+0x160>
 8000ee4:	f1b8 0f00 	cmp.w	r8, #0
 8000ee8:	d00f      	beq.n	8000f0a <_Unwind_VRS_Pop+0x192>
 8000eea:	ac02      	add	r4, sp, #8
 8000eec:	2e10      	cmp	r6, #16
 8000eee:	4631      	mov	r1, r6
 8000ef0:	bf38      	it	cc
 8000ef2:	2110      	movcc	r1, #16
 8000ef4:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8000ef8:	3984      	subs	r1, #132	; 0x84
 8000efa:	eb02 04c8 	add.w	r4, r2, r8, lsl #3
 8000efe:	f852 0b04 	ldr.w	r0, [r2], #4
 8000f02:	f841 0f04 	str.w	r0, [r1, #4]!
 8000f06:	4294      	cmp	r4, r2
 8000f08:	d1f9      	bne.n	8000efe <_Unwind_VRS_Pop+0x186>
 8000f0a:	2b01      	cmp	r3, #1
 8000f0c:	f47f af7b 	bne.w	8000e06 <_Unwind_VRS_Pop+0x8e>
 8000f10:	ac22      	add	r4, sp, #136	; 0x88
 8000f12:	3204      	adds	r2, #4
 8000f14:	63aa      	str	r2, [r5, #56]	; 0x38
 8000f16:	4620      	mov	r0, r4
 8000f18:	f000 f87a 	bl	8001010 <__gnu_Unwind_Restore_VFP>
 8000f1c:	e77d      	b.n	8000e1a <_Unwind_VRS_Pop+0xa2>
 8000f1e:	f023 0308 	bic.w	r3, r3, #8
 8000f22:	602b      	str	r3, [r5, #0]
 8000f24:	f505 70a8 	add.w	r0, r5, #336	; 0x150
 8000f28:	f000 f8ac 	bl	8001084 <__gnu_Unwind_Save_WMMXD>
 8000f2c:	e799      	b.n	8000e62 <_Unwind_VRS_Pop+0xea>
 8000f2e:	f1b8 0f10 	cmp.w	r8, #16
 8000f32:	682a      	ldr	r2, [r5, #0]
 8000f34:	d943      	bls.n	8000fbe <_Unwind_VRS_Pop+0x246>
 8000f36:	07d0      	lsls	r0, r2, #31
 8000f38:	f1a8 0810 	sub.w	r8, r8, #16
 8000f3c:	d50b      	bpl.n	8000f56 <_Unwind_VRS_Pop+0x1de>
 8000f3e:	4628      	mov	r0, r5
 8000f40:	f022 0201 	bic.w	r2, r2, #1
 8000f44:	f042 0202 	orr.w	r2, r2, #2
 8000f48:	f840 2b48 	str.w	r2, [r0], #72
 8000f4c:	9301      	str	r3, [sp, #4]
 8000f4e:	f000 f86b 	bl	8001028 <__gnu_Unwind_Save_VFP_D>
 8000f52:	682a      	ldr	r2, [r5, #0]
 8000f54:	9b01      	ldr	r3, [sp, #4]
 8000f56:	0751      	lsls	r1, r2, #29
 8000f58:	d425      	bmi.n	8000fa6 <_Unwind_VRS_Pop+0x22e>
 8000f5a:	2e0f      	cmp	r6, #15
 8000f5c:	d804      	bhi.n	8000f68 <_Unwind_VRS_Pop+0x1f0>
 8000f5e:	a822      	add	r0, sp, #136	; 0x88
 8000f60:	9301      	str	r3, [sp, #4]
 8000f62:	f000 f861 	bl	8001028 <__gnu_Unwind_Save_VFP_D>
 8000f66:	9b01      	ldr	r3, [sp, #4]
 8000f68:	9301      	str	r3, [sp, #4]
 8000f6a:	ac02      	add	r4, sp, #8
 8000f6c:	4620      	mov	r0, r4
 8000f6e:	f000 f863 	bl	8001038 <__gnu_Unwind_Save_VFP_D_16_to_31>
 8000f72:	f1c6 0110 	rsb	r1, r6, #16
 8000f76:	2900      	cmp	r1, #0
 8000f78:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000f7a:	9b01      	ldr	r3, [sp, #4]
 8000f7c:	ddb6      	ble.n	8000eec <_Unwind_VRS_Pop+0x174>
 8000f7e:	ac22      	add	r4, sp, #136	; 0x88
 8000f80:	004f      	lsls	r7, r1, #1
 8000f82:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
 8000f86:	4611      	mov	r1, r2
 8000f88:	e7a3      	b.n	8000ed2 <_Unwind_VRS_Pop+0x15a>
 8000f8a:	a822      	add	r0, sp, #136	; 0x88
 8000f8c:	f000 f848 	bl	8001020 <__gnu_Unwind_Restore_VFP_D>
 8000f90:	e73d      	b.n	8000e0e <_Unwind_VRS_Pop+0x96>
 8000f92:	f023 0310 	bic.w	r3, r3, #16
 8000f96:	602b      	str	r3, [r5, #0]
 8000f98:	f505 70e8 	add.w	r0, r5, #464	; 0x1d0
 8000f9c:	9201      	str	r2, [sp, #4]
 8000f9e:	f000 f89d 	bl	80010dc <__gnu_Unwind_Save_WMMXC>
 8000fa2:	9a01      	ldr	r2, [sp, #4]
 8000fa4:	e701      	b.n	8000daa <_Unwind_VRS_Pop+0x32>
 8000fa6:	4628      	mov	r0, r5
 8000fa8:	f022 0204 	bic.w	r2, r2, #4
 8000fac:	f840 2bd0 	str.w	r2, [r0], #208
 8000fb0:	9301      	str	r3, [sp, #4]
 8000fb2:	f000 f841 	bl	8001038 <__gnu_Unwind_Save_VFP_D_16_to_31>
 8000fb6:	9b01      	ldr	r3, [sp, #4]
 8000fb8:	e7cf      	b.n	8000f5a <_Unwind_VRS_Pop+0x1e2>
 8000fba:	682a      	ldr	r2, [r5, #0]
 8000fbc:	e7cb      	b.n	8000f56 <_Unwind_VRS_Pop+0x1de>
 8000fbe:	07d0      	lsls	r0, r2, #31
 8000fc0:	d50a      	bpl.n	8000fd8 <_Unwind_VRS_Pop+0x260>
 8000fc2:	4628      	mov	r0, r5
 8000fc4:	f022 0201 	bic.w	r2, r2, #1
 8000fc8:	f042 0202 	orr.w	r2, r2, #2
 8000fcc:	f840 2b48 	str.w	r2, [r0], #72
 8000fd0:	9301      	str	r3, [sp, #4]
 8000fd2:	f000 f829 	bl	8001028 <__gnu_Unwind_Save_VFP_D>
 8000fd6:	9b01      	ldr	r3, [sp, #4]
 8000fd8:	9301      	str	r3, [sp, #4]
 8000fda:	ac22      	add	r4, sp, #136	; 0x88
 8000fdc:	4620      	mov	r0, r4
 8000fde:	f000 f823 	bl	8001028 <__gnu_Unwind_Save_VFP_D>
 8000fe2:	46b8      	mov	r8, r7
 8000fe4:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8000fe6:	9b01      	ldr	r3, [sp, #4]
 8000fe8:	2f00      	cmp	r7, #0
 8000fea:	f47f af6d 	bne.w	8000ec8 <_Unwind_VRS_Pop+0x150>
 8000fee:	460a      	mov	r2, r1
 8000ff0:	e709      	b.n	8000e06 <_Unwind_VRS_Pop+0x8e>
 8000ff2:	460a      	mov	r2, r1
 8000ff4:	e78d      	b.n	8000f12 <_Unwind_VRS_Pop+0x19a>
 8000ff6:	bf00      	nop

08000ff8 <__restore_core_regs>:
 8000ff8:	f100 0134 	add.w	r1, r0, #52	; 0x34
 8000ffc:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
 8001000:	469c      	mov	ip, r3
 8001002:	46a6      	mov	lr, r4
 8001004:	f84c 5d04 	str.w	r5, [ip, #-4]!
 8001008:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
 800100c:	46e5      	mov	sp, ip
 800100e:	bd00      	pop	{pc}

08001010 <__gnu_Unwind_Restore_VFP>:
 8001010:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
 8001014:	4770      	bx	lr
 8001016:	bf00      	nop

08001018 <__gnu_Unwind_Save_VFP>:
 8001018:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
 800101c:	4770      	bx	lr
 800101e:	bf00      	nop

08001020 <__gnu_Unwind_Restore_VFP_D>:
 8001020:	ec90 0b20 	vldmia	r0, {d0-d15}
 8001024:	4770      	bx	lr
 8001026:	bf00      	nop

08001028 <__gnu_Unwind_Save_VFP_D>:
 8001028:	ec80 0b20 	vstmia	r0, {d0-d15}
 800102c:	4770      	bx	lr
 800102e:	bf00      	nop

08001030 <__gnu_Unwind_Restore_VFP_D_16_to_31>:
 8001030:	ecd0 0b20 	vldmia	r0, {d16-d31}
 8001034:	4770      	bx	lr
 8001036:	bf00      	nop

08001038 <__gnu_Unwind_Save_VFP_D_16_to_31>:
 8001038:	ecc0 0b20 	vstmia	r0, {d16-d31}
 800103c:	4770      	bx	lr
 800103e:	bf00      	nop

08001040 <__gnu_Unwind_Restore_WMMXD>:
 8001040:	ecf0 0102 	ldfe	f0, [r0], #8
 8001044:	ecf0 1102 	ldfe	f1, [r0], #8
 8001048:	ecf0 2102 	ldfe	f2, [r0], #8
 800104c:	ecf0 3102 	ldfe	f3, [r0], #8
 8001050:	ecf0 4102 	ldfe	f4, [r0], #8
 8001054:	ecf0 5102 	ldfe	f5, [r0], #8
 8001058:	ecf0 6102 	ldfe	f6, [r0], #8
 800105c:	ecf0 7102 	ldfe	f7, [r0], #8
 8001060:	ecf0 8102 	ldfp	f0, [r0], #8
 8001064:	ecf0 9102 	ldfp	f1, [r0], #8
 8001068:	ecf0 a102 	ldfp	f2, [r0], #8
 800106c:	ecf0 b102 	ldfp	f3, [r0], #8
 8001070:	ecf0 c102 	ldfp	f4, [r0], #8
 8001074:	ecf0 d102 	ldfp	f5, [r0], #8
 8001078:	ecf0 e102 	ldfp	f6, [r0], #8
 800107c:	ecf0 f102 	ldfp	f7, [r0], #8
 8001080:	4770      	bx	lr
 8001082:	bf00      	nop

08001084 <__gnu_Unwind_Save_WMMXD>:
 8001084:	ece0 0102 	stfe	f0, [r0], #8
 8001088:	ece0 1102 	stfe	f1, [r0], #8
 800108c:	ece0 2102 	stfe	f2, [r0], #8
 8001090:	ece0 3102 	stfe	f3, [r0], #8
 8001094:	ece0 4102 	stfe	f4, [r0], #8
 8001098:	ece0 5102 	stfe	f5, [r0], #8
 800109c:	ece0 6102 	stfe	f6, [r0], #8
 80010a0:	ece0 7102 	stfe	f7, [r0], #8
 80010a4:	ece0 8102 	stfp	f0, [r0], #8
 80010a8:	ece0 9102 	stfp	f1, [r0], #8
 80010ac:	ece0 a102 	stfp	f2, [r0], #8
 80010b0:	ece0 b102 	stfp	f3, [r0], #8
 80010b4:	ece0 c102 	stfp	f4, [r0], #8
 80010b8:	ece0 d102 	stfp	f5, [r0], #8
 80010bc:	ece0 e102 	stfp	f6, [r0], #8
 80010c0:	ece0 f102 	stfp	f7, [r0], #8
 80010c4:	4770      	bx	lr
 80010c6:	bf00      	nop

080010c8 <__gnu_Unwind_Restore_WMMXC>:
 80010c8:	fcb0 8101 	ldc2	1, cr8, [r0], #4
 80010cc:	fcb0 9101 	ldc2	1, cr9, [r0], #4
 80010d0:	fcb0 a101 	ldc2	1, cr10, [r0], #4
 80010d4:	fcb0 b101 	ldc2	1, cr11, [r0], #4
 80010d8:	4770      	bx	lr
 80010da:	bf00      	nop

080010dc <__gnu_Unwind_Save_WMMXC>:
 80010dc:	fca0 8101 	stc2	1, cr8, [r0], #4
 80010e0:	fca0 9101 	stc2	1, cr9, [r0], #4
 80010e4:	fca0 a101 	stc2	1, cr10, [r0], #4
 80010e8:	fca0 b101 	stc2	1, cr11, [r0], #4
 80010ec:	4770      	bx	lr
 80010ee:	bf00      	nop

080010f0 <_Unwind_RaiseException>:
 80010f0:	46ec      	mov	ip, sp
 80010f2:	b500      	push	{lr}
 80010f4:	e92d 5000 	stmdb	sp!, {ip, lr}
 80010f8:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 80010fc:	f04f 0300 	mov.w	r3, #0
 8001100:	e92d 000c 	stmdb	sp!, {r2, r3}
 8001104:	a901      	add	r1, sp, #4
 8001106:	f7ff fbdd 	bl	80008c4 <__gnu_Unwind_RaiseException>
 800110a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 800110e:	b012      	add	sp, #72	; 0x48
 8001110:	4770      	bx	lr
 8001112:	bf00      	nop

08001114 <_Unwind_Resume>:
 8001114:	46ec      	mov	ip, sp
 8001116:	b500      	push	{lr}
 8001118:	e92d 5000 	stmdb	sp!, {ip, lr}
 800111c:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8001120:	f04f 0300 	mov.w	r3, #0
 8001124:	e92d 000c 	stmdb	sp!, {r2, r3}
 8001128:	a901      	add	r1, sp, #4
 800112a:	f7ff fc05 	bl	8000938 <__gnu_Unwind_Resume>
 800112e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8001132:	b012      	add	sp, #72	; 0x48
 8001134:	4770      	bx	lr
 8001136:	bf00      	nop

08001138 <_Unwind_Resume_or_Rethrow>:
 8001138:	46ec      	mov	ip, sp
 800113a:	b500      	push	{lr}
 800113c:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001140:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8001144:	f04f 0300 	mov.w	r3, #0
 8001148:	e92d 000c 	stmdb	sp!, {r2, r3}
 800114c:	a901      	add	r1, sp, #4
 800114e:	f7ff fc15 	bl	800097c <__gnu_Unwind_Resume_or_Rethrow>
 8001152:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8001156:	b012      	add	sp, #72	; 0x48
 8001158:	4770      	bx	lr
 800115a:	bf00      	nop

0800115c <_Unwind_ForcedUnwind>:
 800115c:	46ec      	mov	ip, sp
 800115e:	b500      	push	{lr}
 8001160:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001164:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8001168:	f04f 0300 	mov.w	r3, #0
 800116c:	e92d 000c 	stmdb	sp!, {r2, r3}
 8001170:	ab01      	add	r3, sp, #4
 8001172:	f7ff fbd7 	bl	8000924 <__gnu_Unwind_ForcedUnwind>
 8001176:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 800117a:	b012      	add	sp, #72	; 0x48
 800117c:	4770      	bx	lr
 800117e:	bf00      	nop

08001180 <_Unwind_Backtrace>:
 8001180:	46ec      	mov	ip, sp
 8001182:	b500      	push	{lr}
 8001184:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001188:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 800118c:	f04f 0300 	mov.w	r3, #0
 8001190:	e92d 000c 	stmdb	sp!, {r2, r3}
 8001194:	aa01      	add	r2, sp, #4
 8001196:	f7ff fc47 	bl	8000a28 <__gnu_Unwind_Backtrace>
 800119a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 800119e:	b012      	add	sp, #72	; 0x48
 80011a0:	4770      	bx	lr
 80011a2:	bf00      	nop

080011a4 <next_unwind_byte>:
 80011a4:	7a02      	ldrb	r2, [r0, #8]
 80011a6:	b982      	cbnz	r2, 80011ca <next_unwind_byte+0x26>
 80011a8:	7a43      	ldrb	r3, [r0, #9]
 80011aa:	b1ab      	cbz	r3, 80011d8 <next_unwind_byte+0x34>
 80011ac:	6842      	ldr	r2, [r0, #4]
 80011ae:	3b01      	subs	r3, #1
 80011b0:	b410      	push	{r4}
 80011b2:	7243      	strb	r3, [r0, #9]
 80011b4:	6813      	ldr	r3, [r2, #0]
 80011b6:	2103      	movs	r1, #3
 80011b8:	1d14      	adds	r4, r2, #4
 80011ba:	7201      	strb	r1, [r0, #8]
 80011bc:	021a      	lsls	r2, r3, #8
 80011be:	6044      	str	r4, [r0, #4]
 80011c0:	6002      	str	r2, [r0, #0]
 80011c2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80011c6:	0e18      	lsrs	r0, r3, #24
 80011c8:	4770      	bx	lr
 80011ca:	6803      	ldr	r3, [r0, #0]
 80011cc:	3a01      	subs	r2, #1
 80011ce:	7202      	strb	r2, [r0, #8]
 80011d0:	021a      	lsls	r2, r3, #8
 80011d2:	6002      	str	r2, [r0, #0]
 80011d4:	0e18      	lsrs	r0, r3, #24
 80011d6:	4770      	bx	lr
 80011d8:	20b0      	movs	r0, #176	; 0xb0
 80011da:	4770      	bx	lr

080011dc <_Unwind_GetGR.constprop.0>:
 80011dc:	b500      	push	{lr}
 80011de:	b085      	sub	sp, #20
 80011e0:	aa03      	add	r2, sp, #12
 80011e2:	2300      	movs	r3, #0
 80011e4:	9200      	str	r2, [sp, #0]
 80011e6:	4619      	mov	r1, r3
 80011e8:	220c      	movs	r2, #12
 80011ea:	f7ff fbd7 	bl	800099c <_Unwind_VRS_Get>
 80011ee:	9803      	ldr	r0, [sp, #12]
 80011f0:	b005      	add	sp, #20
 80011f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80011f6:	bf00      	nop

080011f8 <unwind_UCB_from_context>:
 80011f8:	e7f0      	b.n	80011dc <_Unwind_GetGR.constprop.0>
 80011fa:	bf00      	nop

080011fc <__gnu_unwind_execute>:
 80011fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001200:	4605      	mov	r5, r0
 8001202:	b085      	sub	sp, #20
 8001204:	460e      	mov	r6, r1
 8001206:	f04f 0800 	mov.w	r8, #0
 800120a:	4630      	mov	r0, r6
 800120c:	f7ff ffca 	bl	80011a4 <next_unwind_byte>
 8001210:	28b0      	cmp	r0, #176	; 0xb0
 8001212:	4604      	mov	r4, r0
 8001214:	f000 80b1 	beq.w	800137a <__gnu_unwind_execute+0x17e>
 8001218:	0607      	lsls	r7, r0, #24
 800121a:	d520      	bpl.n	800125e <__gnu_unwind_execute+0x62>
 800121c:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 8001220:	2b80      	cmp	r3, #128	; 0x80
 8001222:	d065      	beq.n	80012f0 <__gnu_unwind_execute+0xf4>
 8001224:	2b90      	cmp	r3, #144	; 0x90
 8001226:	d036      	beq.n	8001296 <__gnu_unwind_execute+0x9a>
 8001228:	2ba0      	cmp	r3, #160	; 0xa0
 800122a:	d078      	beq.n	800131e <__gnu_unwind_execute+0x122>
 800122c:	2bb0      	cmp	r3, #176	; 0xb0
 800122e:	d047      	beq.n	80012c0 <__gnu_unwind_execute+0xc4>
 8001230:	2bc0      	cmp	r3, #192	; 0xc0
 8001232:	f000 808a 	beq.w	800134a <__gnu_unwind_execute+0x14e>
 8001236:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 800123a:	2bd0      	cmp	r3, #208	; 0xd0
 800123c:	d10b      	bne.n	8001256 <__gnu_unwind_execute+0x5a>
 800123e:	f000 0207 	and.w	r2, r0, #7
 8001242:	3201      	adds	r2, #1
 8001244:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8001248:	2305      	movs	r3, #5
 800124a:	2101      	movs	r1, #1
 800124c:	4628      	mov	r0, r5
 800124e:	f7ff fd93 	bl	8000d78 <_Unwind_VRS_Pop>
 8001252:	2800      	cmp	r0, #0
 8001254:	d0d9      	beq.n	800120a <__gnu_unwind_execute+0xe>
 8001256:	2009      	movs	r0, #9
 8001258:	b005      	add	sp, #20
 800125a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800125e:	f10d 090c 	add.w	r9, sp, #12
 8001262:	2300      	movs	r3, #0
 8001264:	4619      	mov	r1, r3
 8001266:	0087      	lsls	r7, r0, #2
 8001268:	f8cd 9000 	str.w	r9, [sp]
 800126c:	220d      	movs	r2, #13
 800126e:	4628      	mov	r0, r5
 8001270:	f7ff fb94 	bl	800099c <_Unwind_VRS_Get>
 8001274:	b2ff      	uxtb	r7, r7
 8001276:	9b03      	ldr	r3, [sp, #12]
 8001278:	f8cd 9000 	str.w	r9, [sp]
 800127c:	3704      	adds	r7, #4
 800127e:	0660      	lsls	r0, r4, #25
 8001280:	bf4c      	ite	mi
 8001282:	1bdf      	submi	r7, r3, r7
 8001284:	18ff      	addpl	r7, r7, r3
 8001286:	2300      	movs	r3, #0
 8001288:	4619      	mov	r1, r3
 800128a:	220d      	movs	r2, #13
 800128c:	4628      	mov	r0, r5
 800128e:	9703      	str	r7, [sp, #12]
 8001290:	f7ff fba6 	bl	80009e0 <_Unwind_VRS_Set>
 8001294:	e7b9      	b.n	800120a <__gnu_unwind_execute+0xe>
 8001296:	f000 030d 	and.w	r3, r0, #13
 800129a:	2b0d      	cmp	r3, #13
 800129c:	d0db      	beq.n	8001256 <__gnu_unwind_execute+0x5a>
 800129e:	af03      	add	r7, sp, #12
 80012a0:	2300      	movs	r3, #0
 80012a2:	f000 020f 	and.w	r2, r0, #15
 80012a6:	4619      	mov	r1, r3
 80012a8:	9700      	str	r7, [sp, #0]
 80012aa:	4628      	mov	r0, r5
 80012ac:	f7ff fb76 	bl	800099c <_Unwind_VRS_Get>
 80012b0:	2300      	movs	r3, #0
 80012b2:	9700      	str	r7, [sp, #0]
 80012b4:	4619      	mov	r1, r3
 80012b6:	220d      	movs	r2, #13
 80012b8:	4628      	mov	r0, r5
 80012ba:	f7ff fb91 	bl	80009e0 <_Unwind_VRS_Set>
 80012be:	e7a4      	b.n	800120a <__gnu_unwind_execute+0xe>
 80012c0:	28b1      	cmp	r0, #177	; 0xb1
 80012c2:	d05f      	beq.n	8001384 <__gnu_unwind_execute+0x188>
 80012c4:	28b2      	cmp	r0, #178	; 0xb2
 80012c6:	f000 80cc 	beq.w	8001462 <__gnu_unwind_execute+0x266>
 80012ca:	28b3      	cmp	r0, #179	; 0xb3
 80012cc:	d07e      	beq.n	80013cc <__gnu_unwind_execute+0x1d0>
 80012ce:	f000 03fc 	and.w	r3, r0, #252	; 0xfc
 80012d2:	2bb4      	cmp	r3, #180	; 0xb4
 80012d4:	d0bf      	beq.n	8001256 <__gnu_unwind_execute+0x5a>
 80012d6:	f000 0207 	and.w	r2, r0, #7
 80012da:	3201      	adds	r2, #1
 80012dc:	2301      	movs	r3, #1
 80012de:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80012e2:	4619      	mov	r1, r3
 80012e4:	4628      	mov	r0, r5
 80012e6:	f7ff fd47 	bl	8000d78 <_Unwind_VRS_Pop>
 80012ea:	2800      	cmp	r0, #0
 80012ec:	d08d      	beq.n	800120a <__gnu_unwind_execute+0xe>
 80012ee:	e7b2      	b.n	8001256 <__gnu_unwind_execute+0x5a>
 80012f0:	4630      	mov	r0, r6
 80012f2:	f7ff ff57 	bl	80011a4 <next_unwind_byte>
 80012f6:	0224      	lsls	r4, r4, #8
 80012f8:	4304      	orrs	r4, r0
 80012fa:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 80012fe:	d0aa      	beq.n	8001256 <__gnu_unwind_execute+0x5a>
 8001300:	0124      	lsls	r4, r4, #4
 8001302:	2300      	movs	r3, #0
 8001304:	b2a2      	uxth	r2, r4
 8001306:	4619      	mov	r1, r3
 8001308:	4628      	mov	r0, r5
 800130a:	f7ff fd35 	bl	8000d78 <_Unwind_VRS_Pop>
 800130e:	2800      	cmp	r0, #0
 8001310:	d1a1      	bne.n	8001256 <__gnu_unwind_execute+0x5a>
 8001312:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8001316:	bf18      	it	ne
 8001318:	f04f 0801 	movne.w	r8, #1
 800131c:	e775      	b.n	800120a <__gnu_unwind_execute+0xe>
 800131e:	43c2      	mvns	r2, r0
 8001320:	f002 0307 	and.w	r3, r2, #7
 8001324:	f44f 627f 	mov.w	r2, #4080	; 0xff0
 8001328:	411a      	asrs	r2, r3
 800132a:	0701      	lsls	r1, r0, #28
 800132c:	f402 627f 	and.w	r2, r2, #4080	; 0xff0
 8001330:	f04f 0300 	mov.w	r3, #0
 8001334:	bf48      	it	mi
 8001336:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
 800133a:	4619      	mov	r1, r3
 800133c:	4628      	mov	r0, r5
 800133e:	f7ff fd1b 	bl	8000d78 <_Unwind_VRS_Pop>
 8001342:	2800      	cmp	r0, #0
 8001344:	f43f af61 	beq.w	800120a <__gnu_unwind_execute+0xe>
 8001348:	e785      	b.n	8001256 <__gnu_unwind_execute+0x5a>
 800134a:	28c6      	cmp	r0, #198	; 0xc6
 800134c:	d051      	beq.n	80013f2 <__gnu_unwind_execute+0x1f6>
 800134e:	28c7      	cmp	r0, #199	; 0xc7
 8001350:	d05a      	beq.n	8001408 <__gnu_unwind_execute+0x20c>
 8001352:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 8001356:	2bc0      	cmp	r3, #192	; 0xc0
 8001358:	d069      	beq.n	800142e <__gnu_unwind_execute+0x232>
 800135a:	28c8      	cmp	r0, #200	; 0xc8
 800135c:	d075      	beq.n	800144a <__gnu_unwind_execute+0x24e>
 800135e:	28c9      	cmp	r0, #201	; 0xc9
 8001360:	f47f af79 	bne.w	8001256 <__gnu_unwind_execute+0x5a>
 8001364:	4630      	mov	r0, r6
 8001366:	f7ff ff1d 	bl	80011a4 <next_unwind_byte>
 800136a:	0302      	lsls	r2, r0, #12
 800136c:	f000 000f 	and.w	r0, r0, #15
 8001370:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
 8001374:	3001      	adds	r0, #1
 8001376:	4302      	orrs	r2, r0
 8001378:	e766      	b.n	8001248 <__gnu_unwind_execute+0x4c>
 800137a:	f1b8 0f00 	cmp.w	r8, #0
 800137e:	d014      	beq.n	80013aa <__gnu_unwind_execute+0x1ae>
 8001380:	2000      	movs	r0, #0
 8001382:	e769      	b.n	8001258 <__gnu_unwind_execute+0x5c>
 8001384:	4630      	mov	r0, r6
 8001386:	f7ff ff0d 	bl	80011a4 <next_unwind_byte>
 800138a:	2800      	cmp	r0, #0
 800138c:	f43f af63 	beq.w	8001256 <__gnu_unwind_execute+0x5a>
 8001390:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 8001394:	f47f af5f 	bne.w	8001256 <__gnu_unwind_execute+0x5a>
 8001398:	4602      	mov	r2, r0
 800139a:	4619      	mov	r1, r3
 800139c:	4628      	mov	r0, r5
 800139e:	f7ff fceb 	bl	8000d78 <_Unwind_VRS_Pop>
 80013a2:	2800      	cmp	r0, #0
 80013a4:	f43f af31 	beq.w	800120a <__gnu_unwind_execute+0xe>
 80013a8:	e755      	b.n	8001256 <__gnu_unwind_execute+0x5a>
 80013aa:	ac03      	add	r4, sp, #12
 80013ac:	4643      	mov	r3, r8
 80013ae:	220e      	movs	r2, #14
 80013b0:	4641      	mov	r1, r8
 80013b2:	9400      	str	r4, [sp, #0]
 80013b4:	4628      	mov	r0, r5
 80013b6:	f7ff faf1 	bl	800099c <_Unwind_VRS_Get>
 80013ba:	9400      	str	r4, [sp, #0]
 80013bc:	4628      	mov	r0, r5
 80013be:	4643      	mov	r3, r8
 80013c0:	220f      	movs	r2, #15
 80013c2:	4641      	mov	r1, r8
 80013c4:	f7ff fb0c 	bl	80009e0 <_Unwind_VRS_Set>
 80013c8:	4640      	mov	r0, r8
 80013ca:	e745      	b.n	8001258 <__gnu_unwind_execute+0x5c>
 80013cc:	4630      	mov	r0, r6
 80013ce:	f7ff fee9 	bl	80011a4 <next_unwind_byte>
 80013d2:	0301      	lsls	r1, r0, #12
 80013d4:	f000 000f 	and.w	r0, r0, #15
 80013d8:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
 80013dc:	1c42      	adds	r2, r0, #1
 80013de:	2301      	movs	r3, #1
 80013e0:	430a      	orrs	r2, r1
 80013e2:	4628      	mov	r0, r5
 80013e4:	4619      	mov	r1, r3
 80013e6:	f7ff fcc7 	bl	8000d78 <_Unwind_VRS_Pop>
 80013ea:	2800      	cmp	r0, #0
 80013ec:	f43f af0d 	beq.w	800120a <__gnu_unwind_execute+0xe>
 80013f0:	e731      	b.n	8001256 <__gnu_unwind_execute+0x5a>
 80013f2:	4630      	mov	r0, r6
 80013f4:	f7ff fed6 	bl	80011a4 <next_unwind_byte>
 80013f8:	0301      	lsls	r1, r0, #12
 80013fa:	f000 000f 	and.w	r0, r0, #15
 80013fe:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
 8001402:	1c42      	adds	r2, r0, #1
 8001404:	2303      	movs	r3, #3
 8001406:	e7eb      	b.n	80013e0 <__gnu_unwind_execute+0x1e4>
 8001408:	4630      	mov	r0, r6
 800140a:	f7ff fecb 	bl	80011a4 <next_unwind_byte>
 800140e:	4602      	mov	r2, r0
 8001410:	2800      	cmp	r0, #0
 8001412:	f43f af20 	beq.w	8001256 <__gnu_unwind_execute+0x5a>
 8001416:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 800141a:	f47f af1c 	bne.w	8001256 <__gnu_unwind_execute+0x5a>
 800141e:	2104      	movs	r1, #4
 8001420:	4628      	mov	r0, r5
 8001422:	f7ff fca9 	bl	8000d78 <_Unwind_VRS_Pop>
 8001426:	2800      	cmp	r0, #0
 8001428:	f43f aeef 	beq.w	800120a <__gnu_unwind_execute+0xe>
 800142c:	e713      	b.n	8001256 <__gnu_unwind_execute+0x5a>
 800142e:	f000 020f 	and.w	r2, r0, #15
 8001432:	3201      	adds	r2, #1
 8001434:	2303      	movs	r3, #3
 8001436:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
 800143a:	4619      	mov	r1, r3
 800143c:	4628      	mov	r0, r5
 800143e:	f7ff fc9b 	bl	8000d78 <_Unwind_VRS_Pop>
 8001442:	2800      	cmp	r0, #0
 8001444:	f43f aee1 	beq.w	800120a <__gnu_unwind_execute+0xe>
 8001448:	e705      	b.n	8001256 <__gnu_unwind_execute+0x5a>
 800144a:	4630      	mov	r0, r6
 800144c:	f7ff feaa 	bl	80011a4 <next_unwind_byte>
 8001450:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 8001454:	f000 030f 	and.w	r3, r0, #15
 8001458:	3210      	adds	r2, #16
 800145a:	3301      	adds	r3, #1
 800145c:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 8001460:	e6f2      	b.n	8001248 <__gnu_unwind_execute+0x4c>
 8001462:	2300      	movs	r3, #0
 8001464:	f10d 090c 	add.w	r9, sp, #12
 8001468:	220d      	movs	r2, #13
 800146a:	4619      	mov	r1, r3
 800146c:	f8cd 9000 	str.w	r9, [sp]
 8001470:	4628      	mov	r0, r5
 8001472:	f7ff fa93 	bl	800099c <_Unwind_VRS_Get>
 8001476:	4630      	mov	r0, r6
 8001478:	f7ff fe94 	bl	80011a4 <next_unwind_byte>
 800147c:	0602      	lsls	r2, r0, #24
 800147e:	f04f 0702 	mov.w	r7, #2
 8001482:	d50c      	bpl.n	800149e <__gnu_unwind_execute+0x2a2>
 8001484:	9b03      	ldr	r3, [sp, #12]
 8001486:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800148a:	40b8      	lsls	r0, r7
 800148c:	4403      	add	r3, r0
 800148e:	4630      	mov	r0, r6
 8001490:	9303      	str	r3, [sp, #12]
 8001492:	f7ff fe87 	bl	80011a4 <next_unwind_byte>
 8001496:	0603      	lsls	r3, r0, #24
 8001498:	f107 0707 	add.w	r7, r7, #7
 800149c:	d4f2      	bmi.n	8001484 <__gnu_unwind_execute+0x288>
 800149e:	9b03      	ldr	r3, [sp, #12]
 80014a0:	f8cd 9000 	str.w	r9, [sp]
 80014a4:	f000 047f 	and.w	r4, r0, #127	; 0x7f
 80014a8:	f503 7201 	add.w	r2, r3, #516	; 0x204
 80014ac:	40bc      	lsls	r4, r7
 80014ae:	2300      	movs	r3, #0
 80014b0:	4414      	add	r4, r2
 80014b2:	4619      	mov	r1, r3
 80014b4:	220d      	movs	r2, #13
 80014b6:	4628      	mov	r0, r5
 80014b8:	9403      	str	r4, [sp, #12]
 80014ba:	f7ff fa91 	bl	80009e0 <_Unwind_VRS_Set>
 80014be:	e6a4      	b.n	800120a <__gnu_unwind_execute+0xe>

080014c0 <__gnu_unwind_frame>:
 80014c0:	b510      	push	{r4, lr}
 80014c2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80014c4:	b084      	sub	sp, #16
 80014c6:	685a      	ldr	r2, [r3, #4]
 80014c8:	2003      	movs	r0, #3
 80014ca:	f88d 000c 	strb.w	r0, [sp, #12]
 80014ce:	79dc      	ldrb	r4, [r3, #7]
 80014d0:	f88d 400d 	strb.w	r4, [sp, #13]
 80014d4:	0212      	lsls	r2, r2, #8
 80014d6:	3308      	adds	r3, #8
 80014d8:	4608      	mov	r0, r1
 80014da:	a901      	add	r1, sp, #4
 80014dc:	9201      	str	r2, [sp, #4]
 80014de:	9302      	str	r3, [sp, #8]
 80014e0:	f7ff fe8c 	bl	80011fc <__gnu_unwind_execute>
 80014e4:	b004      	add	sp, #16
 80014e6:	bd10      	pop	{r4, pc}

080014e8 <_Unwind_GetRegionStart>:
 80014e8:	b508      	push	{r3, lr}
 80014ea:	f7ff fe85 	bl	80011f8 <unwind_UCB_from_context>
 80014ee:	6c80      	ldr	r0, [r0, #72]	; 0x48
 80014f0:	bd08      	pop	{r3, pc}
 80014f2:	bf00      	nop

080014f4 <_Unwind_GetLanguageSpecificData>:
 80014f4:	b508      	push	{r3, lr}
 80014f6:	f7ff fe7f 	bl	80011f8 <unwind_UCB_from_context>
 80014fa:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 80014fc:	79c3      	ldrb	r3, [r0, #7]
 80014fe:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8001502:	3008      	adds	r0, #8
 8001504:	bd08      	pop	{r3, pc}
 8001506:	bf00      	nop

08001508 <_Unwind_GetDataRelBase>:
 8001508:	b508      	push	{r3, lr}
 800150a:	f00d ff76 	bl	800f3fa <abort>
 800150e:	bf00      	nop

08001510 <_Unwind_GetTextRelBase>:
 8001510:	b508      	push	{r3, lr}
 8001512:	f7ff fff9 	bl	8001508 <_Unwind_GetDataRelBase>
 8001516:	bf00      	nop

08001518 <__aeabi_idiv0>:
 8001518:	4770      	bx	lr
 800151a:	bf00      	nop

0800151c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800151c:	b508      	push	{r3, lr}
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800151e:	2003      	movs	r0, #3
 8001520:	f000 f82e 	bl	8001580 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001524:	2000      	movs	r0, #0
 8001526:	f009 fb83 	bl	800ac30 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 800152a:	f009 fabb 	bl	800aaa4 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 800152e:	2000      	movs	r0, #0
 8001530:	bd08      	pop	{r3, pc}
	...

08001534 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8001534:	4a03      	ldr	r2, [pc, #12]	; (8001544 <HAL_IncTick+0x10>)
 8001536:	6811      	ldr	r1, [r2, #0]
 8001538:	4b03      	ldr	r3, [pc, #12]	; (8001548 <HAL_IncTick+0x14>)
 800153a:	781b      	ldrb	r3, [r3, #0]
 800153c:	440b      	add	r3, r1
 800153e:	6013      	str	r3, [r2, #0]
}
 8001540:	4770      	bx	lr
 8001542:	bf00      	nop
 8001544:	200059e8 	.word	0x200059e8
 8001548:	20000000 	.word	0x20000000

0800154c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800154c:	4b01      	ldr	r3, [pc, #4]	; (8001554 <HAL_GetTick+0x8>)
 800154e:	6818      	ldr	r0, [r3, #0]
}
 8001550:	4770      	bx	lr
 8001552:	bf00      	nop
 8001554:	200059e8 	.word	0x200059e8

08001558 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001558:	b538      	push	{r3, r4, r5, lr}
 800155a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800155c:	f7ff fff6 	bl	800154c <HAL_GetTick>
 8001560:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001562:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 8001566:	d002      	beq.n	800156e <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 8001568:	4b04      	ldr	r3, [pc, #16]	; (800157c <HAL_Delay+0x24>)
 800156a:	781b      	ldrb	r3, [r3, #0]
 800156c:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800156e:	f7ff ffed 	bl	800154c <HAL_GetTick>
 8001572:	1b40      	subs	r0, r0, r5
 8001574:	42a0      	cmp	r0, r4
 8001576:	d3fa      	bcc.n	800156e <HAL_Delay+0x16>
  {
  }
}
 8001578:	bd38      	pop	{r3, r4, r5, pc}
 800157a:	bf00      	nop
 800157c:	20000000 	.word	0x20000000

08001580 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001580:	4906      	ldr	r1, [pc, #24]	; (800159c <HAL_NVIC_SetPriorityGrouping+0x1c>)
 8001582:	68cb      	ldr	r3, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001584:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001588:	041b      	lsls	r3, r3, #16
 800158a:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800158c:	0200      	lsls	r0, r0, #8
 800158e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001592:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 8001594:	4a02      	ldr	r2, [pc, #8]	; (80015a0 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001596:	431a      	orrs	r2, r3
  SCB->AIRCR =  reg_value;
 8001598:	60ca      	str	r2, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800159a:	4770      	bx	lr
 800159c:	e000ed00 	.word	0xe000ed00
 80015a0:	05fa0000 	.word	0x05fa0000

080015a4 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80015a4:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80015a6:	4b15      	ldr	r3, [pc, #84]	; (80015fc <HAL_NVIC_SetPriority+0x58>)
 80015a8:	68db      	ldr	r3, [r3, #12]
 80015aa:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80015ae:	f1c3 0407 	rsb	r4, r3, #7
 80015b2:	2c04      	cmp	r4, #4
 80015b4:	bf28      	it	cs
 80015b6:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80015b8:	1d1d      	adds	r5, r3, #4
 80015ba:	2d06      	cmp	r5, #6
 80015bc:	d914      	bls.n	80015e8 <HAL_NVIC_SetPriority+0x44>
 80015be:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80015c0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 80015c4:	fa05 f404 	lsl.w	r4, r5, r4
 80015c8:	ea21 0104 	bic.w	r1, r1, r4
 80015cc:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80015ce:	fa05 f303 	lsl.w	r3, r5, r3
 80015d2:	ea22 0303 	bic.w	r3, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80015d6:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 80015d8:	2800      	cmp	r0, #0
 80015da:	db07      	blt.n	80015ec <HAL_NVIC_SetPriority+0x48>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80015dc:	0109      	lsls	r1, r1, #4
 80015de:	b2c9      	uxtb	r1, r1
 80015e0:	4b07      	ldr	r3, [pc, #28]	; (8001600 <HAL_NVIC_SetPriority+0x5c>)
 80015e2:	5419      	strb	r1, [r3, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80015e4:	bc30      	pop	{r4, r5}
 80015e6:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80015e8:	2300      	movs	r3, #0
 80015ea:	e7e9      	b.n	80015c0 <HAL_NVIC_SetPriority+0x1c>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80015ec:	f000 000f 	and.w	r0, r0, #15
 80015f0:	0109      	lsls	r1, r1, #4
 80015f2:	b2c9      	uxtb	r1, r1
 80015f4:	4b03      	ldr	r3, [pc, #12]	; (8001604 <HAL_NVIC_SetPriority+0x60>)
 80015f6:	5419      	strb	r1, [r3, r0]
 80015f8:	e7f4      	b.n	80015e4 <HAL_NVIC_SetPriority+0x40>
 80015fa:	bf00      	nop
 80015fc:	e000ed00 	.word	0xe000ed00
 8001600:	e000e400 	.word	0xe000e400
 8001604:	e000ed14 	.word	0xe000ed14

08001608 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8001608:	2800      	cmp	r0, #0
 800160a:	db07      	blt.n	800161c <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800160c:	f000 021f 	and.w	r2, r0, #31
 8001610:	0940      	lsrs	r0, r0, #5
 8001612:	2301      	movs	r3, #1
 8001614:	4093      	lsls	r3, r2
 8001616:	4a02      	ldr	r2, [pc, #8]	; (8001620 <HAL_NVIC_EnableIRQ+0x18>)
 8001618:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800161c:	4770      	bx	lr
 800161e:	bf00      	nop
 8001620:	e000e100 	.word	0xe000e100

08001624 <ETH_MACAddressConfig>:
  
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
 8001624:	7950      	ldrb	r0, [r2, #5]
 8001626:	7913      	ldrb	r3, [r2, #4]
 8001628:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg;
 800162c:	4807      	ldr	r0, [pc, #28]	; (800164c <ETH_MACAddressConfig+0x28>)
 800162e:	500b      	str	r3, [r1, r0]
  /* Calculate the selected MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
 8001630:	78d0      	ldrb	r0, [r2, #3]
 8001632:	7893      	ldrb	r3, [r2, #2]
 8001634:	041b      	lsls	r3, r3, #16
 8001636:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 800163a:	7850      	ldrb	r0, [r2, #1]
 800163c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8001640:	7812      	ldrb	r2, [r2, #0]
 8001642:	4313      	orrs	r3, r2
  
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_LBASE + MacAddr))) = tmpreg;
 8001644:	4a02      	ldr	r2, [pc, #8]	; (8001650 <ETH_MACAddressConfig+0x2c>)
 8001646:	508b      	str	r3, [r1, r2]
}
 8001648:	4770      	bx	lr
 800164a:	bf00      	nop
 800164c:	40028040 	.word	0x40028040
 8001650:	40028044 	.word	0x40028044

08001654 <ETH_DMATransmissionEnable>:
  * @retval None
  */
static void ETH_DMATransmissionEnable(ETH_HandleTypeDef *heth)
{
  /* Enable the DMA transmission */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;  
 8001654:	6801      	ldr	r1, [r0, #0]
 8001656:	f241 0218 	movw	r2, #4120	; 0x1018
 800165a:	588b      	ldr	r3, [r1, r2]
 800165c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001660:	508b      	str	r3, [r1, r2]
}
 8001662:	4770      	bx	lr

08001664 <ETH_DMAReceptionEnable>:
  * @retval None
  */
static void ETH_DMAReceptionEnable(ETH_HandleTypeDef *heth)
{  
  /* Enable the DMA reception */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_SR;  
 8001664:	6801      	ldr	r1, [r0, #0]
 8001666:	f241 0218 	movw	r2, #4120	; 0x1018
 800166a:	588b      	ldr	r3, [r1, r2]
 800166c:	f043 0302 	orr.w	r3, r3, #2
 8001670:	508b      	str	r3, [r1, r2]
}
 8001672:	4770      	bx	lr

08001674 <ETH_MACDMAConfig>:
{
 8001674:	b570      	push	{r4, r5, r6, lr}
 8001676:	b09e      	sub	sp, #120	; 0x78
 8001678:	4604      	mov	r4, r0
  if (err != ETH_SUCCESS) /* Auto-negotiation failed */
 800167a:	b129      	cbz	r1, 8001688 <ETH_MACDMAConfig+0x14>
    (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;
 800167c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001680:	60c3      	str	r3, [r0, #12]
    (heth->Init).Speed = ETH_SPEED_100M;
 8001682:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8001686:	6083      	str	r3, [r0, #8]
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8001688:	69e3      	ldr	r3, [r4, #28]
 800168a:	2b00      	cmp	r3, #0
 800168c:	d168      	bne.n	8001760 <ETH_MACDMAConfig+0xec>
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_ENABLE;
 800168e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001692:	9307      	str	r3, [sp, #28]
  tmpreg = (heth->Instance)->MACCR;
 8001694:	6821      	ldr	r1, [r4, #0]
 8001696:	680b      	ldr	r3, [r1, #0]
  tmpreg &= ETH_MACCR_CLEAR_MASK;
 8001698:	4a37      	ldr	r2, [pc, #220]	; (8001778 <ETH_MACDMAConfig+0x104>)
 800169a:	401a      	ands	r2, r3
                       (heth->Init).Speed | 
 800169c:	68a3      	ldr	r3, [r4, #8]
                       (heth->Init).DuplexMode | 
 800169e:	68e0      	ldr	r0, [r4, #12]
                       macinit.LoopbackMode |
 80016a0:	4303      	orrs	r3, r0
                       macinit.ChecksumOffload |    
 80016a2:	9807      	ldr	r0, [sp, #28]
                       (heth->Init).DuplexMode | 
 80016a4:	4303      	orrs	r3, r0
                       macinit.ChecksumOffload |    
 80016a6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  tmpreg |= (uint32_t)(macinit.Watchdog | 
 80016aa:	4313      	orrs	r3, r2
  (heth->Instance)->MACCR = (uint32_t)tmpreg;
 80016ac:	600b      	str	r3, [r1, #0]
  tmpreg = (heth->Instance)->MACCR;
 80016ae:	6823      	ldr	r3, [r4, #0]
 80016b0:	681d      	ldr	r5, [r3, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 80016b2:	2001      	movs	r0, #1
 80016b4:	f7ff ff50 	bl	8001558 <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg; 
 80016b8:	6823      	ldr	r3, [r4, #0]
 80016ba:	601d      	str	r5, [r3, #0]
  (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll | 
 80016bc:	6823      	ldr	r3, [r4, #0]
 80016be:	2241      	movs	r2, #65	; 0x41
 80016c0:	605a      	str	r2, [r3, #4]
   tmpreg = (heth->Instance)->MACFFR;
 80016c2:	6823      	ldr	r3, [r4, #0]
 80016c4:	685d      	ldr	r5, [r3, #4]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 80016c6:	2001      	movs	r0, #1
 80016c8:	f7ff ff46 	bl	8001558 <HAL_Delay>
   (heth->Instance)->MACFFR = tmpreg;
 80016cc:	6823      	ldr	r3, [r4, #0]
 80016ce:	605d      	str	r5, [r3, #4]
   (heth->Instance)->MACHTHR = (uint32_t)macinit.HashTableHigh;
 80016d0:	6823      	ldr	r3, [r4, #0]
 80016d2:	2500      	movs	r5, #0
 80016d4:	609d      	str	r5, [r3, #8]
   (heth->Instance)->MACHTLR = (uint32_t)macinit.HashTableLow;
 80016d6:	6823      	ldr	r3, [r4, #0]
 80016d8:	60dd      	str	r5, [r3, #12]
   tmpreg = (heth->Instance)->MACFCR;
 80016da:	6822      	ldr	r2, [r4, #0]
 80016dc:	6993      	ldr	r3, [r2, #24]
   tmpreg &= ETH_MACFCR_CLEAR_MASK;
 80016de:	f023 03be 	bic.w	r3, r3, #190	; 0xbe
 80016e2:	041b      	lsls	r3, r3, #16
 80016e4:	0c1b      	lsrs	r3, r3, #16
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) | 
 80016e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   (heth->Instance)->MACFCR = (uint32_t)tmpreg;
 80016ea:	6193      	str	r3, [r2, #24]
   tmpreg = (heth->Instance)->MACFCR;
 80016ec:	6823      	ldr	r3, [r4, #0]
 80016ee:	699e      	ldr	r6, [r3, #24]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 80016f0:	2001      	movs	r0, #1
 80016f2:	f7ff ff31 	bl	8001558 <HAL_Delay>
   (heth->Instance)->MACFCR = tmpreg;
 80016f6:	6823      	ldr	r3, [r4, #0]
 80016f8:	619e      	str	r6, [r3, #24]
   (heth->Instance)->MACVLANTR = (uint32_t)(macinit.VLANTagComparison | 
 80016fa:	6823      	ldr	r3, [r4, #0]
 80016fc:	61dd      	str	r5, [r3, #28]
    tmpreg = (heth->Instance)->MACVLANTR;
 80016fe:	6823      	ldr	r3, [r4, #0]
 8001700:	69dd      	ldr	r5, [r3, #28]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8001702:	2001      	movs	r0, #1
 8001704:	f7ff ff28 	bl	8001558 <HAL_Delay>
    (heth->Instance)->MACVLANTR = tmpreg;
 8001708:	6823      	ldr	r3, [r4, #0]
 800170a:	61dd      	str	r5, [r3, #28]
    tmpreg = (heth->Instance)->DMAOMR;
 800170c:	6821      	ldr	r1, [r4, #0]
 800170e:	f241 0518 	movw	r5, #4120	; 0x1018
 8001712:	594b      	ldr	r3, [r1, r5]
    tmpreg &= ETH_DMAOMR_CLEAR_MASK;
 8001714:	4a19      	ldr	r2, [pc, #100]	; (800177c <ETH_MACDMAConfig+0x108>)
 8001716:	401a      	ands	r2, r3
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame | 
 8001718:	4b19      	ldr	r3, [pc, #100]	; (8001780 <ETH_MACDMAConfig+0x10c>)
 800171a:	4313      	orrs	r3, r2
    (heth->Instance)->DMAOMR = (uint32_t)tmpreg;
 800171c:	514b      	str	r3, [r1, r5]
    tmpreg = (heth->Instance)->DMAOMR;
 800171e:	6823      	ldr	r3, [r4, #0]
 8001720:	595e      	ldr	r6, [r3, r5]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8001722:	2001      	movs	r0, #1
 8001724:	f7ff ff18 	bl	8001558 <HAL_Delay>
    (heth->Instance)->DMAOMR = tmpreg;
 8001728:	6823      	ldr	r3, [r4, #0]
 800172a:	515e      	str	r6, [r3, r5]
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 800172c:	6823      	ldr	r3, [r4, #0]
 800172e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001732:	4a14      	ldr	r2, [pc, #80]	; (8001784 <ETH_MACDMAConfig+0x110>)
 8001734:	601a      	str	r2, [r3, #0]
     tmpreg = (heth->Instance)->DMABMR;
 8001736:	6823      	ldr	r3, [r4, #0]
 8001738:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800173c:	681d      	ldr	r5, [r3, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 800173e:	2001      	movs	r0, #1
 8001740:	f7ff ff0a 	bl	8001558 <HAL_Delay>
     (heth->Instance)->DMABMR = tmpreg;
 8001744:	6823      	ldr	r3, [r4, #0]
 8001746:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800174a:	601d      	str	r5, [r3, #0]
     if((heth->Init).RxMode == ETH_RXINTERRUPT_MODE)
 800174c:	69a3      	ldr	r3, [r4, #24]
 800174e:	2b01      	cmp	r3, #1
 8001750:	d009      	beq.n	8001766 <ETH_MACDMAConfig+0xf2>
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 8001752:	6962      	ldr	r2, [r4, #20]
 8001754:	2100      	movs	r1, #0
 8001756:	4620      	mov	r0, r4
 8001758:	f7ff ff64 	bl	8001624 <ETH_MACAddressConfig>
}
 800175c:	b01e      	add	sp, #120	; 0x78
 800175e:	bd70      	pop	{r4, r5, r6, pc}
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 8001760:	2300      	movs	r3, #0
 8001762:	9307      	str	r3, [sp, #28]
 8001764:	e796      	b.n	8001694 <ETH_MACDMAConfig+0x20>
       __HAL_ETH_DMA_ENABLE_IT((heth), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 8001766:	6821      	ldr	r1, [r4, #0]
 8001768:	f241 021c 	movw	r2, #4124	; 0x101c
 800176c:	5888      	ldr	r0, [r1, r2]
 800176e:	4b06      	ldr	r3, [pc, #24]	; (8001788 <ETH_MACDMAConfig+0x114>)
 8001770:	4303      	orrs	r3, r0
 8001772:	508b      	str	r3, [r1, r2]
 8001774:	e7ed      	b.n	8001752 <ETH_MACDMAConfig+0xde>
 8001776:	bf00      	nop
 8001778:	ff20810f 	.word	0xff20810f
 800177c:	f8de3f23 	.word	0xf8de3f23
 8001780:	02200004 	.word	0x02200004
 8001784:	02c12080 	.word	0x02c12080
 8001788:	00010040 	.word	0x00010040

0800178c <ETH_MACTransmissionEnable>:
{ 
 800178c:	b510      	push	{r4, lr}
 800178e:	b082      	sub	sp, #8
 8001790:	4604      	mov	r4, r0
  __IO uint32_t tmpreg = 0;
 8001792:	2300      	movs	r3, #0
 8001794:	9301      	str	r3, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8001796:	6802      	ldr	r2, [r0, #0]
 8001798:	6813      	ldr	r3, [r2, #0]
 800179a:	f043 0308 	orr.w	r3, r3, #8
 800179e:	6013      	str	r3, [r2, #0]
  tmpreg = (heth->Instance)->MACCR;
 80017a0:	6803      	ldr	r3, [r0, #0]
 80017a2:	681b      	ldr	r3, [r3, #0]
 80017a4:	9301      	str	r3, [sp, #4]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 80017a6:	2001      	movs	r0, #1
 80017a8:	f7ff fed6 	bl	8001558 <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg;
 80017ac:	6823      	ldr	r3, [r4, #0]
 80017ae:	9a01      	ldr	r2, [sp, #4]
 80017b0:	601a      	str	r2, [r3, #0]
}
 80017b2:	b002      	add	sp, #8
 80017b4:	bd10      	pop	{r4, pc}

080017b6 <ETH_MACReceptionEnable>:
{ 
 80017b6:	b510      	push	{r4, lr}
 80017b8:	b082      	sub	sp, #8
 80017ba:	4604      	mov	r4, r0
  __IO uint32_t tmpreg = 0;
 80017bc:	2300      	movs	r3, #0
 80017be:	9301      	str	r3, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_RE;
 80017c0:	6802      	ldr	r2, [r0, #0]
 80017c2:	6813      	ldr	r3, [r2, #0]
 80017c4:	f043 0304 	orr.w	r3, r3, #4
 80017c8:	6013      	str	r3, [r2, #0]
  tmpreg = (heth->Instance)->MACCR;
 80017ca:	6803      	ldr	r3, [r0, #0]
 80017cc:	681b      	ldr	r3, [r3, #0]
 80017ce:	9301      	str	r3, [sp, #4]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 80017d0:	2001      	movs	r0, #1
 80017d2:	f7ff fec1 	bl	8001558 <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg;
 80017d6:	6823      	ldr	r3, [r4, #0]
 80017d8:	9a01      	ldr	r2, [sp, #4]
 80017da:	601a      	str	r2, [r3, #0]
}
 80017dc:	b002      	add	sp, #8
 80017de:	bd10      	pop	{r4, pc}

080017e0 <ETH_FlushTransmitFIFO>:
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_FlushTransmitFIFO(ETH_HandleTypeDef *heth)
{
 80017e0:	b530      	push	{r4, r5, lr}
 80017e2:	b083      	sub	sp, #12
 80017e4:	4605      	mov	r5, r0
  __IO uint32_t tmpreg = 0;
 80017e6:	2300      	movs	r3, #0
 80017e8:	9301      	str	r3, [sp, #4]
  
  /* Set the Flush Transmit FIFO bit */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
 80017ea:	6802      	ldr	r2, [r0, #0]
 80017ec:	f241 0418 	movw	r4, #4120	; 0x1018
 80017f0:	5913      	ldr	r3, [r2, r4]
 80017f2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80017f6:	5113      	str	r3, [r2, r4]
  
  /* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */
  tmpreg = (heth->Instance)->DMAOMR;
 80017f8:	6803      	ldr	r3, [r0, #0]
 80017fa:	591b      	ldr	r3, [r3, r4]
 80017fc:	9301      	str	r3, [sp, #4]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 80017fe:	2001      	movs	r0, #1
 8001800:	f7ff feaa 	bl	8001558 <HAL_Delay>
  (heth->Instance)->DMAOMR = tmpreg;
 8001804:	682b      	ldr	r3, [r5, #0]
 8001806:	9a01      	ldr	r2, [sp, #4]
 8001808:	511a      	str	r2, [r3, r4]
}
 800180a:	b003      	add	sp, #12
 800180c:	bd30      	pop	{r4, r5, pc}

0800180e <HAL_ETH_DMATxDescListInit>:
{
 800180e:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(heth);
 8001810:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 8001814:	2c01      	cmp	r4, #1
 8001816:	d031      	beq.n	800187c <HAL_ETH_DMATxDescListInit+0x6e>
 8001818:	2401      	movs	r4, #1
 800181a:	f880 4045 	strb.w	r4, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 800181e:	2402      	movs	r4, #2
 8001820:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->TxDesc = DMATxDescTab;
 8001824:	62c1      	str	r1, [r0, #44]	; 0x2c
  for(i=0; i < TxBuffCount; i++)
 8001826:	2400      	movs	r4, #0
 8001828:	e001      	b.n	800182e <HAL_ETH_DMATxDescListInit+0x20>
      dmatxdesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
 800182a:	60f9      	str	r1, [r7, #12]
  for(i=0; i < TxBuffCount; i++)
 800182c:	3401      	adds	r4, #1
 800182e:	429c      	cmp	r4, r3
 8001830:	d217      	bcs.n	8001862 <HAL_ETH_DMATxDescListInit+0x54>
    dmatxdesc = DMATxDescTab + i;
 8001832:	0165      	lsls	r5, r4, #5
 8001834:	194f      	adds	r7, r1, r5
    dmatxdesc->Status = ETH_DMATXDESC_TCH;  
 8001836:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
 800183a:	514e      	str	r6, [r1, r5]
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 800183c:	f240 56f4 	movw	r6, #1524	; 0x5f4
 8001840:	fb06 2604 	mla	r6, r6, r4, r2
 8001844:	60be      	str	r6, [r7, #8]
    if ((heth->Init).ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8001846:	69c6      	ldr	r6, [r0, #28]
 8001848:	b91e      	cbnz	r6, 8001852 <HAL_ETH_DMATxDescListInit+0x44>
      dmatxdesc->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 800184a:	594e      	ldr	r6, [r1, r5]
 800184c:	f446 0640 	orr.w	r6, r6, #12582912	; 0xc00000
 8001850:	514e      	str	r6, [r1, r5]
    if(i < (TxBuffCount-1))
 8001852:	1e5d      	subs	r5, r3, #1
 8001854:	42a5      	cmp	r5, r4
 8001856:	d9e8      	bls.n	800182a <HAL_ETH_DMATxDescListInit+0x1c>
      dmatxdesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
 8001858:	1c65      	adds	r5, r4, #1
 800185a:	eb01 1545 	add.w	r5, r1, r5, lsl #5
 800185e:	60fd      	str	r5, [r7, #12]
 8001860:	e7e4      	b.n	800182c <HAL_ETH_DMATxDescListInit+0x1e>
  (heth->Instance)->DMATDLAR = (uint32_t) DMATxDescTab;
 8001862:	6802      	ldr	r2, [r0, #0]
 8001864:	f241 0310 	movw	r3, #4112	; 0x1010
 8001868:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 800186a:	2301      	movs	r3, #1
 800186c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8001870:	2300      	movs	r3, #0
 8001872:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 8001876:	4618      	mov	r0, r3
}
 8001878:	bcf0      	pop	{r4, r5, r6, r7}
 800187a:	4770      	bx	lr
  __HAL_LOCK(heth);
 800187c:	2002      	movs	r0, #2
 800187e:	e7fb      	b.n	8001878 <HAL_ETH_DMATxDescListInit+0x6a>

08001880 <HAL_ETH_DMARxDescListInit>:
{
 8001880:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(heth);
 8001882:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 8001886:	2c01      	cmp	r4, #1
 8001888:	d02e      	beq.n	80018e8 <HAL_ETH_DMARxDescListInit+0x68>
 800188a:	2401      	movs	r4, #1
 800188c:	f880 4045 	strb.w	r4, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8001890:	2402      	movs	r4, #2
 8001892:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->RxDesc = DMARxDescTab; 
 8001896:	6281      	str	r1, [r0, #40]	; 0x28
  for(i=0; i < RxBuffCount; i++)
 8001898:	2400      	movs	r4, #0
 800189a:	e001      	b.n	80018a0 <HAL_ETH_DMARxDescListInit+0x20>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
 800189c:	60e9      	str	r1, [r5, #12]
  for(i=0; i < RxBuffCount; i++)
 800189e:	3401      	adds	r4, #1
 80018a0:	429c      	cmp	r4, r3
 80018a2:	d214      	bcs.n	80018ce <HAL_ETH_DMARxDescListInit+0x4e>
    DMARxDesc = DMARxDescTab+i;
 80018a4:	0166      	lsls	r6, r4, #5
 80018a6:	198d      	adds	r5, r1, r6
    DMARxDesc->Status = ETH_DMARXDESC_OWN;
 80018a8:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
 80018ac:	518f      	str	r7, [r1, r6]
    DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;  
 80018ae:	f244 56f4 	movw	r6, #17908	; 0x45f4
 80018b2:	606e      	str	r6, [r5, #4]
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 80018b4:	f240 56f4 	movw	r6, #1524	; 0x5f4
 80018b8:	fb06 2604 	mla	r6, r6, r4, r2
 80018bc:	60ae      	str	r6, [r5, #8]
    if(i < (RxBuffCount-1))
 80018be:	1e5e      	subs	r6, r3, #1
 80018c0:	42a6      	cmp	r6, r4
 80018c2:	d9eb      	bls.n	800189c <HAL_ETH_DMARxDescListInit+0x1c>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
 80018c4:	1c66      	adds	r6, r4, #1
 80018c6:	eb01 1646 	add.w	r6, r1, r6, lsl #5
 80018ca:	60ee      	str	r6, [r5, #12]
 80018cc:	e7e7      	b.n	800189e <HAL_ETH_DMARxDescListInit+0x1e>
  (heth->Instance)->DMARDLAR = (uint32_t) DMARxDescTab;
 80018ce:	6802      	ldr	r2, [r0, #0]
 80018d0:	f241 030c 	movw	r3, #4108	; 0x100c
 80018d4:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 80018d6:	2301      	movs	r3, #1
 80018d8:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80018dc:	2300      	movs	r3, #0
 80018de:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 80018e2:	4618      	mov	r0, r3
}
 80018e4:	bcf0      	pop	{r4, r5, r6, r7}
 80018e6:	4770      	bx	lr
  __HAL_LOCK(heth);
 80018e8:	2002      	movs	r0, #2
 80018ea:	e7fb      	b.n	80018e4 <HAL_ETH_DMARxDescListInit+0x64>

080018ec <HAL_ETH_TransmitFrame>:
  __HAL_LOCK(heth);
 80018ec:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80018f0:	2b01      	cmp	r3, #1
 80018f2:	f000 8085 	beq.w	8001a00 <HAL_ETH_TransmitFrame+0x114>
 80018f6:	2301      	movs	r3, #1
 80018f8:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 80018fc:	2302      	movs	r3, #2
 80018fe:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  if (FrameLength == 0) 
 8001902:	b1b1      	cbz	r1, 8001932 <HAL_ETH_TransmitFrame+0x46>
  if(((heth->TxDesc)->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 8001904:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001906:	681a      	ldr	r2, [r3, #0]
 8001908:	2a00      	cmp	r2, #0
 800190a:	db1a      	blt.n	8001942 <HAL_ETH_TransmitFrame+0x56>
{
 800190c:	b430      	push	{r4, r5}
  if (FrameLength > ETH_TX_BUF_SIZE)
 800190e:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8001912:	4291      	cmp	r1, r2
 8001914:	d91d      	bls.n	8001952 <HAL_ETH_TransmitFrame+0x66>
    bufcount = FrameLength/ETH_TX_BUF_SIZE;
 8001916:	4a3b      	ldr	r2, [pc, #236]	; (8001a04 <HAL_ETH_TransmitFrame+0x118>)
 8001918:	fba2 4201 	umull	r4, r2, r2, r1
 800191c:	0a92      	lsrs	r2, r2, #10
    if (FrameLength % ETH_TX_BUF_SIZE) 
 800191e:	f240 54f4 	movw	r4, #1524	; 0x5f4
 8001922:	fb04 1412 	mls	r4, r4, r2, r1
 8001926:	b104      	cbz	r4, 800192a <HAL_ETH_TransmitFrame+0x3e>
      bufcount++;
 8001928:	3201      	adds	r2, #1
  if (bufcount == 1)
 800192a:	2a01      	cmp	r2, #1
 800192c:	d011      	beq.n	8001952 <HAL_ETH_TransmitFrame+0x66>
    for (i=0; i< bufcount; i++)
 800192e:	2300      	movs	r3, #0
 8001930:	e047      	b.n	80019c2 <HAL_ETH_TransmitFrame+0xd6>
    heth->State = HAL_ETH_STATE_READY;
 8001932:	2301      	movs	r3, #1
 8001934:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8001938:	2200      	movs	r2, #0
 800193a:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
    return  HAL_ERROR;                                    
 800193e:	4618      	mov	r0, r3
 8001940:	4770      	bx	lr
    heth->State = HAL_ETH_STATE_BUSY_TX;
 8001942:	2312      	movs	r3, #18
 8001944:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8001948:	2300      	movs	r3, #0
 800194a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
    return HAL_ERROR;
 800194e:	2001      	movs	r0, #1
 8001950:	4770      	bx	lr
    heth->TxDesc->Status |=ETH_DMATXDESC_FS|ETH_DMATXDESC_LS;
 8001952:	681a      	ldr	r2, [r3, #0]
 8001954:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8001958:	601a      	str	r2, [r3, #0]
    heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
 800195a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800195c:	f3c1 010c 	ubfx	r1, r1, #0, #13
 8001960:	6059      	str	r1, [r3, #4]
    heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8001962:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001964:	6813      	ldr	r3, [r2, #0]
 8001966:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800196a:	6013      	str	r3, [r2, #0]
    heth->TxDesc= (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 800196c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800196e:	68db      	ldr	r3, [r3, #12]
 8001970:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (((heth->Instance)->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
 8001972:	6803      	ldr	r3, [r0, #0]
 8001974:	f241 0214 	movw	r2, #4116	; 0x1014
 8001978:	589a      	ldr	r2, [r3, r2]
 800197a:	f012 0f04 	tst.w	r2, #4
 800197e:	d008      	beq.n	8001992 <HAL_ETH_TransmitFrame+0xa6>
    (heth->Instance)->DMASR = ETH_DMASR_TBUS;
 8001980:	f241 0214 	movw	r2, #4116	; 0x1014
 8001984:	2104      	movs	r1, #4
 8001986:	5099      	str	r1, [r3, r2]
    (heth->Instance)->DMATPDR = 0;
 8001988:	6802      	ldr	r2, [r0, #0]
 800198a:	f241 0304 	movw	r3, #4100	; 0x1004
 800198e:	2100      	movs	r1, #0
 8001990:	50d1      	str	r1, [r2, r3]
  heth->State = HAL_ETH_STATE_READY;
 8001992:	2301      	movs	r3, #1
 8001994:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8001998:	2300      	movs	r3, #0
 800199a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 800199e:	4618      	mov	r0, r3
}
 80019a0:	bc30      	pop	{r4, r5}
 80019a2:	4770      	bx	lr
        heth->TxDesc->Status |= ETH_DMATXDESC_FS;  
 80019a4:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80019a6:	682c      	ldr	r4, [r5, #0]
 80019a8:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 80019ac:	602c      	str	r4, [r5, #0]
 80019ae:	e011      	b.n	80019d4 <HAL_ETH_TransmitFrame+0xe8>
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 80019b0:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80019b2:	682c      	ldr	r4, [r5, #0]
 80019b4:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 80019b8:	602c      	str	r4, [r5, #0]
      heth->TxDesc = (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 80019ba:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80019bc:	68e4      	ldr	r4, [r4, #12]
 80019be:	62c4      	str	r4, [r0, #44]	; 0x2c
    for (i=0; i< bufcount; i++)
 80019c0:	3301      	adds	r3, #1
 80019c2:	429a      	cmp	r2, r3
 80019c4:	d9d5      	bls.n	8001972 <HAL_ETH_TransmitFrame+0x86>
      heth->TxDesc->Status &= ~(ETH_DMATXDESC_FS | ETH_DMATXDESC_LS);
 80019c6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80019c8:	682c      	ldr	r4, [r5, #0]
 80019ca:	f024 5440 	bic.w	r4, r4, #805306368	; 0x30000000
 80019ce:	602c      	str	r4, [r5, #0]
      if (i == 0) 
 80019d0:	2b00      	cmp	r3, #0
 80019d2:	d0e7      	beq.n	80019a4 <HAL_ETH_TransmitFrame+0xb8>
      heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 80019d4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80019d6:	f240 55f4 	movw	r5, #1524	; 0x5f4
 80019da:	6065      	str	r5, [r4, #4]
      if (i == (bufcount-1))
 80019dc:	1e54      	subs	r4, r2, #1
 80019de:	429c      	cmp	r4, r3
 80019e0:	d1e6      	bne.n	80019b0 <HAL_ETH_TransmitFrame+0xc4>
        heth->TxDesc->Status |= ETH_DMATXDESC_LS;
 80019e2:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80019e4:	682c      	ldr	r4, [r5, #0]
 80019e6:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 80019ea:	602c      	str	r4, [r5, #0]
        size = FrameLength - (bufcount-1)*ETH_TX_BUF_SIZE;
 80019ec:	4c06      	ldr	r4, [pc, #24]	; (8001a08 <HAL_ETH_TransmitFrame+0x11c>)
 80019ee:	fb04 1402 	mla	r4, r4, r2, r1
 80019f2:	f204 54f4 	addw	r4, r4, #1524	; 0x5f4
        heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 80019f6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80019f8:	f3c4 040c 	ubfx	r4, r4, #0, #13
 80019fc:	606c      	str	r4, [r5, #4]
 80019fe:	e7d7      	b.n	80019b0 <HAL_ETH_TransmitFrame+0xc4>
  __HAL_LOCK(heth);
 8001a00:	2002      	movs	r0, #2
}
 8001a02:	4770      	bx	lr
 8001a04:	ac02b00b 	.word	0xac02b00b
 8001a08:	fffffa0c 	.word	0xfffffa0c

08001a0c <HAL_ETH_GetReceivedFrame_IT>:
  __HAL_LOCK(heth);
 8001a0c:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001a10:	2b01      	cmp	r3, #1
 8001a12:	d045      	beq.n	8001aa0 <HAL_ETH_GetReceivedFrame_IT+0x94>
 8001a14:	2301      	movs	r3, #1
 8001a16:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8001a1a:	2302      	movs	r3, #2
 8001a1c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  uint32_t descriptorscancounter = 0;
 8001a20:	2100      	movs	r1, #0
  while (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET) && (descriptorscancounter < ETH_RXBUFNB))
 8001a22:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001a24:	681a      	ldr	r2, [r3, #0]
 8001a26:	2a00      	cmp	r2, #0
 8001a28:	db32      	blt.n	8001a90 <HAL_ETH_GetReceivedFrame_IT+0x84>
 8001a2a:	2903      	cmp	r1, #3
 8001a2c:	d830      	bhi.n	8001a90 <HAL_ETH_GetReceivedFrame_IT+0x84>
    descriptorscancounter++;
 8001a2e:	3101      	adds	r1, #1
    if((heth->RxDesc->Status & (ETH_DMARXDESC_FS | ETH_DMARXDESC_LS)) == (uint32_t)ETH_DMARXDESC_FS)
 8001a30:	681a      	ldr	r2, [r3, #0]
 8001a32:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8001a36:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8001a3a:	d009      	beq.n	8001a50 <HAL_ETH_GetReceivedFrame_IT+0x44>
    else if ((heth->RxDesc->Status & (ETH_DMARXDESC_LS | ETH_DMARXDESC_FS)) == (uint32_t)RESET)
 8001a3c:	681a      	ldr	r2, [r3, #0]
 8001a3e:	f412 7f40 	tst.w	r2, #768	; 0x300
 8001a42:	d10b      	bne.n	8001a5c <HAL_ETH_GetReceivedFrame_IT+0x50>
      (heth->RxFrameInfos.SegCount)++;
 8001a44:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001a46:	3201      	adds	r2, #1
 8001a48:	6382      	str	r2, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*)(heth->RxDesc->Buffer2NextDescAddr);
 8001a4a:	68db      	ldr	r3, [r3, #12]
 8001a4c:	6283      	str	r3, [r0, #40]	; 0x28
 8001a4e:	e7e8      	b.n	8001a22 <HAL_ETH_GetReceivedFrame_IT+0x16>
      heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
 8001a50:	6303      	str	r3, [r0, #48]	; 0x30
      heth->RxFrameInfos.SegCount = 1;   
 8001a52:	2201      	movs	r2, #1
 8001a54:	6382      	str	r2, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 8001a56:	68db      	ldr	r3, [r3, #12]
 8001a58:	6283      	str	r3, [r0, #40]	; 0x28
 8001a5a:	e7e2      	b.n	8001a22 <HAL_ETH_GetReceivedFrame_IT+0x16>
      heth->RxFrameInfos.LSRxDesc = heth->RxDesc;
 8001a5c:	6343      	str	r3, [r0, #52]	; 0x34
      (heth->RxFrameInfos.SegCount)++;
 8001a5e:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001a60:	3201      	adds	r2, #1
 8001a62:	6382      	str	r2, [r0, #56]	; 0x38
      if ((heth->RxFrameInfos.SegCount) == 1)
 8001a64:	2a01      	cmp	r2, #1
 8001a66:	d011      	beq.n	8001a8c <HAL_ETH_GetReceivedFrame_IT+0x80>
      heth->RxFrameInfos.length = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4;
 8001a68:	681a      	ldr	r2, [r3, #0]
 8001a6a:	f3c2 420d 	ubfx	r2, r2, #16, #14
 8001a6e:	3a04      	subs	r2, #4
 8001a70:	63c2      	str	r2, [r0, #60]	; 0x3c
      heth->RxFrameInfos.buffer =((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
 8001a72:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8001a74:	6892      	ldr	r2, [r2, #8]
 8001a76:	6402      	str	r2, [r0, #64]	; 0x40
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 8001a78:	68db      	ldr	r3, [r3, #12]
 8001a7a:	6283      	str	r3, [r0, #40]	; 0x28
      heth->State = HAL_ETH_STATE_READY;
 8001a7c:	2301      	movs	r3, #1
 8001a7e:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8001a82:	2300      	movs	r3, #0
 8001a84:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
      return HAL_OK;
 8001a88:	4618      	mov	r0, r3
 8001a8a:	4770      	bx	lr
        heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
 8001a8c:	6303      	str	r3, [r0, #48]	; 0x30
 8001a8e:	e7eb      	b.n	8001a68 <HAL_ETH_GetReceivedFrame_IT+0x5c>
  heth->State = HAL_ETH_STATE_READY;
 8001a90:	2301      	movs	r3, #1
 8001a92:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8001a96:	2200      	movs	r2, #0
 8001a98:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  return HAL_ERROR;
 8001a9c:	4618      	mov	r0, r3
 8001a9e:	4770      	bx	lr
  __HAL_LOCK(heth);
 8001aa0:	2002      	movs	r0, #2
}
 8001aa2:	4770      	bx	lr

08001aa4 <HAL_ETH_TxCpltCallback>:
}
 8001aa4:	4770      	bx	lr

08001aa6 <HAL_ETH_ErrorCallback>:
}
 8001aa6:	4770      	bx	lr

08001aa8 <HAL_ETH_IRQHandler>:
{
 8001aa8:	b510      	push	{r4, lr}
 8001aaa:	4604      	mov	r4, r0
  if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_R)) 
 8001aac:	6803      	ldr	r3, [r0, #0]
 8001aae:	f241 0214 	movw	r2, #4116	; 0x1014
 8001ab2:	589a      	ldr	r2, [r3, r2]
 8001ab4:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001ab8:	d111      	bne.n	8001ade <HAL_ETH_IRQHandler+0x36>
  else if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_T)) 
 8001aba:	f241 0214 	movw	r2, #4116	; 0x1014
 8001abe:	589b      	ldr	r3, [r3, r2]
 8001ac0:	f013 0f01 	tst.w	r3, #1
 8001ac4:	d119      	bne.n	8001afa <HAL_ETH_IRQHandler+0x52>
  __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_NIS);
 8001ac6:	6822      	ldr	r2, [r4, #0]
 8001ac8:	f241 0314 	movw	r3, #4116	; 0x1014
 8001acc:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8001ad0:	50d1      	str	r1, [r2, r3]
  if(__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_AIS))
 8001ad2:	6822      	ldr	r2, [r4, #0]
 8001ad4:	58d3      	ldr	r3, [r2, r3]
 8001ad6:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001ada:	d11b      	bne.n	8001b14 <HAL_ETH_IRQHandler+0x6c>
}
 8001adc:	bd10      	pop	{r4, pc}
    HAL_ETH_RxCpltCallback(heth);
 8001ade:	f007 fd11 	bl	8009504 <HAL_ETH_RxCpltCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_R);
 8001ae2:	6822      	ldr	r2, [r4, #0]
 8001ae4:	f241 0314 	movw	r3, #4116	; 0x1014
 8001ae8:	2140      	movs	r1, #64	; 0x40
 8001aea:	50d1      	str	r1, [r2, r3]
    heth->State = HAL_ETH_STATE_READY;
 8001aec:	2301      	movs	r3, #1
 8001aee:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8001af2:	2300      	movs	r3, #0
 8001af4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8001af8:	e7e5      	b.n	8001ac6 <HAL_ETH_IRQHandler+0x1e>
    HAL_ETH_TxCpltCallback(heth);
 8001afa:	f7ff ffd3 	bl	8001aa4 <HAL_ETH_TxCpltCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_T);
 8001afe:	6821      	ldr	r1, [r4, #0]
 8001b00:	2301      	movs	r3, #1
 8001b02:	f241 0214 	movw	r2, #4116	; 0x1014
 8001b06:	508b      	str	r3, [r1, r2]
    heth->State = HAL_ETH_STATE_READY;
 8001b08:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8001b0c:	2300      	movs	r3, #0
 8001b0e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8001b12:	e7d8      	b.n	8001ac6 <HAL_ETH_IRQHandler+0x1e>
    HAL_ETH_ErrorCallback(heth);
 8001b14:	4620      	mov	r0, r4
 8001b16:	f7ff ffc6 	bl	8001aa6 <HAL_ETH_ErrorCallback>
    __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_FLAG_AIS);
 8001b1a:	6822      	ldr	r2, [r4, #0]
 8001b1c:	f241 0314 	movw	r3, #4116	; 0x1014
 8001b20:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001b24:	50d1      	str	r1, [r2, r3]
    heth->State = HAL_ETH_STATE_READY;
 8001b26:	2301      	movs	r3, #1
 8001b28:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8001b2c:	2300      	movs	r3, #0
 8001b2e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
}
 8001b32:	e7d3      	b.n	8001adc <HAL_ETH_IRQHandler+0x34>

08001b34 <HAL_ETH_ReadPHYRegister>:
{
 8001b34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(heth->State == HAL_ETH_STATE_BUSY_RD)
 8001b36:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001b3a:	b2db      	uxtb	r3, r3
 8001b3c:	2b82      	cmp	r3, #130	; 0x82
 8001b3e:	d033      	beq.n	8001ba8 <HAL_ETH_ReadPHYRegister+0x74>
 8001b40:	4616      	mov	r6, r2
 8001b42:	4605      	mov	r5, r0
  heth->State = HAL_ETH_STATE_BUSY_RD;
 8001b44:	2382      	movs	r3, #130	; 0x82
 8001b46:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg = heth->Instance->MACMIIAR;
 8001b4a:	6802      	ldr	r2, [r0, #0]
 8001b4c:	6913      	ldr	r3, [r2, #16]
  tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8001b4e:	f003 031c 	and.w	r3, r3, #28
  tmpreg |=(((uint32_t)heth->Init.PhyAddress << 11) & ETH_MACMIIAR_PA); /* Set the PHY device address   */
 8001b52:	8a04      	ldrh	r4, [r0, #16]
 8001b54:	02e4      	lsls	r4, r4, #11
 8001b56:	b2a4      	uxth	r4, r4
 8001b58:	4323      	orrs	r3, r4
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);                   /* Set the PHY register address */
 8001b5a:	018c      	lsls	r4, r1, #6
 8001b5c:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
  tmpreg &= ~ETH_MACMIIAR_MW;                                           /* Set the read mode            */
 8001b60:	431c      	orrs	r4, r3
  tmpreg |= ETH_MACMIIAR_MB;                                            /* Set the MII Busy bit         */
 8001b62:	f044 0401 	orr.w	r4, r4, #1
  heth->Instance->MACMIIAR = tmpreg;
 8001b66:	6114      	str	r4, [r2, #16]
  tickstart = HAL_GetTick();
 8001b68:	f7ff fcf0 	bl	800154c <HAL_GetTick>
 8001b6c:	4607      	mov	r7, r0
  while((tmpreg & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 8001b6e:	f014 0f01 	tst.w	r4, #1
 8001b72:	d010      	beq.n	8001b96 <HAL_ETH_ReadPHYRegister+0x62>
    if((HAL_GetTick() - tickstart ) > PHY_READ_TO)
 8001b74:	f7ff fcea 	bl	800154c <HAL_GetTick>
 8001b78:	1bc0      	subs	r0, r0, r7
 8001b7a:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8001b7e:	d202      	bcs.n	8001b86 <HAL_ETH_ReadPHYRegister+0x52>
    tmpreg = heth->Instance->MACMIIAR;
 8001b80:	682b      	ldr	r3, [r5, #0]
 8001b82:	691c      	ldr	r4, [r3, #16]
 8001b84:	e7f3      	b.n	8001b6e <HAL_ETH_ReadPHYRegister+0x3a>
      heth->State= HAL_ETH_STATE_READY;
 8001b86:	2301      	movs	r3, #1
 8001b88:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8001b8c:	2300      	movs	r3, #0
 8001b8e:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 8001b92:	2003      	movs	r0, #3
 8001b94:	e007      	b.n	8001ba6 <HAL_ETH_ReadPHYRegister+0x72>
  *RegValue = (uint16_t)(heth->Instance->MACMIIDR);
 8001b96:	682b      	ldr	r3, [r5, #0]
 8001b98:	695b      	ldr	r3, [r3, #20]
 8001b9a:	b29b      	uxth	r3, r3
 8001b9c:	6033      	str	r3, [r6, #0]
  heth->State = HAL_ETH_STATE_READY;
 8001b9e:	2301      	movs	r3, #1
 8001ba0:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
  return HAL_OK;
 8001ba4:	2000      	movs	r0, #0
}
 8001ba6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8001ba8:	2002      	movs	r0, #2
 8001baa:	e7fc      	b.n	8001ba6 <HAL_ETH_ReadPHYRegister+0x72>

08001bac <HAL_ETH_WritePHYRegister>:
  if(heth->State == HAL_ETH_STATE_BUSY_WR)
 8001bac:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001bb0:	b2db      	uxtb	r3, r3
 8001bb2:	2b42      	cmp	r3, #66	; 0x42
 8001bb4:	d032      	beq.n	8001c1c <HAL_ETH_WritePHYRegister+0x70>
{
 8001bb6:	b570      	push	{r4, r5, r6, lr}
 8001bb8:	4605      	mov	r5, r0
  heth->State = HAL_ETH_STATE_BUSY_WR;
 8001bba:	2342      	movs	r3, #66	; 0x42
 8001bbc:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg = heth->Instance->MACMIIAR;
 8001bc0:	6800      	ldr	r0, [r0, #0]
 8001bc2:	6903      	ldr	r3, [r0, #16]
  tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8001bc4:	f003 031c 	and.w	r3, r3, #28
  tmpreg |=(((uint32_t)heth->Init.PhyAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 8001bc8:	8a2c      	ldrh	r4, [r5, #16]
 8001bca:	02e4      	lsls	r4, r4, #11
 8001bcc:	b2a4      	uxth	r4, r4
 8001bce:	4323      	orrs	r3, r4
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);                 /* Set the PHY register address */
 8001bd0:	018c      	lsls	r4, r1, #6
 8001bd2:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
 8001bd6:	431c      	orrs	r4, r3
  tmpreg |= ETH_MACMIIAR_MB;                                          /* Set the MII Busy bit */
 8001bd8:	f044 0403 	orr.w	r4, r4, #3
 8001bdc:	b292      	uxth	r2, r2
  heth->Instance->MACMIIDR = (uint16_t)RegValue;
 8001bde:	6142      	str	r2, [r0, #20]
  heth->Instance->MACMIIAR = tmpreg;
 8001be0:	682b      	ldr	r3, [r5, #0]
 8001be2:	611c      	str	r4, [r3, #16]
  tickstart = HAL_GetTick();
 8001be4:	f7ff fcb2 	bl	800154c <HAL_GetTick>
 8001be8:	4606      	mov	r6, r0
  while((tmpreg & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 8001bea:	f014 0f01 	tst.w	r4, #1
 8001bee:	d010      	beq.n	8001c12 <HAL_ETH_WritePHYRegister+0x66>
    if((HAL_GetTick() - tickstart ) > PHY_WRITE_TO)
 8001bf0:	f7ff fcac 	bl	800154c <HAL_GetTick>
 8001bf4:	1b80      	subs	r0, r0, r6
 8001bf6:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8001bfa:	d202      	bcs.n	8001c02 <HAL_ETH_WritePHYRegister+0x56>
    tmpreg = heth->Instance->MACMIIAR;
 8001bfc:	682b      	ldr	r3, [r5, #0]
 8001bfe:	691c      	ldr	r4, [r3, #16]
 8001c00:	e7f3      	b.n	8001bea <HAL_ETH_WritePHYRegister+0x3e>
      heth->State= HAL_ETH_STATE_READY;
 8001c02:	2301      	movs	r3, #1
 8001c04:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8001c08:	2300      	movs	r3, #0
 8001c0a:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 8001c0e:	2003      	movs	r0, #3
 8001c10:	e003      	b.n	8001c1a <HAL_ETH_WritePHYRegister+0x6e>
  heth->State = HAL_ETH_STATE_READY;
 8001c12:	2301      	movs	r3, #1
 8001c14:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
  return HAL_OK; 
 8001c18:	2000      	movs	r0, #0
}
 8001c1a:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 8001c1c:	2002      	movs	r0, #2
}
 8001c1e:	4770      	bx	lr

08001c20 <HAL_ETH_Init>:
{
 8001c20:	b570      	push	{r4, r5, r6, lr}
 8001c22:	b082      	sub	sp, #8
  uint32_t tempreg = 0, phyreg = 0;
 8001c24:	2300      	movs	r3, #0
 8001c26:	9301      	str	r3, [sp, #4]
  if(heth == NULL)
 8001c28:	2800      	cmp	r0, #0
 8001c2a:	f000 810c 	beq.w	8001e46 <HAL_ETH_Init+0x226>
 8001c2e:	4604      	mov	r4, r0
  if(heth->State == HAL_ETH_STATE_RESET)
 8001c30:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001c34:	2b00      	cmp	r3, #0
 8001c36:	d032      	beq.n	8001c9e <HAL_ETH_Init+0x7e>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001c38:	4b84      	ldr	r3, [pc, #528]	; (8001e4c <HAL_ETH_Init+0x22c>)
 8001c3a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001c3c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001c40:	645a      	str	r2, [r3, #68]	; 0x44
 8001c42:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001c44:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001c48:	9300      	str	r3, [sp, #0]
 8001c4a:	9b00      	ldr	r3, [sp, #0]
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8001c4c:	4b80      	ldr	r3, [pc, #512]	; (8001e50 <HAL_ETH_Init+0x230>)
 8001c4e:	685a      	ldr	r2, [r3, #4]
 8001c50:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8001c54:	605a      	str	r2, [r3, #4]
  SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 8001c56:	685a      	ldr	r2, [r3, #4]
 8001c58:	6a21      	ldr	r1, [r4, #32]
 8001c5a:	430a      	orrs	r2, r1
 8001c5c:	605a      	str	r2, [r3, #4]
  (heth->Instance)->DMABMR |= ETH_DMABMR_SR;
 8001c5e:	6823      	ldr	r3, [r4, #0]
 8001c60:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001c64:	681a      	ldr	r2, [r3, #0]
 8001c66:	f042 0201 	orr.w	r2, r2, #1
 8001c6a:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8001c6c:	f7ff fc6e 	bl	800154c <HAL_GetTick>
 8001c70:	4605      	mov	r5, r0
  while (((heth->Instance)->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 8001c72:	6823      	ldr	r3, [r4, #0]
 8001c74:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8001c78:	6812      	ldr	r2, [r2, #0]
 8001c7a:	f012 0f01 	tst.w	r2, #1
 8001c7e:	d013      	beq.n	8001ca8 <HAL_ETH_Init+0x88>
    if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_SWRESET)
 8001c80:	f7ff fc64 	bl	800154c <HAL_GetTick>
 8001c84:	1b40      	subs	r0, r0, r5
 8001c86:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8001c8a:	d9f2      	bls.n	8001c72 <HAL_ETH_Init+0x52>
      heth->State= HAL_ETH_STATE_TIMEOUT;
 8001c8c:	2503      	movs	r5, #3
 8001c8e:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8001c92:	2300      	movs	r3, #0
 8001c94:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
}
 8001c98:	4628      	mov	r0, r5
 8001c9a:	b002      	add	sp, #8
 8001c9c:	bd70      	pop	{r4, r5, r6, pc}
    heth->Lock = HAL_UNLOCKED;
 8001c9e:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
    HAL_ETH_MspInit(heth);
 8001ca2:	f007 fba5 	bl	80093f0 <HAL_ETH_MspInit>
 8001ca6:	e7c7      	b.n	8001c38 <HAL_ETH_Init+0x18>
  tempreg = (heth->Instance)->MACMIIAR;
 8001ca8:	691d      	ldr	r5, [r3, #16]
  tempreg &= ETH_MACMIIAR_CR_MASK;
 8001caa:	f025 051c 	bic.w	r5, r5, #28
  hclk = HAL_RCC_GetHCLKFreq();
 8001cae:	f000 fded 	bl	800288c <HAL_RCC_GetHCLKFreq>
  if((hclk >= 20000000)&&(hclk < 35000000))
 8001cb2:	4b68      	ldr	r3, [pc, #416]	; (8001e54 <HAL_ETH_Init+0x234>)
 8001cb4:	4403      	add	r3, r0
 8001cb6:	4a68      	ldr	r2, [pc, #416]	; (8001e58 <HAL_ETH_Init+0x238>)
 8001cb8:	4293      	cmp	r3, r2
 8001cba:	d855      	bhi.n	8001d68 <HAL_ETH_Init+0x148>
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 8001cbc:	f045 0508 	orr.w	r5, r5, #8
  (heth->Instance)->MACMIIAR = (uint32_t)tempreg;
 8001cc0:	6823      	ldr	r3, [r4, #0]
 8001cc2:	611d      	str	r5, [r3, #16]
  if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
 8001cc4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8001cc8:	2100      	movs	r1, #0
 8001cca:	4620      	mov	r0, r4
 8001ccc:	f7ff ff6e 	bl	8001bac <HAL_ETH_WritePHYRegister>
 8001cd0:	4605      	mov	r5, r0
 8001cd2:	2800      	cmp	r0, #0
 8001cd4:	d160      	bne.n	8001d98 <HAL_ETH_Init+0x178>
  HAL_Delay(PHY_RESET_DELAY);
 8001cd6:	20ff      	movs	r0, #255	; 0xff
 8001cd8:	f7ff fc3e 	bl	8001558 <HAL_Delay>
  if((heth->Init).AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
 8001cdc:	6863      	ldr	r3, [r4, #4]
 8001cde:	2b00      	cmp	r3, #0
 8001ce0:	f000 8091 	beq.w	8001e06 <HAL_ETH_Init+0x1e6>
    tickstart = HAL_GetTick();
 8001ce4:	f7ff fc32 	bl	800154c <HAL_GetTick>
 8001ce8:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8001cea:	aa01      	add	r2, sp, #4
 8001cec:	2101      	movs	r1, #1
 8001cee:	4620      	mov	r0, r4
 8001cf0:	f7ff ff20 	bl	8001b34 <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_LINKED_STATE)
 8001cf4:	f7ff fc2a 	bl	800154c <HAL_GetTick>
 8001cf8:	1b80      	subs	r0, r0, r6
 8001cfa:	f241 3388 	movw	r3, #5000	; 0x1388
 8001cfe:	4298      	cmp	r0, r3
 8001d00:	d852      	bhi.n	8001da8 <HAL_ETH_Init+0x188>
    } while (((phyreg & PHY_LINKED_STATUS) != PHY_LINKED_STATUS));
 8001d02:	9b01      	ldr	r3, [sp, #4]
 8001d04:	f013 0f04 	tst.w	r3, #4
 8001d08:	d0ef      	beq.n	8001cea <HAL_ETH_Init+0xca>
    if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_AUTONEGOTIATION)) != HAL_OK)
 8001d0a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001d0e:	2100      	movs	r1, #0
 8001d10:	4620      	mov	r0, r4
 8001d12:	f7ff ff4b 	bl	8001bac <HAL_ETH_WritePHYRegister>
 8001d16:	2800      	cmp	r0, #0
 8001d18:	d152      	bne.n	8001dc0 <HAL_ETH_Init+0x1a0>
    tickstart = HAL_GetTick();
 8001d1a:	f7ff fc17 	bl	800154c <HAL_GetTick>
 8001d1e:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8001d20:	aa01      	add	r2, sp, #4
 8001d22:	2101      	movs	r1, #1
 8001d24:	4620      	mov	r0, r4
 8001d26:	f7ff ff05 	bl	8001b34 <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
 8001d2a:	f7ff fc0f 	bl	800154c <HAL_GetTick>
 8001d2e:	1b80      	subs	r0, r0, r6
 8001d30:	f241 3388 	movw	r3, #5000	; 0x1388
 8001d34:	4298      	cmp	r0, r3
 8001d36:	d84b      	bhi.n	8001dd0 <HAL_ETH_Init+0x1b0>
    } while (((phyreg & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
 8001d38:	9b01      	ldr	r3, [sp, #4]
 8001d3a:	f013 0f20 	tst.w	r3, #32
 8001d3e:	d0ef      	beq.n	8001d20 <HAL_ETH_Init+0x100>
    if((HAL_ETH_ReadPHYRegister(heth, PHY_SR, &phyreg)) != HAL_OK)
 8001d40:	aa01      	add	r2, sp, #4
 8001d42:	211f      	movs	r1, #31
 8001d44:	4620      	mov	r0, r4
 8001d46:	f7ff fef5 	bl	8001b34 <HAL_ETH_ReadPHYRegister>
 8001d4a:	2800      	cmp	r0, #0
 8001d4c:	d14c      	bne.n	8001de8 <HAL_ETH_Init+0x1c8>
    if((phyreg & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
 8001d4e:	9b01      	ldr	r3, [sp, #4]
 8001d50:	f013 0f10 	tst.w	r3, #16
 8001d54:	d050      	beq.n	8001df8 <HAL_ETH_Init+0x1d8>
      (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;  
 8001d56:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001d5a:	60e2      	str	r2, [r4, #12]
    if((phyreg & PHY_SPEED_STATUS) == PHY_SPEED_STATUS)
 8001d5c:	f013 0f04 	tst.w	r3, #4
 8001d60:	d04d      	beq.n	8001dfe <HAL_ETH_Init+0x1de>
      (heth->Init).Speed = ETH_SPEED_10M; 
 8001d62:	2300      	movs	r3, #0
 8001d64:	60a3      	str	r3, [r4, #8]
 8001d66:	e05e      	b.n	8001e26 <HAL_ETH_Init+0x206>
  else if((hclk >= 35000000)&&(hclk < 60000000))
 8001d68:	4b3c      	ldr	r3, [pc, #240]	; (8001e5c <HAL_ETH_Init+0x23c>)
 8001d6a:	4403      	add	r3, r0
 8001d6c:	4a3c      	ldr	r2, [pc, #240]	; (8001e60 <HAL_ETH_Init+0x240>)
 8001d6e:	4293      	cmp	r3, r2
 8001d70:	d802      	bhi.n	8001d78 <HAL_ETH_Init+0x158>
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;
 8001d72:	f045 050c 	orr.w	r5, r5, #12
 8001d76:	e7a3      	b.n	8001cc0 <HAL_ETH_Init+0xa0>
  else if((hclk >= 60000000)&&(hclk < 100000000))
 8001d78:	4b3a      	ldr	r3, [pc, #232]	; (8001e64 <HAL_ETH_Init+0x244>)
 8001d7a:	4403      	add	r3, r0
 8001d7c:	4a3a      	ldr	r2, [pc, #232]	; (8001e68 <HAL_ETH_Init+0x248>)
 8001d7e:	4293      	cmp	r3, r2
 8001d80:	d99e      	bls.n	8001cc0 <HAL_ETH_Init+0xa0>
  else if((hclk >= 100000000)&&(hclk < 150000000))
 8001d82:	4b3a      	ldr	r3, [pc, #232]	; (8001e6c <HAL_ETH_Init+0x24c>)
 8001d84:	4403      	add	r3, r0
 8001d86:	4a3a      	ldr	r2, [pc, #232]	; (8001e70 <HAL_ETH_Init+0x250>)
 8001d88:	4293      	cmp	r3, r2
 8001d8a:	d802      	bhi.n	8001d92 <HAL_ETH_Init+0x172>
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 8001d8c:	f045 0504 	orr.w	r5, r5, #4
 8001d90:	e796      	b.n	8001cc0 <HAL_ETH_Init+0xa0>
    tempreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
 8001d92:	f045 0510 	orr.w	r5, r5, #16
 8001d96:	e793      	b.n	8001cc0 <HAL_ETH_Init+0xa0>
    ETH_MACDMAConfig(heth, err);
 8001d98:	2101      	movs	r1, #1
 8001d9a:	4620      	mov	r0, r4
 8001d9c:	f7ff fc6a 	bl	8001674 <ETH_MACDMAConfig>
    heth->State = HAL_ETH_STATE_READY;
 8001da0:	2501      	movs	r5, #1
 8001da2:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
    return HAL_ERROR;
 8001da6:	e777      	b.n	8001c98 <HAL_ETH_Init+0x78>
        ETH_MACDMAConfig(heth, err);
 8001da8:	2101      	movs	r1, #1
 8001daa:	4620      	mov	r0, r4
 8001dac:	f7ff fc62 	bl	8001674 <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 8001db0:	2301      	movs	r3, #1
 8001db2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 8001db6:	2300      	movs	r3, #0
 8001db8:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 8001dbc:	2503      	movs	r5, #3
 8001dbe:	e76b      	b.n	8001c98 <HAL_ETH_Init+0x78>
      ETH_MACDMAConfig(heth, err);
 8001dc0:	2101      	movs	r1, #1
 8001dc2:	4620      	mov	r0, r4
 8001dc4:	f7ff fc56 	bl	8001674 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8001dc8:	2501      	movs	r5, #1
 8001dca:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;   
 8001dce:	e763      	b.n	8001c98 <HAL_ETH_Init+0x78>
        ETH_MACDMAConfig(heth, err);
 8001dd0:	2101      	movs	r1, #1
 8001dd2:	4620      	mov	r0, r4
 8001dd4:	f7ff fc4e 	bl	8001674 <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 8001dd8:	2301      	movs	r3, #1
 8001dda:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 8001dde:	2300      	movs	r3, #0
 8001de0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 8001de4:	2503      	movs	r5, #3
 8001de6:	e757      	b.n	8001c98 <HAL_ETH_Init+0x78>
      ETH_MACDMAConfig(heth, err);
 8001de8:	2101      	movs	r1, #1
 8001dea:	4620      	mov	r0, r4
 8001dec:	f7ff fc42 	bl	8001674 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8001df0:	2501      	movs	r5, #1
 8001df2:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;   
 8001df6:	e74f      	b.n	8001c98 <HAL_ETH_Init+0x78>
      (heth->Init).DuplexMode = ETH_MODE_HALFDUPLEX;           
 8001df8:	2200      	movs	r2, #0
 8001dfa:	60e2      	str	r2, [r4, #12]
 8001dfc:	e7ae      	b.n	8001d5c <HAL_ETH_Init+0x13c>
      (heth->Init).Speed = ETH_SPEED_100M;
 8001dfe:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8001e02:	60a3      	str	r3, [r4, #8]
 8001e04:	e00f      	b.n	8001e26 <HAL_ETH_Init+0x206>
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3) |
 8001e06:	68e2      	ldr	r2, [r4, #12]
 8001e08:	f3c2 02cf 	ubfx	r2, r2, #3, #16
                                                (uint16_t)((heth->Init).Speed >> 1))) != HAL_OK)
 8001e0c:	68a3      	ldr	r3, [r4, #8]
 8001e0e:	f3c3 034f 	ubfx	r3, r3, #1, #16
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3) |
 8001e12:	431a      	orrs	r2, r3
 8001e14:	2100      	movs	r1, #0
 8001e16:	4620      	mov	r0, r4
 8001e18:	f7ff fec8 	bl	8001bac <HAL_ETH_WritePHYRegister>
 8001e1c:	b958      	cbnz	r0, 8001e36 <HAL_ETH_Init+0x216>
    HAL_Delay(PHY_CONFIG_DELAY);
 8001e1e:	f640 70ff 	movw	r0, #4095	; 0xfff
 8001e22:	f7ff fb99 	bl	8001558 <HAL_Delay>
  ETH_MACDMAConfig(heth, err);
 8001e26:	2100      	movs	r1, #0
 8001e28:	4620      	mov	r0, r4
 8001e2a:	f7ff fc23 	bl	8001674 <ETH_MACDMAConfig>
  heth->State= HAL_ETH_STATE_READY;
 8001e2e:	2301      	movs	r3, #1
 8001e30:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  return HAL_OK;
 8001e34:	e730      	b.n	8001c98 <HAL_ETH_Init+0x78>
      ETH_MACDMAConfig(heth, err);
 8001e36:	2101      	movs	r1, #1
 8001e38:	4620      	mov	r0, r4
 8001e3a:	f7ff fc1b 	bl	8001674 <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8001e3e:	2501      	movs	r5, #1
 8001e40:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;
 8001e44:	e728      	b.n	8001c98 <HAL_ETH_Init+0x78>
    return HAL_ERROR;
 8001e46:	2501      	movs	r5, #1
 8001e48:	e726      	b.n	8001c98 <HAL_ETH_Init+0x78>
 8001e4a:	bf00      	nop
 8001e4c:	40023800 	.word	0x40023800
 8001e50:	40013800 	.word	0x40013800
 8001e54:	feced300 	.word	0xfeced300
 8001e58:	00e4e1bf 	.word	0x00e4e1bf
 8001e5c:	fde9f140 	.word	0xfde9f140
 8001e60:	017d783f 	.word	0x017d783f
 8001e64:	fc6c7900 	.word	0xfc6c7900
 8001e68:	026259ff 	.word	0x026259ff
 8001e6c:	fa0a1f00 	.word	0xfa0a1f00
 8001e70:	02faf07f 	.word	0x02faf07f

08001e74 <HAL_ETH_Start>:
{  
 8001e74:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(heth);
 8001e76:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001e7a:	2b01      	cmp	r3, #1
 8001e7c:	d01a      	beq.n	8001eb4 <HAL_ETH_Start+0x40>
 8001e7e:	4604      	mov	r4, r0
 8001e80:	2501      	movs	r5, #1
 8001e82:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8001e86:	2302      	movs	r3, #2
 8001e88:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  ETH_MACTransmissionEnable(heth);
 8001e8c:	f7ff fc7e 	bl	800178c <ETH_MACTransmissionEnable>
  ETH_MACReceptionEnable(heth);
 8001e90:	4620      	mov	r0, r4
 8001e92:	f7ff fc90 	bl	80017b6 <ETH_MACReceptionEnable>
  ETH_FlushTransmitFIFO(heth);
 8001e96:	4620      	mov	r0, r4
 8001e98:	f7ff fca2 	bl	80017e0 <ETH_FlushTransmitFIFO>
  ETH_DMATransmissionEnable(heth);
 8001e9c:	4620      	mov	r0, r4
 8001e9e:	f7ff fbd9 	bl	8001654 <ETH_DMATransmissionEnable>
  ETH_DMAReceptionEnable(heth);
 8001ea2:	4620      	mov	r0, r4
 8001ea4:	f7ff fbde 	bl	8001664 <ETH_DMAReceptionEnable>
  heth->State= HAL_ETH_STATE_READY;
 8001ea8:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8001eac:	2000      	movs	r0, #0
 8001eae:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
}
 8001eb2:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(heth);
 8001eb4:	2002      	movs	r0, #2
 8001eb6:	e7fc      	b.n	8001eb2 <HAL_ETH_Start+0x3e>

08001eb8 <HAL_GPIO_Init>:
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8001eb8:	2300      	movs	r3, #0
 8001eba:	2b0f      	cmp	r3, #15
 8001ebc:	f200 80e2 	bhi.w	8002084 <HAL_GPIO_Init+0x1cc>
{
 8001ec0:	b4f0      	push	{r4, r5, r6, r7}
 8001ec2:	b082      	sub	sp, #8
 8001ec4:	e039      	b.n	8001f3a <HAL_GPIO_Init+0x82>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001ec6:	2209      	movs	r2, #9
 8001ec8:	e000      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 8001eca:	2200      	movs	r2, #0
 8001ecc:	40b2      	lsls	r2, r6
 8001ece:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2] = temp;
 8001ed0:	3402      	adds	r4, #2
 8001ed2:	4e6d      	ldr	r6, [pc, #436]	; (8002088 <HAL_GPIO_Init+0x1d0>)
 8001ed4:	f846 2024 	str.w	r2, [r6, r4, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001ed8:	4a6c      	ldr	r2, [pc, #432]	; (800208c <HAL_GPIO_Init+0x1d4>)
 8001eda:	6814      	ldr	r4, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8001edc:	43ea      	mvns	r2, r5
 8001ede:	ea02 0604 	and.w	r6, r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001ee2:	684f      	ldr	r7, [r1, #4]
 8001ee4:	f417 3f80 	tst.w	r7, #65536	; 0x10000
 8001ee8:	d001      	beq.n	8001eee <HAL_GPIO_Init+0x36>
        {
          temp |= iocurrent;
 8001eea:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->IMR = temp;
 8001eee:	4c67      	ldr	r4, [pc, #412]	; (800208c <HAL_GPIO_Init+0x1d4>)
 8001ef0:	6026      	str	r6, [r4, #0]

        temp = EXTI->EMR;
 8001ef2:	6864      	ldr	r4, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 8001ef4:	ea02 0604 	and.w	r6, r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001ef8:	684f      	ldr	r7, [r1, #4]
 8001efa:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8001efe:	d001      	beq.n	8001f04 <HAL_GPIO_Init+0x4c>
        {
          temp |= iocurrent;
 8001f00:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->EMR = temp;
 8001f04:	4c61      	ldr	r4, [pc, #388]	; (800208c <HAL_GPIO_Init+0x1d4>)
 8001f06:	6066      	str	r6, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8001f08:	68a4      	ldr	r4, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
 8001f0a:	ea02 0604 	and.w	r6, r2, r4
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001f0e:	684f      	ldr	r7, [r1, #4]
 8001f10:	f417 1f80 	tst.w	r7, #1048576	; 0x100000
 8001f14:	d001      	beq.n	8001f1a <HAL_GPIO_Init+0x62>
        {
          temp |= iocurrent;
 8001f16:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->RTSR = temp;
 8001f1a:	4c5c      	ldr	r4, [pc, #368]	; (800208c <HAL_GPIO_Init+0x1d4>)
 8001f1c:	60a6      	str	r6, [r4, #8]

        temp = EXTI->FTSR;
 8001f1e:	68e4      	ldr	r4, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 8001f20:	4022      	ands	r2, r4
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001f22:	684e      	ldr	r6, [r1, #4]
 8001f24:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
 8001f28:	d001      	beq.n	8001f2e <HAL_GPIO_Init+0x76>
        {
          temp |= iocurrent;
 8001f2a:	ea45 0204 	orr.w	r2, r5, r4
        }
        EXTI->FTSR = temp;
 8001f2e:	4c57      	ldr	r4, [pc, #348]	; (800208c <HAL_GPIO_Init+0x1d4>)
 8001f30:	60e2      	str	r2, [r4, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8001f32:	3301      	adds	r3, #1
 8001f34:	2b0f      	cmp	r3, #15
 8001f36:	f200 80a2 	bhi.w	800207e <HAL_GPIO_Init+0x1c6>
    ioposition = ((uint32_t)0x01) << position;
 8001f3a:	2201      	movs	r2, #1
 8001f3c:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001f3e:	680c      	ldr	r4, [r1, #0]
 8001f40:	ea04 0502 	and.w	r5, r4, r2
    if(iocurrent == ioposition)
 8001f44:	42aa      	cmp	r2, r5
 8001f46:	d1f4      	bne.n	8001f32 <HAL_GPIO_Init+0x7a>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001f48:	684c      	ldr	r4, [r1, #4]
 8001f4a:	2c12      	cmp	r4, #18
 8001f4c:	bf18      	it	ne
 8001f4e:	2c02      	cmpne	r4, #2
 8001f50:	d110      	bne.n	8001f74 <HAL_GPIO_Init+0xbc>
        temp = GPIOx->AFR[position >> 3];
 8001f52:	08de      	lsrs	r6, r3, #3
 8001f54:	3608      	adds	r6, #8
 8001f56:	f850 c026 	ldr.w	ip, [r0, r6, lsl #2]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f5a:	f003 0407 	and.w	r4, r3, #7
 8001f5e:	00a7      	lsls	r7, r4, #2
 8001f60:	240f      	movs	r4, #15
 8001f62:	40bc      	lsls	r4, r7
 8001f64:	ea2c 0c04 	bic.w	ip, ip, r4
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001f68:	690c      	ldr	r4, [r1, #16]
 8001f6a:	40bc      	lsls	r4, r7
 8001f6c:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->AFR[position >> 3] = temp;
 8001f70:	f840 4026 	str.w	r4, [r0, r6, lsl #2]
      temp = GPIOx->MODER;
 8001f74:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f76:	005f      	lsls	r7, r3, #1
 8001f78:	2603      	movs	r6, #3
 8001f7a:	40be      	lsls	r6, r7
 8001f7c:	43f6      	mvns	r6, r6
 8001f7e:	ea06 0c04 	and.w	ip, r6, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f82:	684c      	ldr	r4, [r1, #4]
 8001f84:	f004 0403 	and.w	r4, r4, #3
 8001f88:	40bc      	lsls	r4, r7
 8001f8a:	ea44 040c 	orr.w	r4, r4, ip
      GPIOx->MODER = temp;
 8001f8e:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001f90:	684c      	ldr	r4, [r1, #4]
 8001f92:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
 8001f96:	2c11      	cmp	r4, #17
 8001f98:	bf18      	it	ne
 8001f9a:	f1bc 0f01 	cmpne.w	ip, #1
 8001f9e:	d901      	bls.n	8001fa4 <HAL_GPIO_Init+0xec>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001fa0:	2c12      	cmp	r4, #18
 8001fa2:	d111      	bne.n	8001fc8 <HAL_GPIO_Init+0x110>
        temp = GPIOx->OSPEEDR; 
 8001fa4:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8001fa6:	ea06 0c04 	and.w	ip, r6, r4
        temp |= (GPIO_Init->Speed << (position * 2));
 8001faa:	68cc      	ldr	r4, [r1, #12]
 8001fac:	40bc      	lsls	r4, r7
 8001fae:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->OSPEEDR = temp;
 8001fb2:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 8001fb4:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001fb6:	ea24 0c02 	bic.w	ip, r4, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001fba:	684c      	ldr	r4, [r1, #4]
 8001fbc:	f3c4 1200 	ubfx	r2, r4, #4, #1
 8001fc0:	409a      	lsls	r2, r3
 8001fc2:	ea42 020c 	orr.w	r2, r2, ip
        GPIOx->OTYPER = temp;
 8001fc6:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 8001fc8:	68c2      	ldr	r2, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8001fca:	4016      	ands	r6, r2
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001fcc:	688a      	ldr	r2, [r1, #8]
 8001fce:	40ba      	lsls	r2, r7
 8001fd0:	4332      	orrs	r2, r6
      GPIOx->PUPDR = temp;
 8001fd2:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001fd4:	684a      	ldr	r2, [r1, #4]
 8001fd6:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 8001fda:	d0aa      	beq.n	8001f32 <HAL_GPIO_Init+0x7a>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fdc:	4a2c      	ldr	r2, [pc, #176]	; (8002090 <HAL_GPIO_Init+0x1d8>)
 8001fde:	6c54      	ldr	r4, [r2, #68]	; 0x44
 8001fe0:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 8001fe4:	6454      	str	r4, [r2, #68]	; 0x44
 8001fe6:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8001fe8:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8001fec:	9201      	str	r2, [sp, #4]
 8001fee:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 8001ff0:	089c      	lsrs	r4, r3, #2
 8001ff2:	1ca6      	adds	r6, r4, #2
 8001ff4:	4a24      	ldr	r2, [pc, #144]	; (8002088 <HAL_GPIO_Init+0x1d0>)
 8001ff6:	f852 7026 	ldr.w	r7, [r2, r6, lsl #2]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001ffa:	f003 0203 	and.w	r2, r3, #3
 8001ffe:	0096      	lsls	r6, r2, #2
 8002000:	220f      	movs	r2, #15
 8002002:	40b2      	lsls	r2, r6
 8002004:	ea27 0702 	bic.w	r7, r7, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8002008:	4a22      	ldr	r2, [pc, #136]	; (8002094 <HAL_GPIO_Init+0x1dc>)
 800200a:	4290      	cmp	r0, r2
 800200c:	f43f af5d 	beq.w	8001eca <HAL_GPIO_Init+0x12>
 8002010:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002014:	4290      	cmp	r0, r2
 8002016:	d022      	beq.n	800205e <HAL_GPIO_Init+0x1a6>
 8002018:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800201c:	4290      	cmp	r0, r2
 800201e:	d020      	beq.n	8002062 <HAL_GPIO_Init+0x1aa>
 8002020:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002024:	4290      	cmp	r0, r2
 8002026:	d01e      	beq.n	8002066 <HAL_GPIO_Init+0x1ae>
 8002028:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800202c:	4290      	cmp	r0, r2
 800202e:	d01c      	beq.n	800206a <HAL_GPIO_Init+0x1b2>
 8002030:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002034:	4290      	cmp	r0, r2
 8002036:	d01a      	beq.n	800206e <HAL_GPIO_Init+0x1b6>
 8002038:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800203c:	4290      	cmp	r0, r2
 800203e:	d018      	beq.n	8002072 <HAL_GPIO_Init+0x1ba>
 8002040:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002044:	4290      	cmp	r0, r2
 8002046:	d016      	beq.n	8002076 <HAL_GPIO_Init+0x1be>
 8002048:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800204c:	4290      	cmp	r0, r2
 800204e:	d014      	beq.n	800207a <HAL_GPIO_Init+0x1c2>
 8002050:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002054:	4290      	cmp	r0, r2
 8002056:	f43f af36 	beq.w	8001ec6 <HAL_GPIO_Init+0xe>
 800205a:	220a      	movs	r2, #10
 800205c:	e736      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 800205e:	2201      	movs	r2, #1
 8002060:	e734      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 8002062:	2202      	movs	r2, #2
 8002064:	e732      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 8002066:	2203      	movs	r2, #3
 8002068:	e730      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 800206a:	2204      	movs	r2, #4
 800206c:	e72e      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 800206e:	2205      	movs	r2, #5
 8002070:	e72c      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 8002072:	2206      	movs	r2, #6
 8002074:	e72a      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 8002076:	2207      	movs	r2, #7
 8002078:	e728      	b.n	8001ecc <HAL_GPIO_Init+0x14>
 800207a:	2208      	movs	r2, #8
 800207c:	e726      	b.n	8001ecc <HAL_GPIO_Init+0x14>
      }
    }
  }
}
 800207e:	b002      	add	sp, #8
 8002080:	bcf0      	pop	{r4, r5, r6, r7}
 8002082:	4770      	bx	lr
 8002084:	4770      	bx	lr
 8002086:	bf00      	nop
 8002088:	40013800 	.word	0x40013800
 800208c:	40013c00 	.word	0x40013c00
 8002090:	40023800 	.word	0x40023800
 8002094:	40020000 	.word	0x40020000

08002098 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002098:	b912      	cbnz	r2, 80020a0 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800209a:	0409      	lsls	r1, r1, #16
 800209c:	6181      	str	r1, [r0, #24]
  }
}
 800209e:	4770      	bx	lr
    GPIOx->BSRR = GPIO_Pin;
 80020a0:	6181      	str	r1, [r0, #24]
 80020a2:	4770      	bx	lr

080020a4 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80020a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80020a6:	b08b      	sub	sp, #44	; 0x2c
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80020a8:	2800      	cmp	r0, #0
 80020aa:	f000 808a 	beq.w	80021c2 <HAL_PCD_Init+0x11e>
 80020ae:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80020b0:	f890 33bd 	ldrb.w	r3, [r0, #957]	; 0x3bd
 80020b4:	b1f3      	cbz	r3, 80020f4 <HAL_PCD_Init+0x50>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80020b6:	2303      	movs	r3, #3
 80020b8:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 80020bc:	6820      	ldr	r0, [r4, #0]
 80020be:	f001 fc21 	bl	8003904 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80020c2:	4625      	mov	r5, r4
 80020c4:	f855 7b10 	ldr.w	r7, [r5], #16
 80020c8:	466e      	mov	r6, sp
 80020ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80020cc:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80020ce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80020d0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80020d2:	e895 0003 	ldmia.w	r5, {r0, r1}
 80020d6:	e886 0003 	stmia.w	r6, {r0, r1}
 80020da:	1d23      	adds	r3, r4, #4
 80020dc:	cb0e      	ldmia	r3, {r1, r2, r3}
 80020de:	4638      	mov	r0, r7
 80020e0:	f001 fbd2 	bl	8003888 <USB_CoreInit>
 80020e4:	b158      	cbz	r0, 80020fe <HAL_PCD_Init+0x5a>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80020e6:	2302      	movs	r3, #2
 80020e8:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd
    return HAL_ERROR;
 80020ec:	2501      	movs	r5, #1
  }
  
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 80020ee:	4628      	mov	r0, r5
 80020f0:	b00b      	add	sp, #44	; 0x2c
 80020f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->Lock = HAL_UNLOCKED;
 80020f4:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
    HAL_PCD_MspInit(hpcd);
 80020f8:	f008 fd52 	bl	800aba0 <HAL_PCD_MspInit>
 80020fc:	e7db      	b.n	80020b6 <HAL_PCD_Init+0x12>
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 80020fe:	2100      	movs	r1, #0
 8002100:	6820      	ldr	r0, [r4, #0]
 8002102:	f001 fc05 	bl	8003910 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002106:	2300      	movs	r3, #0
 8002108:	e015      	b.n	8002136 <HAL_PCD_Init+0x92>
    hpcd->IN_ep[i].is_in = 1U;
 800210a:	00d9      	lsls	r1, r3, #3
 800210c:	1ac8      	subs	r0, r1, r3
 800210e:	0082      	lsls	r2, r0, #2
 8002110:	4422      	add	r2, r4
 8002112:	2001      	movs	r0, #1
 8002114:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
    hpcd->IN_ep[i].num = i;
 8002118:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 800211c:	f8a2 3042 	strh.w	r3, [r2, #66]	; 0x42
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8002120:	2000      	movs	r0, #0
 8002122:	f882 003f 	strb.w	r0, [r2, #63]	; 0x3f
    hpcd->IN_ep[i].maxpacket = 0U;
 8002126:	6450      	str	r0, [r2, #68]	; 0x44
    hpcd->IN_ep[i].xfer_buff = 0U;
 8002128:	6490      	str	r0, [r2, #72]	; 0x48
    hpcd->IN_ep[i].xfer_len = 0U;
 800212a:	1aca      	subs	r2, r1, r3
 800212c:	0091      	lsls	r1, r2, #2
 800212e:	4421      	add	r1, r4
 8002130:	6508      	str	r0, [r1, #80]	; 0x50
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002132:	3301      	adds	r3, #1
 8002134:	b2db      	uxtb	r3, r3
 8002136:	6865      	ldr	r5, [r4, #4]
 8002138:	42ab      	cmp	r3, r5
 800213a:	d3e6      	bcc.n	800210a <HAL_PCD_Init+0x66>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800213c:	2300      	movs	r3, #0
 800213e:	e015      	b.n	800216c <HAL_PCD_Init+0xc8>
    hpcd->OUT_ep[i].is_in = 0U;
 8002140:	00d8      	lsls	r0, r3, #3
 8002142:	1ac1      	subs	r1, r0, r3
 8002144:	008a      	lsls	r2, r1, #2
 8002146:	4422      	add	r2, r4
 8002148:	2100      	movs	r1, #0
 800214a:	f882 11fd 	strb.w	r1, [r2, #509]	; 0x1fd
    hpcd->OUT_ep[i].num = i;
 800214e:	f882 31fc 	strb.w	r3, [r2, #508]	; 0x1fc
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8002152:	f882 11ff 	strb.w	r1, [r2, #511]	; 0x1ff
    hpcd->OUT_ep[i].maxpacket = 0U;
 8002156:	f8c2 1204 	str.w	r1, [r2, #516]	; 0x204
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800215a:	f8c2 1208 	str.w	r1, [r2, #520]	; 0x208
    hpcd->OUT_ep[i].xfer_len = 0U;
 800215e:	1ac2      	subs	r2, r0, r3
 8002160:	0090      	lsls	r0, r2, #2
 8002162:	4420      	add	r0, r4
 8002164:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002168:	3301      	adds	r3, #1
 800216a:	b2db      	uxtb	r3, r3
 800216c:	429d      	cmp	r5, r3
 800216e:	d8e7      	bhi.n	8002140 <HAL_PCD_Init+0x9c>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8002170:	4625      	mov	r5, r4
 8002172:	f855 7b10 	ldr.w	r7, [r5], #16
 8002176:	466e      	mov	r6, sp
 8002178:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800217a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800217c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800217e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8002180:	e895 0003 	ldmia.w	r5, {r0, r1}
 8002184:	e886 0003 	stmia.w	r6, {r0, r1}
 8002188:	1d23      	adds	r3, r4, #4
 800218a:	cb0e      	ldmia	r3, {r1, r2, r3}
 800218c:	4638      	mov	r0, r7
 800218e:	f001 fc05 	bl	800399c <USB_DevInit>
 8002192:	4605      	mov	r5, r0
 8002194:	b960      	cbnz	r0, 80021b0 <HAL_PCD_Init+0x10c>
  hpcd->USB_Address = 0U;
 8002196:	2300      	movs	r3, #0
 8002198:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  hpcd->State = HAL_PCD_STATE_READY;
 800219c:	2301      	movs	r3, #1
 800219e:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd
  if (hpcd->Init.lpm_enable == 1U)
 80021a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80021a4:	2b01      	cmp	r3, #1
 80021a6:	d008      	beq.n	80021ba <HAL_PCD_Init+0x116>
  (void)USB_DevDisconnect(hpcd->Instance);
 80021a8:	6820      	ldr	r0, [r4, #0]
 80021aa:	f001 fcd1 	bl	8003b50 <USB_DevDisconnect>
  return HAL_OK;
 80021ae:	e79e      	b.n	80020ee <HAL_PCD_Init+0x4a>
    hpcd->State = HAL_PCD_STATE_ERROR;
 80021b0:	2302      	movs	r3, #2
 80021b2:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd
    return HAL_ERROR;
 80021b6:	2501      	movs	r5, #1
 80021b8:	e799      	b.n	80020ee <HAL_PCD_Init+0x4a>
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 80021ba:	4620      	mov	r0, r4
 80021bc:	f000 f804 	bl	80021c8 <HAL_PCDEx_ActivateLPM>
 80021c0:	e7f2      	b.n	80021a8 <HAL_PCD_Init+0x104>
    return HAL_ERROR;
 80021c2:	2501      	movs	r5, #1
 80021c4:	e793      	b.n	80020ee <HAL_PCD_Init+0x4a>
	...

080021c8 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 80021c8:	4602      	mov	r2, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80021ca:	6803      	ldr	r3, [r0, #0]

  hpcd->lpm_active = 1U;
 80021cc:	2101      	movs	r1, #1
 80021ce:	f8c0 13fc 	str.w	r1, [r0, #1020]	; 0x3fc
  hpcd->LPM_State = LPM_L0;
 80021d2:	2000      	movs	r0, #0
 80021d4:	f882 03f4 	strb.w	r0, [r2, #1012]	; 0x3f4
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 80021d8:	699a      	ldr	r2, [r3, #24]
 80021da:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80021de:	619a      	str	r2, [r3, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 80021e0:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80021e2:	4a02      	ldr	r2, [pc, #8]	; (80021ec <HAL_PCDEx_ActivateLPM+0x24>)
 80021e4:	430a      	orrs	r2, r1
 80021e6:	655a      	str	r2, [r3, #84]	; 0x54

  return HAL_OK;
}
 80021e8:	4770      	bx	lr
 80021ea:	bf00      	nop
 80021ec:	10000003 	.word	0x10000003

080021f0 <HAL_PWR_EnableBkUpAccess>:
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80021f0:	4a02      	ldr	r2, [pc, #8]	; (80021fc <HAL_PWR_EnableBkUpAccess+0xc>)
 80021f2:	6813      	ldr	r3, [r2, #0]
 80021f4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80021f8:	6013      	str	r3, [r2, #0]
}
 80021fa:	4770      	bx	lr
 80021fc:	40007000 	.word	0x40007000

08002200 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 8002200:	b510      	push	{r4, lr}
 8002202:	b082      	sub	sp, #8
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8002204:	4b1b      	ldr	r3, [pc, #108]	; (8002274 <HAL_PWREx_EnableOverDrive+0x74>)
 8002206:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002208:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800220c:	641a      	str	r2, [r3, #64]	; 0x40
 800220e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002210:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002214:	9301      	str	r3, [sp, #4]
 8002216:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8002218:	4a17      	ldr	r2, [pc, #92]	; (8002278 <HAL_PWREx_EnableOverDrive+0x78>)
 800221a:	6813      	ldr	r3, [r2, #0]
 800221c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002220:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8002222:	f7ff f993 	bl	800154c <HAL_GetTick>
 8002226:	4604      	mov	r4, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8002228:	4b13      	ldr	r3, [pc, #76]	; (8002278 <HAL_PWREx_EnableOverDrive+0x78>)
 800222a:	685b      	ldr	r3, [r3, #4]
 800222c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8002230:	d108      	bne.n	8002244 <HAL_PWREx_EnableOverDrive+0x44>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8002232:	f7ff f98b 	bl	800154c <HAL_GetTick>
 8002236:	1b00      	subs	r0, r0, r4
 8002238:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800223c:	d9f4      	bls.n	8002228 <HAL_PWREx_EnableOverDrive+0x28>
    {
      return HAL_TIMEOUT;
 800223e:	2003      	movs	r0, #3
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
}
 8002240:	b002      	add	sp, #8
 8002242:	bd10      	pop	{r4, pc}
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8002244:	4a0c      	ldr	r2, [pc, #48]	; (8002278 <HAL_PWREx_EnableOverDrive+0x78>)
 8002246:	6813      	ldr	r3, [r2, #0]
 8002248:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800224c:	6013      	str	r3, [r2, #0]
  tickstart = HAL_GetTick();
 800224e:	f7ff f97d 	bl	800154c <HAL_GetTick>
 8002252:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8002254:	4b08      	ldr	r3, [pc, #32]	; (8002278 <HAL_PWREx_EnableOverDrive+0x78>)
 8002256:	685b      	ldr	r3, [r3, #4]
 8002258:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800225c:	d107      	bne.n	800226e <HAL_PWREx_EnableOverDrive+0x6e>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800225e:	f7ff f975 	bl	800154c <HAL_GetTick>
 8002262:	1b00      	subs	r0, r0, r4
 8002264:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8002268:	d9f4      	bls.n	8002254 <HAL_PWREx_EnableOverDrive+0x54>
      return HAL_TIMEOUT;
 800226a:	2003      	movs	r0, #3
 800226c:	e7e8      	b.n	8002240 <HAL_PWREx_EnableOverDrive+0x40>
  return HAL_OK;
 800226e:	2000      	movs	r0, #0
 8002270:	e7e6      	b.n	8002240 <HAL_PWREx_EnableOverDrive+0x40>
 8002272:	bf00      	nop
 8002274:	40023800 	.word	0x40023800
 8002278:	40007000 	.word	0x40007000

0800227c <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800227c:	2800      	cmp	r0, #0
 800227e:	f000 81dc 	beq.w	800263a <HAL_RCC_OscConfig+0x3be>
{
 8002282:	b570      	push	{r4, r5, r6, lr}
 8002284:	b082      	sub	sp, #8
 8002286:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002288:	6803      	ldr	r3, [r0, #0]
 800228a:	f013 0f01 	tst.w	r3, #1
 800228e:	d029      	beq.n	80022e4 <HAL_RCC_OscConfig+0x68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8002290:	4ba2      	ldr	r3, [pc, #648]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002292:	689b      	ldr	r3, [r3, #8]
 8002294:	f003 030c 	and.w	r3, r3, #12
 8002298:	2b04      	cmp	r3, #4
 800229a:	d01a      	beq.n	80022d2 <HAL_RCC_OscConfig+0x56>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800229c:	4b9f      	ldr	r3, [pc, #636]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 800229e:	689b      	ldr	r3, [r3, #8]
 80022a0:	f003 030c 	and.w	r3, r3, #12
 80022a4:	2b08      	cmp	r3, #8
 80022a6:	d00f      	beq.n	80022c8 <HAL_RCC_OscConfig+0x4c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80022a8:	6863      	ldr	r3, [r4, #4]
 80022aa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80022ae:	d040      	beq.n	8002332 <HAL_RCC_OscConfig+0xb6>
 80022b0:	2b00      	cmp	r3, #0
 80022b2:	d154      	bne.n	800235e <HAL_RCC_OscConfig+0xe2>
 80022b4:	4b99      	ldr	r3, [pc, #612]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80022b6:	681a      	ldr	r2, [r3, #0]
 80022b8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80022bc:	601a      	str	r2, [r3, #0]
 80022be:	681a      	ldr	r2, [r3, #0]
 80022c0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80022c4:	601a      	str	r2, [r3, #0]
 80022c6:	e039      	b.n	800233c <HAL_RCC_OscConfig+0xc0>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80022c8:	4b94      	ldr	r3, [pc, #592]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80022ca:	685b      	ldr	r3, [r3, #4]
 80022cc:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80022d0:	d0ea      	beq.n	80022a8 <HAL_RCC_OscConfig+0x2c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80022d2:	4b92      	ldr	r3, [pc, #584]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80022d4:	681b      	ldr	r3, [r3, #0]
 80022d6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80022da:	d003      	beq.n	80022e4 <HAL_RCC_OscConfig+0x68>
 80022dc:	6863      	ldr	r3, [r4, #4]
 80022de:	2b00      	cmp	r3, #0
 80022e0:	f000 81ad 	beq.w	800263e <HAL_RCC_OscConfig+0x3c2>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80022e4:	6823      	ldr	r3, [r4, #0]
 80022e6:	f013 0f02 	tst.w	r3, #2
 80022ea:	d075      	beq.n	80023d8 <HAL_RCC_OscConfig+0x15c>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 80022ec:	4b8b      	ldr	r3, [pc, #556]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80022ee:	689b      	ldr	r3, [r3, #8]
 80022f0:	f013 0f0c 	tst.w	r3, #12
 80022f4:	d05e      	beq.n	80023b4 <HAL_RCC_OscConfig+0x138>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80022f6:	4b89      	ldr	r3, [pc, #548]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80022f8:	689b      	ldr	r3, [r3, #8]
 80022fa:	f003 030c 	and.w	r3, r3, #12
 80022fe:	2b08      	cmp	r3, #8
 8002300:	d053      	beq.n	80023aa <HAL_RCC_OscConfig+0x12e>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8002302:	68e3      	ldr	r3, [r4, #12]
 8002304:	2b00      	cmp	r3, #0
 8002306:	f000 808a 	beq.w	800241e <HAL_RCC_OscConfig+0x1a2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800230a:	4a84      	ldr	r2, [pc, #528]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 800230c:	6813      	ldr	r3, [r2, #0]
 800230e:	f043 0301 	orr.w	r3, r3, #1
 8002312:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002314:	f7ff f91a 	bl	800154c <HAL_GetTick>
 8002318:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800231a:	4b80      	ldr	r3, [pc, #512]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 800231c:	681b      	ldr	r3, [r3, #0]
 800231e:	f013 0f02 	tst.w	r3, #2
 8002322:	d173      	bne.n	800240c <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002324:	f7ff f912 	bl	800154c <HAL_GetTick>
 8002328:	1b40      	subs	r0, r0, r5
 800232a:	2802      	cmp	r0, #2
 800232c:	d9f5      	bls.n	800231a <HAL_RCC_OscConfig+0x9e>
          {
            return HAL_TIMEOUT;
 800232e:	2003      	movs	r0, #3
 8002330:	e188      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002332:	4a7a      	ldr	r2, [pc, #488]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002334:	6813      	ldr	r3, [r2, #0]
 8002336:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800233a:	6013      	str	r3, [r2, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800233c:	6863      	ldr	r3, [r4, #4]
 800233e:	b32b      	cbz	r3, 800238c <HAL_RCC_OscConfig+0x110>
        tickstart = HAL_GetTick();
 8002340:	f7ff f904 	bl	800154c <HAL_GetTick>
 8002344:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002346:	4b75      	ldr	r3, [pc, #468]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002348:	681b      	ldr	r3, [r3, #0]
 800234a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800234e:	d1c9      	bne.n	80022e4 <HAL_RCC_OscConfig+0x68>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002350:	f7ff f8fc 	bl	800154c <HAL_GetTick>
 8002354:	1b40      	subs	r0, r0, r5
 8002356:	2864      	cmp	r0, #100	; 0x64
 8002358:	d9f5      	bls.n	8002346 <HAL_RCC_OscConfig+0xca>
            return HAL_TIMEOUT;
 800235a:	2003      	movs	r0, #3
 800235c:	e172      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800235e:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002362:	d009      	beq.n	8002378 <HAL_RCC_OscConfig+0xfc>
 8002364:	4b6d      	ldr	r3, [pc, #436]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002366:	681a      	ldr	r2, [r3, #0]
 8002368:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800236c:	601a      	str	r2, [r3, #0]
 800236e:	681a      	ldr	r2, [r3, #0]
 8002370:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002374:	601a      	str	r2, [r3, #0]
 8002376:	e7e1      	b.n	800233c <HAL_RCC_OscConfig+0xc0>
 8002378:	4b68      	ldr	r3, [pc, #416]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 800237a:	681a      	ldr	r2, [r3, #0]
 800237c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8002380:	601a      	str	r2, [r3, #0]
 8002382:	681a      	ldr	r2, [r3, #0]
 8002384:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002388:	601a      	str	r2, [r3, #0]
 800238a:	e7d7      	b.n	800233c <HAL_RCC_OscConfig+0xc0>
        tickstart = HAL_GetTick();
 800238c:	f7ff f8de 	bl	800154c <HAL_GetTick>
 8002390:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002392:	4b62      	ldr	r3, [pc, #392]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002394:	681b      	ldr	r3, [r3, #0]
 8002396:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800239a:	d0a3      	beq.n	80022e4 <HAL_RCC_OscConfig+0x68>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800239c:	f7ff f8d6 	bl	800154c <HAL_GetTick>
 80023a0:	1b40      	subs	r0, r0, r5
 80023a2:	2864      	cmp	r0, #100	; 0x64
 80023a4:	d9f5      	bls.n	8002392 <HAL_RCC_OscConfig+0x116>
            return HAL_TIMEOUT;
 80023a6:	2003      	movs	r0, #3
 80023a8:	e14c      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80023aa:	4b5c      	ldr	r3, [pc, #368]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80023ac:	685b      	ldr	r3, [r3, #4]
 80023ae:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80023b2:	d1a6      	bne.n	8002302 <HAL_RCC_OscConfig+0x86>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80023b4:	4b59      	ldr	r3, [pc, #356]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80023b6:	681b      	ldr	r3, [r3, #0]
 80023b8:	f013 0f02 	tst.w	r3, #2
 80023bc:	d004      	beq.n	80023c8 <HAL_RCC_OscConfig+0x14c>
 80023be:	68e3      	ldr	r3, [r4, #12]
 80023c0:	2b01      	cmp	r3, #1
 80023c2:	d001      	beq.n	80023c8 <HAL_RCC_OscConfig+0x14c>
        return HAL_ERROR;
 80023c4:	2001      	movs	r0, #1
 80023c6:	e13d      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80023c8:	4a54      	ldr	r2, [pc, #336]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80023ca:	6813      	ldr	r3, [r2, #0]
 80023cc:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80023d0:	6921      	ldr	r1, [r4, #16]
 80023d2:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80023d6:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80023d8:	6823      	ldr	r3, [r4, #0]
 80023da:	f013 0f08 	tst.w	r3, #8
 80023de:	d046      	beq.n	800246e <HAL_RCC_OscConfig+0x1f2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80023e0:	6963      	ldr	r3, [r4, #20]
 80023e2:	b383      	cbz	r3, 8002446 <HAL_RCC_OscConfig+0x1ca>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80023e4:	4a4d      	ldr	r2, [pc, #308]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80023e6:	6f53      	ldr	r3, [r2, #116]	; 0x74
 80023e8:	f043 0301 	orr.w	r3, r3, #1
 80023ec:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80023ee:	f7ff f8ad 	bl	800154c <HAL_GetTick>
 80023f2:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80023f4:	4b49      	ldr	r3, [pc, #292]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80023f6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80023f8:	f013 0f02 	tst.w	r3, #2
 80023fc:	d137      	bne.n	800246e <HAL_RCC_OscConfig+0x1f2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80023fe:	f7ff f8a5 	bl	800154c <HAL_GetTick>
 8002402:	1b40      	subs	r0, r0, r5
 8002404:	2802      	cmp	r0, #2
 8002406:	d9f5      	bls.n	80023f4 <HAL_RCC_OscConfig+0x178>
        {
          return HAL_TIMEOUT;
 8002408:	2003      	movs	r0, #3
 800240a:	e11b      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800240c:	4a43      	ldr	r2, [pc, #268]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 800240e:	6813      	ldr	r3, [r2, #0]
 8002410:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8002414:	6921      	ldr	r1, [r4, #16]
 8002416:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800241a:	6013      	str	r3, [r2, #0]
 800241c:	e7dc      	b.n	80023d8 <HAL_RCC_OscConfig+0x15c>
        __HAL_RCC_HSI_DISABLE();
 800241e:	4a3f      	ldr	r2, [pc, #252]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002420:	6813      	ldr	r3, [r2, #0]
 8002422:	f023 0301 	bic.w	r3, r3, #1
 8002426:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002428:	f7ff f890 	bl	800154c <HAL_GetTick>
 800242c:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800242e:	4b3b      	ldr	r3, [pc, #236]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002430:	681b      	ldr	r3, [r3, #0]
 8002432:	f013 0f02 	tst.w	r3, #2
 8002436:	d0cf      	beq.n	80023d8 <HAL_RCC_OscConfig+0x15c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002438:	f7ff f888 	bl	800154c <HAL_GetTick>
 800243c:	1b40      	subs	r0, r0, r5
 800243e:	2802      	cmp	r0, #2
 8002440:	d9f5      	bls.n	800242e <HAL_RCC_OscConfig+0x1b2>
            return HAL_TIMEOUT;
 8002442:	2003      	movs	r0, #3
 8002444:	e0fe      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002446:	4a35      	ldr	r2, [pc, #212]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002448:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800244a:	f023 0301 	bic.w	r3, r3, #1
 800244e:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002450:	f7ff f87c 	bl	800154c <HAL_GetTick>
 8002454:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002456:	4b31      	ldr	r3, [pc, #196]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002458:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800245a:	f013 0f02 	tst.w	r3, #2
 800245e:	d006      	beq.n	800246e <HAL_RCC_OscConfig+0x1f2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002460:	f7ff f874 	bl	800154c <HAL_GetTick>
 8002464:	1b40      	subs	r0, r0, r5
 8002466:	2802      	cmp	r0, #2
 8002468:	d9f5      	bls.n	8002456 <HAL_RCC_OscConfig+0x1da>
        {
          return HAL_TIMEOUT;
 800246a:	2003      	movs	r0, #3
 800246c:	e0ea      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800246e:	6823      	ldr	r3, [r4, #0]
 8002470:	f013 0f04 	tst.w	r3, #4
 8002474:	d07e      	beq.n	8002574 <HAL_RCC_OscConfig+0x2f8>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002476:	4b29      	ldr	r3, [pc, #164]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002478:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800247a:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 800247e:	d11e      	bne.n	80024be <HAL_RCC_OscConfig+0x242>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 8002480:	4b26      	ldr	r3, [pc, #152]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002482:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002484:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002488:	641a      	str	r2, [r3, #64]	; 0x40
 800248a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800248c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002490:	9301      	str	r3, [sp, #4]
 8002492:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002494:	2501      	movs	r5, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8002496:	4b22      	ldr	r3, [pc, #136]	; (8002520 <HAL_RCC_OscConfig+0x2a4>)
 8002498:	681b      	ldr	r3, [r3, #0]
 800249a:	f413 7f80 	tst.w	r3, #256	; 0x100
 800249e:	d010      	beq.n	80024c2 <HAL_RCC_OscConfig+0x246>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024a0:	68a3      	ldr	r3, [r4, #8]
 80024a2:	2b01      	cmp	r3, #1
 80024a4:	d021      	beq.n	80024ea <HAL_RCC_OscConfig+0x26e>
 80024a6:	2b00      	cmp	r3, #0
 80024a8:	d13c      	bne.n	8002524 <HAL_RCC_OscConfig+0x2a8>
 80024aa:	4b1c      	ldr	r3, [pc, #112]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80024ac:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80024ae:	f022 0201 	bic.w	r2, r2, #1
 80024b2:	671a      	str	r2, [r3, #112]	; 0x70
 80024b4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80024b6:	f022 0204 	bic.w	r2, r2, #4
 80024ba:	671a      	str	r2, [r3, #112]	; 0x70
 80024bc:	e01a      	b.n	80024f4 <HAL_RCC_OscConfig+0x278>
  FlagStatus pwrclkchanged = RESET;
 80024be:	2500      	movs	r5, #0
 80024c0:	e7e9      	b.n	8002496 <HAL_RCC_OscConfig+0x21a>
      PWR->CR1 |= PWR_CR1_DBP;
 80024c2:	4a17      	ldr	r2, [pc, #92]	; (8002520 <HAL_RCC_OscConfig+0x2a4>)
 80024c4:	6813      	ldr	r3, [r2, #0]
 80024c6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80024ca:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80024cc:	f7ff f83e 	bl	800154c <HAL_GetTick>
 80024d0:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80024d2:	4b13      	ldr	r3, [pc, #76]	; (8002520 <HAL_RCC_OscConfig+0x2a4>)
 80024d4:	681b      	ldr	r3, [r3, #0]
 80024d6:	f413 7f80 	tst.w	r3, #256	; 0x100
 80024da:	d1e1      	bne.n	80024a0 <HAL_RCC_OscConfig+0x224>
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80024dc:	f7ff f836 	bl	800154c <HAL_GetTick>
 80024e0:	1b80      	subs	r0, r0, r6
 80024e2:	2864      	cmp	r0, #100	; 0x64
 80024e4:	d9f5      	bls.n	80024d2 <HAL_RCC_OscConfig+0x256>
          return HAL_TIMEOUT;
 80024e6:	2003      	movs	r0, #3
 80024e8:	e0ac      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024ea:	4a0c      	ldr	r2, [pc, #48]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 80024ec:	6f13      	ldr	r3, [r2, #112]	; 0x70
 80024ee:	f043 0301 	orr.w	r3, r3, #1
 80024f2:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80024f4:	68a3      	ldr	r3, [r4, #8]
 80024f6:	b35b      	cbz	r3, 8002550 <HAL_RCC_OscConfig+0x2d4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80024f8:	f7ff f828 	bl	800154c <HAL_GetTick>
 80024fc:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80024fe:	4b07      	ldr	r3, [pc, #28]	; (800251c <HAL_RCC_OscConfig+0x2a0>)
 8002500:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002502:	f013 0f02 	tst.w	r3, #2
 8002506:	d134      	bne.n	8002572 <HAL_RCC_OscConfig+0x2f6>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002508:	f7ff f820 	bl	800154c <HAL_GetTick>
 800250c:	1b80      	subs	r0, r0, r6
 800250e:	f241 3388 	movw	r3, #5000	; 0x1388
 8002512:	4298      	cmp	r0, r3
 8002514:	d9f3      	bls.n	80024fe <HAL_RCC_OscConfig+0x282>
        {
          return HAL_TIMEOUT;
 8002516:	2003      	movs	r0, #3
 8002518:	e094      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
 800251a:	bf00      	nop
 800251c:	40023800 	.word	0x40023800
 8002520:	40007000 	.word	0x40007000
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002524:	2b05      	cmp	r3, #5
 8002526:	d009      	beq.n	800253c <HAL_RCC_OscConfig+0x2c0>
 8002528:	4b48      	ldr	r3, [pc, #288]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 800252a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800252c:	f022 0201 	bic.w	r2, r2, #1
 8002530:	671a      	str	r2, [r3, #112]	; 0x70
 8002532:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002534:	f022 0204 	bic.w	r2, r2, #4
 8002538:	671a      	str	r2, [r3, #112]	; 0x70
 800253a:	e7db      	b.n	80024f4 <HAL_RCC_OscConfig+0x278>
 800253c:	4b43      	ldr	r3, [pc, #268]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 800253e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002540:	f042 0204 	orr.w	r2, r2, #4
 8002544:	671a      	str	r2, [r3, #112]	; 0x70
 8002546:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002548:	f042 0201 	orr.w	r2, r2, #1
 800254c:	671a      	str	r2, [r3, #112]	; 0x70
 800254e:	e7d1      	b.n	80024f4 <HAL_RCC_OscConfig+0x278>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002550:	f7fe fffc 	bl	800154c <HAL_GetTick>
 8002554:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002556:	4b3d      	ldr	r3, [pc, #244]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 8002558:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800255a:	f013 0f02 	tst.w	r3, #2
 800255e:	d008      	beq.n	8002572 <HAL_RCC_OscConfig+0x2f6>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002560:	f7fe fff4 	bl	800154c <HAL_GetTick>
 8002564:	1b80      	subs	r0, r0, r6
 8002566:	f241 3388 	movw	r3, #5000	; 0x1388
 800256a:	4298      	cmp	r0, r3
 800256c:	d9f3      	bls.n	8002556 <HAL_RCC_OscConfig+0x2da>
        {
          return HAL_TIMEOUT;
 800256e:	2003      	movs	r0, #3
 8002570:	e068      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8002572:	b9f5      	cbnz	r5, 80025b2 <HAL_RCC_OscConfig+0x336>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8002574:	69a3      	ldr	r3, [r4, #24]
 8002576:	2b00      	cmp	r3, #0
 8002578:	d063      	beq.n	8002642 <HAL_RCC_OscConfig+0x3c6>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800257a:	4a34      	ldr	r2, [pc, #208]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 800257c:	6892      	ldr	r2, [r2, #8]
 800257e:	f002 020c 	and.w	r2, r2, #12
 8002582:	2a08      	cmp	r2, #8
 8002584:	d060      	beq.n	8002648 <HAL_RCC_OscConfig+0x3cc>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002586:	2b02      	cmp	r3, #2
 8002588:	d019      	beq.n	80025be <HAL_RCC_OscConfig+0x342>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800258a:	4a30      	ldr	r2, [pc, #192]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 800258c:	6813      	ldr	r3, [r2, #0]
 800258e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002592:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002594:	f7fe ffda 	bl	800154c <HAL_GetTick>
 8002598:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800259a:	4b2c      	ldr	r3, [pc, #176]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 800259c:	681b      	ldr	r3, [r3, #0]
 800259e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80025a2:	d048      	beq.n	8002636 <HAL_RCC_OscConfig+0x3ba>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80025a4:	f7fe ffd2 	bl	800154c <HAL_GetTick>
 80025a8:	1b00      	subs	r0, r0, r4
 80025aa:	2802      	cmp	r0, #2
 80025ac:	d9f5      	bls.n	800259a <HAL_RCC_OscConfig+0x31e>
          {
            return HAL_TIMEOUT;
 80025ae:	2003      	movs	r0, #3
 80025b0:	e048      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
      __HAL_RCC_PWR_CLK_DISABLE();
 80025b2:	4a26      	ldr	r2, [pc, #152]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 80025b4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80025b6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80025ba:	6413      	str	r3, [r2, #64]	; 0x40
 80025bc:	e7da      	b.n	8002574 <HAL_RCC_OscConfig+0x2f8>
        __HAL_RCC_PLL_DISABLE();
 80025be:	4a23      	ldr	r2, [pc, #140]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 80025c0:	6813      	ldr	r3, [r2, #0]
 80025c2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80025c6:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80025c8:	f7fe ffc0 	bl	800154c <HAL_GetTick>
 80025cc:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80025ce:	4b1f      	ldr	r3, [pc, #124]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 80025d0:	681b      	ldr	r3, [r3, #0]
 80025d2:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80025d6:	d006      	beq.n	80025e6 <HAL_RCC_OscConfig+0x36a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80025d8:	f7fe ffb8 	bl	800154c <HAL_GetTick>
 80025dc:	1b40      	subs	r0, r0, r5
 80025de:	2802      	cmp	r0, #2
 80025e0:	d9f5      	bls.n	80025ce <HAL_RCC_OscConfig+0x352>
            return HAL_TIMEOUT;
 80025e2:	2003      	movs	r0, #3
 80025e4:	e02e      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80025e6:	69e3      	ldr	r3, [r4, #28]
 80025e8:	6a22      	ldr	r2, [r4, #32]
 80025ea:	4313      	orrs	r3, r2
 80025ec:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80025ee:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80025f2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80025f4:	0852      	lsrs	r2, r2, #1
 80025f6:	3a01      	subs	r2, #1
 80025f8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80025fc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80025fe:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8002602:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002604:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8002608:	4a10      	ldr	r2, [pc, #64]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 800260a:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 800260c:	6813      	ldr	r3, [r2, #0]
 800260e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002612:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002614:	f7fe ff9a 	bl	800154c <HAL_GetTick>
 8002618:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800261a:	4b0c      	ldr	r3, [pc, #48]	; (800264c <HAL_RCC_OscConfig+0x3d0>)
 800261c:	681b      	ldr	r3, [r3, #0]
 800261e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002622:	d106      	bne.n	8002632 <HAL_RCC_OscConfig+0x3b6>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002624:	f7fe ff92 	bl	800154c <HAL_GetTick>
 8002628:	1b00      	subs	r0, r0, r4
 800262a:	2802      	cmp	r0, #2
 800262c:	d9f5      	bls.n	800261a <HAL_RCC_OscConfig+0x39e>
            return HAL_TIMEOUT;
 800262e:	2003      	movs	r0, #3
 8002630:	e008      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8002632:	2000      	movs	r0, #0
 8002634:	e006      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
 8002636:	2000      	movs	r0, #0
 8002638:	e004      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
    return HAL_ERROR;
 800263a:	2001      	movs	r0, #1
}
 800263c:	4770      	bx	lr
        return HAL_ERROR;
 800263e:	2001      	movs	r0, #1
 8002640:	e000      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
  return HAL_OK;
 8002642:	2000      	movs	r0, #0
}
 8002644:	b002      	add	sp, #8
 8002646:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8002648:	2001      	movs	r0, #1
 800264a:	e7fb      	b.n	8002644 <HAL_RCC_OscConfig+0x3c8>
 800264c:	40023800 	.word	0x40023800

08002650 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002650:	4b32      	ldr	r3, [pc, #200]	; (800271c <HAL_RCC_GetSysClockFreq+0xcc>)
 8002652:	689b      	ldr	r3, [r3, #8]
 8002654:	f003 030c 	and.w	r3, r3, #12
 8002658:	2b04      	cmp	r3, #4
 800265a:	d05c      	beq.n	8002716 <HAL_RCC_GetSysClockFreq+0xc6>
 800265c:	2b08      	cmp	r3, #8
 800265e:	d001      	beq.n	8002664 <HAL_RCC_GetSysClockFreq+0x14>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8002660:	482f      	ldr	r0, [pc, #188]	; (8002720 <HAL_RCC_GetSysClockFreq+0xd0>)
 8002662:	4770      	bx	lr
{
 8002664:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002668:	4b2c      	ldr	r3, [pc, #176]	; (800271c <HAL_RCC_GetSysClockFreq+0xcc>)
 800266a:	685a      	ldr	r2, [r3, #4]
 800266c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8002670:	685b      	ldr	r3, [r3, #4]
 8002672:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8002676:	d02b      	beq.n	80026d0 <HAL_RCC_GetSysClockFreq+0x80>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002678:	4b28      	ldr	r3, [pc, #160]	; (800271c <HAL_RCC_GetSysClockFreq+0xcc>)
 800267a:	685b      	ldr	r3, [r3, #4]
 800267c:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8002680:	461e      	mov	r6, r3
 8002682:	2700      	movs	r7, #0
 8002684:	015c      	lsls	r4, r3, #5
 8002686:	2500      	movs	r5, #0
 8002688:	1ae4      	subs	r4, r4, r3
 800268a:	eb65 0507 	sbc.w	r5, r5, r7
 800268e:	01a9      	lsls	r1, r5, #6
 8002690:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 8002694:	01a0      	lsls	r0, r4, #6
 8002696:	1b00      	subs	r0, r0, r4
 8002698:	eb61 0105 	sbc.w	r1, r1, r5
 800269c:	00cb      	lsls	r3, r1, #3
 800269e:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 80026a2:	00c4      	lsls	r4, r0, #3
 80026a4:	19a0      	adds	r0, r4, r6
 80026a6:	eb43 0107 	adc.w	r1, r3, r7
 80026aa:	024b      	lsls	r3, r1, #9
 80026ac:	ea43 53d0 	orr.w	r3, r3, r0, lsr #23
 80026b0:	0244      	lsls	r4, r0, #9
 80026b2:	4620      	mov	r0, r4
 80026b4:	4619      	mov	r1, r3
 80026b6:	2300      	movs	r3, #0
 80026b8:	f7fd fe2a 	bl	8000310 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 80026bc:	4b17      	ldr	r3, [pc, #92]	; (800271c <HAL_RCC_GetSysClockFreq+0xcc>)
 80026be:	685b      	ldr	r3, [r3, #4]
 80026c0:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80026c4:	3301      	adds	r3, #1
 80026c6:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 80026c8:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80026cc:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80026d0:	4b12      	ldr	r3, [pc, #72]	; (800271c <HAL_RCC_GetSysClockFreq+0xcc>)
 80026d2:	685b      	ldr	r3, [r3, #4]
 80026d4:	f3c3 1388 	ubfx	r3, r3, #6, #9
 80026d8:	461e      	mov	r6, r3
 80026da:	2700      	movs	r7, #0
 80026dc:	015c      	lsls	r4, r3, #5
 80026de:	2500      	movs	r5, #0
 80026e0:	1ae4      	subs	r4, r4, r3
 80026e2:	eb65 0507 	sbc.w	r5, r5, r7
 80026e6:	01a9      	lsls	r1, r5, #6
 80026e8:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 80026ec:	01a0      	lsls	r0, r4, #6
 80026ee:	1b00      	subs	r0, r0, r4
 80026f0:	eb61 0105 	sbc.w	r1, r1, r5
 80026f4:	00cb      	lsls	r3, r1, #3
 80026f6:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 80026fa:	00c4      	lsls	r4, r0, #3
 80026fc:	19a0      	adds	r0, r4, r6
 80026fe:	eb43 0107 	adc.w	r1, r3, r7
 8002702:	028b      	lsls	r3, r1, #10
 8002704:	ea43 5390 	orr.w	r3, r3, r0, lsr #22
 8002708:	0284      	lsls	r4, r0, #10
 800270a:	4620      	mov	r0, r4
 800270c:	4619      	mov	r1, r3
 800270e:	2300      	movs	r3, #0
 8002710:	f7fd fdfe 	bl	8000310 <__aeabi_uldivmod>
 8002714:	e7d2      	b.n	80026bc <HAL_RCC_GetSysClockFreq+0x6c>
      sysclockfreq = HSE_VALUE;
 8002716:	4803      	ldr	r0, [pc, #12]	; (8002724 <HAL_RCC_GetSysClockFreq+0xd4>)
}
 8002718:	4770      	bx	lr
 800271a:	bf00      	nop
 800271c:	40023800 	.word	0x40023800
 8002720:	00f42400 	.word	0x00f42400
 8002724:	007a1200 	.word	0x007a1200

08002728 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8002728:	2800      	cmp	r0, #0
 800272a:	f000 80a2 	beq.w	8002872 <HAL_RCC_ClockConfig+0x14a>
{
 800272e:	b570      	push	{r4, r5, r6, lr}
 8002730:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002732:	4b52      	ldr	r3, [pc, #328]	; (800287c <HAL_RCC_ClockConfig+0x154>)
 8002734:	681b      	ldr	r3, [r3, #0]
 8002736:	f003 030f 	and.w	r3, r3, #15
 800273a:	428b      	cmp	r3, r1
 800273c:	d20c      	bcs.n	8002758 <HAL_RCC_ClockConfig+0x30>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800273e:	4a4f      	ldr	r2, [pc, #316]	; (800287c <HAL_RCC_ClockConfig+0x154>)
 8002740:	6813      	ldr	r3, [r2, #0]
 8002742:	f023 030f 	bic.w	r3, r3, #15
 8002746:	430b      	orrs	r3, r1
 8002748:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800274a:	6813      	ldr	r3, [r2, #0]
 800274c:	f003 030f 	and.w	r3, r3, #15
 8002750:	428b      	cmp	r3, r1
 8002752:	d001      	beq.n	8002758 <HAL_RCC_ClockConfig+0x30>
      return HAL_ERROR;
 8002754:	2001      	movs	r0, #1
}
 8002756:	bd70      	pop	{r4, r5, r6, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002758:	6823      	ldr	r3, [r4, #0]
 800275a:	f013 0f02 	tst.w	r3, #2
 800275e:	d017      	beq.n	8002790 <HAL_RCC_ClockConfig+0x68>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002760:	f013 0f04 	tst.w	r3, #4
 8002764:	d004      	beq.n	8002770 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8002766:	4a46      	ldr	r2, [pc, #280]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 8002768:	6893      	ldr	r3, [r2, #8]
 800276a:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 800276e:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002770:	6823      	ldr	r3, [r4, #0]
 8002772:	f013 0f08 	tst.w	r3, #8
 8002776:	d004      	beq.n	8002782 <HAL_RCC_ClockConfig+0x5a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8002778:	4a41      	ldr	r2, [pc, #260]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 800277a:	6893      	ldr	r3, [r2, #8]
 800277c:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 8002780:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002782:	4a3f      	ldr	r2, [pc, #252]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 8002784:	6893      	ldr	r3, [r2, #8]
 8002786:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800278a:	68a0      	ldr	r0, [r4, #8]
 800278c:	4303      	orrs	r3, r0
 800278e:	6093      	str	r3, [r2, #8]
 8002790:	460d      	mov	r5, r1
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002792:	6823      	ldr	r3, [r4, #0]
 8002794:	f013 0f01 	tst.w	r3, #1
 8002798:	d031      	beq.n	80027fe <HAL_RCC_ClockConfig+0xd6>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800279a:	6863      	ldr	r3, [r4, #4]
 800279c:	2b01      	cmp	r3, #1
 800279e:	d020      	beq.n	80027e2 <HAL_RCC_ClockConfig+0xba>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80027a0:	2b02      	cmp	r3, #2
 80027a2:	d025      	beq.n	80027f0 <HAL_RCC_ClockConfig+0xc8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80027a4:	4a36      	ldr	r2, [pc, #216]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 80027a6:	6812      	ldr	r2, [r2, #0]
 80027a8:	f012 0f02 	tst.w	r2, #2
 80027ac:	d063      	beq.n	8002876 <HAL_RCC_ClockConfig+0x14e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80027ae:	4934      	ldr	r1, [pc, #208]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 80027b0:	688a      	ldr	r2, [r1, #8]
 80027b2:	f022 0203 	bic.w	r2, r2, #3
 80027b6:	4313      	orrs	r3, r2
 80027b8:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 80027ba:	f7fe fec7 	bl	800154c <HAL_GetTick>
 80027be:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80027c0:	4b2f      	ldr	r3, [pc, #188]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 80027c2:	689b      	ldr	r3, [r3, #8]
 80027c4:	f003 030c 	and.w	r3, r3, #12
 80027c8:	6862      	ldr	r2, [r4, #4]
 80027ca:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80027ce:	d016      	beq.n	80027fe <HAL_RCC_ClockConfig+0xd6>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80027d0:	f7fe febc 	bl	800154c <HAL_GetTick>
 80027d4:	1b80      	subs	r0, r0, r6
 80027d6:	f241 3388 	movw	r3, #5000	; 0x1388
 80027da:	4298      	cmp	r0, r3
 80027dc:	d9f0      	bls.n	80027c0 <HAL_RCC_ClockConfig+0x98>
        return HAL_TIMEOUT;
 80027de:	2003      	movs	r0, #3
 80027e0:	e7b9      	b.n	8002756 <HAL_RCC_ClockConfig+0x2e>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80027e2:	4a27      	ldr	r2, [pc, #156]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 80027e4:	6812      	ldr	r2, [r2, #0]
 80027e6:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80027ea:	d1e0      	bne.n	80027ae <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 80027ec:	2001      	movs	r0, #1
 80027ee:	e7b2      	b.n	8002756 <HAL_RCC_ClockConfig+0x2e>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80027f0:	4a23      	ldr	r2, [pc, #140]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 80027f2:	6812      	ldr	r2, [r2, #0]
 80027f4:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80027f8:	d1d9      	bne.n	80027ae <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 80027fa:	2001      	movs	r0, #1
 80027fc:	e7ab      	b.n	8002756 <HAL_RCC_ClockConfig+0x2e>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80027fe:	4b1f      	ldr	r3, [pc, #124]	; (800287c <HAL_RCC_ClockConfig+0x154>)
 8002800:	681b      	ldr	r3, [r3, #0]
 8002802:	f003 030f 	and.w	r3, r3, #15
 8002806:	42ab      	cmp	r3, r5
 8002808:	d90c      	bls.n	8002824 <HAL_RCC_ClockConfig+0xfc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800280a:	4a1c      	ldr	r2, [pc, #112]	; (800287c <HAL_RCC_ClockConfig+0x154>)
 800280c:	6813      	ldr	r3, [r2, #0]
 800280e:	f023 030f 	bic.w	r3, r3, #15
 8002812:	432b      	orrs	r3, r5
 8002814:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8002816:	6813      	ldr	r3, [r2, #0]
 8002818:	f003 030f 	and.w	r3, r3, #15
 800281c:	42ab      	cmp	r3, r5
 800281e:	d001      	beq.n	8002824 <HAL_RCC_ClockConfig+0xfc>
      return HAL_ERROR;
 8002820:	2001      	movs	r0, #1
 8002822:	e798      	b.n	8002756 <HAL_RCC_ClockConfig+0x2e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002824:	6823      	ldr	r3, [r4, #0]
 8002826:	f013 0f04 	tst.w	r3, #4
 800282a:	d006      	beq.n	800283a <HAL_RCC_ClockConfig+0x112>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800282c:	4a14      	ldr	r2, [pc, #80]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 800282e:	6893      	ldr	r3, [r2, #8]
 8002830:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8002834:	68e1      	ldr	r1, [r4, #12]
 8002836:	430b      	orrs	r3, r1
 8002838:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800283a:	6823      	ldr	r3, [r4, #0]
 800283c:	f013 0f08 	tst.w	r3, #8
 8002840:	d007      	beq.n	8002852 <HAL_RCC_ClockConfig+0x12a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8002842:	4a0f      	ldr	r2, [pc, #60]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 8002844:	6893      	ldr	r3, [r2, #8]
 8002846:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800284a:	6921      	ldr	r1, [r4, #16]
 800284c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002850:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8002852:	f7ff fefd 	bl	8002650 <HAL_RCC_GetSysClockFreq>
 8002856:	4b0a      	ldr	r3, [pc, #40]	; (8002880 <HAL_RCC_ClockConfig+0x158>)
 8002858:	689b      	ldr	r3, [r3, #8]
 800285a:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800285e:	4a09      	ldr	r2, [pc, #36]	; (8002884 <HAL_RCC_ClockConfig+0x15c>)
 8002860:	5cd3      	ldrb	r3, [r2, r3]
 8002862:	40d8      	lsrs	r0, r3
 8002864:	4b08      	ldr	r3, [pc, #32]	; (8002888 <HAL_RCC_ClockConfig+0x160>)
 8002866:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8002868:	2000      	movs	r0, #0
 800286a:	f008 f9e1 	bl	800ac30 <HAL_InitTick>
  return HAL_OK;
 800286e:	2000      	movs	r0, #0
 8002870:	e771      	b.n	8002756 <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8002872:	2001      	movs	r0, #1
}
 8002874:	4770      	bx	lr
        return HAL_ERROR;
 8002876:	2001      	movs	r0, #1
 8002878:	e76d      	b.n	8002756 <HAL_RCC_ClockConfig+0x2e>
 800287a:	bf00      	nop
 800287c:	40023c00 	.word	0x40023c00
 8002880:	40023800 	.word	0x40023800
 8002884:	08010918 	.word	0x08010918
 8002888:	20000010 	.word	0x20000010

0800288c <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 800288c:	4b01      	ldr	r3, [pc, #4]	; (8002894 <HAL_RCC_GetHCLKFreq+0x8>)
 800288e:	6818      	ldr	r0, [r3, #0]
 8002890:	4770      	bx	lr
 8002892:	bf00      	nop
 8002894:	20000010 	.word	0x20000010

08002898 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8002898:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800289a:	f7ff fff7 	bl	800288c <HAL_RCC_GetHCLKFreq>
 800289e:	4b04      	ldr	r3, [pc, #16]	; (80028b0 <HAL_RCC_GetPCLK1Freq+0x18>)
 80028a0:	689b      	ldr	r3, [r3, #8]
 80028a2:	f3c3 2382 	ubfx	r3, r3, #10, #3
 80028a6:	4a03      	ldr	r2, [pc, #12]	; (80028b4 <HAL_RCC_GetPCLK1Freq+0x1c>)
 80028a8:	5cd3      	ldrb	r3, [r2, r3]
}
 80028aa:	40d8      	lsrs	r0, r3
 80028ac:	bd08      	pop	{r3, pc}
 80028ae:	bf00      	nop
 80028b0:	40023800 	.word	0x40023800
 80028b4:	08010928 	.word	0x08010928

080028b8 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 80028b8:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80028ba:	f7ff ffe7 	bl	800288c <HAL_RCC_GetHCLKFreq>
 80028be:	4b04      	ldr	r3, [pc, #16]	; (80028d0 <HAL_RCC_GetPCLK2Freq+0x18>)
 80028c0:	689b      	ldr	r3, [r3, #8]
 80028c2:	f3c3 3342 	ubfx	r3, r3, #13, #3
 80028c6:	4a03      	ldr	r2, [pc, #12]	; (80028d4 <HAL_RCC_GetPCLK2Freq+0x1c>)
 80028c8:	5cd3      	ldrb	r3, [r2, r3]
}
 80028ca:	40d8      	lsrs	r0, r3
 80028cc:	bd08      	pop	{r3, pc}
 80028ce:	bf00      	nop
 80028d0:	40023800 	.word	0x40023800
 80028d4:	08010928 	.word	0x08010928

080028d8 <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80028d8:	230f      	movs	r3, #15
 80028da:	6003      	str	r3, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80028dc:	4b0b      	ldr	r3, [pc, #44]	; (800290c <HAL_RCC_GetClockConfig+0x34>)
 80028de:	689a      	ldr	r2, [r3, #8]
 80028e0:	f002 0203 	and.w	r2, r2, #3
 80028e4:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80028e6:	689a      	ldr	r2, [r3, #8]
 80028e8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80028ec:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 80028ee:	689a      	ldr	r2, [r3, #8]
 80028f0:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 80028f4:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 80028f6:	689b      	ldr	r3, [r3, #8]
 80028f8:	08db      	lsrs	r3, r3, #3
 80028fa:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 80028fe:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8002900:	4b03      	ldr	r3, [pc, #12]	; (8002910 <HAL_RCC_GetClockConfig+0x38>)
 8002902:	681b      	ldr	r3, [r3, #0]
 8002904:	f003 030f 	and.w	r3, r3, #15
 8002908:	600b      	str	r3, [r1, #0]
}
 800290a:	4770      	bx	lr
 800290c:	40023800 	.word	0x40023800
 8002910:	40023c00 	.word	0x40023c00

08002914 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002914:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002916:	b083      	sub	sp, #12
 8002918:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 800291a:	6803      	ldr	r3, [r0, #0]
 800291c:	f013 0f01 	tst.w	r3, #1
 8002920:	d00c      	beq.n	800293c <HAL_RCCEx_PeriphCLKConfig+0x28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8002922:	4bb5      	ldr	r3, [pc, #724]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002924:	689a      	ldr	r2, [r3, #8]
 8002926:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 800292a:	609a      	str	r2, [r3, #8]
 800292c:	689a      	ldr	r2, [r3, #8]
 800292e:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8002930:	430a      	orrs	r2, r1
 8002932:	609a      	str	r2, [r3, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8002934:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002936:	b1c3      	cbz	r3, 800296a <HAL_RCCEx_PeriphCLKConfig+0x56>
  uint32_t plli2sused = 0;
 8002938:	2600      	movs	r6, #0
 800293a:	e000      	b.n	800293e <HAL_RCCEx_PeriphCLKConfig+0x2a>
 800293c:	2600      	movs	r6, #0
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 800293e:	6823      	ldr	r3, [r4, #0]
 8002940:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8002944:	d015      	beq.n	8002972 <HAL_RCCEx_PeriphCLKConfig+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8002946:	4aac      	ldr	r2, [pc, #688]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002948:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 800294c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8002950:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002952:	430b      	orrs	r3, r1
 8002954:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8002958:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800295a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800295e:	d006      	beq.n	800296e <HAL_RCCEx_PeriphCLKConfig+0x5a>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8002960:	2b00      	cmp	r3, #0
 8002962:	f000 8145 	beq.w	8002bf0 <HAL_RCCEx_PeriphCLKConfig+0x2dc>
  uint32_t pllsaiused = 0;
 8002966:	2500      	movs	r5, #0
 8002968:	e004      	b.n	8002974 <HAL_RCCEx_PeriphCLKConfig+0x60>
      plli2sused = 1;
 800296a:	2601      	movs	r6, #1
 800296c:	e7e7      	b.n	800293e <HAL_RCCEx_PeriphCLKConfig+0x2a>
      plli2sused = 1;
 800296e:	2601      	movs	r6, #1
 8002970:	e7f6      	b.n	8002960 <HAL_RCCEx_PeriphCLKConfig+0x4c>
  uint32_t pllsaiused = 0;
 8002972:	2500      	movs	r5, #0
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8002974:	6823      	ldr	r3, [r4, #0]
 8002976:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800297a:	d00f      	beq.n	800299c <HAL_RCCEx_PeriphCLKConfig+0x88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800297c:	4a9e      	ldr	r2, [pc, #632]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 800297e:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002982:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8002986:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8002988:	430b      	orrs	r3, r1
 800298a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 800298e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002990:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8002994:	f000 812e 	beq.w	8002bf4 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
 8002998:	b903      	cbnz	r3, 800299c <HAL_RCCEx_PeriphCLKConfig+0x88>
    {
      pllsaiused = 1;
 800299a:	2501      	movs	r5, #1
    }
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800299c:	6823      	ldr	r3, [r4, #0]
 800299e:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 80029a2:	d000      	beq.n	80029a6 <HAL_RCCEx_PeriphCLKConfig+0x92>
  {
      plli2sused = 1;
 80029a4:	2601      	movs	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80029a6:	f013 0f20 	tst.w	r3, #32
 80029aa:	f040 8127 	bne.w	8002bfc <HAL_RCCEx_PeriphCLKConfig+0x2e8>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80029ae:	6823      	ldr	r3, [r4, #0]
 80029b0:	f013 0f10 	tst.w	r3, #16
 80029b4:	d00c      	beq.n	80029d0 <HAL_RCCEx_PeriphCLKConfig+0xbc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80029b6:	4b90      	ldr	r3, [pc, #576]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 80029b8:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80029bc:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80029c0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 80029c4:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80029c8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80029ca:	430a      	orrs	r2, r1
 80029cc:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80029d0:	6823      	ldr	r3, [r4, #0]
 80029d2:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80029d6:	d008      	beq.n	80029ea <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80029d8:	4a87      	ldr	r2, [pc, #540]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 80029da:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80029de:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 80029e2:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80029e4:	430b      	orrs	r3, r1
 80029e6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80029ea:	6823      	ldr	r3, [r4, #0]
 80029ec:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 80029f0:	d008      	beq.n	8002a04 <HAL_RCCEx_PeriphCLKConfig+0xf0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80029f2:	4a81      	ldr	r2, [pc, #516]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 80029f4:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80029f8:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 80029fc:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 80029fe:	430b      	orrs	r3, r1
 8002a00:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8002a04:	6823      	ldr	r3, [r4, #0]
 8002a06:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8002a0a:	d008      	beq.n	8002a1e <HAL_RCCEx_PeriphCLKConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8002a0c:	4a7a      	ldr	r2, [pc, #488]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002a0e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002a12:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8002a16:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8002a18:	430b      	orrs	r3, r1
 8002a1a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8002a1e:	6823      	ldr	r3, [r4, #0]
 8002a20:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002a24:	d008      	beq.n	8002a38 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8002a26:	4a74      	ldr	r2, [pc, #464]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002a28:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002a2c:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8002a30:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8002a32:	430b      	orrs	r3, r1
 8002a34:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8002a38:	6823      	ldr	r3, [r4, #0]
 8002a3a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8002a3e:	d008      	beq.n	8002a52 <HAL_RCCEx_PeriphCLKConfig+0x13e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8002a40:	4a6d      	ldr	r2, [pc, #436]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002a42:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002a46:	f023 0303 	bic.w	r3, r3, #3
 8002a4a:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8002a4c:	430b      	orrs	r3, r1
 8002a4e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8002a52:	6823      	ldr	r3, [r4, #0]
 8002a54:	f013 0f80 	tst.w	r3, #128	; 0x80
 8002a58:	d008      	beq.n	8002a6c <HAL_RCCEx_PeriphCLKConfig+0x158>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8002a5a:	4a67      	ldr	r2, [pc, #412]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002a5c:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002a60:	f023 030c 	bic.w	r3, r3, #12
 8002a64:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8002a66:	430b      	orrs	r3, r1
 8002a68:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8002a6c:	6823      	ldr	r3, [r4, #0]
 8002a6e:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002a72:	d008      	beq.n	8002a86 <HAL_RCCEx_PeriphCLKConfig+0x172>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8002a74:	4a60      	ldr	r2, [pc, #384]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002a76:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002a7a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8002a7e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8002a80:	430b      	orrs	r3, r1
 8002a82:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8002a86:	6823      	ldr	r3, [r4, #0]
 8002a88:	f413 7f00 	tst.w	r3, #512	; 0x200
 8002a8c:	d008      	beq.n	8002aa0 <HAL_RCCEx_PeriphCLKConfig+0x18c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8002a8e:	4a5a      	ldr	r2, [pc, #360]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002a90:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002a94:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8002a98:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8002a9a:	430b      	orrs	r3, r1
 8002a9c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8002aa0:	6823      	ldr	r3, [r4, #0]
 8002aa2:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8002aa6:	d008      	beq.n	8002aba <HAL_RCCEx_PeriphCLKConfig+0x1a6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8002aa8:	4a53      	ldr	r2, [pc, #332]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002aaa:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002aae:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002ab2:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8002ab4:	430b      	orrs	r3, r1
 8002ab6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8002aba:	6823      	ldr	r3, [r4, #0]
 8002abc:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8002ac0:	d008      	beq.n	8002ad4 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8002ac2:	4a4d      	ldr	r2, [pc, #308]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002ac4:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002ac8:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8002acc:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8002ace:	430b      	orrs	r3, r1
 8002ad0:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8002ad4:	6823      	ldr	r3, [r4, #0]
 8002ad6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8002ada:	d008      	beq.n	8002aee <HAL_RCCEx_PeriphCLKConfig+0x1da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8002adc:	4a46      	ldr	r2, [pc, #280]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002ade:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002ae2:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8002ae6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8002ae8:	430b      	orrs	r3, r1
 8002aea:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8002aee:	6823      	ldr	r3, [r4, #0]
 8002af0:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 8002af4:	d008      	beq.n	8002b08 <HAL_RCCEx_PeriphCLKConfig+0x1f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8002af6:	4a40      	ldr	r2, [pc, #256]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002af8:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002afc:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002b00:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8002b02:	430b      	orrs	r3, r1
 8002b04:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8002b08:	6823      	ldr	r3, [r4, #0]
 8002b0a:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8002b0e:	d008      	beq.n	8002b22 <HAL_RCCEx_PeriphCLKConfig+0x20e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8002b10:	4a39      	ldr	r2, [pc, #228]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002b12:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002b16:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8002b1a:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 8002b1c:	430b      	orrs	r3, r1
 8002b1e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8002b22:	6823      	ldr	r3, [r4, #0]
 8002b24:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8002b28:	d00d      	beq.n	8002b46 <HAL_RCCEx_PeriphCLKConfig+0x232>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8002b2a:	4a33      	ldr	r2, [pc, #204]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002b2c:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002b30:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 8002b34:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8002b36:	430b      	orrs	r3, r1
 8002b38:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
 8002b3c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8002b3e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8002b42:	f000 80c1 	beq.w	8002cc8 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8002b46:	6823      	ldr	r3, [r4, #0]
 8002b48:	f013 0f08 	tst.w	r3, #8
 8002b4c:	d000      	beq.n	8002b50 <HAL_RCCEx_PeriphCLKConfig+0x23c>
  {
    pllsaiused = 1;
 8002b4e:	2501      	movs	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8002b50:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8002b54:	d008      	beq.n	8002b68 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8002b56:	4a28      	ldr	r2, [pc, #160]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002b58:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002b5c:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 8002b60:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8002b62:	430b      	orrs	r3, r1
 8002b64:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8002b68:	6823      	ldr	r3, [r4, #0]
 8002b6a:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
 8002b6e:	d009      	beq.n	8002b84 <HAL_RCCEx_PeriphCLKConfig+0x270>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8002b70:	4a21      	ldr	r2, [pc, #132]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002b72:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002b76:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002b7a:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 8002b7e:	430b      	orrs	r3, r1
 8002b80:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
 8002b84:	6823      	ldr	r3, [r4, #0]
 8002b86:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 8002b8a:	d009      	beq.n	8002ba0 <HAL_RCCEx_PeriphCLKConfig+0x28c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
 8002b8c:	4a1a      	ldr	r2, [pc, #104]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002b8e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002b92:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8002b96:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
 8002b9a:	430b      	orrs	r3, r1
 8002b9c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  }

  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8002ba0:	6823      	ldr	r3, [r4, #0]
 8002ba2:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8002ba6:	d009      	beq.n	8002bbc <HAL_RCCEx_PeriphCLKConfig+0x2a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8002ba8:	4a13      	ldr	r2, [pc, #76]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002baa:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002bae:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8002bb2:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
 8002bb6:	430b      	orrs	r3, r1
 8002bb8:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  }

  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
 8002bbc:	6823      	ldr	r3, [r4, #0]
 8002bbe:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8002bc2:	d009      	beq.n	8002bd8 <HAL_RCCEx_PeriphCLKConfig+0x2c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8002bc4:	4a0c      	ldr	r2, [pc, #48]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 8002bc6:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002bca:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8002bce:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 8002bd2:	430b      	orrs	r3, r1
 8002bd4:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8002bd8:	2e00      	cmp	r6, #0
 8002bda:	d177      	bne.n	8002ccc <HAL_RCCEx_PeriphCLKConfig+0x3b8>
 8002bdc:	6823      	ldr	r3, [r4, #0]
 8002bde:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8002be2:	d073      	beq.n	8002ccc <HAL_RCCEx_PeriphCLKConfig+0x3b8>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8002be4:	2d00      	cmp	r5, #0
 8002be6:	f040 8104 	bne.w	8002df2 <HAL_RCCEx_PeriphCLKConfig+0x4de>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8002bea:	2000      	movs	r0, #0
}
 8002bec:	b003      	add	sp, #12
 8002bee:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pllsaiused = 1;
 8002bf0:	2501      	movs	r5, #1
 8002bf2:	e6bf      	b.n	8002974 <HAL_RCCEx_PeriphCLKConfig+0x60>
      plli2sused = 1;
 8002bf4:	2601      	movs	r6, #1
 8002bf6:	e6cf      	b.n	8002998 <HAL_RCCEx_PeriphCLKConfig+0x84>
 8002bf8:	40023800 	.word	0x40023800
    __HAL_RCC_PWR_CLK_ENABLE();
 8002bfc:	4bb7      	ldr	r3, [pc, #732]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002bfe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002c00:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002c04:	641a      	str	r2, [r3, #64]	; 0x40
 8002c06:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002c08:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002c0c:	9301      	str	r3, [sp, #4]
 8002c0e:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8002c10:	4ab3      	ldr	r2, [pc, #716]	; (8002ee0 <HAL_RCCEx_PeriphCLKConfig+0x5cc>)
 8002c12:	6813      	ldr	r3, [r2, #0]
 8002c14:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c18:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002c1a:	f7fe fc97 	bl	800154c <HAL_GetTick>
 8002c1e:	4607      	mov	r7, r0
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8002c20:	4baf      	ldr	r3, [pc, #700]	; (8002ee0 <HAL_RCCEx_PeriphCLKConfig+0x5cc>)
 8002c22:	681b      	ldr	r3, [r3, #0]
 8002c24:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002c28:	d106      	bne.n	8002c38 <HAL_RCCEx_PeriphCLKConfig+0x324>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002c2a:	f7fe fc8f 	bl	800154c <HAL_GetTick>
 8002c2e:	1bc0      	subs	r0, r0, r7
 8002c30:	2864      	cmp	r0, #100	; 0x64
 8002c32:	d9f5      	bls.n	8002c20 <HAL_RCCEx_PeriphCLKConfig+0x30c>
        return HAL_TIMEOUT;
 8002c34:	2003      	movs	r0, #3
 8002c36:	e7d9      	b.n	8002bec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8002c38:	4ba8      	ldr	r3, [pc, #672]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002c3a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8002c3c:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8002c40:	d015      	beq.n	8002c6e <HAL_RCCEx_PeriphCLKConfig+0x35a>
 8002c42:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002c44:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8002c48:	429a      	cmp	r2, r3
 8002c4a:	d010      	beq.n	8002c6e <HAL_RCCEx_PeriphCLKConfig+0x35a>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002c4c:	4ba3      	ldr	r3, [pc, #652]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002c4e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002c50:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8002c54:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8002c56:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8002c5a:	6719      	str	r1, [r3, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002c5c:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8002c5e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8002c62:	6719      	str	r1, [r3, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 8002c64:	671a      	str	r2, [r3, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8002c66:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002c68:	f013 0f01 	tst.w	r3, #1
 8002c6c:	d112      	bne.n	8002c94 <HAL_RCCEx_PeriphCLKConfig+0x380>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002c6e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002c70:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8002c74:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8002c78:	d01d      	beq.n	8002cb6 <HAL_RCCEx_PeriphCLKConfig+0x3a2>
 8002c7a:	4a98      	ldr	r2, [pc, #608]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002c7c:	6893      	ldr	r3, [r2, #8]
 8002c7e:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8002c82:	6093      	str	r3, [r2, #8]
 8002c84:	4995      	ldr	r1, [pc, #596]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002c86:	6f0b      	ldr	r3, [r1, #112]	; 0x70
 8002c88:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002c8a:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8002c8e:	4313      	orrs	r3, r2
 8002c90:	670b      	str	r3, [r1, #112]	; 0x70
 8002c92:	e68c      	b.n	80029ae <HAL_RCCEx_PeriphCLKConfig+0x9a>
        tickstart = HAL_GetTick();
 8002c94:	f7fe fc5a 	bl	800154c <HAL_GetTick>
 8002c98:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002c9a:	4b90      	ldr	r3, [pc, #576]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002c9c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002c9e:	f013 0f02 	tst.w	r3, #2
 8002ca2:	d1e4      	bne.n	8002c6e <HAL_RCCEx_PeriphCLKConfig+0x35a>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002ca4:	f7fe fc52 	bl	800154c <HAL_GetTick>
 8002ca8:	1bc0      	subs	r0, r0, r7
 8002caa:	f241 3388 	movw	r3, #5000	; 0x1388
 8002cae:	4298      	cmp	r0, r3
 8002cb0:	d9f3      	bls.n	8002c9a <HAL_RCCEx_PeriphCLKConfig+0x386>
            return HAL_TIMEOUT;
 8002cb2:	2003      	movs	r0, #3
 8002cb4:	e79a      	b.n	8002bec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002cb6:	4889      	ldr	r0, [pc, #548]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002cb8:	6882      	ldr	r2, [r0, #8]
 8002cba:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8002cbe:	4989      	ldr	r1, [pc, #548]	; (8002ee4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8002cc0:	4019      	ands	r1, r3
 8002cc2:	430a      	orrs	r2, r1
 8002cc4:	6082      	str	r2, [r0, #8]
 8002cc6:	e7dd      	b.n	8002c84 <HAL_RCCEx_PeriphCLKConfig+0x370>
      pllsaiused = 1;
 8002cc8:	2501      	movs	r5, #1
 8002cca:	e73c      	b.n	8002b46 <HAL_RCCEx_PeriphCLKConfig+0x232>
    __HAL_RCC_PLLI2S_DISABLE();
 8002ccc:	4a83      	ldr	r2, [pc, #524]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002cce:	6813      	ldr	r3, [r2, #0]
 8002cd0:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8002cd4:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002cd6:	f7fe fc39 	bl	800154c <HAL_GetTick>
 8002cda:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002cdc:	4b7f      	ldr	r3, [pc, #508]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002cde:	681b      	ldr	r3, [r3, #0]
 8002ce0:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8002ce4:	d006      	beq.n	8002cf4 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8002ce6:	f7fe fc31 	bl	800154c <HAL_GetTick>
 8002cea:	1b80      	subs	r0, r0, r6
 8002cec:	2864      	cmp	r0, #100	; 0x64
 8002cee:	d9f5      	bls.n	8002cdc <HAL_RCCEx_PeriphCLKConfig+0x3c8>
        return HAL_TIMEOUT;
 8002cf0:	2003      	movs	r0, #3
 8002cf2:	e77b      	b.n	8002bec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8002cf4:	6823      	ldr	r3, [r4, #0]
 8002cf6:	f013 0f01 	tst.w	r3, #1
 8002cfa:	d013      	beq.n	8002d24 <HAL_RCCEx_PeriphCLKConfig+0x410>
 8002cfc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002cfe:	b98b      	cbnz	r3, 8002d24 <HAL_RCCEx_PeriphCLKConfig+0x410>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8002d00:	4a76      	ldr	r2, [pc, #472]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002d02:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8002d06:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8002d0a:	6860      	ldr	r0, [r4, #4]
 8002d0c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002d10:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8002d14:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8002d18:	430b      	orrs	r3, r1
 8002d1a:	68a1      	ldr	r1, [r4, #8]
 8002d1c:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8002d20:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8002d24:	6823      	ldr	r3, [r4, #0]
 8002d26:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8002d2a:	d003      	beq.n	8002d34 <HAL_RCCEx_PeriphCLKConfig+0x420>
 8002d2c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8002d2e:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8002d32:	d006      	beq.n	8002d42 <HAL_RCCEx_PeriphCLKConfig+0x42e>
 8002d34:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8002d38:	d01e      	beq.n	8002d78 <HAL_RCCEx_PeriphCLKConfig+0x464>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8002d3a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002d3c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8002d40:	d11a      	bne.n	8002d78 <HAL_RCCEx_PeriphCLKConfig+0x464>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8002d42:	4a66      	ldr	r2, [pc, #408]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002d44:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8002d48:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8002d4c:	6860      	ldr	r0, [r4, #4]
 8002d4e:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002d52:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8002d56:	68e0      	ldr	r0, [r4, #12]
 8002d58:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8002d5c:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 8002d60:	430b      	orrs	r3, r1
 8002d62:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8002d66:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002d6a:	f023 031f 	bic.w	r3, r3, #31
 8002d6e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002d70:	3901      	subs	r1, #1
 8002d72:	430b      	orrs	r3, r1
 8002d74:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8002d78:	6823      	ldr	r3, [r4, #0]
 8002d7a:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8002d7e:	d011      	beq.n	8002da4 <HAL_RCCEx_PeriphCLKConfig+0x490>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8002d80:	4a56      	ldr	r2, [pc, #344]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002d82:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8002d86:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8002d8a:	6866      	ldr	r6, [r4, #4]
 8002d8c:	6923      	ldr	r3, [r4, #16]
 8002d8e:	041b      	lsls	r3, r3, #16
 8002d90:	ea43 1386 	orr.w	r3, r3, r6, lsl #6
 8002d94:	f000 6070 	and.w	r0, r0, #251658240	; 0xf000000
 8002d98:	4303      	orrs	r3, r0
 8002d9a:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 8002d9e:	430b      	orrs	r3, r1
 8002da0:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8002da4:	6823      	ldr	r3, [r4, #0]
 8002da6:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002daa:	d00d      	beq.n	8002dc8 <HAL_RCCEx_PeriphCLKConfig+0x4b4>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8002dac:	6862      	ldr	r2, [r4, #4]
 8002dae:	6923      	ldr	r3, [r4, #16]
 8002db0:	041b      	lsls	r3, r3, #16
 8002db2:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8002db6:	68e2      	ldr	r2, [r4, #12]
 8002db8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8002dbc:	68a2      	ldr	r2, [r4, #8]
 8002dbe:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8002dc2:	4a46      	ldr	r2, [pc, #280]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002dc4:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8002dc8:	4a44      	ldr	r2, [pc, #272]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002dca:	6813      	ldr	r3, [r2, #0]
 8002dcc:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8002dd0:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002dd2:	f7fe fbbb 	bl	800154c <HAL_GetTick>
 8002dd6:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8002dd8:	4b40      	ldr	r3, [pc, #256]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002dda:	681b      	ldr	r3, [r3, #0]
 8002ddc:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8002de0:	f47f af00 	bne.w	8002be4 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8002de4:	f7fe fbb2 	bl	800154c <HAL_GetTick>
 8002de8:	1b80      	subs	r0, r0, r6
 8002dea:	2864      	cmp	r0, #100	; 0x64
 8002dec:	d9f4      	bls.n	8002dd8 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
        return HAL_TIMEOUT;
 8002dee:	2003      	movs	r0, #3
 8002df0:	e6fc      	b.n	8002bec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
    __HAL_RCC_PLLSAI_DISABLE();
 8002df2:	4a3a      	ldr	r2, [pc, #232]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002df4:	6813      	ldr	r3, [r2, #0]
 8002df6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002dfa:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002dfc:	f7fe fba6 	bl	800154c <HAL_GetTick>
 8002e00:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8002e02:	4b36      	ldr	r3, [pc, #216]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002e04:	681b      	ldr	r3, [r3, #0]
 8002e06:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 8002e0a:	d006      	beq.n	8002e1a <HAL_RCCEx_PeriphCLKConfig+0x506>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8002e0c:	f7fe fb9e 	bl	800154c <HAL_GetTick>
 8002e10:	1b40      	subs	r0, r0, r5
 8002e12:	2864      	cmp	r0, #100	; 0x64
 8002e14:	d9f5      	bls.n	8002e02 <HAL_RCCEx_PeriphCLKConfig+0x4ee>
        return HAL_TIMEOUT;
 8002e16:	2003      	movs	r0, #3
 8002e18:	e6e8      	b.n	8002bec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8002e1a:	6823      	ldr	r3, [r4, #0]
 8002e1c:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8002e20:	d001      	beq.n	8002e26 <HAL_RCCEx_PeriphCLKConfig+0x512>
 8002e22:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8002e24:	b122      	cbz	r2, 8002e30 <HAL_RCCEx_PeriphCLKConfig+0x51c>
 8002e26:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8002e2a:	d01d      	beq.n	8002e68 <HAL_RCCEx_PeriphCLKConfig+0x554>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 8002e2c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002e2e:	b9db      	cbnz	r3, 8002e68 <HAL_RCCEx_PeriphCLKConfig+0x554>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8002e30:	4a2a      	ldr	r2, [pc, #168]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002e32:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8002e36:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8002e3a:	6960      	ldr	r0, [r4, #20]
 8002e3c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002e40:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8002e44:	69a0      	ldr	r0, [r4, #24]
 8002e46:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8002e4a:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 8002e4e:	430b      	orrs	r3, r1
 8002e50:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8002e54:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002e58:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8002e5c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8002e5e:	3901      	subs	r1, #1
 8002e60:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8002e64:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8002e68:	6823      	ldr	r3, [r4, #0]
 8002e6a:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8002e6e:	d003      	beq.n	8002e78 <HAL_RCCEx_PeriphCLKConfig+0x564>
 8002e70:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8002e72:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8002e76:	d037      	beq.n	8002ee8 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8002e78:	6823      	ldr	r3, [r4, #0]
 8002e7a:	f013 0f08 	tst.w	r3, #8
 8002e7e:	d019      	beq.n	8002eb4 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002e80:	4a16      	ldr	r2, [pc, #88]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002e82:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8002e86:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8002e8a:	6960      	ldr	r0, [r4, #20]
 8002e8c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002e90:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8002e94:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8002e98:	430b      	orrs	r3, r1
 8002e9a:	69e1      	ldr	r1, [r4, #28]
 8002e9c:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8002ea0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8002ea4:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002ea8:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8002eac:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8002eae:	430b      	orrs	r3, r1
 8002eb0:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 8002eb4:	4a09      	ldr	r2, [pc, #36]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002eb6:	6813      	ldr	r3, [r2, #0]
 8002eb8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002ebc:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002ebe:	f7fe fb45 	bl	800154c <HAL_GetTick>
 8002ec2:	4604      	mov	r4, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8002ec4:	4b05      	ldr	r3, [pc, #20]	; (8002edc <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8002ec6:	681b      	ldr	r3, [r3, #0]
 8002ec8:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 8002ecc:	d11f      	bne.n	8002f0e <HAL_RCCEx_PeriphCLKConfig+0x5fa>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8002ece:	f7fe fb3d 	bl	800154c <HAL_GetTick>
 8002ed2:	1b00      	subs	r0, r0, r4
 8002ed4:	2864      	cmp	r0, #100	; 0x64
 8002ed6:	d9f5      	bls.n	8002ec4 <HAL_RCCEx_PeriphCLKConfig+0x5b0>
        return HAL_TIMEOUT;
 8002ed8:	2003      	movs	r0, #3
 8002eda:	e687      	b.n	8002bec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
 8002edc:	40023800 	.word	0x40023800
 8002ee0:	40007000 	.word	0x40007000
 8002ee4:	0ffffcff 	.word	0x0ffffcff
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002ee8:	4a0a      	ldr	r2, [pc, #40]	; (8002f14 <HAL_RCCEx_PeriphCLKConfig+0x600>)
 8002eea:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8002eee:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8002ef2:	6965      	ldr	r5, [r4, #20]
 8002ef4:	6a23      	ldr	r3, [r4, #32]
 8002ef6:	041b      	lsls	r3, r3, #16
 8002ef8:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 8002efc:	f000 6070 	and.w	r0, r0, #251658240	; 0xf000000
 8002f00:	4303      	orrs	r3, r0
 8002f02:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 8002f06:	430b      	orrs	r3, r1
 8002f08:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 8002f0c:	e7b4      	b.n	8002e78 <HAL_RCCEx_PeriphCLKConfig+0x564>
  return HAL_OK;
 8002f0e:	2000      	movs	r0, #0
 8002f10:	e66c      	b.n	8002bec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
 8002f12:	bf00      	nop
 8002f14:	40023800 	.word	0x40023800

08002f18 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8002f18:	4770      	bx	lr
	...

08002f1c <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002f1c:	6802      	ldr	r2, [r0, #0]
 8002f1e:	68d3      	ldr	r3, [r2, #12]
 8002f20:	f043 0301 	orr.w	r3, r3, #1
 8002f24:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002f26:	6802      	ldr	r2, [r0, #0]
 8002f28:	6891      	ldr	r1, [r2, #8]
 8002f2a:	4b06      	ldr	r3, [pc, #24]	; (8002f44 <HAL_TIM_Base_Start_IT+0x28>)
 8002f2c:	400b      	ands	r3, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8002f2e:	2b06      	cmp	r3, #6
 8002f30:	bf18      	it	ne
 8002f32:	f5b3 3f80 	cmpne.w	r3, #65536	; 0x10000
 8002f36:	d003      	beq.n	8002f40 <HAL_TIM_Base_Start_IT+0x24>
  {
    __HAL_TIM_ENABLE(htim);
 8002f38:	6813      	ldr	r3, [r2, #0]
 8002f3a:	f043 0301 	orr.w	r3, r3, #1
 8002f3e:	6013      	str	r3, [r2, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8002f40:	2000      	movs	r0, #0
 8002f42:	4770      	bx	lr
 8002f44:	00010007 	.word	0x00010007

08002f48 <HAL_TIM_OC_DelayElapsedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8002f48:	4770      	bx	lr

08002f4a <HAL_TIM_IC_CaptureCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8002f4a:	4770      	bx	lr

08002f4c <HAL_TIM_PWM_PulseFinishedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8002f4c:	4770      	bx	lr

08002f4e <HAL_TIM_TriggerCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8002f4e:	4770      	bx	lr

08002f50 <HAL_TIM_IRQHandler>:
{
 8002f50:	b510      	push	{r4, lr}
 8002f52:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002f54:	6803      	ldr	r3, [r0, #0]
 8002f56:	691a      	ldr	r2, [r3, #16]
 8002f58:	f012 0f02 	tst.w	r2, #2
 8002f5c:	d011      	beq.n	8002f82 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8002f5e:	68da      	ldr	r2, [r3, #12]
 8002f60:	f012 0f02 	tst.w	r2, #2
 8002f64:	d00d      	beq.n	8002f82 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8002f66:	f06f 0202 	mvn.w	r2, #2
 8002f6a:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002f6c:	2301      	movs	r3, #1
 8002f6e:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002f70:	6803      	ldr	r3, [r0, #0]
 8002f72:	699b      	ldr	r3, [r3, #24]
 8002f74:	f013 0f03 	tst.w	r3, #3
 8002f78:	d079      	beq.n	800306e <HAL_TIM_IRQHandler+0x11e>
          HAL_TIM_IC_CaptureCallback(htim);
 8002f7a:	f7ff ffe6 	bl	8002f4a <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002f7e:	2300      	movs	r3, #0
 8002f80:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8002f82:	6823      	ldr	r3, [r4, #0]
 8002f84:	691a      	ldr	r2, [r3, #16]
 8002f86:	f012 0f04 	tst.w	r2, #4
 8002f8a:	d012      	beq.n	8002fb2 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8002f8c:	68da      	ldr	r2, [r3, #12]
 8002f8e:	f012 0f04 	tst.w	r2, #4
 8002f92:	d00e      	beq.n	8002fb2 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8002f94:	f06f 0204 	mvn.w	r2, #4
 8002f98:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8002f9a:	2302      	movs	r3, #2
 8002f9c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002f9e:	6823      	ldr	r3, [r4, #0]
 8002fa0:	699b      	ldr	r3, [r3, #24]
 8002fa2:	f413 7f40 	tst.w	r3, #768	; 0x300
 8002fa6:	d068      	beq.n	800307a <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8002fa8:	4620      	mov	r0, r4
 8002faa:	f7ff ffce 	bl	8002f4a <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002fae:	2300      	movs	r3, #0
 8002fb0:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8002fb2:	6823      	ldr	r3, [r4, #0]
 8002fb4:	691a      	ldr	r2, [r3, #16]
 8002fb6:	f012 0f08 	tst.w	r2, #8
 8002fba:	d012      	beq.n	8002fe2 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8002fbc:	68da      	ldr	r2, [r3, #12]
 8002fbe:	f012 0f08 	tst.w	r2, #8
 8002fc2:	d00e      	beq.n	8002fe2 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002fc4:	f06f 0208 	mvn.w	r2, #8
 8002fc8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002fca:	2304      	movs	r3, #4
 8002fcc:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002fce:	6823      	ldr	r3, [r4, #0]
 8002fd0:	69db      	ldr	r3, [r3, #28]
 8002fd2:	f013 0f03 	tst.w	r3, #3
 8002fd6:	d057      	beq.n	8003088 <HAL_TIM_IRQHandler+0x138>
        HAL_TIM_IC_CaptureCallback(htim);
 8002fd8:	4620      	mov	r0, r4
 8002fda:	f7ff ffb6 	bl	8002f4a <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002fde:	2300      	movs	r3, #0
 8002fe0:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8002fe2:	6823      	ldr	r3, [r4, #0]
 8002fe4:	691a      	ldr	r2, [r3, #16]
 8002fe6:	f012 0f10 	tst.w	r2, #16
 8002fea:	d012      	beq.n	8003012 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8002fec:	68da      	ldr	r2, [r3, #12]
 8002fee:	f012 0f10 	tst.w	r2, #16
 8002ff2:	d00e      	beq.n	8003012 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8002ff4:	f06f 0210 	mvn.w	r2, #16
 8002ff8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002ffa:	2308      	movs	r3, #8
 8002ffc:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002ffe:	6823      	ldr	r3, [r4, #0]
 8003000:	69db      	ldr	r3, [r3, #28]
 8003002:	f413 7f40 	tst.w	r3, #768	; 0x300
 8003006:	d046      	beq.n	8003096 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8003008:	4620      	mov	r0, r4
 800300a:	f7ff ff9e 	bl	8002f4a <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800300e:	2300      	movs	r3, #0
 8003010:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8003012:	6823      	ldr	r3, [r4, #0]
 8003014:	691a      	ldr	r2, [r3, #16]
 8003016:	f012 0f01 	tst.w	r2, #1
 800301a:	d003      	beq.n	8003024 <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800301c:	68da      	ldr	r2, [r3, #12]
 800301e:	f012 0f01 	tst.w	r2, #1
 8003022:	d13f      	bne.n	80030a4 <HAL_TIM_IRQHandler+0x154>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8003024:	6823      	ldr	r3, [r4, #0]
 8003026:	691a      	ldr	r2, [r3, #16]
 8003028:	f012 0f80 	tst.w	r2, #128	; 0x80
 800302c:	d003      	beq.n	8003036 <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800302e:	68da      	ldr	r2, [r3, #12]
 8003030:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003034:	d13d      	bne.n	80030b2 <HAL_TIM_IRQHandler+0x162>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8003036:	6823      	ldr	r3, [r4, #0]
 8003038:	691a      	ldr	r2, [r3, #16]
 800303a:	f412 7f80 	tst.w	r2, #256	; 0x100
 800303e:	d003      	beq.n	8003048 <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8003040:	68da      	ldr	r2, [r3, #12]
 8003042:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003046:	d13b      	bne.n	80030c0 <HAL_TIM_IRQHandler+0x170>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8003048:	6823      	ldr	r3, [r4, #0]
 800304a:	691a      	ldr	r2, [r3, #16]
 800304c:	f012 0f40 	tst.w	r2, #64	; 0x40
 8003050:	d003      	beq.n	800305a <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8003052:	68da      	ldr	r2, [r3, #12]
 8003054:	f012 0f40 	tst.w	r2, #64	; 0x40
 8003058:	d139      	bne.n	80030ce <HAL_TIM_IRQHandler+0x17e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800305a:	6823      	ldr	r3, [r4, #0]
 800305c:	691a      	ldr	r2, [r3, #16]
 800305e:	f012 0f20 	tst.w	r2, #32
 8003062:	d003      	beq.n	800306c <HAL_TIM_IRQHandler+0x11c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8003064:	68da      	ldr	r2, [r3, #12]
 8003066:	f012 0f20 	tst.w	r2, #32
 800306a:	d137      	bne.n	80030dc <HAL_TIM_IRQHandler+0x18c>
}
 800306c:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800306e:	f7ff ff6b 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003072:	4620      	mov	r0, r4
 8003074:	f7ff ff6a 	bl	8002f4c <HAL_TIM_PWM_PulseFinishedCallback>
 8003078:	e781      	b.n	8002f7e <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800307a:	4620      	mov	r0, r4
 800307c:	f7ff ff64 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003080:	4620      	mov	r0, r4
 8003082:	f7ff ff63 	bl	8002f4c <HAL_TIM_PWM_PulseFinishedCallback>
 8003086:	e792      	b.n	8002fae <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003088:	4620      	mov	r0, r4
 800308a:	f7ff ff5d 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800308e:	4620      	mov	r0, r4
 8003090:	f7ff ff5c 	bl	8002f4c <HAL_TIM_PWM_PulseFinishedCallback>
 8003094:	e7a3      	b.n	8002fde <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003096:	4620      	mov	r0, r4
 8003098:	f7ff ff56 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800309c:	4620      	mov	r0, r4
 800309e:	f7ff ff55 	bl	8002f4c <HAL_TIM_PWM_PulseFinishedCallback>
 80030a2:	e7b4      	b.n	800300e <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 80030a4:	f06f 0201 	mvn.w	r2, #1
 80030a8:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80030aa:	4620      	mov	r0, r4
 80030ac:	f006 fffe 	bl	800a0ac <HAL_TIM_PeriodElapsedCallback>
 80030b0:	e7b8      	b.n	8003024 <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80030b2:	f06f 0280 	mvn.w	r2, #128	; 0x80
 80030b6:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80030b8:	4620      	mov	r0, r4
 80030ba:	f000 f8b7 	bl	800322c <HAL_TIMEx_BreakCallback>
 80030be:	e7ba      	b.n	8003036 <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80030c0:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80030c4:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 80030c6:	4620      	mov	r0, r4
 80030c8:	f000 f8b1 	bl	800322e <HAL_TIMEx_Break2Callback>
 80030cc:	e7bc      	b.n	8003048 <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80030ce:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80030d2:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80030d4:	4620      	mov	r0, r4
 80030d6:	f7ff ff3a 	bl	8002f4e <HAL_TIM_TriggerCallback>
 80030da:	e7be      	b.n	800305a <HAL_TIM_IRQHandler+0x10a>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80030dc:	f06f 0220 	mvn.w	r2, #32
 80030e0:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 80030e2:	4620      	mov	r0, r4
 80030e4:	f000 f8a1 	bl	800322a <HAL_TIMEx_CommutCallback>
}
 80030e8:	e7c0      	b.n	800306c <HAL_TIM_IRQHandler+0x11c>
	...

080030ec <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 80030ec:	b470      	push	{r4, r5, r6}
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 80030ee:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80030f0:	4c3a      	ldr	r4, [pc, #232]	; (80031dc <TIM_Base_SetConfig+0xf0>)
 80030f2:	42a0      	cmp	r0, r4
 80030f4:	bf14      	ite	ne
 80030f6:	2400      	movne	r4, #0
 80030f8:	2401      	moveq	r4, #1
 80030fa:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80030fe:	bf14      	ite	ne
 8003100:	4622      	movne	r2, r4
 8003102:	f044 0201 	orreq.w	r2, r4, #1
 8003106:	b9aa      	cbnz	r2, 8003134 <TIM_Base_SetConfig+0x48>
 8003108:	4d35      	ldr	r5, [pc, #212]	; (80031e0 <TIM_Base_SetConfig+0xf4>)
 800310a:	42a8      	cmp	r0, r5
 800310c:	bf14      	ite	ne
 800310e:	2500      	movne	r5, #0
 8003110:	2501      	moveq	r5, #1
 8003112:	4e34      	ldr	r6, [pc, #208]	; (80031e4 <TIM_Base_SetConfig+0xf8>)
 8003114:	42b0      	cmp	r0, r6
 8003116:	d00d      	beq.n	8003134 <TIM_Base_SetConfig+0x48>
 8003118:	b965      	cbnz	r5, 8003134 <TIM_Base_SetConfig+0x48>
 800311a:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 800311e:	f505 3582 	add.w	r5, r5, #66560	; 0x10400
 8003122:	42a8      	cmp	r0, r5
 8003124:	bf14      	ite	ne
 8003126:	2500      	movne	r5, #0
 8003128:	2501      	moveq	r5, #1
 800312a:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 800312e:	42b0      	cmp	r0, r6
 8003130:	d000      	beq.n	8003134 <TIM_Base_SetConfig+0x48>
 8003132:	b11d      	cbz	r5, 800313c <TIM_Base_SetConfig+0x50>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8003134:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8003138:	684d      	ldr	r5, [r1, #4]
 800313a:	432b      	orrs	r3, r5
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800313c:	2a00      	cmp	r2, #0
 800313e:	d133      	bne.n	80031a8 <TIM_Base_SetConfig+0xbc>
 8003140:	4a27      	ldr	r2, [pc, #156]	; (80031e0 <TIM_Base_SetConfig+0xf4>)
 8003142:	4290      	cmp	r0, r2
 8003144:	bf14      	ite	ne
 8003146:	2200      	movne	r2, #0
 8003148:	2201      	moveq	r2, #1
 800314a:	4d26      	ldr	r5, [pc, #152]	; (80031e4 <TIM_Base_SetConfig+0xf8>)
 800314c:	42a8      	cmp	r0, r5
 800314e:	d02b      	beq.n	80031a8 <TIM_Base_SetConfig+0xbc>
 8003150:	bb52      	cbnz	r2, 80031a8 <TIM_Base_SetConfig+0xbc>
 8003152:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8003156:	f502 3282 	add.w	r2, r2, #66560	; 0x10400
 800315a:	4290      	cmp	r0, r2
 800315c:	bf14      	ite	ne
 800315e:	2200      	movne	r2, #0
 8003160:	2201      	moveq	r2, #1
 8003162:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8003166:	42a8      	cmp	r0, r5
 8003168:	d01e      	beq.n	80031a8 <TIM_Base_SetConfig+0xbc>
 800316a:	b9ea      	cbnz	r2, 80031a8 <TIM_Base_SetConfig+0xbc>
 800316c:	4a1e      	ldr	r2, [pc, #120]	; (80031e8 <TIM_Base_SetConfig+0xfc>)
 800316e:	4290      	cmp	r0, r2
 8003170:	bf14      	ite	ne
 8003172:	2200      	movne	r2, #0
 8003174:	2201      	moveq	r2, #1
 8003176:	f505 359a 	add.w	r5, r5, #78848	; 0x13400
 800317a:	42a8      	cmp	r0, r5
 800317c:	d014      	beq.n	80031a8 <TIM_Base_SetConfig+0xbc>
 800317e:	b99a      	cbnz	r2, 80031a8 <TIM_Base_SetConfig+0xbc>
 8003180:	4a1a      	ldr	r2, [pc, #104]	; (80031ec <TIM_Base_SetConfig+0x100>)
 8003182:	4290      	cmp	r0, r2
 8003184:	bf14      	ite	ne
 8003186:	2200      	movne	r2, #0
 8003188:	2201      	moveq	r2, #1
 800318a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800318e:	42a8      	cmp	r0, r5
 8003190:	d00a      	beq.n	80031a8 <TIM_Base_SetConfig+0xbc>
 8003192:	b94a      	cbnz	r2, 80031a8 <TIM_Base_SetConfig+0xbc>
 8003194:	4a16      	ldr	r2, [pc, #88]	; (80031f0 <TIM_Base_SetConfig+0x104>)
 8003196:	4290      	cmp	r0, r2
 8003198:	bf14      	ite	ne
 800319a:	2200      	movne	r2, #0
 800319c:	2201      	moveq	r2, #1
 800319e:	f5a5 3596 	sub.w	r5, r5, #76800	; 0x12c00
 80031a2:	42a8      	cmp	r0, r5
 80031a4:	d000      	beq.n	80031a8 <TIM_Base_SetConfig+0xbc>
 80031a6:	b11a      	cbz	r2, 80031b0 <TIM_Base_SetConfig+0xc4>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80031a8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80031ac:	68ca      	ldr	r2, [r1, #12]
 80031ae:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80031b0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80031b4:	694a      	ldr	r2, [r1, #20]
 80031b6:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 80031b8:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80031ba:	688a      	ldr	r2, [r1, #8]
 80031bc:	62c2      	str	r2, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 80031be:	680a      	ldr	r2, [r1, #0]
 80031c0:	6282      	str	r2, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80031c2:	4b0c      	ldr	r3, [pc, #48]	; (80031f4 <TIM_Base_SetConfig+0x108>)
 80031c4:	4298      	cmp	r0, r3
 80031c6:	bf14      	ite	ne
 80031c8:	4623      	movne	r3, r4
 80031ca:	f044 0301 	orreq.w	r3, r4, #1
 80031ce:	b10b      	cbz	r3, 80031d4 <TIM_Base_SetConfig+0xe8>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 80031d0:	690b      	ldr	r3, [r1, #16]
 80031d2:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80031d4:	2301      	movs	r3, #1
 80031d6:	6143      	str	r3, [r0, #20]
}
 80031d8:	bc70      	pop	{r4, r5, r6}
 80031da:	4770      	bx	lr
 80031dc:	40010000 	.word	0x40010000
 80031e0:	40000800 	.word	0x40000800
 80031e4:	40000400 	.word	0x40000400
 80031e8:	40014400 	.word	0x40014400
 80031ec:	40001800 	.word	0x40001800
 80031f0:	40002000 	.word	0x40002000
 80031f4:	40010400 	.word	0x40010400

080031f8 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 80031f8:	b1a8      	cbz	r0, 8003226 <HAL_TIM_Base_Init+0x2e>
{
 80031fa:	b510      	push	{r4, lr}
 80031fc:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 80031fe:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8003202:	b15b      	cbz	r3, 800321c <HAL_TIM_Base_Init+0x24>
  htim->State = HAL_TIM_STATE_BUSY;
 8003204:	2302      	movs	r3, #2
 8003206:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800320a:	1d21      	adds	r1, r4, #4
 800320c:	6820      	ldr	r0, [r4, #0]
 800320e:	f7ff ff6d 	bl	80030ec <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8003212:	2301      	movs	r3, #1
 8003214:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8003218:	2000      	movs	r0, #0
}
 800321a:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 800321c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8003220:	f7ff fe7a 	bl	8002f18 <HAL_TIM_Base_MspInit>
 8003224:	e7ee      	b.n	8003204 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8003226:	2001      	movs	r0, #1
}
 8003228:	4770      	bx	lr

0800322a <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 800322a:	4770      	bx	lr

0800322c <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 800322c:	4770      	bx	lr

0800322e <HAL_TIMEx_Break2Callback>:
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 800322e:	4770      	bx	lr

08003230 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8003230:	b510      	push	{r4, lr}
 8003232:	4604      	mov	r4, r0
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8003234:	6883      	ldr	r3, [r0, #8]
 8003236:	6902      	ldr	r2, [r0, #16]
 8003238:	4313      	orrs	r3, r2
 800323a:	6942      	ldr	r2, [r0, #20]
 800323c:	4313      	orrs	r3, r2
 800323e:	69c2      	ldr	r2, [r0, #28]
 8003240:	4313      	orrs	r3, r2
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8003242:	6801      	ldr	r1, [r0, #0]
 8003244:	6808      	ldr	r0, [r1, #0]
 8003246:	4a99      	ldr	r2, [pc, #612]	; (80034ac <UART_SetConfig+0x27c>)
 8003248:	4002      	ands	r2, r0
 800324a:	4313      	orrs	r3, r2
 800324c:	600b      	str	r3, [r1, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800324e:	6822      	ldr	r2, [r4, #0]
 8003250:	6853      	ldr	r3, [r2, #4]
 8003252:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8003256:	68e1      	ldr	r1, [r4, #12]
 8003258:	430b      	orrs	r3, r1
 800325a:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800325c:	69a2      	ldr	r2, [r4, #24]

  tmpreg |= huart->Init.OneBitSampling;
 800325e:	6a23      	ldr	r3, [r4, #32]
 8003260:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8003262:	6821      	ldr	r1, [r4, #0]
 8003264:	688b      	ldr	r3, [r1, #8]
 8003266:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 800326a:	4313      	orrs	r3, r2
 800326c:	608b      	str	r3, [r1, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800326e:	6823      	ldr	r3, [r4, #0]
 8003270:	4a8f      	ldr	r2, [pc, #572]	; (80034b0 <UART_SetConfig+0x280>)
 8003272:	4293      	cmp	r3, r2
 8003274:	d018      	beq.n	80032a8 <UART_SetConfig+0x78>
 8003276:	4a8f      	ldr	r2, [pc, #572]	; (80034b4 <UART_SetConfig+0x284>)
 8003278:	4293      	cmp	r3, r2
 800327a:	d028      	beq.n	80032ce <UART_SetConfig+0x9e>
 800327c:	4a8e      	ldr	r2, [pc, #568]	; (80034b8 <UART_SetConfig+0x288>)
 800327e:	4293      	cmp	r3, r2
 8003280:	d03d      	beq.n	80032fe <UART_SetConfig+0xce>
 8003282:	4a8e      	ldr	r2, [pc, #568]	; (80034bc <UART_SetConfig+0x28c>)
 8003284:	4293      	cmp	r3, r2
 8003286:	d050      	beq.n	800332a <UART_SetConfig+0xfa>
 8003288:	4a8d      	ldr	r2, [pc, #564]	; (80034c0 <UART_SetConfig+0x290>)
 800328a:	4293      	cmp	r3, r2
 800328c:	d062      	beq.n	8003354 <UART_SetConfig+0x124>
 800328e:	4a8d      	ldr	r2, [pc, #564]	; (80034c4 <UART_SetConfig+0x294>)
 8003290:	4293      	cmp	r3, r2
 8003292:	d077      	beq.n	8003384 <UART_SetConfig+0x154>
 8003294:	4a8c      	ldr	r2, [pc, #560]	; (80034c8 <UART_SetConfig+0x298>)
 8003296:	4293      	cmp	r3, r2
 8003298:	f000 808c 	beq.w	80033b4 <UART_SetConfig+0x184>
 800329c:	4a8b      	ldr	r2, [pc, #556]	; (80034cc <UART_SetConfig+0x29c>)
 800329e:	4293      	cmp	r3, r2
 80032a0:	f000 80a0 	beq.w	80033e4 <UART_SetConfig+0x1b4>
 80032a4:	2310      	movs	r3, #16
 80032a6:	e0b6      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032a8:	4b89      	ldr	r3, [pc, #548]	; (80034d0 <UART_SetConfig+0x2a0>)
 80032aa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80032ae:	f003 0303 	and.w	r3, r3, #3
 80032b2:	2b03      	cmp	r3, #3
 80032b4:	d809      	bhi.n	80032ca <UART_SetConfig+0x9a>
 80032b6:	e8df f003 	tbb	[pc, r3]
 80032ba:	0402      	.short	0x0402
 80032bc:	06ad      	.short	0x06ad
 80032be:	2301      	movs	r3, #1
 80032c0:	e0a9      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032c2:	2304      	movs	r3, #4
 80032c4:	e0a7      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032c6:	2308      	movs	r3, #8
 80032c8:	e0a5      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032ca:	2310      	movs	r3, #16
 80032cc:	e0a3      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032ce:	4b80      	ldr	r3, [pc, #512]	; (80034d0 <UART_SetConfig+0x2a0>)
 80032d0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80032d4:	f003 030c 	and.w	r3, r3, #12
 80032d8:	2b0c      	cmp	r3, #12
 80032da:	d80e      	bhi.n	80032fa <UART_SetConfig+0xca>
 80032dc:	e8df f003 	tbb	[pc, r3]
 80032e0:	0d0d0d07 	.word	0x0d0d0d07
 80032e4:	0d0d0d09 	.word	0x0d0d0d09
 80032e8:	0d0d0da9 	.word	0x0d0d0da9
 80032ec:	0b          	.byte	0x0b
 80032ed:	00          	.byte	0x00
 80032ee:	2300      	movs	r3, #0
 80032f0:	e091      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032f2:	2304      	movs	r3, #4
 80032f4:	e08f      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032f6:	2308      	movs	r3, #8
 80032f8:	e08d      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032fa:	2310      	movs	r3, #16
 80032fc:	e08b      	b.n	8003416 <UART_SetConfig+0x1e6>
 80032fe:	4b74      	ldr	r3, [pc, #464]	; (80034d0 <UART_SetConfig+0x2a0>)
 8003300:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003304:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8003308:	2b10      	cmp	r3, #16
 800330a:	d00a      	beq.n	8003322 <UART_SetConfig+0xf2>
 800330c:	d906      	bls.n	800331c <UART_SetConfig+0xec>
 800330e:	2b20      	cmp	r3, #32
 8003310:	f000 8091 	beq.w	8003436 <UART_SetConfig+0x206>
 8003314:	2b30      	cmp	r3, #48	; 0x30
 8003316:	d106      	bne.n	8003326 <UART_SetConfig+0xf6>
 8003318:	2308      	movs	r3, #8
 800331a:	e07c      	b.n	8003416 <UART_SetConfig+0x1e6>
 800331c:	b91b      	cbnz	r3, 8003326 <UART_SetConfig+0xf6>
 800331e:	2300      	movs	r3, #0
 8003320:	e079      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003322:	2304      	movs	r3, #4
 8003324:	e077      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003326:	2310      	movs	r3, #16
 8003328:	e075      	b.n	8003416 <UART_SetConfig+0x1e6>
 800332a:	4b69      	ldr	r3, [pc, #420]	; (80034d0 <UART_SetConfig+0x2a0>)
 800332c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003330:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8003334:	2b40      	cmp	r3, #64	; 0x40
 8003336:	d009      	beq.n	800334c <UART_SetConfig+0x11c>
 8003338:	d905      	bls.n	8003346 <UART_SetConfig+0x116>
 800333a:	2b80      	cmp	r3, #128	; 0x80
 800333c:	d07d      	beq.n	800343a <UART_SetConfig+0x20a>
 800333e:	2bc0      	cmp	r3, #192	; 0xc0
 8003340:	d106      	bne.n	8003350 <UART_SetConfig+0x120>
 8003342:	2308      	movs	r3, #8
 8003344:	e067      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003346:	b91b      	cbnz	r3, 8003350 <UART_SetConfig+0x120>
 8003348:	2300      	movs	r3, #0
 800334a:	e064      	b.n	8003416 <UART_SetConfig+0x1e6>
 800334c:	2304      	movs	r3, #4
 800334e:	e062      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003350:	2310      	movs	r3, #16
 8003352:	e060      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003354:	4b5e      	ldr	r3, [pc, #376]	; (80034d0 <UART_SetConfig+0x2a0>)
 8003356:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800335a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800335e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003362:	d00b      	beq.n	800337c <UART_SetConfig+0x14c>
 8003364:	d907      	bls.n	8003376 <UART_SetConfig+0x146>
 8003366:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800336a:	d068      	beq.n	800343e <UART_SetConfig+0x20e>
 800336c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003370:	d106      	bne.n	8003380 <UART_SetConfig+0x150>
 8003372:	2308      	movs	r3, #8
 8003374:	e04f      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003376:	b91b      	cbnz	r3, 8003380 <UART_SetConfig+0x150>
 8003378:	2300      	movs	r3, #0
 800337a:	e04c      	b.n	8003416 <UART_SetConfig+0x1e6>
 800337c:	2304      	movs	r3, #4
 800337e:	e04a      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003380:	2310      	movs	r3, #16
 8003382:	e048      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003384:	4b52      	ldr	r3, [pc, #328]	; (80034d0 <UART_SetConfig+0x2a0>)
 8003386:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800338a:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800338e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003392:	d00b      	beq.n	80033ac <UART_SetConfig+0x17c>
 8003394:	d907      	bls.n	80033a6 <UART_SetConfig+0x176>
 8003396:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800339a:	d052      	beq.n	8003442 <UART_SetConfig+0x212>
 800339c:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80033a0:	d106      	bne.n	80033b0 <UART_SetConfig+0x180>
 80033a2:	2308      	movs	r3, #8
 80033a4:	e037      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033a6:	b91b      	cbnz	r3, 80033b0 <UART_SetConfig+0x180>
 80033a8:	2301      	movs	r3, #1
 80033aa:	e034      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033ac:	2304      	movs	r3, #4
 80033ae:	e032      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033b0:	2310      	movs	r3, #16
 80033b2:	e030      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033b4:	4b46      	ldr	r3, [pc, #280]	; (80034d0 <UART_SetConfig+0x2a0>)
 80033b6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80033ba:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80033be:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80033c2:	d00b      	beq.n	80033dc <UART_SetConfig+0x1ac>
 80033c4:	d907      	bls.n	80033d6 <UART_SetConfig+0x1a6>
 80033c6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80033ca:	d03c      	beq.n	8003446 <UART_SetConfig+0x216>
 80033cc:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 80033d0:	d106      	bne.n	80033e0 <UART_SetConfig+0x1b0>
 80033d2:	2308      	movs	r3, #8
 80033d4:	e01f      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033d6:	b91b      	cbnz	r3, 80033e0 <UART_SetConfig+0x1b0>
 80033d8:	2300      	movs	r3, #0
 80033da:	e01c      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033dc:	2304      	movs	r3, #4
 80033de:	e01a      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033e0:	2310      	movs	r3, #16
 80033e2:	e018      	b.n	8003416 <UART_SetConfig+0x1e6>
 80033e4:	4b3a      	ldr	r3, [pc, #232]	; (80034d0 <UART_SetConfig+0x2a0>)
 80033e6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80033ea:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 80033ee:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80033f2:	d00b      	beq.n	800340c <UART_SetConfig+0x1dc>
 80033f4:	d907      	bls.n	8003406 <UART_SetConfig+0x1d6>
 80033f6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80033fa:	d026      	beq.n	800344a <UART_SetConfig+0x21a>
 80033fc:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8003400:	d106      	bne.n	8003410 <UART_SetConfig+0x1e0>
 8003402:	2308      	movs	r3, #8
 8003404:	e007      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003406:	b91b      	cbnz	r3, 8003410 <UART_SetConfig+0x1e0>
 8003408:	2300      	movs	r3, #0
 800340a:	e004      	b.n	8003416 <UART_SetConfig+0x1e6>
 800340c:	2304      	movs	r3, #4
 800340e:	e002      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003410:	2310      	movs	r3, #16
 8003412:	e000      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003414:	2302      	movs	r3, #2

  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003416:	69e2      	ldr	r2, [r4, #28]
 8003418:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 800341c:	d017      	beq.n	800344e <UART_SetConfig+0x21e>
      ret = HAL_ERROR;
    }
  }
  else
  {
    switch (clocksource)
 800341e:	2b08      	cmp	r3, #8
 8003420:	f200 80b3 	bhi.w	800358a <UART_SetConfig+0x35a>
 8003424:	e8df f003 	tbb	[pc, r3]
 8003428:	b1958b76 	.word	0xb1958b76
 800342c:	b1b1b19e 	.word	0xb1b1b19e
 8003430:	a8          	.byte	0xa8
 8003431:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003432:	2302      	movs	r3, #2
 8003434:	e7ef      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003436:	2302      	movs	r3, #2
 8003438:	e7ed      	b.n	8003416 <UART_SetConfig+0x1e6>
 800343a:	2302      	movs	r3, #2
 800343c:	e7eb      	b.n	8003416 <UART_SetConfig+0x1e6>
 800343e:	2302      	movs	r3, #2
 8003440:	e7e9      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003442:	2302      	movs	r3, #2
 8003444:	e7e7      	b.n	8003416 <UART_SetConfig+0x1e6>
 8003446:	2302      	movs	r3, #2
 8003448:	e7e5      	b.n	8003416 <UART_SetConfig+0x1e6>
 800344a:	2302      	movs	r3, #2
 800344c:	e7e3      	b.n	8003416 <UART_SetConfig+0x1e6>
    switch (clocksource)
 800344e:	2b08      	cmp	r3, #8
 8003450:	d85d      	bhi.n	800350e <UART_SetConfig+0x2de>
 8003452:	e8df f003 	tbb	[pc, r3]
 8003456:	1f05      	.short	0x1f05
 8003458:	5c485c3f 	.word	0x5c485c3f
 800345c:	5c5c      	.short	0x5c5c
 800345e:	53          	.byte	0x53
 800345f:	00          	.byte	0x00
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8003460:	f7ff fa1a 	bl	8002898 <HAL_RCC_GetPCLK1Freq>
 8003464:	6862      	ldr	r2, [r4, #4]
 8003466:	0853      	lsrs	r3, r2, #1
 8003468:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800346c:	fbb3 f3f2 	udiv	r3, r3, r2
 8003470:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003472:	2000      	movs	r0, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8003474:	f1a3 0110 	sub.w	r1, r3, #16
 8003478:	f64f 72ef 	movw	r2, #65519	; 0xffef
 800347c:	4291      	cmp	r1, r2
 800347e:	f200 8087 	bhi.w	8003590 <UART_SetConfig+0x360>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8003482:	b29a      	uxth	r2, r3
 8003484:	f022 020f 	bic.w	r2, r2, #15
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8003488:	f3c3 0342 	ubfx	r3, r3, #1, #3
 800348c:	4313      	orrs	r3, r2
      huart->Instance->BRR = brrtemp;
 800348e:	6822      	ldr	r2, [r4, #0]
 8003490:	60d3      	str	r3, [r2, #12]
 8003492:	e050      	b.n	8003536 <UART_SetConfig+0x306>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8003494:	f7ff fa10 	bl	80028b8 <HAL_RCC_GetPCLK2Freq>
 8003498:	6862      	ldr	r2, [r4, #4]
 800349a:	0853      	lsrs	r3, r2, #1
 800349c:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80034a0:	fbb3 f3f2 	udiv	r3, r3, r2
 80034a4:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 80034a6:	2000      	movs	r0, #0
        break;
 80034a8:	e7e4      	b.n	8003474 <UART_SetConfig+0x244>
 80034aa:	bf00      	nop
 80034ac:	efff69f3 	.word	0xefff69f3
 80034b0:	40011000 	.word	0x40011000
 80034b4:	40004400 	.word	0x40004400
 80034b8:	40004800 	.word	0x40004800
 80034bc:	40004c00 	.word	0x40004c00
 80034c0:	40005000 	.word	0x40005000
 80034c4:	40011400 	.word	0x40011400
 80034c8:	40007800 	.word	0x40007800
 80034cc:	40007c00 	.word	0x40007c00
 80034d0:	40023800 	.word	0x40023800
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 80034d4:	6862      	ldr	r2, [r4, #4]
 80034d6:	4b30      	ldr	r3, [pc, #192]	; (8003598 <UART_SetConfig+0x368>)
 80034d8:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 80034dc:	fbb3 f3f2 	udiv	r3, r3, r2
 80034e0:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 80034e2:	2000      	movs	r0, #0
        break;
 80034e4:	e7c6      	b.n	8003474 <UART_SetConfig+0x244>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80034e6:	f7ff f8b3 	bl	8002650 <HAL_RCC_GetSysClockFreq>
 80034ea:	6862      	ldr	r2, [r4, #4]
 80034ec:	0853      	lsrs	r3, r2, #1
 80034ee:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80034f2:	fbb3 f3f2 	udiv	r3, r3, r2
 80034f6:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 80034f8:	2000      	movs	r0, #0
        break;
 80034fa:	e7bb      	b.n	8003474 <UART_SetConfig+0x244>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80034fc:	6862      	ldr	r2, [r4, #4]
 80034fe:	0853      	lsrs	r3, r2, #1
 8003500:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8003504:	fbb3 f3f2 	udiv	r3, r3, r2
 8003508:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 800350a:	2000      	movs	r0, #0
        break;
 800350c:	e7b2      	b.n	8003474 <UART_SetConfig+0x244>
        ret = HAL_ERROR;
 800350e:	2001      	movs	r0, #1
  uint32_t usartdiv                   = 0x00000000U;
 8003510:	2300      	movs	r3, #0
 8003512:	e7af      	b.n	8003474 <UART_SetConfig+0x244>
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8003514:	f7ff f9c0 	bl	8002898 <HAL_RCC_GetPCLK1Freq>
 8003518:	6862      	ldr	r2, [r4, #4]
 800351a:	eb00 0352 	add.w	r3, r0, r2, lsr #1
 800351e:	fbb3 f3f2 	udiv	r3, r3, r2
 8003522:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003524:	2000      	movs	r0, #0
        ret = HAL_ERROR;
        break;
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8003526:	f1a3 0110 	sub.w	r1, r3, #16
 800352a:	f64f 72ef 	movw	r2, #65519	; 0xffef
 800352e:	4291      	cmp	r1, r2
 8003530:	d830      	bhi.n	8003594 <UART_SetConfig+0x364>
    {
      huart->Instance->BRR = usartdiv;
 8003532:	6822      	ldr	r2, [r4, #0]
 8003534:	60d3      	str	r3, [r2, #12]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8003536:	2300      	movs	r3, #0
 8003538:	6623      	str	r3, [r4, #96]	; 0x60
  huart->TxISR = NULL;
 800353a:	6663      	str	r3, [r4, #100]	; 0x64

  return ret;
}
 800353c:	bd10      	pop	{r4, pc}
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800353e:	f7ff f9bb 	bl	80028b8 <HAL_RCC_GetPCLK2Freq>
 8003542:	6862      	ldr	r2, [r4, #4]
 8003544:	eb00 0352 	add.w	r3, r0, r2, lsr #1
 8003548:	fbb3 f3f2 	udiv	r3, r3, r2
 800354c:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 800354e:	2000      	movs	r0, #0
        break;
 8003550:	e7e9      	b.n	8003526 <UART_SetConfig+0x2f6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8003552:	6862      	ldr	r2, [r4, #4]
 8003554:	4b11      	ldr	r3, [pc, #68]	; (800359c <UART_SetConfig+0x36c>)
 8003556:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 800355a:	fbb3 f3f2 	udiv	r3, r3, r2
 800355e:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003560:	2000      	movs	r0, #0
        break;
 8003562:	e7e0      	b.n	8003526 <UART_SetConfig+0x2f6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8003564:	f7ff f874 	bl	8002650 <HAL_RCC_GetSysClockFreq>
 8003568:	6862      	ldr	r2, [r4, #4]
 800356a:	eb00 0352 	add.w	r3, r0, r2, lsr #1
 800356e:	fbb3 f3f2 	udiv	r3, r3, r2
 8003572:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003574:	2000      	movs	r0, #0
        break;
 8003576:	e7d6      	b.n	8003526 <UART_SetConfig+0x2f6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8003578:	6862      	ldr	r2, [r4, #4]
 800357a:	0853      	lsrs	r3, r2, #1
 800357c:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 8003580:	fbb3 f3f2 	udiv	r3, r3, r2
 8003584:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003586:	2000      	movs	r0, #0
        break;
 8003588:	e7cd      	b.n	8003526 <UART_SetConfig+0x2f6>
        ret = HAL_ERROR;
 800358a:	2001      	movs	r0, #1
  uint32_t usartdiv                   = 0x00000000U;
 800358c:	2300      	movs	r3, #0
 800358e:	e7ca      	b.n	8003526 <UART_SetConfig+0x2f6>
      ret = HAL_ERROR;
 8003590:	2001      	movs	r0, #1
 8003592:	e7d0      	b.n	8003536 <UART_SetConfig+0x306>
      ret = HAL_ERROR;
 8003594:	2001      	movs	r0, #1
 8003596:	e7ce      	b.n	8003536 <UART_SetConfig+0x306>
 8003598:	01e84800 	.word	0x01e84800
 800359c:	00f42400 	.word	0x00f42400

080035a0 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80035a0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80035a2:	f013 0f01 	tst.w	r3, #1
 80035a6:	d006      	beq.n	80035b6 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80035a8:	6802      	ldr	r2, [r0, #0]
 80035aa:	6853      	ldr	r3, [r2, #4]
 80035ac:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80035b0:	6a81      	ldr	r1, [r0, #40]	; 0x28
 80035b2:	430b      	orrs	r3, r1
 80035b4:	6053      	str	r3, [r2, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80035b6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80035b8:	f013 0f02 	tst.w	r3, #2
 80035bc:	d006      	beq.n	80035cc <UART_AdvFeatureConfig+0x2c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80035be:	6802      	ldr	r2, [r0, #0]
 80035c0:	6853      	ldr	r3, [r2, #4]
 80035c2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80035c6:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80035c8:	430b      	orrs	r3, r1
 80035ca:	6053      	str	r3, [r2, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80035cc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80035ce:	f013 0f04 	tst.w	r3, #4
 80035d2:	d006      	beq.n	80035e2 <UART_AdvFeatureConfig+0x42>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80035d4:	6802      	ldr	r2, [r0, #0]
 80035d6:	6853      	ldr	r3, [r2, #4]
 80035d8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80035dc:	6b01      	ldr	r1, [r0, #48]	; 0x30
 80035de:	430b      	orrs	r3, r1
 80035e0:	6053      	str	r3, [r2, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80035e2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80035e4:	f013 0f08 	tst.w	r3, #8
 80035e8:	d006      	beq.n	80035f8 <UART_AdvFeatureConfig+0x58>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80035ea:	6802      	ldr	r2, [r0, #0]
 80035ec:	6853      	ldr	r3, [r2, #4]
 80035ee:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80035f2:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80035f4:	430b      	orrs	r3, r1
 80035f6:	6053      	str	r3, [r2, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80035f8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80035fa:	f013 0f10 	tst.w	r3, #16
 80035fe:	d006      	beq.n	800360e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8003600:	6802      	ldr	r2, [r0, #0]
 8003602:	6893      	ldr	r3, [r2, #8]
 8003604:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003608:	6b81      	ldr	r1, [r0, #56]	; 0x38
 800360a:	430b      	orrs	r3, r1
 800360c:	6093      	str	r3, [r2, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800360e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003610:	f013 0f20 	tst.w	r3, #32
 8003614:	d006      	beq.n	8003624 <UART_AdvFeatureConfig+0x84>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8003616:	6802      	ldr	r2, [r0, #0]
 8003618:	6893      	ldr	r3, [r2, #8]
 800361a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800361e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8003620:	430b      	orrs	r3, r1
 8003622:	6093      	str	r3, [r2, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8003624:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003626:	f013 0f40 	tst.w	r3, #64	; 0x40
 800362a:	d00a      	beq.n	8003642 <UART_AdvFeatureConfig+0xa2>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800362c:	6802      	ldr	r2, [r0, #0]
 800362e:	6853      	ldr	r3, [r2, #4]
 8003630:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8003634:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8003636:	430b      	orrs	r3, r1
 8003638:	6053      	str	r3, [r2, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800363a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800363c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8003640:	d00b      	beq.n	800365a <UART_AdvFeatureConfig+0xba>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8003642:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003644:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003648:	d006      	beq.n	8003658 <UART_AdvFeatureConfig+0xb8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800364a:	6802      	ldr	r2, [r0, #0]
 800364c:	6853      	ldr	r3, [r2, #4]
 800364e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003652:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8003654:	430b      	orrs	r3, r1
 8003656:	6053      	str	r3, [r2, #4]
  }
}
 8003658:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800365a:	6802      	ldr	r2, [r0, #0]
 800365c:	6853      	ldr	r3, [r2, #4]
 800365e:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 8003662:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8003664:	430b      	orrs	r3, r1
 8003666:	6053      	str	r3, [r2, #4]
 8003668:	e7eb      	b.n	8003642 <UART_AdvFeatureConfig+0xa2>

0800366a <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 800366a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800366e:	4605      	mov	r5, r0
 8003670:	460f      	mov	r7, r1
 8003672:	4616      	mov	r6, r2
 8003674:	4698      	mov	r8, r3
 8003676:	9c06      	ldr	r4, [sp, #24]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8003678:	682b      	ldr	r3, [r5, #0]
 800367a:	69db      	ldr	r3, [r3, #28]
 800367c:	ea37 0303 	bics.w	r3, r7, r3
 8003680:	bf0c      	ite	eq
 8003682:	2301      	moveq	r3, #1
 8003684:	2300      	movne	r3, #0
 8003686:	42b3      	cmp	r3, r6
 8003688:	d11c      	bne.n	80036c4 <UART_WaitOnFlagUntilTimeout+0x5a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800368a:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 800368e:	d0f3      	beq.n	8003678 <UART_WaitOnFlagUntilTimeout+0xe>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003690:	f7fd ff5c 	bl	800154c <HAL_GetTick>
 8003694:	eba0 0008 	sub.w	r0, r0, r8
 8003698:	42a0      	cmp	r0, r4
 800369a:	d801      	bhi.n	80036a0 <UART_WaitOnFlagUntilTimeout+0x36>
 800369c:	2c00      	cmp	r4, #0
 800369e:	d1eb      	bne.n	8003678 <UART_WaitOnFlagUntilTimeout+0xe>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80036a0:	682a      	ldr	r2, [r5, #0]
 80036a2:	6813      	ldr	r3, [r2, #0]
 80036a4:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 80036a8:	6013      	str	r3, [r2, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80036aa:	682a      	ldr	r2, [r5, #0]
 80036ac:	6893      	ldr	r3, [r2, #8]
 80036ae:	f023 0301 	bic.w	r3, r3, #1
 80036b2:	6093      	str	r3, [r2, #8]

        huart->gState = HAL_UART_STATE_READY;
 80036b4:	2320      	movs	r3, #32
 80036b6:	676b      	str	r3, [r5, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 80036b8:	67ab      	str	r3, [r5, #120]	; 0x78

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 80036ba:	2300      	movs	r3, #0
 80036bc:	f885 3070 	strb.w	r3, [r5, #112]	; 0x70

        return HAL_TIMEOUT;
 80036c0:	2003      	movs	r0, #3
 80036c2:	e000      	b.n	80036c6 <UART_WaitOnFlagUntilTimeout+0x5c>
      }
    }
  }
  return HAL_OK;
 80036c4:	2000      	movs	r0, #0
}
 80036c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080036ca <HAL_UART_Transmit>:
{
 80036ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80036ce:	b082      	sub	sp, #8
 80036d0:	461e      	mov	r6, r3
  if (huart->gState == HAL_UART_STATE_READY)
 80036d2:	6f43      	ldr	r3, [r0, #116]	; 0x74
 80036d4:	2b20      	cmp	r3, #32
 80036d6:	d159      	bne.n	800378c <HAL_UART_Transmit+0xc2>
 80036d8:	4604      	mov	r4, r0
 80036da:	460d      	mov	r5, r1
 80036dc:	4690      	mov	r8, r2
    if ((pData == NULL) || (Size == 0U))
 80036de:	fab2 f382 	clz	r3, r2
 80036e2:	095b      	lsrs	r3, r3, #5
 80036e4:	2900      	cmp	r1, #0
 80036e6:	bf08      	it	eq
 80036e8:	2301      	moveq	r3, #1
 80036ea:	2b00      	cmp	r3, #0
 80036ec:	d153      	bne.n	8003796 <HAL_UART_Transmit+0xcc>
    __HAL_LOCK(huart);
 80036ee:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 80036f2:	2b01      	cmp	r3, #1
 80036f4:	d051      	beq.n	800379a <HAL_UART_Transmit+0xd0>
 80036f6:	2301      	movs	r3, #1
 80036f8:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80036fc:	2300      	movs	r3, #0
 80036fe:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003700:	2321      	movs	r3, #33	; 0x21
 8003702:	6743      	str	r3, [r0, #116]	; 0x74
    tickstart = HAL_GetTick();
 8003704:	f7fd ff22 	bl	800154c <HAL_GetTick>
 8003708:	4607      	mov	r7, r0
    huart->TxXferSize  = Size;
 800370a:	f8a4 8050 	strh.w	r8, [r4, #80]	; 0x50
    huart->TxXferCount = Size;
 800370e:	f8a4 8052 	strh.w	r8, [r4, #82]	; 0x52
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003712:	68a3      	ldr	r3, [r4, #8]
 8003714:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003718:	d002      	beq.n	8003720 <HAL_UART_Transmit+0x56>
      pdata16bits = NULL;
 800371a:	f04f 0800 	mov.w	r8, #0
 800371e:	e010      	b.n	8003742 <HAL_UART_Transmit+0x78>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003720:	6923      	ldr	r3, [r4, #16]
 8003722:	b30b      	cbz	r3, 8003768 <HAL_UART_Transmit+0x9e>
      pdata16bits = NULL;
 8003724:	f04f 0800 	mov.w	r8, #0
 8003728:	e00b      	b.n	8003742 <HAL_UART_Transmit+0x78>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800372a:	f838 3b02 	ldrh.w	r3, [r8], #2
 800372e:	6822      	ldr	r2, [r4, #0]
 8003730:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003734:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 8003736:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 800373a:	3b01      	subs	r3, #1
 800373c:	b29b      	uxth	r3, r3
 800373e:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 8003742:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 8003746:	b29b      	uxth	r3, r3
 8003748:	b18b      	cbz	r3, 800376e <HAL_UART_Transmit+0xa4>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800374a:	9600      	str	r6, [sp, #0]
 800374c:	463b      	mov	r3, r7
 800374e:	2200      	movs	r2, #0
 8003750:	2180      	movs	r1, #128	; 0x80
 8003752:	4620      	mov	r0, r4
 8003754:	f7ff ff89 	bl	800366a <UART_WaitOnFlagUntilTimeout>
 8003758:	bb08      	cbnz	r0, 800379e <HAL_UART_Transmit+0xd4>
      if (pdata8bits == NULL)
 800375a:	2d00      	cmp	r5, #0
 800375c:	d0e5      	beq.n	800372a <HAL_UART_Transmit+0x60>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800375e:	f815 2b01 	ldrb.w	r2, [r5], #1
 8003762:	6823      	ldr	r3, [r4, #0]
 8003764:	629a      	str	r2, [r3, #40]	; 0x28
 8003766:	e7e6      	b.n	8003736 <HAL_UART_Transmit+0x6c>
      pdata16bits = (uint16_t *) pData;
 8003768:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 800376a:	2500      	movs	r5, #0
 800376c:	e7e9      	b.n	8003742 <HAL_UART_Transmit+0x78>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800376e:	9600      	str	r6, [sp, #0]
 8003770:	463b      	mov	r3, r7
 8003772:	2200      	movs	r2, #0
 8003774:	2140      	movs	r1, #64	; 0x40
 8003776:	4620      	mov	r0, r4
 8003778:	f7ff ff77 	bl	800366a <UART_WaitOnFlagUntilTimeout>
 800377c:	4603      	mov	r3, r0
 800377e:	b980      	cbnz	r0, 80037a2 <HAL_UART_Transmit+0xd8>
    huart->gState = HAL_UART_STATE_READY;
 8003780:	2220      	movs	r2, #32
 8003782:	6762      	str	r2, [r4, #116]	; 0x74
    __HAL_UNLOCK(huart);
 8003784:	2200      	movs	r2, #0
 8003786:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
    return HAL_OK;
 800378a:	e000      	b.n	800378e <HAL_UART_Transmit+0xc4>
    return HAL_BUSY;
 800378c:	2302      	movs	r3, #2
}
 800378e:	4618      	mov	r0, r3
 8003790:	b002      	add	sp, #8
 8003792:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 8003796:	2301      	movs	r3, #1
 8003798:	e7f9      	b.n	800378e <HAL_UART_Transmit+0xc4>
    __HAL_LOCK(huart);
 800379a:	2302      	movs	r3, #2
 800379c:	e7f7      	b.n	800378e <HAL_UART_Transmit+0xc4>
        return HAL_TIMEOUT;
 800379e:	2303      	movs	r3, #3
 80037a0:	e7f5      	b.n	800378e <HAL_UART_Transmit+0xc4>
      return HAL_TIMEOUT;
 80037a2:	2303      	movs	r3, #3
 80037a4:	e7f3      	b.n	800378e <HAL_UART_Transmit+0xc4>

080037a6 <UART_CheckIdleState>:
{
 80037a6:	b510      	push	{r4, lr}
 80037a8:	b082      	sub	sp, #8
 80037aa:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80037ac:	2300      	movs	r3, #0
 80037ae:	67c3      	str	r3, [r0, #124]	; 0x7c
  tickstart = HAL_GetTick();
 80037b0:	f7fd fecc 	bl	800154c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80037b4:	6822      	ldr	r2, [r4, #0]
 80037b6:	6812      	ldr	r2, [r2, #0]
 80037b8:	f012 0f08 	tst.w	r2, #8
 80037bc:	d107      	bne.n	80037ce <UART_CheckIdleState+0x28>
  huart->gState = HAL_UART_STATE_READY;
 80037be:	2320      	movs	r3, #32
 80037c0:	6763      	str	r3, [r4, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 80037c2:	67a3      	str	r3, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 80037c4:	2000      	movs	r0, #0
 80037c6:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
}
 80037ca:	b002      	add	sp, #8
 80037cc:	bd10      	pop	{r4, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80037ce:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80037d2:	9300      	str	r3, [sp, #0]
 80037d4:	4603      	mov	r3, r0
 80037d6:	2200      	movs	r2, #0
 80037d8:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80037dc:	4620      	mov	r0, r4
 80037de:	f7ff ff44 	bl	800366a <UART_WaitOnFlagUntilTimeout>
 80037e2:	2800      	cmp	r0, #0
 80037e4:	d0eb      	beq.n	80037be <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 80037e6:	2003      	movs	r0, #3
 80037e8:	e7ef      	b.n	80037ca <UART_CheckIdleState+0x24>

080037ea <HAL_UART_Init>:
  if (huart == NULL)
 80037ea:	b368      	cbz	r0, 8003848 <HAL_UART_Init+0x5e>
{
 80037ec:	b510      	push	{r4, lr}
 80037ee:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 80037f0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 80037f2:	b303      	cbz	r3, 8003836 <HAL_UART_Init+0x4c>
  huart->gState = HAL_UART_STATE_BUSY;
 80037f4:	2324      	movs	r3, #36	; 0x24
 80037f6:	6763      	str	r3, [r4, #116]	; 0x74
  __HAL_UART_DISABLE(huart);
 80037f8:	6822      	ldr	r2, [r4, #0]
 80037fa:	6813      	ldr	r3, [r2, #0]
 80037fc:	f023 0301 	bic.w	r3, r3, #1
 8003800:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8003802:	4620      	mov	r0, r4
 8003804:	f7ff fd14 	bl	8003230 <UART_SetConfig>
 8003808:	2801      	cmp	r0, #1
 800380a:	d013      	beq.n	8003834 <HAL_UART_Init+0x4a>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800380c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800380e:	b9bb      	cbnz	r3, 8003840 <HAL_UART_Init+0x56>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003810:	6822      	ldr	r2, [r4, #0]
 8003812:	6853      	ldr	r3, [r2, #4]
 8003814:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8003818:	6053      	str	r3, [r2, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800381a:	6822      	ldr	r2, [r4, #0]
 800381c:	6893      	ldr	r3, [r2, #8]
 800381e:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8003822:	6093      	str	r3, [r2, #8]
  __HAL_UART_ENABLE(huart);
 8003824:	6822      	ldr	r2, [r4, #0]
 8003826:	6813      	ldr	r3, [r2, #0]
 8003828:	f043 0301 	orr.w	r3, r3, #1
 800382c:	6013      	str	r3, [r2, #0]
  return (UART_CheckIdleState(huart));
 800382e:	4620      	mov	r0, r4
 8003830:	f7ff ffb9 	bl	80037a6 <UART_CheckIdleState>
}
 8003834:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 8003836:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 800383a:	f007 f953 	bl	800aae4 <HAL_UART_MspInit>
 800383e:	e7d9      	b.n	80037f4 <HAL_UART_Init+0xa>
    UART_AdvFeatureConfig(huart);
 8003840:	4620      	mov	r0, r4
 8003842:	f7ff fead 	bl	80035a0 <UART_AdvFeatureConfig>
 8003846:	e7e3      	b.n	8003810 <HAL_UART_Init+0x26>
    return HAL_ERROR;
 8003848:	2001      	movs	r0, #1
}
 800384a:	4770      	bx	lr

0800384c <USB_CoreReset>:
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;
 800384c:	2300      	movs	r3, #0

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 800384e:	3301      	adds	r3, #1
 8003850:	4a0c      	ldr	r2, [pc, #48]	; (8003884 <USB_CoreReset+0x38>)
 8003852:	4293      	cmp	r3, r2
 8003854:	d811      	bhi.n	800387a <USB_CoreReset+0x2e>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8003856:	6902      	ldr	r2, [r0, #16]
 8003858:	2a00      	cmp	r2, #0
 800385a:	daf8      	bge.n	800384e <USB_CoreReset+0x2>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800385c:	6903      	ldr	r3, [r0, #16]
 800385e:	f043 0301 	orr.w	r3, r3, #1
 8003862:	6103      	str	r3, [r0, #16]
  count = 0U;
 8003864:	2300      	movs	r3, #0

  do
  {
    if (++count > 200000U)
 8003866:	3301      	adds	r3, #1
 8003868:	4a06      	ldr	r2, [pc, #24]	; (8003884 <USB_CoreReset+0x38>)
 800386a:	4293      	cmp	r3, r2
 800386c:	d807      	bhi.n	800387e <USB_CoreReset+0x32>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800386e:	6902      	ldr	r2, [r0, #16]
 8003870:	f012 0f01 	tst.w	r2, #1
 8003874:	d1f7      	bne.n	8003866 <USB_CoreReset+0x1a>

  return HAL_OK;
 8003876:	2000      	movs	r0, #0
 8003878:	4770      	bx	lr
      return HAL_TIMEOUT;
 800387a:	2003      	movs	r0, #3
 800387c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800387e:	2003      	movs	r0, #3
}
 8003880:	4770      	bx	lr
 8003882:	bf00      	nop
 8003884:	00030d40 	.word	0x00030d40

08003888 <USB_CoreInit>:
{
 8003888:	b084      	sub	sp, #16
 800388a:	b510      	push	{r4, lr}
 800388c:	4604      	mov	r4, r0
 800388e:	a803      	add	r0, sp, #12
 8003890:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8003894:	9b08      	ldr	r3, [sp, #32]
 8003896:	2b01      	cmp	r3, #1
 8003898:	d11d      	bne.n	80038d6 <USB_CoreInit+0x4e>
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800389a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800389c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80038a0:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80038a2:	68e2      	ldr	r2, [r4, #12]
 80038a4:	4b16      	ldr	r3, [pc, #88]	; (8003900 <USB_CoreInit+0x78>)
 80038a6:	4013      	ands	r3, r2
 80038a8:	60e3      	str	r3, [r4, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80038aa:	68e3      	ldr	r3, [r4, #12]
 80038ac:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80038b0:	60e3      	str	r3, [r4, #12]
    if (cfg.use_external_vbus == 1U)
 80038b2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80038b4:	2b01      	cmp	r3, #1
 80038b6:	d009      	beq.n	80038cc <USB_CoreInit+0x44>
    ret = USB_CoreReset(USBx);
 80038b8:	4620      	mov	r0, r4
 80038ba:	f7ff ffc7 	bl	800384c <USB_CoreReset>
  if (cfg.dma_enable == 1U)
 80038be:	9b06      	ldr	r3, [sp, #24]
 80038c0:	2b01      	cmp	r3, #1
 80038c2:	d014      	beq.n	80038ee <USB_CoreInit+0x66>
}
 80038c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80038c8:	b004      	add	sp, #16
 80038ca:	4770      	bx	lr
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80038cc:	68e3      	ldr	r3, [r4, #12]
 80038ce:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80038d2:	60e3      	str	r3, [r4, #12]
 80038d4:	e7f0      	b.n	80038b8 <USB_CoreInit+0x30>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 80038d6:	68e3      	ldr	r3, [r4, #12]
 80038d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80038dc:	60e3      	str	r3, [r4, #12]
    ret = USB_CoreReset(USBx);
 80038de:	4620      	mov	r0, r4
 80038e0:	f7ff ffb4 	bl	800384c <USB_CoreReset>
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80038e4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80038e6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80038ea:	63a3      	str	r3, [r4, #56]	; 0x38
 80038ec:	e7e7      	b.n	80038be <USB_CoreInit+0x36>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 80038ee:	68a3      	ldr	r3, [r4, #8]
 80038f0:	f043 0306 	orr.w	r3, r3, #6
 80038f4:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 80038f6:	68a3      	ldr	r3, [r4, #8]
 80038f8:	f043 0320 	orr.w	r3, r3, #32
 80038fc:	60a3      	str	r3, [r4, #8]
 80038fe:	e7e1      	b.n	80038c4 <USB_CoreInit+0x3c>
 8003900:	ffbdffbf 	.word	0xffbdffbf

08003904 <USB_DisableGlobalInt>:
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8003904:	6883      	ldr	r3, [r0, #8]
 8003906:	f023 0301 	bic.w	r3, r3, #1
 800390a:	6083      	str	r3, [r0, #8]
}
 800390c:	2000      	movs	r0, #0
 800390e:	4770      	bx	lr

08003910 <USB_SetCurrentMode>:
{
 8003910:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8003912:	68c3      	ldr	r3, [r0, #12]
 8003914:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8003918:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 800391a:	2901      	cmp	r1, #1
 800391c:	d009      	beq.n	8003932 <USB_SetCurrentMode+0x22>
  else if (mode == USB_DEVICE_MODE)
 800391e:	b969      	cbnz	r1, 800393c <USB_SetCurrentMode+0x2c>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8003920:	68c3      	ldr	r3, [r0, #12]
 8003922:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8003926:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 8003928:	2032      	movs	r0, #50	; 0x32
 800392a:	f7fd fe15 	bl	8001558 <HAL_Delay>
  return HAL_OK;
 800392e:	2000      	movs	r0, #0
}
 8003930:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8003932:	68c3      	ldr	r3, [r0, #12]
 8003934:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003938:	60c3      	str	r3, [r0, #12]
 800393a:	e7f5      	b.n	8003928 <USB_SetCurrentMode+0x18>
    return HAL_ERROR;
 800393c:	2001      	movs	r0, #1
 800393e:	e7f7      	b.n	8003930 <USB_SetCurrentMode+0x20>

08003940 <USB_FlushTxFifo>:
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8003940:	0189      	lsls	r1, r1, #6
 8003942:	f041 0120 	orr.w	r1, r1, #32
 8003946:	6101      	str	r1, [r0, #16]
  uint32_t count = 0U;
 8003948:	2300      	movs	r3, #0
    if (++count > 200000U)
 800394a:	3301      	adds	r3, #1
 800394c:	4a05      	ldr	r2, [pc, #20]	; (8003964 <USB_FlushTxFifo+0x24>)
 800394e:	4293      	cmp	r3, r2
 8003950:	d805      	bhi.n	800395e <USB_FlushTxFifo+0x1e>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8003952:	6902      	ldr	r2, [r0, #16]
 8003954:	f012 0f20 	tst.w	r2, #32
 8003958:	d1f7      	bne.n	800394a <USB_FlushTxFifo+0xa>
  return HAL_OK;
 800395a:	2000      	movs	r0, #0
 800395c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800395e:	2003      	movs	r0, #3
}
 8003960:	4770      	bx	lr
 8003962:	bf00      	nop
 8003964:	00030d40 	.word	0x00030d40

08003968 <USB_FlushRxFifo>:
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8003968:	2310      	movs	r3, #16
 800396a:	6103      	str	r3, [r0, #16]
  uint32_t count = 0;
 800396c:	2300      	movs	r3, #0
    if (++count > 200000U)
 800396e:	3301      	adds	r3, #1
 8003970:	4a05      	ldr	r2, [pc, #20]	; (8003988 <USB_FlushRxFifo+0x20>)
 8003972:	4293      	cmp	r3, r2
 8003974:	d805      	bhi.n	8003982 <USB_FlushRxFifo+0x1a>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8003976:	6902      	ldr	r2, [r0, #16]
 8003978:	f012 0f10 	tst.w	r2, #16
 800397c:	d1f7      	bne.n	800396e <USB_FlushRxFifo+0x6>
  return HAL_OK;
 800397e:	2000      	movs	r0, #0
 8003980:	4770      	bx	lr
      return HAL_TIMEOUT;
 8003982:	2003      	movs	r0, #3
}
 8003984:	4770      	bx	lr
 8003986:	bf00      	nop
 8003988:	00030d40 	.word	0x00030d40

0800398c <USB_SetDevSpeed>:
  USBx_DEVICE->DCFG |= speed;
 800398c:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8003990:	4319      	orrs	r1, r3
 8003992:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 8003996:	2000      	movs	r0, #0
 8003998:	4770      	bx	lr
	...

0800399c <USB_DevInit>:
{
 800399c:	b084      	sub	sp, #16
 800399e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80039a2:	4604      	mov	r4, r0
 80039a4:	a807      	add	r0, sp, #28
 80039a6:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t USBx_BASE = (uint32_t)USBx;
 80039aa:	4625      	mov	r5, r4
  for (i = 0U; i < 15U; i++)
 80039ac:	2300      	movs	r3, #0
 80039ae:	e006      	b.n	80039be <USB_DevInit+0x22>
    USBx->DIEPTXF[i] = 0U;
 80039b0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80039b4:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80039b8:	2100      	movs	r1, #0
 80039ba:	6051      	str	r1, [r2, #4]
  for (i = 0U; i < 15U; i++)
 80039bc:	3301      	adds	r3, #1
 80039be:	2b0e      	cmp	r3, #14
 80039c0:	d9f6      	bls.n	80039b0 <USB_DevInit+0x14>
  if (cfg.vbus_sensing_enable == 0U)
 80039c2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80039c4:	bb03      	cbnz	r3, 8003a08 <USB_DevInit+0x6c>
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 80039c6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80039c8:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80039cc:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 80039ce:	6823      	ldr	r3, [r4, #0]
 80039d0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80039d4:	6023      	str	r3, [r4, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 80039d6:	6823      	ldr	r3, [r4, #0]
 80039d8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80039dc:	6023      	str	r3, [r4, #0]
  USBx_PCGCCTL = 0U;
 80039de:	2300      	movs	r3, #0
 80039e0:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80039e4:	f504 6600 	add.w	r6, r4, #2048	; 0x800
 80039e8:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 80039ec:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80039f0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80039f2:	2b01      	cmp	r3, #1
 80039f4:	d00d      	beq.n	8003a12 <USB_DevInit+0x76>
  else if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)
 80039f6:	2b03      	cmp	r3, #3
 80039f8:	d11c      	bne.n	8003a34 <USB_DevInit+0x98>
    if (cfg.speed == USB_OTG_SPEED_HIGH)
 80039fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80039fc:	b9ab      	cbnz	r3, 8003a2a <USB_DevInit+0x8e>
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 80039fe:	2100      	movs	r1, #0
 8003a00:	4620      	mov	r0, r4
 8003a02:	f7ff ffc3 	bl	800398c <USB_SetDevSpeed>
 8003a06:	e019      	b.n	8003a3c <USB_DevInit+0xa0>
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 8003a08:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003a0a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003a0e:	63a3      	str	r3, [r4, #56]	; 0x38
 8003a10:	e7e5      	b.n	80039de <USB_DevInit+0x42>
    if (cfg.speed == USB_OTG_SPEED_HIGH)
 8003a12:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003a14:	b923      	cbnz	r3, 8003a20 <USB_DevInit+0x84>
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 8003a16:	2100      	movs	r1, #0
 8003a18:	4620      	mov	r0, r4
 8003a1a:	f7ff ffb7 	bl	800398c <USB_SetDevSpeed>
 8003a1e:	e00d      	b.n	8003a3c <USB_DevInit+0xa0>
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 8003a20:	2101      	movs	r1, #1
 8003a22:	4620      	mov	r0, r4
 8003a24:	f7ff ffb2 	bl	800398c <USB_SetDevSpeed>
 8003a28:	e008      	b.n	8003a3c <USB_DevInit+0xa0>
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 8003a2a:	2101      	movs	r1, #1
 8003a2c:	4620      	mov	r0, r4
 8003a2e:	f7ff ffad 	bl	800398c <USB_SetDevSpeed>
 8003a32:	e003      	b.n	8003a3c <USB_DevInit+0xa0>
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8003a34:	2103      	movs	r1, #3
 8003a36:	4620      	mov	r0, r4
 8003a38:	f7ff ffa8 	bl	800398c <USB_SetDevSpeed>
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8003a3c:	2110      	movs	r1, #16
 8003a3e:	4620      	mov	r0, r4
 8003a40:	f7ff ff7e 	bl	8003940 <USB_FlushTxFifo>
 8003a44:	4680      	mov	r8, r0
 8003a46:	b108      	cbz	r0, 8003a4c <USB_DevInit+0xb0>
    ret = HAL_ERROR;
 8003a48:	f04f 0801 	mov.w	r8, #1
  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8003a4c:	4620      	mov	r0, r4
 8003a4e:	f7ff ff8b 	bl	8003968 <USB_FlushRxFifo>
 8003a52:	b108      	cbz	r0, 8003a58 <USB_DevInit+0xbc>
    ret = HAL_ERROR;
 8003a54:	f04f 0801 	mov.w	r8, #1
  USBx_DEVICE->DIEPMSK = 0U;
 8003a58:	2300      	movs	r3, #0
 8003a5a:	6133      	str	r3, [r6, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8003a5c:	6173      	str	r3, [r6, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8003a5e:	61f3      	str	r3, [r6, #28]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003a60:	e00a      	b.n	8003a78 <USB_DevInit+0xdc>
      if (i == 0U)
 8003a62:	b9c3      	cbnz	r3, 8003a96 <USB_DevInit+0xfa>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8003a64:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8003a68:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8003a6c:	2200      	movs	r2, #0
 8003a6e:	610a      	str	r2, [r1, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8003a70:	f64f 327f 	movw	r2, #64383	; 0xfb7f
 8003a74:	608a      	str	r2, [r1, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003a76:	3301      	adds	r3, #1
 8003a78:	9907      	ldr	r1, [sp, #28]
 8003a7a:	4299      	cmp	r1, r3
 8003a7c:	d910      	bls.n	8003aa0 <USB_DevInit+0x104>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8003a7e:	eb05 1243 	add.w	r2, r5, r3, lsl #5
 8003a82:	f502 6110 	add.w	r1, r2, #2304	; 0x900
 8003a86:	f8d2 0900 	ldr.w	r0, [r2, #2304]	; 0x900
 8003a8a:	2800      	cmp	r0, #0
 8003a8c:	dbe9      	blt.n	8003a62 <USB_DevInit+0xc6>
      USBx_INEP(i)->DIEPCTL = 0U;
 8003a8e:	2000      	movs	r0, #0
 8003a90:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
 8003a94:	e7ea      	b.n	8003a6c <USB_DevInit+0xd0>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8003a96:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8003a9a:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
 8003a9e:	e7e5      	b.n	8003a6c <USB_DevInit+0xd0>
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003aa0:	2300      	movs	r3, #0
 8003aa2:	e00a      	b.n	8003aba <USB_DevInit+0x11e>
      if (i == 0U)
 8003aa4:	b1bb      	cbz	r3, 8003ad6 <USB_DevInit+0x13a>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8003aa6:	f04f 4790 	mov.w	r7, #1207959552	; 0x48000000
 8003aaa:	f8c2 7b00 	str.w	r7, [r2, #2816]	; 0xb00
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8003aae:	2200      	movs	r2, #0
 8003ab0:	6102      	str	r2, [r0, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8003ab2:	f64f 327f 	movw	r2, #64383	; 0xfb7f
 8003ab6:	6082      	str	r2, [r0, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003ab8:	3301      	adds	r3, #1
 8003aba:	4299      	cmp	r1, r3
 8003abc:	d910      	bls.n	8003ae0 <USB_DevInit+0x144>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003abe:	eb05 1243 	add.w	r2, r5, r3, lsl #5
 8003ac2:	f502 6030 	add.w	r0, r2, #2816	; 0xb00
 8003ac6:	f8d2 7b00 	ldr.w	r7, [r2, #2816]	; 0xb00
 8003aca:	2f00      	cmp	r7, #0
 8003acc:	dbea      	blt.n	8003aa4 <USB_DevInit+0x108>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8003ace:	2700      	movs	r7, #0
 8003ad0:	f8c2 7b00 	str.w	r7, [r2, #2816]	; 0xb00
 8003ad4:	e7eb      	b.n	8003aae <USB_DevInit+0x112>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8003ad6:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
 8003ada:	f8c2 7b00 	str.w	r7, [r2, #2816]	; 0xb00
 8003ade:	e7e6      	b.n	8003aae <USB_DevInit+0x112>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8003ae0:	6933      	ldr	r3, [r6, #16]
 8003ae2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003ae6:	6133      	str	r3, [r6, #16]
  if (cfg.dma_enable == 1U)
 8003ae8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003aea:	2b01      	cmp	r3, #1
 8003aec:	d01b      	beq.n	8003b26 <USB_DevInit+0x18a>
  USBx->GINTMSK = 0U;
 8003aee:	2200      	movs	r2, #0
 8003af0:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8003af2:	f06f 4280 	mvn.w	r2, #1073741824	; 0x40000000
 8003af6:	6162      	str	r2, [r4, #20]
  if (cfg.dma_enable == 0U)
 8003af8:	b91b      	cbnz	r3, 8003b02 <USB_DevInit+0x166>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8003afa:	69a3      	ldr	r3, [r4, #24]
 8003afc:	f043 0310 	orr.w	r3, r3, #16
 8003b00:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8003b02:	69a2      	ldr	r2, [r4, #24]
 8003b04:	4b0e      	ldr	r3, [pc, #56]	; (8003b40 <USB_DevInit+0x1a4>)
 8003b06:	4313      	orrs	r3, r2
 8003b08:	61a3      	str	r3, [r4, #24]
  if (cfg.Sof_enable != 0U)
 8003b0a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003b0c:	b11b      	cbz	r3, 8003b16 <USB_DevInit+0x17a>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8003b0e:	69a3      	ldr	r3, [r4, #24]
 8003b10:	f043 0308 	orr.w	r3, r3, #8
 8003b14:	61a3      	str	r3, [r4, #24]
  if (cfg.vbus_sensing_enable == 1U)
 8003b16:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8003b18:	2b01      	cmp	r3, #1
 8003b1a:	d00b      	beq.n	8003b34 <USB_DevInit+0x198>
}
 8003b1c:	4640      	mov	r0, r8
 8003b1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8003b22:	b004      	add	sp, #16
 8003b24:	4770      	bx	lr
    USBx_DEVICE->DTHRCTL = USB_OTG_DTHRCTL_TXTHRLEN_6 |
 8003b26:	4a07      	ldr	r2, [pc, #28]	; (8003b44 <USB_DevInit+0x1a8>)
 8003b28:	6332      	str	r2, [r6, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= USB_OTG_DTHRCTL_RXTHREN |
 8003b2a:	6b31      	ldr	r1, [r6, #48]	; 0x30
 8003b2c:	4a06      	ldr	r2, [pc, #24]	; (8003b48 <USB_DevInit+0x1ac>)
 8003b2e:	430a      	orrs	r2, r1
 8003b30:	6332      	str	r2, [r6, #48]	; 0x30
 8003b32:	e7dc      	b.n	8003aee <USB_DevInit+0x152>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8003b34:	69a2      	ldr	r2, [r4, #24]
 8003b36:	4b05      	ldr	r3, [pc, #20]	; (8003b4c <USB_DevInit+0x1b0>)
 8003b38:	4313      	orrs	r3, r2
 8003b3a:	61a3      	str	r3, [r4, #24]
 8003b3c:	e7ee      	b.n	8003b1c <USB_DevInit+0x180>
 8003b3e:	bf00      	nop
 8003b40:	803c3800 	.word	0x803c3800
 8003b44:	00800100 	.word	0x00800100
 8003b48:	00010003 	.word	0x00010003
 8003b4c:	40000004 	.word	0x40000004

08003b50 <USB_DevDisconnect>:
{
 8003b50:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8003b52:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8003b56:	f043 0302 	orr.w	r3, r3, #2
 8003b5a:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8003b5e:	2003      	movs	r0, #3
 8003b60:	f7fd fcfa 	bl	8001558 <HAL_Delay>
}
 8003b64:	2000      	movs	r0, #0
 8003b66:	bd08      	pop	{r3, pc}

08003b68 <makeFreeRtosPriority>:
/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  
  if (priority != osPriorityError) {
 8003b68:	2884      	cmp	r0, #132	; 0x84
 8003b6a:	d001      	beq.n	8003b70 <makeFreeRtosPriority+0x8>
    fpriority += (priority - osPriorityIdle);
 8003b6c:	3003      	adds	r0, #3
 8003b6e:	4770      	bx	lr
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8003b70:	2000      	movs	r0, #0
  }
  
  return fpriority;
}
 8003b72:	4770      	bx	lr

08003b74 <inHandlerMode>:
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003b74:	f3ef 8005 	mrs	r0, IPSR

/* Determine whether we are in thread mode or handler mode. */
static int inHandlerMode (void)
{
  return __get_IPSR() != 0;
}
 8003b78:	3000      	adds	r0, #0
 8003b7a:	bf18      	it	ne
 8003b7c:	2001      	movne	r0, #1
 8003b7e:	4770      	bx	lr

08003b80 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8003b80:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8003b82:	f001 f877 	bl	8004c74 <vTaskStartScheduler>
  
  return osOK;
}
 8003b86:	2000      	movs	r0, #0
 8003b88:	bd08      	pop	{r3, pc}

08003b8a <osKernelSysTick>:
* @param  None
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
 8003b8a:	b508      	push	{r3, lr}
  if (inHandlerMode()) {
 8003b8c:	f7ff fff2 	bl	8003b74 <inHandlerMode>
 8003b90:	b910      	cbnz	r0, 8003b98 <osKernelSysTick+0xe>
    return xTaskGetTickCountFromISR();
  }
  else {
    return xTaskGetTickCount();
 8003b92:	f001 f8b7 	bl	8004d04 <xTaskGetTickCount>
  }
}
 8003b96:	bd08      	pop	{r3, pc}
    return xTaskGetTickCountFromISR();
 8003b98:	f001 f8ba 	bl	8004d10 <xTaskGetTickCountFromISR>
 8003b9c:	e7fb      	b.n	8003b96 <osKernelSysTick+0xc>

08003b9e <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8003b9e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003ba0:	b085      	sub	sp, #20
 8003ba2:	460f      	mov	r7, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003ba4:	6844      	ldr	r4, [r0, #4]
 8003ba6:	6805      	ldr	r5, [r0, #0]
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 8003ba8:	6906      	ldr	r6, [r0, #16]
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003baa:	f9b0 0008 	ldrsh.w	r0, [r0, #8]
 8003bae:	f7ff ffdb 	bl	8003b68 <makeFreeRtosPriority>
 8003bb2:	ab03      	add	r3, sp, #12
 8003bb4:	9301      	str	r3, [sp, #4]
 8003bb6:	9000      	str	r0, [sp, #0]
 8003bb8:	463b      	mov	r3, r7
 8003bba:	b2b2      	uxth	r2, r6
 8003bbc:	4629      	mov	r1, r5
 8003bbe:	4620      	mov	r0, r4
 8003bc0:	f001 f826 	bl	8004c10 <xTaskCreate>
 8003bc4:	2801      	cmp	r0, #1
 8003bc6:	d102      	bne.n	8003bce <osThreadCreate+0x30>
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8003bc8:	9803      	ldr	r0, [sp, #12]
}
 8003bca:	b005      	add	sp, #20
 8003bcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 8003bce:	2000      	movs	r0, #0
 8003bd0:	e7fb      	b.n	8003bca <osThreadCreate+0x2c>

08003bd2 <osMutexCreate>:
* @param  mutex_def     mutex definition referenced with \ref osMutex.
* @retval  mutex ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS.
*/
osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
{
 8003bd2:	b508      	push	{r3, lr}
    return xSemaphoreCreateMutex(); 
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
#else  
    return xSemaphoreCreateMutex(); 
 8003bd4:	2001      	movs	r0, #1
 8003bd6:	f000 fbc5 	bl	8004364 <xQueueCreateMutex>
#endif
#else
  return NULL;
#endif
}
 8003bda:	bd08      	pop	{r3, pc}

08003bdc <osMutexWait>:
* @param millisec      timeout value or 0 in case of no time-out.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
{
 8003bdc:	b530      	push	{r4, r5, lr}
 8003bde:	b083      	sub	sp, #12
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8003be0:	2300      	movs	r3, #0
 8003be2:	9301      	str	r3, [sp, #4]
  
  
  if (mutex_id == NULL) {
 8003be4:	b350      	cbz	r0, 8003c3c <osMutexWait+0x60>
 8003be6:	460c      	mov	r4, r1
 8003be8:	4605      	mov	r5, r0
    return osErrorParameter;
  }
  
  ticks = 0;
  if (millisec == osWaitForever) {
 8003bea:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
 8003bee:	d002      	beq.n	8003bf6 <osMutexWait+0x1a>
    ticks = portMAX_DELAY;
  }
  else if (millisec != 0) {
 8003bf0:	b919      	cbnz	r1, 8003bfa <osMutexWait+0x1e>
  ticks = 0;
 8003bf2:	461c      	mov	r4, r3
 8003bf4:	e001      	b.n	8003bfa <osMutexWait+0x1e>
    ticks = portMAX_DELAY;
 8003bf6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8003bfa:	f7ff ffbb 	bl	8003b74 <inHandlerMode>
 8003bfe:	b190      	cbz	r0, 8003c26 <osMutexWait+0x4a>
    if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
 8003c00:	aa01      	add	r2, sp, #4
 8003c02:	2100      	movs	r1, #0
 8003c04:	4628      	mov	r0, r5
 8003c06:	f000 fe0f 	bl	8004828 <xQueueReceiveFromISR>
 8003c0a:	2801      	cmp	r0, #1
 8003c0c:	d118      	bne.n	8003c40 <osMutexWait+0x64>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 8003c0e:	9b01      	ldr	r3, [sp, #4]
 8003c10:	b1c3      	cbz	r3, 8003c44 <osMutexWait+0x68>
 8003c12:	4b0d      	ldr	r3, [pc, #52]	; (8003c48 <osMutexWait+0x6c>)
 8003c14:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003c18:	601a      	str	r2, [r3, #0]
 8003c1a:	f3bf 8f4f 	dsb	sy
 8003c1e:	f3bf 8f6f 	isb	sy
  } 
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 8003c22:	2000      	movs	r0, #0
 8003c24:	e006      	b.n	8003c34 <osMutexWait+0x58>
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
 8003c26:	4621      	mov	r1, r4
 8003c28:	4628      	mov	r0, r5
 8003c2a:	f000 fd27 	bl	800467c <xQueueSemaphoreTake>
 8003c2e:	2801      	cmp	r0, #1
 8003c30:	d102      	bne.n	8003c38 <osMutexWait+0x5c>
  return osOK;
 8003c32:	2000      	movs	r0, #0
}
 8003c34:	b003      	add	sp, #12
 8003c36:	bd30      	pop	{r4, r5, pc}
    return osErrorOS;
 8003c38:	20ff      	movs	r0, #255	; 0xff
 8003c3a:	e7fb      	b.n	8003c34 <osMutexWait+0x58>
    return osErrorParameter;
 8003c3c:	2080      	movs	r0, #128	; 0x80
 8003c3e:	e7f9      	b.n	8003c34 <osMutexWait+0x58>
      return osErrorOS;
 8003c40:	20ff      	movs	r0, #255	; 0xff
 8003c42:	e7f7      	b.n	8003c34 <osMutexWait+0x58>
  return osOK;
 8003c44:	2000      	movs	r0, #0
 8003c46:	e7f5      	b.n	8003c34 <osMutexWait+0x58>
 8003c48:	e000ed04 	.word	0xe000ed04

08003c4c <osMutexRelease>:
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexRelease (osMutexId mutex_id)
{
 8003c4c:	b510      	push	{r4, lr}
 8003c4e:	b082      	sub	sp, #8
 8003c50:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 8003c52:	2300      	movs	r3, #0
 8003c54:	9301      	str	r3, [sp, #4]
  
  if (inHandlerMode()) {
 8003c56:	f7ff ff8d 	bl	8003b74 <inHandlerMode>
 8003c5a:	b188      	cbz	r0, 8003c80 <osMutexRelease+0x34>
    if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
 8003c5c:	a901      	add	r1, sp, #4
 8003c5e:	4620      	mov	r0, r4
 8003c60:	f000 fbf9 	bl	8004456 <xQueueGiveFromISR>
 8003c64:	2801      	cmp	r0, #1
 8003c66:	d116      	bne.n	8003c96 <osMutexRelease+0x4a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8003c68:	9b01      	ldr	r3, [sp, #4]
 8003c6a:	b1b3      	cbz	r3, 8003c9a <osMutexRelease+0x4e>
 8003c6c:	4b0d      	ldr	r3, [pc, #52]	; (8003ca4 <osMutexRelease+0x58>)
 8003c6e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003c72:	601a      	str	r2, [r3, #0]
 8003c74:	f3bf 8f4f 	dsb	sy
 8003c78:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8003c7c:	2000      	movs	r0, #0
 8003c7e:	e008      	b.n	8003c92 <osMutexRelease+0x46>
  }
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
 8003c80:	2300      	movs	r3, #0
 8003c82:	461a      	mov	r2, r3
 8003c84:	4619      	mov	r1, r3
 8003c86:	4620      	mov	r0, r4
 8003c88:	f000 fa9a 	bl	80041c0 <xQueueGenericSend>
 8003c8c:	2801      	cmp	r0, #1
 8003c8e:	d106      	bne.n	8003c9e <osMutexRelease+0x52>
  osStatus result = osOK;
 8003c90:	2000      	movs	r0, #0
  {
    result = osErrorOS;
  }
  return result;
}
 8003c92:	b002      	add	sp, #8
 8003c94:	bd10      	pop	{r4, pc}
      return osErrorOS;
 8003c96:	20ff      	movs	r0, #255	; 0xff
 8003c98:	e7fb      	b.n	8003c92 <osMutexRelease+0x46>
  osStatus result = osOK;
 8003c9a:	2000      	movs	r0, #0
 8003c9c:	e7f9      	b.n	8003c92 <osMutexRelease+0x46>
    result = osErrorOS;
 8003c9e:	20ff      	movs	r0, #255	; 0xff
 8003ca0:	e7f7      	b.n	8003c92 <osMutexRelease+0x46>
 8003ca2:	bf00      	nop
 8003ca4:	e000ed04 	.word	0xe000ed04

08003ca8 <osMutexDelete>:
* @param mutex_id  mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexDelete shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexDelete (osMutexId mutex_id)
{
 8003ca8:	b510      	push	{r4, lr}
 8003caa:	4604      	mov	r4, r0
  if (inHandlerMode()) {
 8003cac:	f7ff ff62 	bl	8003b74 <inHandlerMode>
 8003cb0:	b920      	cbnz	r0, 8003cbc <osMutexDelete+0x14>
    return osErrorISR;
  }

  vQueueDelete(mutex_id);
 8003cb2:	4620      	mov	r0, r4
 8003cb4:	f000 fe2a 	bl	800490c <vQueueDelete>

  return osOK;
 8003cb8:	2000      	movs	r0, #0
}
 8003cba:	bd10      	pop	{r4, pc}
    return osErrorISR;
 8003cbc:	2082      	movs	r0, #130	; 0x82
 8003cbe:	e7fc      	b.n	8003cba <osMutexDelete+0x12>

08003cc0 <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
 8003cc0:	b510      	push	{r4, lr}
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
 8003cc2:	2901      	cmp	r1, #1
 8003cc4:	d10d      	bne.n	8003ce2 <osSemaphoreCreate+0x22>
    vSemaphoreCreateBinary(sema);
 8003cc6:	2203      	movs	r2, #3
 8003cc8:	2100      	movs	r1, #0
 8003cca:	2001      	movs	r0, #1
 8003ccc:	f000 fa51 	bl	8004172 <xQueueGenericCreate>
 8003cd0:	4604      	mov	r4, r0
 8003cd2:	b120      	cbz	r0, 8003cde <osSemaphoreCreate+0x1e>
 8003cd4:	2300      	movs	r3, #0
 8003cd6:	461a      	mov	r2, r3
 8003cd8:	4619      	mov	r1, r3
 8003cda:	f000 fa71 	bl	80041c0 <xQueueGenericSend>
#else
    return NULL;
#endif
  }
#endif
}
 8003cde:	4620      	mov	r0, r4
 8003ce0:	bd10      	pop	{r4, pc}
    return NULL;
 8003ce2:	2400      	movs	r4, #0
 8003ce4:	e7fb      	b.n	8003cde <osSemaphoreCreate+0x1e>
	...

08003ce8 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8003ce8:	b530      	push	{r4, r5, lr}
 8003cea:	b083      	sub	sp, #12
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8003cec:	2300      	movs	r3, #0
 8003cee:	9301      	str	r3, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 8003cf0:	b350      	cbz	r0, 8003d48 <osSemaphoreWait+0x60>
 8003cf2:	460c      	mov	r4, r1
 8003cf4:	4605      	mov	r5, r0
    return osErrorParameter;
  }
  
  ticks = 0;
  if (millisec == osWaitForever) {
 8003cf6:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
 8003cfa:	d002      	beq.n	8003d02 <osSemaphoreWait+0x1a>
    ticks = portMAX_DELAY;
  }
  else if (millisec != 0) {
 8003cfc:	b919      	cbnz	r1, 8003d06 <osSemaphoreWait+0x1e>
  ticks = 0;
 8003cfe:	461c      	mov	r4, r3
 8003d00:	e001      	b.n	8003d06 <osSemaphoreWait+0x1e>
    ticks = portMAX_DELAY;
 8003d02:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8003d06:	f7ff ff35 	bl	8003b74 <inHandlerMode>
 8003d0a:	b190      	cbz	r0, 8003d32 <osSemaphoreWait+0x4a>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8003d0c:	aa01      	add	r2, sp, #4
 8003d0e:	2100      	movs	r1, #0
 8003d10:	4628      	mov	r0, r5
 8003d12:	f000 fd89 	bl	8004828 <xQueueReceiveFromISR>
 8003d16:	2801      	cmp	r0, #1
 8003d18:	d118      	bne.n	8003d4c <osSemaphoreWait+0x64>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 8003d1a:	9b01      	ldr	r3, [sp, #4]
 8003d1c:	b1c3      	cbz	r3, 8003d50 <osSemaphoreWait+0x68>
 8003d1e:	4b0d      	ldr	r3, [pc, #52]	; (8003d54 <osSemaphoreWait+0x6c>)
 8003d20:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003d24:	601a      	str	r2, [r3, #0]
 8003d26:	f3bf 8f4f 	dsb	sy
 8003d2a:	f3bf 8f6f 	isb	sy
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 8003d2e:	2000      	movs	r0, #0
 8003d30:	e006      	b.n	8003d40 <osSemaphoreWait+0x58>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8003d32:	4621      	mov	r1, r4
 8003d34:	4628      	mov	r0, r5
 8003d36:	f000 fca1 	bl	800467c <xQueueSemaphoreTake>
 8003d3a:	2801      	cmp	r0, #1
 8003d3c:	d102      	bne.n	8003d44 <osSemaphoreWait+0x5c>
  return osOK;
 8003d3e:	2000      	movs	r0, #0
}
 8003d40:	b003      	add	sp, #12
 8003d42:	bd30      	pop	{r4, r5, pc}
    return osErrorOS;
 8003d44:	20ff      	movs	r0, #255	; 0xff
 8003d46:	e7fb      	b.n	8003d40 <osSemaphoreWait+0x58>
    return osErrorParameter;
 8003d48:	2080      	movs	r0, #128	; 0x80
 8003d4a:	e7f9      	b.n	8003d40 <osSemaphoreWait+0x58>
      return osErrorOS;
 8003d4c:	20ff      	movs	r0, #255	; 0xff
 8003d4e:	e7f7      	b.n	8003d40 <osSemaphoreWait+0x58>
  return osOK;
 8003d50:	2000      	movs	r0, #0
 8003d52:	e7f5      	b.n	8003d40 <osSemaphoreWait+0x58>
 8003d54:	e000ed04 	.word	0xe000ed04

08003d58 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 8003d58:	b510      	push	{r4, lr}
 8003d5a:	b082      	sub	sp, #8
 8003d5c:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 8003d5e:	2300      	movs	r3, #0
 8003d60:	9301      	str	r3, [sp, #4]
  
  
  if (inHandlerMode()) {
 8003d62:	f7ff ff07 	bl	8003b74 <inHandlerMode>
 8003d66:	b188      	cbz	r0, 8003d8c <osSemaphoreRelease+0x34>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8003d68:	a901      	add	r1, sp, #4
 8003d6a:	4620      	mov	r0, r4
 8003d6c:	f000 fb73 	bl	8004456 <xQueueGiveFromISR>
 8003d70:	2801      	cmp	r0, #1
 8003d72:	d116      	bne.n	8003da2 <osSemaphoreRelease+0x4a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8003d74:	9b01      	ldr	r3, [sp, #4]
 8003d76:	b1b3      	cbz	r3, 8003da6 <osSemaphoreRelease+0x4e>
 8003d78:	4b0d      	ldr	r3, [pc, #52]	; (8003db0 <osSemaphoreRelease+0x58>)
 8003d7a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003d7e:	601a      	str	r2, [r3, #0]
 8003d80:	f3bf 8f4f 	dsb	sy
 8003d84:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8003d88:	2000      	movs	r0, #0
 8003d8a:	e008      	b.n	8003d9e <osSemaphoreRelease+0x46>
  }
  else {
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 8003d8c:	2300      	movs	r3, #0
 8003d8e:	461a      	mov	r2, r3
 8003d90:	4619      	mov	r1, r3
 8003d92:	4620      	mov	r0, r4
 8003d94:	f000 fa14 	bl	80041c0 <xQueueGenericSend>
 8003d98:	2801      	cmp	r0, #1
 8003d9a:	d106      	bne.n	8003daa <osSemaphoreRelease+0x52>
  osStatus result = osOK;
 8003d9c:	2000      	movs	r0, #0
      result = osErrorOS;
    }
  }
  
  return result;
}
 8003d9e:	b002      	add	sp, #8
 8003da0:	bd10      	pop	{r4, pc}
      return osErrorOS;
 8003da2:	20ff      	movs	r0, #255	; 0xff
 8003da4:	e7fb      	b.n	8003d9e <osSemaphoreRelease+0x46>
  osStatus result = osOK;
 8003da6:	2000      	movs	r0, #0
 8003da8:	e7f9      	b.n	8003d9e <osSemaphoreRelease+0x46>
      result = osErrorOS;
 8003daa:	20ff      	movs	r0, #255	; 0xff
 8003dac:	e7f7      	b.n	8003d9e <osSemaphoreRelease+0x46>
 8003dae:	bf00      	nop
 8003db0:	e000ed04 	.word	0xe000ed04

08003db4 <osSemaphoreDelete>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreDelete shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreDelete (osSemaphoreId semaphore_id)
{
 8003db4:	b510      	push	{r4, lr}
 8003db6:	4604      	mov	r4, r0
  if (inHandlerMode()) {
 8003db8:	f7ff fedc 	bl	8003b74 <inHandlerMode>
 8003dbc:	b920      	cbnz	r0, 8003dc8 <osSemaphoreDelete+0x14>
    return osErrorISR;
  }

  vSemaphoreDelete(semaphore_id);
 8003dbe:	4620      	mov	r0, r4
 8003dc0:	f000 fda4 	bl	800490c <vQueueDelete>

  return osOK; 
 8003dc4:	2000      	movs	r0, #0
}
 8003dc6:	bd10      	pop	{r4, pc}
    return osErrorISR;
 8003dc8:	2082      	movs	r0, #130	; 0x82
 8003dca:	e7fc      	b.n	8003dc6 <osSemaphoreDelete+0x12>

08003dcc <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 8003dcc:	b508      	push	{r3, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 8003dce:	2200      	movs	r2, #0
 8003dd0:	6841      	ldr	r1, [r0, #4]
 8003dd2:	6800      	ldr	r0, [r0, #0]
 8003dd4:	f000 f9cd 	bl	8004172 <xQueueGenericCreate>
#endif
}
 8003dd8:	bd08      	pop	{r3, pc}
	...

08003ddc <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8003ddc:	b530      	push	{r4, r5, lr}
 8003dde:	b085      	sub	sp, #20
 8003de0:	4604      	mov	r4, r0
 8003de2:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 8003de4:	2300      	movs	r3, #0
 8003de6:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 8003de8:	4615      	mov	r5, r2
 8003dea:	b902      	cbnz	r2, 8003dee <osMessagePut+0x12>
    ticks = 1;
 8003dec:	2501      	movs	r5, #1
  }
  
  if (inHandlerMode()) {
 8003dee:	f7ff fec1 	bl	8003b74 <inHandlerMode>
 8003df2:	b198      	cbz	r0, 8003e1c <osMessagePut+0x40>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 8003df4:	2300      	movs	r3, #0
 8003df6:	aa03      	add	r2, sp, #12
 8003df8:	a901      	add	r1, sp, #4
 8003dfa:	4620      	mov	r0, r4
 8003dfc:	f000 fabd 	bl	800437a <xQueueGenericSendFromISR>
 8003e00:	2801      	cmp	r0, #1
 8003e02:	d118      	bne.n	8003e36 <osMessagePut+0x5a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8003e04:	9b03      	ldr	r3, [sp, #12]
 8003e06:	b1c3      	cbz	r3, 8003e3a <osMessagePut+0x5e>
 8003e08:	4b0d      	ldr	r3, [pc, #52]	; (8003e40 <osMessagePut+0x64>)
 8003e0a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003e0e:	601a      	str	r2, [r3, #0]
 8003e10:	f3bf 8f4f 	dsb	sy
 8003e14:	f3bf 8f6f 	isb	sy
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
      return osErrorOS;
    }
  }
  
  return osOK;
 8003e18:	2000      	movs	r0, #0
 8003e1a:	e008      	b.n	8003e2e <osMessagePut+0x52>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 8003e1c:	2300      	movs	r3, #0
 8003e1e:	462a      	mov	r2, r5
 8003e20:	a901      	add	r1, sp, #4
 8003e22:	4620      	mov	r0, r4
 8003e24:	f000 f9cc 	bl	80041c0 <xQueueGenericSend>
 8003e28:	2801      	cmp	r0, #1
 8003e2a:	d102      	bne.n	8003e32 <osMessagePut+0x56>
  return osOK;
 8003e2c:	2000      	movs	r0, #0
}
 8003e2e:	b005      	add	sp, #20
 8003e30:	bd30      	pop	{r4, r5, pc}
      return osErrorOS;
 8003e32:	20ff      	movs	r0, #255	; 0xff
 8003e34:	e7fb      	b.n	8003e2e <osMessagePut+0x52>
      return osErrorOS;
 8003e36:	20ff      	movs	r0, #255	; 0xff
 8003e38:	e7f9      	b.n	8003e2e <osMessagePut+0x52>
  return osOK;
 8003e3a:	2000      	movs	r0, #0
 8003e3c:	e7f7      	b.n	8003e2e <osMessagePut+0x52>
 8003e3e:	bf00      	nop
 8003e40:	e000ed04 	.word	0xe000ed04

08003e44 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 8003e44:	b570      	push	{r4, r5, r6, lr}
 8003e46:	b084      	sub	sp, #16
 8003e48:	4604      	mov	r4, r0
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
 8003e4a:	9102      	str	r1, [sp, #8]
  event.value.v = 0;
 8003e4c:	2300      	movs	r3, #0
 8003e4e:	9301      	str	r3, [sp, #4]
  
  if (queue_id == NULL) {
 8003e50:	b149      	cbz	r1, 8003e66 <osMessageGet+0x22>
 8003e52:	460d      	mov	r5, r1
 8003e54:	4616      	mov	r6, r2
    event.status = osErrorParameter;
    return event;
  }
  
  taskWoken = pdFALSE;
 8003e56:	2300      	movs	r3, #0
 8003e58:	9303      	str	r3, [sp, #12]
  
  ticks = 0;
  if (millisec == osWaitForever) {
 8003e5a:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
 8003e5e:	d00b      	beq.n	8003e78 <osMessageGet+0x34>
    ticks = portMAX_DELAY;
  }
  else if (millisec != 0) {
 8003e60:	b962      	cbnz	r2, 8003e7c <osMessageGet+0x38>
  ticks = 0;
 8003e62:	461e      	mov	r6, r3
 8003e64:	e00a      	b.n	8003e7c <osMessageGet+0x38>
    event.status = osErrorParameter;
 8003e66:	ab04      	add	r3, sp, #16
 8003e68:	2280      	movs	r2, #128	; 0x80
 8003e6a:	f843 2d10 	str.w	r2, [r3, #-16]!
    return event;
 8003e6e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8003e72:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 8003e76:	e02a      	b.n	8003ece <osMessageGet+0x8a>
    ticks = portMAX_DELAY;
 8003e78:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8003e7c:	f7ff fe7a 	bl	8003b74 <inHandlerMode>
 8003e80:	b1b0      	cbz	r0, 8003eb0 <osMessageGet+0x6c>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 8003e82:	aa03      	add	r2, sp, #12
 8003e84:	a901      	add	r1, sp, #4
 8003e86:	4628      	mov	r0, r5
 8003e88:	f000 fcce 	bl	8004828 <xQueueReceiveFromISR>
 8003e8c:	2801      	cmp	r0, #1
 8003e8e:	d00c      	beq.n	8003eaa <osMessageGet+0x66>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = osOK;
 8003e90:	2300      	movs	r3, #0
 8003e92:	9300      	str	r3, [sp, #0]
    }
    portEND_SWITCHING_ISR(taskWoken);
 8003e94:	9b03      	ldr	r3, [sp, #12]
 8003e96:	b1ab      	cbz	r3, 8003ec4 <osMessageGet+0x80>
 8003e98:	4b11      	ldr	r3, [pc, #68]	; (8003ee0 <osMessageGet+0x9c>)
 8003e9a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003e9e:	601a      	str	r2, [r3, #0]
 8003ea0:	f3bf 8f4f 	dsb	sy
 8003ea4:	f3bf 8f6f 	isb	sy
 8003ea8:	e00c      	b.n	8003ec4 <osMessageGet+0x80>
      event.status = osEventMessage;
 8003eaa:	2310      	movs	r3, #16
 8003eac:	9300      	str	r3, [sp, #0]
 8003eae:	e7f1      	b.n	8003e94 <osMessageGet+0x50>
  }
  else {
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 8003eb0:	4632      	mov	r2, r6
 8003eb2:	a901      	add	r1, sp, #4
 8003eb4:	4628      	mov	r0, r5
 8003eb6:	f000 fb2f 	bl	8004518 <xQueueReceive>
 8003eba:	2801      	cmp	r0, #1
 8003ebc:	d00a      	beq.n	8003ed4 <osMessageGet+0x90>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 8003ebe:	b966      	cbnz	r6, 8003eda <osMessageGet+0x96>
 8003ec0:	2300      	movs	r3, #0
 8003ec2:	9300      	str	r3, [sp, #0]
    }
  }
  
  return event;
 8003ec4:	466b      	mov	r3, sp
 8003ec6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8003eca:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8003ece:	4620      	mov	r0, r4
 8003ed0:	b004      	add	sp, #16
 8003ed2:	bd70      	pop	{r4, r5, r6, pc}
      event.status = osEventMessage;
 8003ed4:	2310      	movs	r3, #16
 8003ed6:	9300      	str	r3, [sp, #0]
 8003ed8:	e7f4      	b.n	8003ec4 <osMessageGet+0x80>
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 8003eda:	2340      	movs	r3, #64	; 0x40
 8003edc:	e7f1      	b.n	8003ec2 <osMessageGet+0x7e>
 8003ede:	bf00      	nop
 8003ee0:	e000ed04 	.word	0xe000ed04

08003ee4 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ee4:	f100 0308 	add.w	r3, r0, #8
 8003ee8:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003eea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003eee:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ef0:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ef2:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003ef4:	2300      	movs	r3, #0
 8003ef6:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8003ef8:	4770      	bx	lr

08003efa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8003efa:	2300      	movs	r3, #0
 8003efc:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8003efe:	4770      	bx	lr

08003f00 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8003f00:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8003f02:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003f04:	689a      	ldr	r2, [r3, #8]
 8003f06:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003f08:	689a      	ldr	r2, [r3, #8]
 8003f0a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8003f0c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003f0e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003f10:	6803      	ldr	r3, [r0, #0]
 8003f12:	3301      	adds	r3, #1
 8003f14:	6003      	str	r3, [r0, #0]
}
 8003f16:	4770      	bx	lr

08003f18 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003f18:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003f1a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8003f1c:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
 8003f20:	d002      	beq.n	8003f28 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003f22:	f100 0208 	add.w	r2, r0, #8
 8003f26:	e002      	b.n	8003f2e <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
 8003f28:	6902      	ldr	r2, [r0, #16]
 8003f2a:	e004      	b.n	8003f36 <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003f2c:	461a      	mov	r2, r3
 8003f2e:	6853      	ldr	r3, [r2, #4]
 8003f30:	681c      	ldr	r4, [r3, #0]
 8003f32:	42ac      	cmp	r4, r5
 8003f34:	d9fa      	bls.n	8003f2c <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8003f36:	6853      	ldr	r3, [r2, #4]
 8003f38:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003f3a:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003f3c:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8003f3e:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003f40:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003f42:	6803      	ldr	r3, [r0, #0]
 8003f44:	3301      	adds	r3, #1
 8003f46:	6003      	str	r3, [r0, #0]
}
 8003f48:	bc30      	pop	{r4, r5}
 8003f4a:	4770      	bx	lr

08003f4c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8003f4c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003f4e:	6842      	ldr	r2, [r0, #4]
 8003f50:	6881      	ldr	r1, [r0, #8]
 8003f52:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003f54:	6882      	ldr	r2, [r0, #8]
 8003f56:	6841      	ldr	r1, [r0, #4]
 8003f58:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003f5a:	685a      	ldr	r2, [r3, #4]
 8003f5c:	4282      	cmp	r2, r0
 8003f5e:	d006      	beq.n	8003f6e <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8003f60:	2200      	movs	r2, #0
 8003f62:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8003f64:	681a      	ldr	r2, [r3, #0]
 8003f66:	3a01      	subs	r2, #1
 8003f68:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8003f6a:	6818      	ldr	r0, [r3, #0]
}
 8003f6c:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8003f6e:	6882      	ldr	r2, [r0, #8]
 8003f70:	605a      	str	r2, [r3, #4]
 8003f72:	e7f5      	b.n	8003f60 <uxListRemove+0x14>

08003f74 <prvGetDisinheritPriorityAfterTimeout>:
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 8003f74:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003f76:	b123      	cbz	r3, 8003f82 <prvGetDisinheritPriorityAfterTimeout+0xe>
		{
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8003f78:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8003f7a:	6818      	ldr	r0, [r3, #0]
 8003f7c:	f1c0 0007 	rsb	r0, r0, #7
 8003f80:	4770      	bx	lr
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 8003f82:	2000      	movs	r0, #0
		}

		return uxHighestPriorityOfWaitingTasks;
	}
 8003f84:	4770      	bx	lr

08003f86 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 8003f86:	b510      	push	{r4, lr}
 8003f88:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8003f8a:	f001 faab 	bl	80054e4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8003f8e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8003f90:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003f92:	429a      	cmp	r2, r3
 8003f94:	d004      	beq.n	8003fa0 <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
 8003f96:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
 8003f98:	f001 faca 	bl	8005530 <vPortExitCritical>

	return xReturn;
}
 8003f9c:	4620      	mov	r0, r4
 8003f9e:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
 8003fa0:	2401      	movs	r4, #1
 8003fa2:	e7f9      	b.n	8003f98 <prvIsQueueFull+0x12>

08003fa4 <prvIsQueueEmpty>:
{
 8003fa4:	b510      	push	{r4, lr}
 8003fa6:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8003fa8:	f001 fa9c 	bl	80054e4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8003fac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003fae:	b123      	cbz	r3, 8003fba <prvIsQueueEmpty+0x16>
			xReturn = pdFALSE;
 8003fb0:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8003fb2:	f001 fabd 	bl	8005530 <vPortExitCritical>
}
 8003fb6:	4620      	mov	r0, r4
 8003fb8:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
 8003fba:	2401      	movs	r4, #1
 8003fbc:	e7f9      	b.n	8003fb2 <prvIsQueueEmpty+0xe>

08003fbe <prvCopyDataToQueue>:
{
 8003fbe:	b570      	push	{r4, r5, r6, lr}
 8003fc0:	4604      	mov	r4, r0
 8003fc2:	4616      	mov	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8003fc4:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8003fc6:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8003fc8:	b95a      	cbnz	r2, 8003fe2 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8003fca:	6803      	ldr	r3, [r0, #0]
 8003fcc:	b11b      	cbz	r3, 8003fd6 <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
 8003fce:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8003fd0:	3501      	adds	r5, #1
 8003fd2:	63a5      	str	r5, [r4, #56]	; 0x38
}
 8003fd4:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8003fd6:	6840      	ldr	r0, [r0, #4]
 8003fd8:	f001 f942 	bl	8005260 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8003fdc:	2300      	movs	r3, #0
 8003fde:	6063      	str	r3, [r4, #4]
 8003fe0:	e7f6      	b.n	8003fd0 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 8003fe2:	b96e      	cbnz	r6, 8004000 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8003fe4:	6880      	ldr	r0, [r0, #8]
 8003fe6:	f00b fa4e 	bl	800f486 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8003fea:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8003fec:	68a3      	ldr	r3, [r4, #8]
 8003fee:	4413      	add	r3, r2
 8003ff0:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8003ff2:	6862      	ldr	r2, [r4, #4]
 8003ff4:	4293      	cmp	r3, r2
 8003ff6:	d319      	bcc.n	800402c <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8003ff8:	6823      	ldr	r3, [r4, #0]
 8003ffa:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 8003ffc:	2000      	movs	r0, #0
 8003ffe:	e7e7      	b.n	8003fd0 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004000:	68c0      	ldr	r0, [r0, #12]
 8004002:	f00b fa40 	bl	800f486 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8004006:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8004008:	4252      	negs	r2, r2
 800400a:	68e3      	ldr	r3, [r4, #12]
 800400c:	4413      	add	r3, r2
 800400e:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004010:	6821      	ldr	r1, [r4, #0]
 8004012:	428b      	cmp	r3, r1
 8004014:	d202      	bcs.n	800401c <prvCopyDataToQueue+0x5e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8004016:	6863      	ldr	r3, [r4, #4]
 8004018:	441a      	add	r2, r3
 800401a:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800401c:	2e02      	cmp	r6, #2
 800401e:	d001      	beq.n	8004024 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 8004020:	2000      	movs	r0, #0
 8004022:	e7d5      	b.n	8003fd0 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004024:	b125      	cbz	r5, 8004030 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 8004026:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
 8004028:	2000      	movs	r0, #0
 800402a:	e7d1      	b.n	8003fd0 <prvCopyDataToQueue+0x12>
 800402c:	2000      	movs	r0, #0
 800402e:	e7cf      	b.n	8003fd0 <prvCopyDataToQueue+0x12>
 8004030:	2000      	movs	r0, #0
 8004032:	e7cd      	b.n	8003fd0 <prvCopyDataToQueue+0x12>

08004034 <prvCopyDataFromQueue>:
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8004034:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8004036:	b172      	cbz	r2, 8004056 <prvCopyDataFromQueue+0x22>
{
 8004038:	b510      	push	{r4, lr}
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800403a:	68c3      	ldr	r3, [r0, #12]
 800403c:	4413      	add	r3, r2
 800403e:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8004040:	6844      	ldr	r4, [r0, #4]
 8004042:	42a3      	cmp	r3, r4
 8004044:	d301      	bcc.n	800404a <prvCopyDataFromQueue+0x16>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8004046:	6803      	ldr	r3, [r0, #0]
 8004048:	60c3      	str	r3, [r0, #12]
 800404a:	460c      	mov	r4, r1
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800404c:	68c1      	ldr	r1, [r0, #12]
 800404e:	4620      	mov	r0, r4
 8004050:	f00b fa19 	bl	800f486 <memcpy>
}
 8004054:	bd10      	pop	{r4, pc}
 8004056:	4770      	bx	lr

08004058 <prvUnlockQueue>:
{
 8004058:	b538      	push	{r3, r4, r5, lr}
 800405a:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 800405c:	f001 fa42 	bl	80054e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8004060:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 8004064:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004066:	e003      	b.n	8004070 <prvUnlockQueue+0x18>
						vTaskMissedYield();
 8004068:	f001 f872 	bl	8005150 <vTaskMissedYield>
			--cTxLock;
 800406c:	3c01      	subs	r4, #1
 800406e:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004070:	2c00      	cmp	r4, #0
 8004072:	dd08      	ble.n	8004086 <prvUnlockQueue+0x2e>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004074:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004076:	b133      	cbz	r3, 8004086 <prvUnlockQueue+0x2e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004078:	f105 0024 	add.w	r0, r5, #36	; 0x24
 800407c:	f000 ffd6 	bl	800502c <xTaskRemoveFromEventList>
 8004080:	2800      	cmp	r0, #0
 8004082:	d0f3      	beq.n	800406c <prvUnlockQueue+0x14>
 8004084:	e7f0      	b.n	8004068 <prvUnlockQueue+0x10>
		pxQueue->cTxLock = queueUNLOCKED;
 8004086:	23ff      	movs	r3, #255	; 0xff
 8004088:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
 800408c:	f001 fa50 	bl	8005530 <vPortExitCritical>
	taskENTER_CRITICAL();
 8004090:	f001 fa28 	bl	80054e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8004094:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 8004098:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800409a:	e003      	b.n	80040a4 <prvUnlockQueue+0x4c>
					vTaskMissedYield();
 800409c:	f001 f858 	bl	8005150 <vTaskMissedYield>
				--cRxLock;
 80040a0:	3c01      	subs	r4, #1
 80040a2:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80040a4:	2c00      	cmp	r4, #0
 80040a6:	dd08      	ble.n	80040ba <prvUnlockQueue+0x62>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80040a8:	692b      	ldr	r3, [r5, #16]
 80040aa:	b133      	cbz	r3, 80040ba <prvUnlockQueue+0x62>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80040ac:	f105 0010 	add.w	r0, r5, #16
 80040b0:	f000 ffbc 	bl	800502c <xTaskRemoveFromEventList>
 80040b4:	2800      	cmp	r0, #0
 80040b6:	d0f3      	beq.n	80040a0 <prvUnlockQueue+0x48>
 80040b8:	e7f0      	b.n	800409c <prvUnlockQueue+0x44>
		pxQueue->cRxLock = queueUNLOCKED;
 80040ba:	23ff      	movs	r3, #255	; 0xff
 80040bc:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
 80040c0:	f001 fa36 	bl	8005530 <vPortExitCritical>
}
 80040c4:	bd38      	pop	{r3, r4, r5, pc}
	...

080040c8 <xQueueGenericReset>:
{
 80040c8:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 80040ca:	b950      	cbnz	r0, 80040e2 <xQueueGenericReset+0x1a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80040cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80040d0:	b672      	cpsid	i
 80040d2:	f383 8811 	msr	BASEPRI, r3
 80040d6:	f3bf 8f6f 	isb	sy
 80040da:	f3bf 8f4f 	dsb	sy
 80040de:	b662      	cpsie	i
 80040e0:	e7fe      	b.n	80040e0 <xQueueGenericReset+0x18>
 80040e2:	4604      	mov	r4, r0
 80040e4:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
 80040e6:	f001 f9fd 	bl	80054e4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80040ea:	6821      	ldr	r1, [r4, #0]
 80040ec:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80040ee:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80040f0:	fb03 1002 	mla	r0, r3, r2, r1
 80040f4:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80040f6:	2000      	movs	r0, #0
 80040f8:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80040fa:	60a1      	str	r1, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80040fc:	3a01      	subs	r2, #1
 80040fe:	fb02 1303 	mla	r3, r2, r3, r1
 8004102:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8004104:	23ff      	movs	r3, #255	; 0xff
 8004106:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800410a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 800410e:	b9a5      	cbnz	r5, 800413a <xQueueGenericReset+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004110:	6923      	ldr	r3, [r4, #16]
 8004112:	b91b      	cbnz	r3, 800411c <xQueueGenericReset+0x54>
	taskEXIT_CRITICAL();
 8004114:	f001 fa0c 	bl	8005530 <vPortExitCritical>
}
 8004118:	2001      	movs	r0, #1
 800411a:	bd38      	pop	{r3, r4, r5, pc}
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800411c:	f104 0010 	add.w	r0, r4, #16
 8004120:	f000 ff84 	bl	800502c <xTaskRemoveFromEventList>
 8004124:	2800      	cmp	r0, #0
 8004126:	d0f5      	beq.n	8004114 <xQueueGenericReset+0x4c>
					queueYIELD_IF_USING_PREEMPTION();
 8004128:	4b08      	ldr	r3, [pc, #32]	; (800414c <xQueueGenericReset+0x84>)
 800412a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800412e:	601a      	str	r2, [r3, #0]
 8004130:	f3bf 8f4f 	dsb	sy
 8004134:	f3bf 8f6f 	isb	sy
 8004138:	e7ec      	b.n	8004114 <xQueueGenericReset+0x4c>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800413a:	f104 0010 	add.w	r0, r4, #16
 800413e:	f7ff fed1 	bl	8003ee4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8004142:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004146:	f7ff fecd 	bl	8003ee4 <vListInitialise>
 800414a:	e7e3      	b.n	8004114 <xQueueGenericReset+0x4c>
 800414c:	e000ed04 	.word	0xe000ed04

08004150 <prvInitialiseNewQueue>:
{
 8004150:	b538      	push	{r3, r4, r5, lr}
 8004152:	461d      	mov	r5, r3
 8004154:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
 8004156:	460b      	mov	r3, r1
 8004158:	b149      	cbz	r1, 800416e <prvInitialiseNewQueue+0x1e>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800415a:	6022      	str	r2, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800415c:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800415e:	6423      	str	r3, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8004160:	2101      	movs	r1, #1
 8004162:	4620      	mov	r0, r4
 8004164:	f7ff ffb0 	bl	80040c8 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 8004168:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
}
 800416c:	bd38      	pop	{r3, r4, r5, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800416e:	6024      	str	r4, [r4, #0]
 8004170:	e7f4      	b.n	800415c <prvInitialiseNewQueue+0xc>

08004172 <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8004172:	b950      	cbnz	r0, 800418a <xQueueGenericCreate+0x18>
 8004174:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004178:	b672      	cpsid	i
 800417a:	f383 8811 	msr	BASEPRI, r3
 800417e:	f3bf 8f6f 	isb	sy
 8004182:	f3bf 8f4f 	dsb	sy
 8004186:	b662      	cpsie	i
 8004188:	e7fe      	b.n	8004188 <xQueueGenericCreate+0x16>
	{
 800418a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800418c:	b083      	sub	sp, #12
 800418e:	4605      	mov	r5, r0
		if( uxItemSize == ( UBaseType_t ) 0 )
 8004190:	b111      	cbz	r1, 8004198 <xQueueGenericCreate+0x26>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004192:	fb01 f000 	mul.w	r0, r1, r0
 8004196:	e000      	b.n	800419a <xQueueGenericCreate+0x28>
			xQueueSizeInBytes = ( size_t ) 0;
 8004198:	2000      	movs	r0, #0
 800419a:	4617      	mov	r7, r2
 800419c:	460c      	mov	r4, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800419e:	3050      	adds	r0, #80	; 0x50
 80041a0:	f001 fb2a 	bl	80057f8 <pvPortMalloc>
		if( pxNewQueue != NULL )
 80041a4:	4606      	mov	r6, r0
 80041a6:	b138      	cbz	r0, 80041b8 <xQueueGenericCreate+0x46>
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 80041a8:	9000      	str	r0, [sp, #0]
 80041aa:	463b      	mov	r3, r7
 80041ac:	f100 0250 	add.w	r2, r0, #80	; 0x50
 80041b0:	4621      	mov	r1, r4
 80041b2:	4628      	mov	r0, r5
 80041b4:	f7ff ffcc 	bl	8004150 <prvInitialiseNewQueue>
	}
 80041b8:	4630      	mov	r0, r6
 80041ba:	b003      	add	sp, #12
 80041bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080041c0 <xQueueGenericSend>:
{
 80041c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80041c2:	b085      	sub	sp, #20
 80041c4:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 80041c6:	b170      	cbz	r0, 80041e6 <xQueueGenericSend+0x26>
 80041c8:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80041ca:	b9b9      	cbnz	r1, 80041fc <xQueueGenericSend+0x3c>
 80041cc:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80041ce:	b1aa      	cbz	r2, 80041fc <xQueueGenericSend+0x3c>
 80041d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80041d4:	b672      	cpsid	i
 80041d6:	f383 8811 	msr	BASEPRI, r3
 80041da:	f3bf 8f6f 	isb	sy
 80041de:	f3bf 8f4f 	dsb	sy
 80041e2:	b662      	cpsie	i
 80041e4:	e7fe      	b.n	80041e4 <xQueueGenericSend+0x24>
 80041e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80041ea:	b672      	cpsid	i
 80041ec:	f383 8811 	msr	BASEPRI, r3
 80041f0:	f3bf 8f6f 	isb	sy
 80041f4:	f3bf 8f4f 	dsb	sy
 80041f8:	b662      	cpsie	i
 80041fa:	e7fe      	b.n	80041fa <xQueueGenericSend+0x3a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80041fc:	2b02      	cmp	r3, #2
 80041fe:	d10d      	bne.n	800421c <xQueueGenericSend+0x5c>
 8004200:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8004202:	2a01      	cmp	r2, #1
 8004204:	d00a      	beq.n	800421c <xQueueGenericSend+0x5c>
 8004206:	f04f 0350 	mov.w	r3, #80	; 0x50
 800420a:	b672      	cpsid	i
 800420c:	f383 8811 	msr	BASEPRI, r3
 8004210:	f3bf 8f6f 	isb	sy
 8004214:	f3bf 8f4f 	dsb	sy
 8004218:	b662      	cpsie	i
 800421a:	e7fe      	b.n	800421a <xQueueGenericSend+0x5a>
 800421c:	461e      	mov	r6, r3
 800421e:	460f      	mov	r7, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004220:	f000 ffac 	bl	800517c <xTaskGetSchedulerState>
 8004224:	b960      	cbnz	r0, 8004240 <xQueueGenericSend+0x80>
 8004226:	9b01      	ldr	r3, [sp, #4]
 8004228:	b163      	cbz	r3, 8004244 <xQueueGenericSend+0x84>
 800422a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800422e:	b672      	cpsid	i
 8004230:	f383 8811 	msr	BASEPRI, r3
 8004234:	f3bf 8f6f 	isb	sy
 8004238:	f3bf 8f4f 	dsb	sy
 800423c:	b662      	cpsie	i
 800423e:	e7fe      	b.n	800423e <xQueueGenericSend+0x7e>
 8004240:	2500      	movs	r5, #0
 8004242:	e03a      	b.n	80042ba <xQueueGenericSend+0xfa>
 8004244:	2500      	movs	r5, #0
 8004246:	e038      	b.n	80042ba <xQueueGenericSend+0xfa>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004248:	4632      	mov	r2, r6
 800424a:	4639      	mov	r1, r7
 800424c:	4620      	mov	r0, r4
 800424e:	f7ff feb6 	bl	8003fbe <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004252:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004254:	b94b      	cbnz	r3, 800426a <xQueueGenericSend+0xaa>
					else if( xYieldRequired != pdFALSE )
 8004256:	b1a8      	cbz	r0, 8004284 <xQueueGenericSend+0xc4>
						queueYIELD_IF_USING_PREEMPTION();
 8004258:	4b3b      	ldr	r3, [pc, #236]	; (8004348 <xQueueGenericSend+0x188>)
 800425a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800425e:	601a      	str	r2, [r3, #0]
 8004260:	f3bf 8f4f 	dsb	sy
 8004264:	f3bf 8f6f 	isb	sy
 8004268:	e00c      	b.n	8004284 <xQueueGenericSend+0xc4>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800426a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800426e:	f000 fedd 	bl	800502c <xTaskRemoveFromEventList>
 8004272:	b138      	cbz	r0, 8004284 <xQueueGenericSend+0xc4>
							queueYIELD_IF_USING_PREEMPTION();
 8004274:	4b34      	ldr	r3, [pc, #208]	; (8004348 <xQueueGenericSend+0x188>)
 8004276:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800427a:	601a      	str	r2, [r3, #0]
 800427c:	f3bf 8f4f 	dsb	sy
 8004280:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8004284:	f001 f954 	bl	8005530 <vPortExitCritical>
				return pdPASS;
 8004288:	2001      	movs	r0, #1
}
 800428a:	b005      	add	sp, #20
 800428c:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
 800428e:	f001 f94f 	bl	8005530 <vPortExitCritical>
					return errQUEUE_FULL;
 8004292:	2000      	movs	r0, #0
 8004294:	e7f9      	b.n	800428a <xQueueGenericSend+0xca>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8004296:	a802      	add	r0, sp, #8
 8004298:	f000 ff0c 	bl	80050b4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800429c:	2501      	movs	r5, #1
 800429e:	e019      	b.n	80042d4 <xQueueGenericSend+0x114>
		prvLockQueue( pxQueue );
 80042a0:	2300      	movs	r3, #0
 80042a2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80042a6:	e021      	b.n	80042ec <xQueueGenericSend+0x12c>
 80042a8:	2300      	movs	r3, #0
 80042aa:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80042ae:	e023      	b.n	80042f8 <xQueueGenericSend+0x138>
				prvUnlockQueue( pxQueue );
 80042b0:	4620      	mov	r0, r4
 80042b2:	f7ff fed1 	bl	8004058 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80042b6:	f000 fdbd 	bl	8004e34 <xTaskResumeAll>
		taskENTER_CRITICAL();
 80042ba:	f001 f913 	bl	80054e4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80042be:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80042c0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80042c2:	429a      	cmp	r2, r3
 80042c4:	d3c0      	bcc.n	8004248 <xQueueGenericSend+0x88>
 80042c6:	2e02      	cmp	r6, #2
 80042c8:	d0be      	beq.n	8004248 <xQueueGenericSend+0x88>
				if( xTicksToWait == ( TickType_t ) 0 )
 80042ca:	9b01      	ldr	r3, [sp, #4]
 80042cc:	2b00      	cmp	r3, #0
 80042ce:	d0de      	beq.n	800428e <xQueueGenericSend+0xce>
				else if( xEntryTimeSet == pdFALSE )
 80042d0:	2d00      	cmp	r5, #0
 80042d2:	d0e0      	beq.n	8004296 <xQueueGenericSend+0xd6>
		taskEXIT_CRITICAL();
 80042d4:	f001 f92c 	bl	8005530 <vPortExitCritical>
		vTaskSuspendAll();
 80042d8:	f000 fd0a 	bl	8004cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80042dc:	f001 f902 	bl	80054e4 <vPortEnterCritical>
 80042e0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80042e4:	b25b      	sxtb	r3, r3
 80042e6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80042ea:	d0d9      	beq.n	80042a0 <xQueueGenericSend+0xe0>
 80042ec:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80042f0:	b25b      	sxtb	r3, r3
 80042f2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80042f6:	d0d7      	beq.n	80042a8 <xQueueGenericSend+0xe8>
 80042f8:	f001 f91a 	bl	8005530 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80042fc:	a901      	add	r1, sp, #4
 80042fe:	a802      	add	r0, sp, #8
 8004300:	f000 fee2 	bl	80050c8 <xTaskCheckForTimeOut>
 8004304:	b9c8      	cbnz	r0, 800433a <xQueueGenericSend+0x17a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8004306:	4620      	mov	r0, r4
 8004308:	f7ff fe3d 	bl	8003f86 <prvIsQueueFull>
 800430c:	2800      	cmp	r0, #0
 800430e:	d0cf      	beq.n	80042b0 <xQueueGenericSend+0xf0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8004310:	9901      	ldr	r1, [sp, #4]
 8004312:	f104 0010 	add.w	r0, r4, #16
 8004316:	f000 fe6d 	bl	8004ff4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800431a:	4620      	mov	r0, r4
 800431c:	f7ff fe9c 	bl	8004058 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004320:	f000 fd88 	bl	8004e34 <xTaskResumeAll>
 8004324:	2800      	cmp	r0, #0
 8004326:	d1c8      	bne.n	80042ba <xQueueGenericSend+0xfa>
					portYIELD_WITHIN_API();
 8004328:	4b07      	ldr	r3, [pc, #28]	; (8004348 <xQueueGenericSend+0x188>)
 800432a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800432e:	601a      	str	r2, [r3, #0]
 8004330:	f3bf 8f4f 	dsb	sy
 8004334:	f3bf 8f6f 	isb	sy
 8004338:	e7bf      	b.n	80042ba <xQueueGenericSend+0xfa>
			prvUnlockQueue( pxQueue );
 800433a:	4620      	mov	r0, r4
 800433c:	f7ff fe8c 	bl	8004058 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004340:	f000 fd78 	bl	8004e34 <xTaskResumeAll>
			return errQUEUE_FULL;
 8004344:	2000      	movs	r0, #0
 8004346:	e7a0      	b.n	800428a <xQueueGenericSend+0xca>
 8004348:	e000ed04 	.word	0xe000ed04

0800434c <prvInitialiseMutex>:
		if( pxNewQueue != NULL )
 800434c:	b148      	cbz	r0, 8004362 <prvInitialiseMutex+0x16>
	{
 800434e:	b508      	push	{r3, lr}
			pxNewQueue->pxMutexHolder = NULL;
 8004350:	2100      	movs	r1, #0
 8004352:	6041      	str	r1, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8004354:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
 8004356:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8004358:	460b      	mov	r3, r1
 800435a:	460a      	mov	r2, r1
 800435c:	f7ff ff30 	bl	80041c0 <xQueueGenericSend>
	}
 8004360:	bd08      	pop	{r3, pc}
 8004362:	4770      	bx	lr

08004364 <xQueueCreateMutex>:
	{
 8004364:	b510      	push	{r4, lr}
		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 8004366:	4602      	mov	r2, r0
 8004368:	2100      	movs	r1, #0
 800436a:	2001      	movs	r0, #1
 800436c:	f7ff ff01 	bl	8004172 <xQueueGenericCreate>
 8004370:	4604      	mov	r4, r0
		prvInitialiseMutex( pxNewQueue );
 8004372:	f7ff ffeb 	bl	800434c <prvInitialiseMutex>
	}
 8004376:	4620      	mov	r0, r4
 8004378:	bd10      	pop	{r4, pc}

0800437a <xQueueGenericSendFromISR>:
{
 800437a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 800437e:	b170      	cbz	r0, 800439e <xQueueGenericSendFromISR+0x24>
 8004380:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004382:	b9b9      	cbnz	r1, 80043b4 <xQueueGenericSendFromISR+0x3a>
 8004384:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8004386:	b1a8      	cbz	r0, 80043b4 <xQueueGenericSendFromISR+0x3a>
 8004388:	f04f 0350 	mov.w	r3, #80	; 0x50
 800438c:	b672      	cpsid	i
 800438e:	f383 8811 	msr	BASEPRI, r3
 8004392:	f3bf 8f6f 	isb	sy
 8004396:	f3bf 8f4f 	dsb	sy
 800439a:	b662      	cpsie	i
 800439c:	e7fe      	b.n	800439c <xQueueGenericSendFromISR+0x22>
 800439e:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043a2:	b672      	cpsid	i
 80043a4:	f383 8811 	msr	BASEPRI, r3
 80043a8:	f3bf 8f6f 	isb	sy
 80043ac:	f3bf 8f4f 	dsb	sy
 80043b0:	b662      	cpsie	i
 80043b2:	e7fe      	b.n	80043b2 <xQueueGenericSendFromISR+0x38>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80043b4:	2b02      	cmp	r3, #2
 80043b6:	d10d      	bne.n	80043d4 <xQueueGenericSendFromISR+0x5a>
 80043b8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80043ba:	2801      	cmp	r0, #1
 80043bc:	d00a      	beq.n	80043d4 <xQueueGenericSendFromISR+0x5a>
 80043be:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043c2:	b672      	cpsid	i
 80043c4:	f383 8811 	msr	BASEPRI, r3
 80043c8:	f3bf 8f6f 	isb	sy
 80043cc:	f3bf 8f4f 	dsb	sy
 80043d0:	b662      	cpsie	i
 80043d2:	e7fe      	b.n	80043d2 <xQueueGenericSendFromISR+0x58>
 80043d4:	461f      	mov	r7, r3
 80043d6:	4690      	mov	r8, r2
 80043d8:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80043da:	f001 f98b 	bl	80056f4 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 80043de:	f3ef 8611 	mrs	r6, BASEPRI
 80043e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043e6:	b672      	cpsid	i
 80043e8:	f383 8811 	msr	BASEPRI, r3
 80043ec:	f3bf 8f6f 	isb	sy
 80043f0:	f3bf 8f4f 	dsb	sy
 80043f4:	b662      	cpsie	i
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80043f6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80043f8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80043fa:	429a      	cmp	r2, r3
 80043fc:	d303      	bcc.n	8004406 <xQueueGenericSendFromISR+0x8c>
 80043fe:	2f02      	cmp	r7, #2
 8004400:	d001      	beq.n	8004406 <xQueueGenericSendFromISR+0x8c>
			xReturn = errQUEUE_FULL;
 8004402:	2000      	movs	r0, #0
 8004404:	e00f      	b.n	8004426 <xQueueGenericSendFromISR+0xac>
			const int8_t cTxLock = pxQueue->cTxLock;
 8004406:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 800440a:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800440c:	463a      	mov	r2, r7
 800440e:	4649      	mov	r1, r9
 8004410:	4620      	mov	r0, r4
 8004412:	f7ff fdd4 	bl	8003fbe <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8004416:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
 800441a:	d008      	beq.n	800442e <xQueueGenericSendFromISR+0xb4>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800441c:	1c6b      	adds	r3, r5, #1
 800441e:	b25b      	sxtb	r3, r3
 8004420:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 8004424:	2001      	movs	r0, #1
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8004426:	f386 8811 	msr	BASEPRI, r6
}
 800442a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800442e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004430:	b15b      	cbz	r3, 800444a <xQueueGenericSendFromISR+0xd0>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004432:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004436:	f000 fdf9 	bl	800502c <xTaskRemoveFromEventList>
 800443a:	b140      	cbz	r0, 800444e <xQueueGenericSendFromISR+0xd4>
							if( pxHigherPriorityTaskWoken != NULL )
 800443c:	f1b8 0f00 	cmp.w	r8, #0
 8004440:	d007      	beq.n	8004452 <xQueueGenericSendFromISR+0xd8>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8004442:	2001      	movs	r0, #1
 8004444:	f8c8 0000 	str.w	r0, [r8]
 8004448:	e7ed      	b.n	8004426 <xQueueGenericSendFromISR+0xac>
			xReturn = pdPASS;
 800444a:	2001      	movs	r0, #1
 800444c:	e7eb      	b.n	8004426 <xQueueGenericSendFromISR+0xac>
 800444e:	2001      	movs	r0, #1
 8004450:	e7e9      	b.n	8004426 <xQueueGenericSendFromISR+0xac>
 8004452:	2001      	movs	r0, #1
 8004454:	e7e7      	b.n	8004426 <xQueueGenericSendFromISR+0xac>

08004456 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 8004456:	b170      	cbz	r0, 8004476 <xQueueGiveFromISR+0x20>
{
 8004458:	b570      	push	{r4, r5, r6, lr}
 800445a:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 800445c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800445e:	b1ab      	cbz	r3, 800448c <xQueueGiveFromISR+0x36>
	__asm volatile
 8004460:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004464:	b672      	cpsid	i
 8004466:	f383 8811 	msr	BASEPRI, r3
 800446a:	f3bf 8f6f 	isb	sy
 800446e:	f3bf 8f4f 	dsb	sy
 8004472:	b662      	cpsie	i
 8004474:	e7fe      	b.n	8004474 <xQueueGiveFromISR+0x1e>
 8004476:	f04f 0350 	mov.w	r3, #80	; 0x50
 800447a:	b672      	cpsid	i
 800447c:	f383 8811 	msr	BASEPRI, r3
 8004480:	f3bf 8f6f 	isb	sy
 8004484:	f3bf 8f4f 	dsb	sy
 8004488:	b662      	cpsie	i
 800448a:	e7fe      	b.n	800448a <xQueueGiveFromISR+0x34>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 800448c:	6803      	ldr	r3, [r0, #0]
 800448e:	b33b      	cbz	r3, 80044e0 <xQueueGiveFromISR+0x8a>
 8004490:	460e      	mov	r6, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004492:	f001 f92f 	bl	80056f4 <vPortValidateInterruptPriority>
	__asm volatile
 8004496:	f3ef 8511 	mrs	r5, BASEPRI
 800449a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800449e:	b672      	cpsid	i
 80044a0:	f383 8811 	msr	BASEPRI, r3
 80044a4:	f3bf 8f6f 	isb	sy
 80044a8:	f3bf 8f4f 	dsb	sy
 80044ac:	b662      	cpsie	i
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80044ae:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 80044b0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80044b2:	4293      	cmp	r3, r2
 80044b4:	d928      	bls.n	8004508 <xQueueGiveFromISR+0xb2>
			const int8_t cTxLock = pxQueue->cTxLock;
 80044b6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80044ba:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80044bc:	3201      	adds	r2, #1
 80044be:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 80044c0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80044c4:	d11a      	bne.n	80044fc <xQueueGiveFromISR+0xa6>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80044c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80044c8:	b303      	cbz	r3, 800450c <xQueueGiveFromISR+0xb6>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80044ca:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80044ce:	f000 fdad 	bl	800502c <xTaskRemoveFromEventList>
 80044d2:	b1e8      	cbz	r0, 8004510 <xQueueGiveFromISR+0xba>
							if( pxHigherPriorityTaskWoken != NULL )
 80044d4:	b1f6      	cbz	r6, 8004514 <xQueueGiveFromISR+0xbe>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80044d6:	2001      	movs	r0, #1
 80044d8:	6030      	str	r0, [r6, #0]
	__asm volatile
 80044da:	f385 8811 	msr	BASEPRI, r5
}
 80044de:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 80044e0:	6843      	ldr	r3, [r0, #4]
 80044e2:	2b00      	cmp	r3, #0
 80044e4:	d0d4      	beq.n	8004490 <xQueueGiveFromISR+0x3a>
	__asm volatile
 80044e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80044ea:	b672      	cpsid	i
 80044ec:	f383 8811 	msr	BASEPRI, r3
 80044f0:	f3bf 8f6f 	isb	sy
 80044f4:	f3bf 8f4f 	dsb	sy
 80044f8:	b662      	cpsie	i
 80044fa:	e7fe      	b.n	80044fa <xQueueGiveFromISR+0xa4>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80044fc:	3301      	adds	r3, #1
 80044fe:	b25b      	sxtb	r3, r3
 8004500:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 8004504:	2001      	movs	r0, #1
 8004506:	e7e8      	b.n	80044da <xQueueGiveFromISR+0x84>
			xReturn = errQUEUE_FULL;
 8004508:	2000      	movs	r0, #0
 800450a:	e7e6      	b.n	80044da <xQueueGiveFromISR+0x84>
			xReturn = pdPASS;
 800450c:	2001      	movs	r0, #1
 800450e:	e7e4      	b.n	80044da <xQueueGiveFromISR+0x84>
 8004510:	2001      	movs	r0, #1
 8004512:	e7e2      	b.n	80044da <xQueueGiveFromISR+0x84>
 8004514:	2001      	movs	r0, #1
 8004516:	e7e0      	b.n	80044da <xQueueGiveFromISR+0x84>

08004518 <xQueueReceive>:
{
 8004518:	b5f0      	push	{r4, r5, r6, r7, lr}
 800451a:	b085      	sub	sp, #20
 800451c:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 800451e:	b170      	cbz	r0, 800453e <xQueueReceive+0x26>
 8004520:	4604      	mov	r4, r0
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004522:	b9b9      	cbnz	r1, 8004554 <xQueueReceive+0x3c>
 8004524:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004526:	b1ab      	cbz	r3, 8004554 <xQueueReceive+0x3c>
 8004528:	f04f 0350 	mov.w	r3, #80	; 0x50
 800452c:	b672      	cpsid	i
 800452e:	f383 8811 	msr	BASEPRI, r3
 8004532:	f3bf 8f6f 	isb	sy
 8004536:	f3bf 8f4f 	dsb	sy
 800453a:	b662      	cpsie	i
 800453c:	e7fe      	b.n	800453c <xQueueReceive+0x24>
 800453e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004542:	b672      	cpsid	i
 8004544:	f383 8811 	msr	BASEPRI, r3
 8004548:	f3bf 8f6f 	isb	sy
 800454c:	f3bf 8f4f 	dsb	sy
 8004550:	b662      	cpsie	i
 8004552:	e7fe      	b.n	8004552 <xQueueReceive+0x3a>
 8004554:	460f      	mov	r7, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004556:	f000 fe11 	bl	800517c <xTaskGetSchedulerState>
 800455a:	b960      	cbnz	r0, 8004576 <xQueueReceive+0x5e>
 800455c:	9b01      	ldr	r3, [sp, #4]
 800455e:	b163      	cbz	r3, 800457a <xQueueReceive+0x62>
 8004560:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004564:	b672      	cpsid	i
 8004566:	f383 8811 	msr	BASEPRI, r3
 800456a:	f3bf 8f6f 	isb	sy
 800456e:	f3bf 8f4f 	dsb	sy
 8004572:	b662      	cpsie	i
 8004574:	e7fe      	b.n	8004574 <xQueueReceive+0x5c>
 8004576:	2600      	movs	r6, #0
 8004578:	e03e      	b.n	80045f8 <xQueueReceive+0xe0>
 800457a:	2600      	movs	r6, #0
 800457c:	e03c      	b.n	80045f8 <xQueueReceive+0xe0>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800457e:	4639      	mov	r1, r7
 8004580:	4620      	mov	r0, r4
 8004582:	f7ff fd57 	bl	8004034 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8004586:	3d01      	subs	r5, #1
 8004588:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800458a:	6923      	ldr	r3, [r4, #16]
 800458c:	b923      	cbnz	r3, 8004598 <xQueueReceive+0x80>
				taskEXIT_CRITICAL();
 800458e:	f000 ffcf 	bl	8005530 <vPortExitCritical>
				return pdPASS;
 8004592:	2001      	movs	r0, #1
}
 8004594:	b005      	add	sp, #20
 8004596:	bdf0      	pop	{r4, r5, r6, r7, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004598:	f104 0010 	add.w	r0, r4, #16
 800459c:	f000 fd46 	bl	800502c <xTaskRemoveFromEventList>
 80045a0:	2800      	cmp	r0, #0
 80045a2:	d0f4      	beq.n	800458e <xQueueReceive+0x76>
						queueYIELD_IF_USING_PREEMPTION();
 80045a4:	4b34      	ldr	r3, [pc, #208]	; (8004678 <xQueueReceive+0x160>)
 80045a6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80045aa:	601a      	str	r2, [r3, #0]
 80045ac:	f3bf 8f4f 	dsb	sy
 80045b0:	f3bf 8f6f 	isb	sy
 80045b4:	e7eb      	b.n	800458e <xQueueReceive+0x76>
					taskEXIT_CRITICAL();
 80045b6:	f000 ffbb 	bl	8005530 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80045ba:	2000      	movs	r0, #0
 80045bc:	e7ea      	b.n	8004594 <xQueueReceive+0x7c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80045be:	a802      	add	r0, sp, #8
 80045c0:	f000 fd78 	bl	80050b4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80045c4:	2601      	movs	r6, #1
 80045c6:	e021      	b.n	800460c <xQueueReceive+0xf4>
		prvLockQueue( pxQueue );
 80045c8:	2300      	movs	r3, #0
 80045ca:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80045ce:	e029      	b.n	8004624 <xQueueReceive+0x10c>
 80045d0:	2300      	movs	r3, #0
 80045d2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80045d6:	e02b      	b.n	8004630 <xQueueReceive+0x118>
				prvUnlockQueue( pxQueue );
 80045d8:	4620      	mov	r0, r4
 80045da:	f7ff fd3d 	bl	8004058 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80045de:	f000 fc29 	bl	8004e34 <xTaskResumeAll>
 80045e2:	e009      	b.n	80045f8 <xQueueReceive+0xe0>
			prvUnlockQueue( pxQueue );
 80045e4:	4620      	mov	r0, r4
 80045e6:	f7ff fd37 	bl	8004058 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80045ea:	f000 fc23 	bl	8004e34 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80045ee:	4620      	mov	r0, r4
 80045f0:	f7ff fcd8 	bl	8003fa4 <prvIsQueueEmpty>
 80045f4:	2800      	cmp	r0, #0
 80045f6:	d13d      	bne.n	8004674 <xQueueReceive+0x15c>
		taskENTER_CRITICAL();
 80045f8:	f000 ff74 	bl	80054e4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80045fc:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80045fe:	2d00      	cmp	r5, #0
 8004600:	d1bd      	bne.n	800457e <xQueueReceive+0x66>
				if( xTicksToWait == ( TickType_t ) 0 )
 8004602:	9b01      	ldr	r3, [sp, #4]
 8004604:	2b00      	cmp	r3, #0
 8004606:	d0d6      	beq.n	80045b6 <xQueueReceive+0x9e>
				else if( xEntryTimeSet == pdFALSE )
 8004608:	2e00      	cmp	r6, #0
 800460a:	d0d8      	beq.n	80045be <xQueueReceive+0xa6>
		taskEXIT_CRITICAL();
 800460c:	f000 ff90 	bl	8005530 <vPortExitCritical>
		vTaskSuspendAll();
 8004610:	f000 fb6e 	bl	8004cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8004614:	f000 ff66 	bl	80054e4 <vPortEnterCritical>
 8004618:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800461c:	b25b      	sxtb	r3, r3
 800461e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004622:	d0d1      	beq.n	80045c8 <xQueueReceive+0xb0>
 8004624:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004628:	b25b      	sxtb	r3, r3
 800462a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800462e:	d0cf      	beq.n	80045d0 <xQueueReceive+0xb8>
 8004630:	f000 ff7e 	bl	8005530 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8004634:	a901      	add	r1, sp, #4
 8004636:	a802      	add	r0, sp, #8
 8004638:	f000 fd46 	bl	80050c8 <xTaskCheckForTimeOut>
 800463c:	2800      	cmp	r0, #0
 800463e:	d1d1      	bne.n	80045e4 <xQueueReceive+0xcc>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004640:	4620      	mov	r0, r4
 8004642:	f7ff fcaf 	bl	8003fa4 <prvIsQueueEmpty>
 8004646:	2800      	cmp	r0, #0
 8004648:	d0c6      	beq.n	80045d8 <xQueueReceive+0xc0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800464a:	9901      	ldr	r1, [sp, #4]
 800464c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004650:	f000 fcd0 	bl	8004ff4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004654:	4620      	mov	r0, r4
 8004656:	f7ff fcff 	bl	8004058 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800465a:	f000 fbeb 	bl	8004e34 <xTaskResumeAll>
 800465e:	2800      	cmp	r0, #0
 8004660:	d1ca      	bne.n	80045f8 <xQueueReceive+0xe0>
					portYIELD_WITHIN_API();
 8004662:	4b05      	ldr	r3, [pc, #20]	; (8004678 <xQueueReceive+0x160>)
 8004664:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004668:	601a      	str	r2, [r3, #0]
 800466a:	f3bf 8f4f 	dsb	sy
 800466e:	f3bf 8f6f 	isb	sy
 8004672:	e7c1      	b.n	80045f8 <xQueueReceive+0xe0>
				return errQUEUE_EMPTY;
 8004674:	2000      	movs	r0, #0
 8004676:	e78d      	b.n	8004594 <xQueueReceive+0x7c>
 8004678:	e000ed04 	.word	0xe000ed04

0800467c <xQueueSemaphoreTake>:
{
 800467c:	b570      	push	{r4, r5, r6, lr}
 800467e:	b084      	sub	sp, #16
 8004680:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 8004682:	b950      	cbnz	r0, 800469a <xQueueSemaphoreTake+0x1e>
 8004684:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004688:	b672      	cpsid	i
 800468a:	f383 8811 	msr	BASEPRI, r3
 800468e:	f3bf 8f6f 	isb	sy
 8004692:	f3bf 8f4f 	dsb	sy
 8004696:	b662      	cpsie	i
 8004698:	e7fe      	b.n	8004698 <xQueueSemaphoreTake+0x1c>
 800469a:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 800469c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800469e:	b153      	cbz	r3, 80046b6 <xQueueSemaphoreTake+0x3a>
 80046a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046a4:	b672      	cpsid	i
 80046a6:	f383 8811 	msr	BASEPRI, r3
 80046aa:	f3bf 8f6f 	isb	sy
 80046ae:	f3bf 8f4f 	dsb	sy
 80046b2:	b662      	cpsie	i
 80046b4:	e7fe      	b.n	80046b4 <xQueueSemaphoreTake+0x38>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80046b6:	f000 fd61 	bl	800517c <xTaskGetSchedulerState>
 80046ba:	b960      	cbnz	r0, 80046d6 <xQueueSemaphoreTake+0x5a>
 80046bc:	9b01      	ldr	r3, [sp, #4]
 80046be:	b16b      	cbz	r3, 80046dc <xQueueSemaphoreTake+0x60>
 80046c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046c4:	b672      	cpsid	i
 80046c6:	f383 8811 	msr	BASEPRI, r3
 80046ca:	f3bf 8f6f 	isb	sy
 80046ce:	f3bf 8f4f 	dsb	sy
 80046d2:	b662      	cpsie	i
 80046d4:	e7fe      	b.n	80046d4 <xQueueSemaphoreTake+0x58>
 80046d6:	2500      	movs	r5, #0
 80046d8:	462e      	mov	r6, r5
 80046da:	e053      	b.n	8004784 <xQueueSemaphoreTake+0x108>
 80046dc:	2500      	movs	r5, #0
 80046de:	462e      	mov	r6, r5
 80046e0:	e050      	b.n	8004784 <xQueueSemaphoreTake+0x108>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 80046e2:	3b01      	subs	r3, #1
 80046e4:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80046e6:	6823      	ldr	r3, [r4, #0]
 80046e8:	b913      	cbnz	r3, 80046f0 <xQueueSemaphoreTake+0x74>
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 80046ea:	f000 fe7b 	bl	80053e4 <pvTaskIncrementMutexHeldCount>
 80046ee:	6060      	str	r0, [r4, #4]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80046f0:	6923      	ldr	r3, [r4, #16]
 80046f2:	b163      	cbz	r3, 800470e <xQueueSemaphoreTake+0x92>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80046f4:	f104 0010 	add.w	r0, r4, #16
 80046f8:	f000 fc98 	bl	800502c <xTaskRemoveFromEventList>
 80046fc:	b138      	cbz	r0, 800470e <xQueueSemaphoreTake+0x92>
						queueYIELD_IF_USING_PREEMPTION();
 80046fe:	4b49      	ldr	r3, [pc, #292]	; (8004824 <xQueueSemaphoreTake+0x1a8>)
 8004700:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004704:	601a      	str	r2, [r3, #0]
 8004706:	f3bf 8f4f 	dsb	sy
 800470a:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 800470e:	f000 ff0f 	bl	8005530 <vPortExitCritical>
				return pdPASS;
 8004712:	2501      	movs	r5, #1
}
 8004714:	4628      	mov	r0, r5
 8004716:	b004      	add	sp, #16
 8004718:	bd70      	pop	{r4, r5, r6, pc}
						configASSERT( xInheritanceOccurred == pdFALSE );
 800471a:	b155      	cbz	r5, 8004732 <xQueueSemaphoreTake+0xb6>
 800471c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004720:	b672      	cpsid	i
 8004722:	f383 8811 	msr	BASEPRI, r3
 8004726:	f3bf 8f6f 	isb	sy
 800472a:	f3bf 8f4f 	dsb	sy
 800472e:	b662      	cpsie	i
 8004730:	e7fe      	b.n	8004730 <xQueueSemaphoreTake+0xb4>
					taskEXIT_CRITICAL();
 8004732:	f000 fefd 	bl	8005530 <vPortExitCritical>
					return errQUEUE_EMPTY;
 8004736:	e7ed      	b.n	8004714 <xQueueSemaphoreTake+0x98>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8004738:	a802      	add	r0, sp, #8
 800473a:	f000 fcbb 	bl	80050b4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800473e:	2601      	movs	r6, #1
 8004740:	e02a      	b.n	8004798 <xQueueSemaphoreTake+0x11c>
		prvLockQueue( pxQueue );
 8004742:	2300      	movs	r3, #0
 8004744:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8004748:	e032      	b.n	80047b0 <xQueueSemaphoreTake+0x134>
 800474a:	2300      	movs	r3, #0
 800474c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8004750:	e034      	b.n	80047bc <xQueueSemaphoreTake+0x140>
						taskENTER_CRITICAL();
 8004752:	f000 fec7 	bl	80054e4 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8004756:	6860      	ldr	r0, [r4, #4]
 8004758:	f000 fd20 	bl	800519c <xTaskPriorityInherit>
 800475c:	4605      	mov	r5, r0
						taskEXIT_CRITICAL();
 800475e:	f000 fee7 	bl	8005530 <vPortExitCritical>
 8004762:	e03b      	b.n	80047dc <xQueueSemaphoreTake+0x160>
				prvUnlockQueue( pxQueue );
 8004764:	4620      	mov	r0, r4
 8004766:	f7ff fc77 	bl	8004058 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800476a:	f000 fb63 	bl	8004e34 <xTaskResumeAll>
 800476e:	e009      	b.n	8004784 <xQueueSemaphoreTake+0x108>
			prvUnlockQueue( pxQueue );
 8004770:	4620      	mov	r0, r4
 8004772:	f7ff fc71 	bl	8004058 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004776:	f000 fb5d 	bl	8004e34 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800477a:	4620      	mov	r0, r4
 800477c:	f7ff fc12 	bl	8003fa4 <prvIsQueueEmpty>
 8004780:	2800      	cmp	r0, #0
 8004782:	d140      	bne.n	8004806 <xQueueSemaphoreTake+0x18a>
		taskENTER_CRITICAL();
 8004784:	f000 feae 	bl	80054e4 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8004788:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 800478a:	2b00      	cmp	r3, #0
 800478c:	d1a9      	bne.n	80046e2 <xQueueSemaphoreTake+0x66>
				if( xTicksToWait == ( TickType_t ) 0 )
 800478e:	9b01      	ldr	r3, [sp, #4]
 8004790:	2b00      	cmp	r3, #0
 8004792:	d0c2      	beq.n	800471a <xQueueSemaphoreTake+0x9e>
				else if( xEntryTimeSet == pdFALSE )
 8004794:	2e00      	cmp	r6, #0
 8004796:	d0cf      	beq.n	8004738 <xQueueSemaphoreTake+0xbc>
		taskEXIT_CRITICAL();
 8004798:	f000 feca 	bl	8005530 <vPortExitCritical>
		vTaskSuspendAll();
 800479c:	f000 faa8 	bl	8004cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80047a0:	f000 fea0 	bl	80054e4 <vPortEnterCritical>
 80047a4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80047a8:	b25b      	sxtb	r3, r3
 80047aa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80047ae:	d0c8      	beq.n	8004742 <xQueueSemaphoreTake+0xc6>
 80047b0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80047b4:	b25b      	sxtb	r3, r3
 80047b6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80047ba:	d0c6      	beq.n	800474a <xQueueSemaphoreTake+0xce>
 80047bc:	f000 feb8 	bl	8005530 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80047c0:	a901      	add	r1, sp, #4
 80047c2:	a802      	add	r0, sp, #8
 80047c4:	f000 fc80 	bl	80050c8 <xTaskCheckForTimeOut>
 80047c8:	2800      	cmp	r0, #0
 80047ca:	d1d1      	bne.n	8004770 <xQueueSemaphoreTake+0xf4>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80047cc:	4620      	mov	r0, r4
 80047ce:	f7ff fbe9 	bl	8003fa4 <prvIsQueueEmpty>
 80047d2:	2800      	cmp	r0, #0
 80047d4:	d0c6      	beq.n	8004764 <xQueueSemaphoreTake+0xe8>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80047d6:	6823      	ldr	r3, [r4, #0]
 80047d8:	2b00      	cmp	r3, #0
 80047da:	d0ba      	beq.n	8004752 <xQueueSemaphoreTake+0xd6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80047dc:	9901      	ldr	r1, [sp, #4]
 80047de:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80047e2:	f000 fc07 	bl	8004ff4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80047e6:	4620      	mov	r0, r4
 80047e8:	f7ff fc36 	bl	8004058 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80047ec:	f000 fb22 	bl	8004e34 <xTaskResumeAll>
 80047f0:	2800      	cmp	r0, #0
 80047f2:	d1c7      	bne.n	8004784 <xQueueSemaphoreTake+0x108>
					portYIELD_WITHIN_API();
 80047f4:	4b0b      	ldr	r3, [pc, #44]	; (8004824 <xQueueSemaphoreTake+0x1a8>)
 80047f6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80047fa:	601a      	str	r2, [r3, #0]
 80047fc:	f3bf 8f4f 	dsb	sy
 8004800:	f3bf 8f6f 	isb	sy
 8004804:	e7be      	b.n	8004784 <xQueueSemaphoreTake+0x108>
					if( xInheritanceOccurred != pdFALSE )
 8004806:	2d00      	cmp	r5, #0
 8004808:	d084      	beq.n	8004714 <xQueueSemaphoreTake+0x98>
						taskENTER_CRITICAL();
 800480a:	f000 fe6b 	bl	80054e4 <vPortEnterCritical>
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 800480e:	4620      	mov	r0, r4
 8004810:	f7ff fbb0 	bl	8003f74 <prvGetDisinheritPriorityAfterTimeout>
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
 8004814:	4601      	mov	r1, r0
 8004816:	6860      	ldr	r0, [r4, #4]
 8004818:	f000 fd7e 	bl	8005318 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 800481c:	f000 fe88 	bl	8005530 <vPortExitCritical>
				return errQUEUE_EMPTY;
 8004820:	2500      	movs	r5, #0
 8004822:	e777      	b.n	8004714 <xQueueSemaphoreTake+0x98>
 8004824:	e000ed04 	.word	0xe000ed04

08004828 <xQueueReceiveFromISR>:
{
 8004828:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 800482c:	b170      	cbz	r0, 800484c <xQueueReceiveFromISR+0x24>
 800482e:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004830:	b9b9      	cbnz	r1, 8004862 <xQueueReceiveFromISR+0x3a>
 8004832:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004834:	b1ab      	cbz	r3, 8004862 <xQueueReceiveFromISR+0x3a>
 8004836:	f04f 0350 	mov.w	r3, #80	; 0x50
 800483a:	b672      	cpsid	i
 800483c:	f383 8811 	msr	BASEPRI, r3
 8004840:	f3bf 8f6f 	isb	sy
 8004844:	f3bf 8f4f 	dsb	sy
 8004848:	b662      	cpsie	i
 800484a:	e7fe      	b.n	800484a <xQueueReceiveFromISR+0x22>
 800484c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004850:	b672      	cpsid	i
 8004852:	f383 8811 	msr	BASEPRI, r3
 8004856:	f3bf 8f6f 	isb	sy
 800485a:	f3bf 8f4f 	dsb	sy
 800485e:	b662      	cpsie	i
 8004860:	e7fe      	b.n	8004860 <xQueueReceiveFromISR+0x38>
 8004862:	4617      	mov	r7, r2
 8004864:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004866:	f000 ff45 	bl	80056f4 <vPortValidateInterruptPriority>
	__asm volatile
 800486a:	f3ef 8611 	mrs	r6, BASEPRI
 800486e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004872:	b672      	cpsid	i
 8004874:	f383 8811 	msr	BASEPRI, r3
 8004878:	f3bf 8f6f 	isb	sy
 800487c:	f3bf 8f4f 	dsb	sy
 8004880:	b662      	cpsie	i
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004882:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004886:	f1b8 0f00 	cmp.w	r8, #0
 800488a:	d01d      	beq.n	80048c8 <xQueueReceiveFromISR+0xa0>
			const int8_t cRxLock = pxQueue->cRxLock;
 800488c:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8004890:	b26d      	sxtb	r5, r5
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8004892:	4649      	mov	r1, r9
 8004894:	4620      	mov	r0, r4
 8004896:	f7ff fbcd 	bl	8004034 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800489a:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
 800489e:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 80048a0:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
 80048a4:	d005      	beq.n	80048b2 <xQueueReceiveFromISR+0x8a>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 80048a6:	1c6b      	adds	r3, r5, #1
 80048a8:	b25b      	sxtb	r3, r3
 80048aa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
			xReturn = pdPASS;
 80048ae:	2001      	movs	r0, #1
 80048b0:	e00b      	b.n	80048ca <xQueueReceiveFromISR+0xa2>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80048b2:	6923      	ldr	r3, [r4, #16]
 80048b4:	b16b      	cbz	r3, 80048d2 <xQueueReceiveFromISR+0xaa>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80048b6:	f104 0010 	add.w	r0, r4, #16
 80048ba:	f000 fbb7 	bl	800502c <xTaskRemoveFromEventList>
 80048be:	b150      	cbz	r0, 80048d6 <xQueueReceiveFromISR+0xae>
						if( pxHigherPriorityTaskWoken != NULL )
 80048c0:	b15f      	cbz	r7, 80048da <xQueueReceiveFromISR+0xb2>
							*pxHigherPriorityTaskWoken = pdTRUE;
 80048c2:	2001      	movs	r0, #1
 80048c4:	6038      	str	r0, [r7, #0]
 80048c6:	e000      	b.n	80048ca <xQueueReceiveFromISR+0xa2>
			xReturn = pdFAIL;
 80048c8:	2000      	movs	r0, #0
	__asm volatile
 80048ca:	f386 8811 	msr	BASEPRI, r6
}
 80048ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			xReturn = pdPASS;
 80048d2:	2001      	movs	r0, #1
 80048d4:	e7f9      	b.n	80048ca <xQueueReceiveFromISR+0xa2>
 80048d6:	2001      	movs	r0, #1
 80048d8:	e7f7      	b.n	80048ca <xQueueReceiveFromISR+0xa2>
 80048da:	2001      	movs	r0, #1
 80048dc:	e7f5      	b.n	80048ca <xQueueReceiveFromISR+0xa2>
	...

080048e0 <vQueueUnregisterQueue>:
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80048e0:	2300      	movs	r3, #0
 80048e2:	2b07      	cmp	r3, #7
 80048e4:	d80f      	bhi.n	8004906 <vQueueUnregisterQueue+0x26>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 80048e6:	4a08      	ldr	r2, [pc, #32]	; (8004908 <vQueueUnregisterQueue+0x28>)
 80048e8:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 80048ec:	6852      	ldr	r2, [r2, #4]
 80048ee:	4282      	cmp	r2, r0
 80048f0:	d001      	beq.n	80048f6 <vQueueUnregisterQueue+0x16>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80048f2:	3301      	adds	r3, #1
 80048f4:	e7f5      	b.n	80048e2 <vQueueUnregisterQueue+0x2>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 80048f6:	4a04      	ldr	r2, [pc, #16]	; (8004908 <vQueueUnregisterQueue+0x28>)
 80048f8:	2100      	movs	r1, #0
 80048fa:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 80048fe:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8004902:	6059      	str	r1, [r3, #4]
				break;
 8004904:	4770      	bx	lr
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8004906:	4770      	bx	lr
 8004908:	200059ec 	.word	0x200059ec

0800490c <vQueueDelete>:
	configASSERT( pxQueue );
 800490c:	b950      	cbnz	r0, 8004924 <vQueueDelete+0x18>
	__asm volatile
 800490e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004912:	b672      	cpsid	i
 8004914:	f383 8811 	msr	BASEPRI, r3
 8004918:	f3bf 8f6f 	isb	sy
 800491c:	f3bf 8f4f 	dsb	sy
 8004920:	b662      	cpsie	i
 8004922:	e7fe      	b.n	8004922 <vQueueDelete+0x16>
{
 8004924:	b510      	push	{r4, lr}
 8004926:	4604      	mov	r4, r0
		vQueueUnregisterQueue( pxQueue );
 8004928:	f7ff ffda 	bl	80048e0 <vQueueUnregisterQueue>
		vPortFree( pxQueue );
 800492c:	4620      	mov	r0, r4
 800492e:	f000 ffef 	bl	8005910 <vPortFree>
}
 8004932:	bd10      	pop	{r4, pc}

08004934 <prvTaskCheckFreeStackSpace>:

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;
 8004934:	2300      	movs	r3, #0

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8004936:	e001      	b.n	800493c <prvTaskCheckFreeStackSpace+0x8>
		{
			pucStackByte -= portSTACK_GROWTH;
 8004938:	3001      	adds	r0, #1
			ulCount++;
 800493a:	3301      	adds	r3, #1
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 800493c:	7802      	ldrb	r2, [r0, #0]
 800493e:	2aa5      	cmp	r2, #165	; 0xa5
 8004940:	d0fa      	beq.n	8004938 <prvTaskCheckFreeStackSpace+0x4>
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

		return ( uint16_t ) ulCount;
	}
 8004942:	f3c3 008f 	ubfx	r0, r3, #2, #16
 8004946:	4770      	bx	lr

08004948 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004948:	4b07      	ldr	r3, [pc, #28]	; (8004968 <prvResetNextTaskUnblockTime+0x20>)
 800494a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800494c:	681b      	ldr	r3, [r3, #0]
 800494e:	b133      	cbz	r3, 800495e <prvResetNextTaskUnblockTime+0x16>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004950:	4b05      	ldr	r3, [pc, #20]	; (8004968 <prvResetNextTaskUnblockTime+0x20>)
 8004952:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004954:	68d2      	ldr	r2, [r2, #12]
 8004956:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8004958:	6852      	ldr	r2, [r2, #4]
 800495a:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
 800495c:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
 800495e:	4b02      	ldr	r3, [pc, #8]	; (8004968 <prvResetNextTaskUnblockTime+0x20>)
 8004960:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004964:	62da      	str	r2, [r3, #44]	; 0x2c
 8004966:	4770      	bx	lr
 8004968:	2000009c 	.word	0x2000009c

0800496c <prvDeleteTCB>:
	{
 800496c:	b510      	push	{r4, lr}
 800496e:	4604      	mov	r4, r0
			vPortFree( pxTCB->pxStack );
 8004970:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8004972:	f000 ffcd 	bl	8005910 <vPortFree>
			vPortFree( pxTCB );
 8004976:	4620      	mov	r0, r4
 8004978:	f000 ffca 	bl	8005910 <vPortFree>
	}
 800497c:	bd10      	pop	{r4, pc}

0800497e <prvInitialiseNewTask>:
{
 800497e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004982:	4681      	mov	r9, r0
 8004984:	460d      	mov	r5, r1
 8004986:	4693      	mov	fp, r2
 8004988:	469a      	mov	sl, r3
 800498a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800498c:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8004990:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8004992:	0092      	lsls	r2, r2, #2
 8004994:	21a5      	movs	r1, #165	; 0xa5
 8004996:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004998:	f00a fd80 	bl	800f49c <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800499c:	6b27      	ldr	r7, [r4, #48]	; 0x30
 800499e:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 80049a2:	445b      	add	r3, fp
 80049a4:	eb07 0783 	add.w	r7, r7, r3, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80049a8:	f027 0707 	bic.w	r7, r7, #7
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80049ac:	2300      	movs	r3, #0
 80049ae:	2b0f      	cmp	r3, #15
 80049b0:	d807      	bhi.n	80049c2 <prvInitialiseNewTask+0x44>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80049b2:	5ce9      	ldrb	r1, [r5, r3]
 80049b4:	18e2      	adds	r2, r4, r3
 80049b6:	f882 1034 	strb.w	r1, [r2, #52]	; 0x34
		if( pcName[ x ] == 0x00 )
 80049ba:	5cea      	ldrb	r2, [r5, r3]
 80049bc:	b10a      	cbz	r2, 80049c2 <prvInitialiseNewTask+0x44>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80049be:	3301      	adds	r3, #1
 80049c0:	e7f5      	b.n	80049ae <prvInitialiseNewTask+0x30>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80049c2:	2300      	movs	r3, #0
 80049c4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80049c8:	2e06      	cmp	r6, #6
 80049ca:	d900      	bls.n	80049ce <prvInitialiseNewTask+0x50>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 80049cc:	2606      	movs	r6, #6
	pxNewTCB->uxPriority = uxPriority;
 80049ce:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 80049d0:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 80049d2:	2500      	movs	r5, #0
 80049d4:	6525      	str	r5, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80049d6:	1d20      	adds	r0, r4, #4
 80049d8:	f7ff fa8f 	bl	8003efa <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80049dc:	f104 0018 	add.w	r0, r4, #24
 80049e0:	f7ff fa8b 	bl	8003efa <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80049e4:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80049e6:	f1c6 0607 	rsb	r6, r6, #7
 80049ea:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80049ec:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 80049ee:	6565      	str	r5, [r4, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80049f0:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80049f4:	4652      	mov	r2, sl
 80049f6:	4649      	mov	r1, r9
 80049f8:	4638      	mov	r0, r7
 80049fa:	f000 fd45 	bl	8005488 <pxPortInitialiseStack>
 80049fe:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8004a00:	f1b8 0f00 	cmp.w	r8, #0
 8004a04:	d001      	beq.n	8004a0a <prvInitialiseNewTask+0x8c>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8004a06:	f8c8 4000 	str.w	r4, [r8]
}
 8004a0a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08004a10 <prvInitialiseTaskLists>:
{
 8004a10:	b570      	push	{r4, r5, r6, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8004a12:	2400      	movs	r4, #0
 8004a14:	e007      	b.n	8004a26 <prvInitialiseTaskLists+0x16>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8004a16:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8004a1a:	0093      	lsls	r3, r2, #2
 8004a1c:	4810      	ldr	r0, [pc, #64]	; (8004a60 <prvInitialiseTaskLists+0x50>)
 8004a1e:	4418      	add	r0, r3
 8004a20:	f7ff fa60 	bl	8003ee4 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8004a24:	3401      	adds	r4, #1
 8004a26:	2c06      	cmp	r4, #6
 8004a28:	d9f5      	bls.n	8004a16 <prvInitialiseTaskLists+0x6>
	vListInitialise( &xDelayedTaskList1 );
 8004a2a:	4c0e      	ldr	r4, [pc, #56]	; (8004a64 <prvInitialiseTaskLists+0x54>)
 8004a2c:	f104 06bc 	add.w	r6, r4, #188	; 0xbc
 8004a30:	4630      	mov	r0, r6
 8004a32:	f7ff fa57 	bl	8003ee4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8004a36:	f104 05d0 	add.w	r5, r4, #208	; 0xd0
 8004a3a:	4628      	mov	r0, r5
 8004a3c:	f7ff fa52 	bl	8003ee4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8004a40:	f104 0014 	add.w	r0, r4, #20
 8004a44:	f7ff fa4e 	bl	8003ee4 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8004a48:	f104 00e4 	add.w	r0, r4, #228	; 0xe4
 8004a4c:	f7ff fa4a 	bl	8003ee4 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8004a50:	4620      	mov	r0, r4
 8004a52:	f7ff fa47 	bl	8003ee4 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8004a56:	62a6      	str	r6, [r4, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8004a58:	f8c4 50f8 	str.w	r5, [r4, #248]	; 0xf8
}
 8004a5c:	bd70      	pop	{r4, r5, r6, pc}
 8004a5e:	bf00      	nop
 8004a60:	200000cc 	.word	0x200000cc
 8004a64:	2000009c 	.word	0x2000009c

08004a68 <prvAddNewTaskToReadyList>:
{
 8004a68:	b538      	push	{r3, r4, r5, lr}
 8004a6a:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 8004a6c:	f000 fd3a 	bl	80054e4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8004a70:	4b26      	ldr	r3, [pc, #152]	; (8004b0c <prvAddNewTaskToReadyList+0xa4>)
 8004a72:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
 8004a76:	3201      	adds	r2, #1
 8004a78:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
		if( pxCurrentTCB == NULL )
 8004a7c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8004a80:	b173      	cbz	r3, 8004aa0 <prvAddNewTaskToReadyList+0x38>
			if( xSchedulerRunning == pdFALSE )
 8004a82:	4b22      	ldr	r3, [pc, #136]	; (8004b0c <prvAddNewTaskToReadyList+0xa4>)
 8004a84:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8004a88:	b98b      	cbnz	r3, 8004aae <prvAddNewTaskToReadyList+0x46>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8004a8a:	4b20      	ldr	r3, [pc, #128]	; (8004b0c <prvAddNewTaskToReadyList+0xa4>)
 8004a8c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8004a90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004a92:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004a94:	429a      	cmp	r2, r3
 8004a96:	d80a      	bhi.n	8004aae <prvAddNewTaskToReadyList+0x46>
					pxCurrentTCB = pxNewTCB;
 8004a98:	4b1c      	ldr	r3, [pc, #112]	; (8004b0c <prvAddNewTaskToReadyList+0xa4>)
 8004a9a:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
 8004a9e:	e006      	b.n	8004aae <prvAddNewTaskToReadyList+0x46>
			pxCurrentTCB = pxNewTCB;
 8004aa0:	4b1a      	ldr	r3, [pc, #104]	; (8004b0c <prvAddNewTaskToReadyList+0xa4>)
 8004aa2:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8004aa6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8004aaa:	2b01      	cmp	r3, #1
 8004aac:	d02b      	beq.n	8004b06 <prvAddNewTaskToReadyList+0x9e>
		uxTaskNumber++;
 8004aae:	4c17      	ldr	r4, [pc, #92]	; (8004b0c <prvAddNewTaskToReadyList+0xa4>)
 8004ab0:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
 8004ab4:	3301      	adds	r3, #1
 8004ab6:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8004aba:	646b      	str	r3, [r5, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8004abc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004abe:	2201      	movs	r2, #1
 8004ac0:	409a      	lsls	r2, r3
 8004ac2:	f8d4 110c 	ldr.w	r1, [r4, #268]	; 0x10c
 8004ac6:	430a      	orrs	r2, r1
 8004ac8:	f8c4 210c 	str.w	r2, [r4, #268]	; 0x10c
 8004acc:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8004ad0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004ad4:	009a      	lsls	r2, r3, #2
 8004ad6:	1d29      	adds	r1, r5, #4
 8004ad8:	4410      	add	r0, r2
 8004ada:	f7ff fa11 	bl	8003f00 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8004ade:	f000 fd27 	bl	8005530 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8004ae2:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 8004ae6:	b16b      	cbz	r3, 8004b04 <prvAddNewTaskToReadyList+0x9c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8004ae8:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8004aec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004aee:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004af0:	429a      	cmp	r2, r3
 8004af2:	d207      	bcs.n	8004b04 <prvAddNewTaskToReadyList+0x9c>
			taskYIELD_IF_USING_PREEMPTION();
 8004af4:	4b06      	ldr	r3, [pc, #24]	; (8004b10 <prvAddNewTaskToReadyList+0xa8>)
 8004af6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004afa:	601a      	str	r2, [r3, #0]
 8004afc:	f3bf 8f4f 	dsb	sy
 8004b00:	f3bf 8f6f 	isb	sy
}
 8004b04:	bd38      	pop	{r3, r4, r5, pc}
				prvInitialiseTaskLists();
 8004b06:	f7ff ff83 	bl	8004a10 <prvInitialiseTaskLists>
 8004b0a:	e7d0      	b.n	8004aae <prvAddNewTaskToReadyList+0x46>
 8004b0c:	2000009c 	.word	0x2000009c
 8004b10:	e000ed04 	.word	0xe000ed04

08004b14 <prvCheckTasksWaitingTermination>:
{
 8004b14:	b538      	push	{r3, r4, r5, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004b16:	e017      	b.n	8004b48 <prvCheckTasksWaitingTermination+0x34>
			taskENTER_CRITICAL();
 8004b18:	f000 fce4 	bl	80054e4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8004b1c:	4c0d      	ldr	r4, [pc, #52]	; (8004b54 <prvCheckTasksWaitingTermination+0x40>)
 8004b1e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 8004b22:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004b24:	1d28      	adds	r0, r5, #4
 8004b26:	f7ff fa11 	bl	8003f4c <uxListRemove>
				--uxCurrentNumberOfTasks;
 8004b2a:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8004b2e:	3b01      	subs	r3, #1
 8004b30:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
				--uxDeletedTasksWaitingCleanUp;
 8004b34:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8004b38:	3b01      	subs	r3, #1
 8004b3a:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
			taskEXIT_CRITICAL();
 8004b3e:	f000 fcf7 	bl	8005530 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 8004b42:	4628      	mov	r0, r5
 8004b44:	f7ff ff12 	bl	800496c <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004b48:	4b02      	ldr	r3, [pc, #8]	; (8004b54 <prvCheckTasksWaitingTermination+0x40>)
 8004b4a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8004b4e:	2b00      	cmp	r3, #0
 8004b50:	d1e2      	bne.n	8004b18 <prvCheckTasksWaitingTermination+0x4>
}
 8004b52:	bd38      	pop	{r3, r4, r5, pc}
 8004b54:	2000009c 	.word	0x2000009c

08004b58 <prvIdleTask>:
{
 8004b58:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 8004b5a:	f7ff ffdb 	bl	8004b14 <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8004b5e:	4b06      	ldr	r3, [pc, #24]	; (8004b78 <prvIdleTask+0x20>)
 8004b60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004b62:	2b01      	cmp	r3, #1
 8004b64:	d9f9      	bls.n	8004b5a <prvIdleTask+0x2>
				taskYIELD();
 8004b66:	4b05      	ldr	r3, [pc, #20]	; (8004b7c <prvIdleTask+0x24>)
 8004b68:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004b6c:	601a      	str	r2, [r3, #0]
 8004b6e:	f3bf 8f4f 	dsb	sy
 8004b72:	f3bf 8f6f 	isb	sy
 8004b76:	e7f0      	b.n	8004b5a <prvIdleTask+0x2>
 8004b78:	2000009c 	.word	0x2000009c
 8004b7c:	e000ed04 	.word	0xe000ed04

08004b80 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8004b80:	b570      	push	{r4, r5, r6, lr}
 8004b82:	4604      	mov	r4, r0
 8004b84:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8004b86:	4b21      	ldr	r3, [pc, #132]	; (8004c0c <prvAddCurrentTaskToDelayedList+0x8c>)
 8004b88:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004b8c:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
 8004b90:	3004      	adds	r0, #4
 8004b92:	f7ff f9db 	bl	8003f4c <uxListRemove>
 8004b96:	b960      	cbnz	r0, 8004bb2 <prvAddCurrentTaskToDelayedList+0x32>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8004b98:	4b1c      	ldr	r3, [pc, #112]	; (8004c0c <prvAddCurrentTaskToDelayedList+0x8c>)
 8004b9a:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 8004b9e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8004ba0:	2201      	movs	r2, #1
 8004ba2:	fa02 f101 	lsl.w	r1, r2, r1
 8004ba6:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8004baa:	ea22 0201 	bic.w	r2, r2, r1
 8004bae:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8004bb2:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 8004bb6:	bf14      	ite	ne
 8004bb8:	2300      	movne	r3, #0
 8004bba:	2301      	moveq	r3, #1
 8004bbc:	2e00      	cmp	r6, #0
 8004bbe:	bf08      	it	eq
 8004bc0:	2300      	moveq	r3, #0
 8004bc2:	b993      	cbnz	r3, 8004bea <prvAddCurrentTaskToDelayedList+0x6a>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8004bc4:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8004bc6:	4b11      	ldr	r3, [pc, #68]	; (8004c0c <prvAddCurrentTaskToDelayedList+0x8c>)
 8004bc8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8004bcc:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8004bce:	42a5      	cmp	r5, r4
 8004bd0:	d812      	bhi.n	8004bf8 <prvAddCurrentTaskToDelayedList+0x78>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004bd2:	4d0e      	ldr	r5, [pc, #56]	; (8004c0c <prvAddCurrentTaskToDelayedList+0x8c>)
 8004bd4:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8004bd6:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
 8004bda:	3104      	adds	r1, #4
 8004bdc:	f7ff f99c 	bl	8003f18 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 8004be0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004be2:	42a3      	cmp	r3, r4
 8004be4:	d910      	bls.n	8004c08 <prvAddCurrentTaskToDelayedList+0x88>
				{
					xNextTaskUnblockTime = xTimeToWake;
 8004be6:	62ec      	str	r4, [r5, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8004be8:	e00e      	b.n	8004c08 <prvAddCurrentTaskToDelayedList+0x88>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004bea:	4808      	ldr	r0, [pc, #32]	; (8004c0c <prvAddCurrentTaskToDelayedList+0x8c>)
 8004bec:	f8d0 1100 	ldr.w	r1, [r0, #256]	; 0x100
 8004bf0:	3104      	adds	r1, #4
 8004bf2:	f7ff f985 	bl	8003f00 <vListInsertEnd>
 8004bf6:	e007      	b.n	8004c08 <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004bf8:	4b04      	ldr	r3, [pc, #16]	; (8004c0c <prvAddCurrentTaskToDelayedList+0x8c>)
 8004bfa:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
 8004bfe:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
 8004c02:	3104      	adds	r1, #4
 8004c04:	f7ff f988 	bl	8003f18 <vListInsert>
}
 8004c08:	bd70      	pop	{r4, r5, r6, pc}
 8004c0a:	bf00      	nop
 8004c0c:	2000009c 	.word	0x2000009c

08004c10 <xTaskCreate>:
	{
 8004c10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004c14:	b085      	sub	sp, #20
 8004c16:	4607      	mov	r7, r0
 8004c18:	4688      	mov	r8, r1
 8004c1a:	4615      	mov	r5, r2
 8004c1c:	4699      	mov	r9, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004c1e:	0090      	lsls	r0, r2, #2
 8004c20:	f000 fdea 	bl	80057f8 <pvPortMalloc>
			if( pxStack != NULL )
 8004c24:	b1f8      	cbz	r0, 8004c66 <xTaskCreate+0x56>
 8004c26:	4606      	mov	r6, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8004c28:	205c      	movs	r0, #92	; 0x5c
 8004c2a:	f000 fde5 	bl	80057f8 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8004c2e:	4604      	mov	r4, r0
 8004c30:	b1a8      	cbz	r0, 8004c5e <xTaskCreate+0x4e>
					pxNewTCB->pxStack = pxStack;
 8004c32:	6306      	str	r6, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
 8004c34:	b1d4      	cbz	r4, 8004c6c <xTaskCreate+0x5c>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8004c36:	2300      	movs	r3, #0
 8004c38:	9303      	str	r3, [sp, #12]
 8004c3a:	9402      	str	r4, [sp, #8]
 8004c3c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004c3e:	9301      	str	r3, [sp, #4]
 8004c40:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004c42:	9300      	str	r3, [sp, #0]
 8004c44:	464b      	mov	r3, r9
 8004c46:	462a      	mov	r2, r5
 8004c48:	4641      	mov	r1, r8
 8004c4a:	4638      	mov	r0, r7
 8004c4c:	f7ff fe97 	bl	800497e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8004c50:	4620      	mov	r0, r4
 8004c52:	f7ff ff09 	bl	8004a68 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8004c56:	2001      	movs	r0, #1
	}
 8004c58:	b005      	add	sp, #20
 8004c5a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 8004c5e:	4630      	mov	r0, r6
 8004c60:	f000 fe56 	bl	8005910 <vPortFree>
 8004c64:	e7e6      	b.n	8004c34 <xTaskCreate+0x24>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004c66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004c6a:	e7f5      	b.n	8004c58 <xTaskCreate+0x48>
 8004c6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return xReturn;
 8004c70:	e7f2      	b.n	8004c58 <xTaskCreate+0x48>
	...

08004c74 <vTaskStartScheduler>:
{
 8004c74:	b500      	push	{lr}
 8004c76:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 8004c78:	4b19      	ldr	r3, [pc, #100]	; (8004ce0 <vTaskStartScheduler+0x6c>)
 8004c7a:	9301      	str	r3, [sp, #4]
 8004c7c:	2300      	movs	r3, #0
 8004c7e:	9300      	str	r3, [sp, #0]
 8004c80:	2280      	movs	r2, #128	; 0x80
 8004c82:	4918      	ldr	r1, [pc, #96]	; (8004ce4 <vTaskStartScheduler+0x70>)
 8004c84:	4818      	ldr	r0, [pc, #96]	; (8004ce8 <vTaskStartScheduler+0x74>)
 8004c86:	f7ff ffc3 	bl	8004c10 <xTaskCreate>
	if( xReturn == pdPASS )
 8004c8a:	2801      	cmp	r0, #1
 8004c8c:	d005      	beq.n	8004c9a <vTaskStartScheduler+0x26>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8004c8e:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8004c92:	d019      	beq.n	8004cc8 <vTaskStartScheduler+0x54>
}
 8004c94:	b003      	add	sp, #12
 8004c96:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c9e:	b672      	cpsid	i
 8004ca0:	f383 8811 	msr	BASEPRI, r3
 8004ca4:	f3bf 8f6f 	isb	sy
 8004ca8:	f3bf 8f4f 	dsb	sy
 8004cac:	b662      	cpsie	i
		xNextTaskUnblockTime = portMAX_DELAY;
 8004cae:	4b0f      	ldr	r3, [pc, #60]	; (8004cec <vTaskStartScheduler+0x78>)
 8004cb0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004cb4:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
 8004cb6:	2201      	movs	r2, #1
 8004cb8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		xTickCount = ( TickType_t ) 0U;
 8004cbc:	2200      	movs	r2, #0
 8004cbe:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
		if( xPortStartScheduler() != pdFALSE )
 8004cc2:	f000 fcb3 	bl	800562c <xPortStartScheduler>
 8004cc6:	e7e5      	b.n	8004c94 <vTaskStartScheduler+0x20>
 8004cc8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ccc:	b672      	cpsid	i
 8004cce:	f383 8811 	msr	BASEPRI, r3
 8004cd2:	f3bf 8f6f 	isb	sy
 8004cd6:	f3bf 8f4f 	dsb	sy
 8004cda:	b662      	cpsie	i
 8004cdc:	e7fe      	b.n	8004cdc <vTaskStartScheduler+0x68>
 8004cde:	bf00      	nop
 8004ce0:	200001b8 	.word	0x200001b8
 8004ce4:	0801099c 	.word	0x0801099c
 8004ce8:	08004b59 	.word	0x08004b59
 8004cec:	2000009c 	.word	0x2000009c

08004cf0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8004cf0:	4a03      	ldr	r2, [pc, #12]	; (8004d00 <vTaskSuspendAll+0x10>)
 8004cf2:	f8d2 3118 	ldr.w	r3, [r2, #280]	; 0x118
 8004cf6:	3301      	adds	r3, #1
 8004cf8:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
}
 8004cfc:	4770      	bx	lr
 8004cfe:	bf00      	nop
 8004d00:	2000009c 	.word	0x2000009c

08004d04 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8004d04:	4b01      	ldr	r3, [pc, #4]	; (8004d0c <xTaskGetTickCount+0x8>)
 8004d06:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
 8004d0a:	4770      	bx	lr
 8004d0c:	2000009c 	.word	0x2000009c

08004d10 <xTaskGetTickCountFromISR>:
{
 8004d10:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004d12:	f000 fcef 	bl	80056f4 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8004d16:	4b02      	ldr	r3, [pc, #8]	; (8004d20 <xTaskGetTickCountFromISR+0x10>)
 8004d18:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
 8004d1c:	bd08      	pop	{r3, pc}
 8004d1e:	bf00      	nop
 8004d20:	2000009c 	.word	0x2000009c

08004d24 <xTaskIncrementTick>:
{
 8004d24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004d28:	4b41      	ldr	r3, [pc, #260]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004d2a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8004d2e:	2b00      	cmp	r3, #0
 8004d30:	d16e      	bne.n	8004e10 <xTaskIncrementTick+0xec>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8004d32:	4b3f      	ldr	r3, [pc, #252]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004d34:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
 8004d38:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 8004d3a:	f8c3 5114 	str.w	r5, [r3, #276]	; 0x114
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8004d3e:	b9dd      	cbnz	r5, 8004d78 <xTaskIncrementTick+0x54>
			taskSWITCH_DELAYED_LISTS();
 8004d40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004d42:	681b      	ldr	r3, [r3, #0]
 8004d44:	b153      	cbz	r3, 8004d5c <xTaskIncrementTick+0x38>
 8004d46:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d4a:	b672      	cpsid	i
 8004d4c:	f383 8811 	msr	BASEPRI, r3
 8004d50:	f3bf 8f6f 	isb	sy
 8004d54:	f3bf 8f4f 	dsb	sy
 8004d58:	b662      	cpsie	i
 8004d5a:	e7fe      	b.n	8004d5a <xTaskIncrementTick+0x36>
 8004d5c:	4b34      	ldr	r3, [pc, #208]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004d5e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004d60:	f8d3 10f8 	ldr.w	r1, [r3, #248]	; 0xf8
 8004d64:	6299      	str	r1, [r3, #40]	; 0x28
 8004d66:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
 8004d6a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
 8004d6e:	3201      	adds	r2, #1
 8004d70:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
 8004d74:	f7ff fde8 	bl	8004948 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8004d78:	4b2d      	ldr	r3, [pc, #180]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004d7a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004d7c:	42ab      	cmp	r3, r5
 8004d7e:	d93d      	bls.n	8004dfc <xTaskIncrementTick+0xd8>
BaseType_t xSwitchRequired = pdFALSE;
 8004d80:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8004d82:	4a2b      	ldr	r2, [pc, #172]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004d84:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
 8004d88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004d8a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004d8e:	0099      	lsls	r1, r3, #2
 8004d90:	440a      	add	r2, r1
 8004d92:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004d94:	2b01      	cmp	r3, #1
 8004d96:	d942      	bls.n	8004e1e <xTaskIncrementTick+0xfa>
				xSwitchRequired = pdTRUE;
 8004d98:	2401      	movs	r4, #1
 8004d9a:	e040      	b.n	8004e1e <xTaskIncrementTick+0xfa>
							xSwitchRequired = pdTRUE;
 8004d9c:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004d9e:	4b24      	ldr	r3, [pc, #144]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004da0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004da2:	681b      	ldr	r3, [r3, #0]
 8004da4:	b363      	cbz	r3, 8004e00 <xTaskIncrementTick+0xdc>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004da6:	4b22      	ldr	r3, [pc, #136]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004da8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004daa:	68db      	ldr	r3, [r3, #12]
 8004dac:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8004dae:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
 8004db0:	429d      	cmp	r5, r3
 8004db2:	d32a      	bcc.n	8004e0a <xTaskIncrementTick+0xe6>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004db4:	f106 0804 	add.w	r8, r6, #4
 8004db8:	4640      	mov	r0, r8
 8004dba:	f7ff f8c7 	bl	8003f4c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004dbe:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8004dc0:	b11b      	cbz	r3, 8004dca <xTaskIncrementTick+0xa6>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004dc2:	f106 0018 	add.w	r0, r6, #24
 8004dc6:	f7ff f8c1 	bl	8003f4c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004dca:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8004dcc:	2201      	movs	r2, #1
 8004dce:	409a      	lsls	r2, r3
 8004dd0:	4f17      	ldr	r7, [pc, #92]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004dd2:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
 8004dd6:	430a      	orrs	r2, r1
 8004dd8:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
 8004ddc:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8004de0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004de4:	009a      	lsls	r2, r3, #2
 8004de6:	4641      	mov	r1, r8
 8004de8:	4410      	add	r0, r2
 8004dea:	f7ff f889 	bl	8003f00 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004dee:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8004df0:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8004df4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004df6:	429a      	cmp	r2, r3
 8004df8:	d2d0      	bcs.n	8004d9c <xTaskIncrementTick+0x78>
 8004dfa:	e7d0      	b.n	8004d9e <xTaskIncrementTick+0x7a>
BaseType_t xSwitchRequired = pdFALSE;
 8004dfc:	2400      	movs	r4, #0
 8004dfe:	e7ce      	b.n	8004d9e <xTaskIncrementTick+0x7a>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004e00:	4b0b      	ldr	r3, [pc, #44]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004e02:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004e06:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
 8004e08:	e7bb      	b.n	8004d82 <xTaskIncrementTick+0x5e>
						xNextTaskUnblockTime = xItemValue;
 8004e0a:	4a09      	ldr	r2, [pc, #36]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004e0c:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
 8004e0e:	e7b8      	b.n	8004d82 <xTaskIncrementTick+0x5e>
		++uxPendedTicks;
 8004e10:	4a07      	ldr	r2, [pc, #28]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004e12:	f8d2 3124 	ldr.w	r3, [r2, #292]	; 0x124
 8004e16:	3301      	adds	r3, #1
 8004e18:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124
BaseType_t xSwitchRequired = pdFALSE;
 8004e1c:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
 8004e1e:	4b04      	ldr	r3, [pc, #16]	; (8004e30 <xTaskIncrementTick+0x10c>)
 8004e20:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 8004e24:	b103      	cbz	r3, 8004e28 <xTaskIncrementTick+0x104>
			xSwitchRequired = pdTRUE;
 8004e26:	2401      	movs	r4, #1
}
 8004e28:	4620      	mov	r0, r4
 8004e2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004e2e:	bf00      	nop
 8004e30:	2000009c 	.word	0x2000009c

08004e34 <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 8004e34:	4b3a      	ldr	r3, [pc, #232]	; (8004f20 <xTaskResumeAll+0xec>)
 8004e36:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8004e3a:	b953      	cbnz	r3, 8004e52 <xTaskResumeAll+0x1e>
 8004e3c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004e40:	b672      	cpsid	i
 8004e42:	f383 8811 	msr	BASEPRI, r3
 8004e46:	f3bf 8f6f 	isb	sy
 8004e4a:	f3bf 8f4f 	dsb	sy
 8004e4e:	b662      	cpsie	i
 8004e50:	e7fe      	b.n	8004e50 <xTaskResumeAll+0x1c>
{
 8004e52:	b570      	push	{r4, r5, r6, lr}
	taskENTER_CRITICAL();
 8004e54:	f000 fb46 	bl	80054e4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8004e58:	4b31      	ldr	r3, [pc, #196]	; (8004f20 <xTaskResumeAll+0xec>)
 8004e5a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8004e5e:	3a01      	subs	r2, #1
 8004e60:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004e64:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8004e68:	2b00      	cmp	r3, #0
 8004e6a:	d154      	bne.n	8004f16 <xTaskResumeAll+0xe2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8004e6c:	4b2c      	ldr	r3, [pc, #176]	; (8004f20 <xTaskResumeAll+0xec>)
 8004e6e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8004e72:	b923      	cbnz	r3, 8004e7e <xTaskResumeAll+0x4a>
BaseType_t xAlreadyYielded = pdFALSE;
 8004e74:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8004e76:	f000 fb5b 	bl	8005530 <vPortExitCritical>
}
 8004e7a:	4620      	mov	r0, r4
 8004e7c:	bd70      	pop	{r4, r5, r6, pc}
TCB_t *pxTCB = NULL;
 8004e7e:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8004e80:	4b27      	ldr	r3, [pc, #156]	; (8004f20 <xTaskResumeAll+0xec>)
 8004e82:	695b      	ldr	r3, [r3, #20]
 8004e84:	b32b      	cbz	r3, 8004ed2 <xTaskResumeAll+0x9e>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8004e86:	4d26      	ldr	r5, [pc, #152]	; (8004f20 <xTaskResumeAll+0xec>)
 8004e88:	6a2b      	ldr	r3, [r5, #32]
 8004e8a:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004e8c:	f104 0018 	add.w	r0, r4, #24
 8004e90:	f7ff f85c 	bl	8003f4c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004e94:	1d26      	adds	r6, r4, #4
 8004e96:	4630      	mov	r0, r6
 8004e98:	f7ff f858 	bl	8003f4c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004e9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004e9e:	2201      	movs	r2, #1
 8004ea0:	409a      	lsls	r2, r3
 8004ea2:	f8d5 110c 	ldr.w	r1, [r5, #268]	; 0x10c
 8004ea6:	430a      	orrs	r2, r1
 8004ea8:	f8c5 210c 	str.w	r2, [r5, #268]	; 0x10c
 8004eac:	f105 0030 	add.w	r0, r5, #48	; 0x30
 8004eb0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004eb4:	009a      	lsls	r2, r3, #2
 8004eb6:	4631      	mov	r1, r6
 8004eb8:	4410      	add	r0, r2
 8004eba:	f7ff f821 	bl	8003f00 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004ebe:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004ec0:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
 8004ec4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004ec6:	429a      	cmp	r2, r3
 8004ec8:	d3da      	bcc.n	8004e80 <xTaskResumeAll+0x4c>
						xYieldPending = pdTRUE;
 8004eca:	2201      	movs	r2, #1
 8004ecc:	f8c5 2128 	str.w	r2, [r5, #296]	; 0x128
 8004ed0:	e7d6      	b.n	8004e80 <xTaskResumeAll+0x4c>
				if( pxTCB != NULL )
 8004ed2:	b10c      	cbz	r4, 8004ed8 <xTaskResumeAll+0xa4>
					prvResetNextTaskUnblockTime();
 8004ed4:	f7ff fd38 	bl	8004948 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8004ed8:	4b11      	ldr	r3, [pc, #68]	; (8004f20 <xTaskResumeAll+0xec>)
 8004eda:	f8d3 4124 	ldr.w	r4, [r3, #292]	; 0x124
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8004ede:	b164      	cbz	r4, 8004efa <xTaskResumeAll+0xc6>
							if( xTaskIncrementTick() != pdFALSE )
 8004ee0:	f7ff ff20 	bl	8004d24 <xTaskIncrementTick>
 8004ee4:	b118      	cbz	r0, 8004eee <xTaskResumeAll+0xba>
								xYieldPending = pdTRUE;
 8004ee6:	4b0e      	ldr	r3, [pc, #56]	; (8004f20 <xTaskResumeAll+0xec>)
 8004ee8:	2201      	movs	r2, #1
 8004eea:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8004eee:	3c01      	subs	r4, #1
 8004ef0:	d1f6      	bne.n	8004ee0 <xTaskResumeAll+0xac>
						uxPendedTicks = 0;
 8004ef2:	4b0b      	ldr	r3, [pc, #44]	; (8004f20 <xTaskResumeAll+0xec>)
 8004ef4:	2200      	movs	r2, #0
 8004ef6:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
				if( xYieldPending != pdFALSE )
 8004efa:	4b09      	ldr	r3, [pc, #36]	; (8004f20 <xTaskResumeAll+0xec>)
 8004efc:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 8004f00:	b15b      	cbz	r3, 8004f1a <xTaskResumeAll+0xe6>
					taskYIELD_IF_USING_PREEMPTION();
 8004f02:	4b08      	ldr	r3, [pc, #32]	; (8004f24 <xTaskResumeAll+0xf0>)
 8004f04:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004f08:	601a      	str	r2, [r3, #0]
 8004f0a:	f3bf 8f4f 	dsb	sy
 8004f0e:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8004f12:	2401      	movs	r4, #1
 8004f14:	e7af      	b.n	8004e76 <xTaskResumeAll+0x42>
BaseType_t xAlreadyYielded = pdFALSE;
 8004f16:	2400      	movs	r4, #0
 8004f18:	e7ad      	b.n	8004e76 <xTaskResumeAll+0x42>
 8004f1a:	2400      	movs	r4, #0
 8004f1c:	e7ab      	b.n	8004e76 <xTaskResumeAll+0x42>
 8004f1e:	bf00      	nop
 8004f20:	2000009c 	.word	0x2000009c
 8004f24:	e000ed04 	.word	0xe000ed04

08004f28 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004f28:	4b31      	ldr	r3, [pc, #196]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004f2a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8004f2e:	b123      	cbz	r3, 8004f3a <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 8004f30:	4b2f      	ldr	r3, [pc, #188]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004f32:	2201      	movs	r2, #1
 8004f34:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
 8004f38:	4770      	bx	lr
{
 8004f3a:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
 8004f3c:	4b2c      	ldr	r3, [pc, #176]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004f3e:	2200      	movs	r2, #0
 8004f40:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
		taskCHECK_FOR_STACK_OVERFLOW();
 8004f44:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8004f48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004f4a:	681a      	ldr	r2, [r3, #0]
 8004f4c:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8004f50:	d103      	bne.n	8004f5a <vTaskSwitchContext+0x32>
 8004f52:	685a      	ldr	r2, [r3, #4]
 8004f54:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8004f58:	d020      	beq.n	8004f9c <vTaskSwitchContext+0x74>
 8004f5a:	4b25      	ldr	r3, [pc, #148]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004f5c:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
 8004f60:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
 8004f64:	3134      	adds	r1, #52	; 0x34
 8004f66:	f004 ff9d 	bl	8009ea4 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004f6a:	4a21      	ldr	r2, [pc, #132]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004f6c:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8004f70:	fab3 f383 	clz	r3, r3
 8004f74:	b2db      	uxtb	r3, r3
 8004f76:	f1c3 031f 	rsb	r3, r3, #31
 8004f7a:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 8004f7e:	0081      	lsls	r1, r0, #2
 8004f80:	440a      	add	r2, r1
 8004f82:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8004f84:	b99a      	cbnz	r2, 8004fae <vTaskSwitchContext+0x86>
	__asm volatile
 8004f86:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f8a:	b672      	cpsid	i
 8004f8c:	f383 8811 	msr	BASEPRI, r3
 8004f90:	f3bf 8f6f 	isb	sy
 8004f94:	f3bf 8f4f 	dsb	sy
 8004f98:	b662      	cpsie	i
 8004f9a:	e7fe      	b.n	8004f9a <vTaskSwitchContext+0x72>
		taskCHECK_FOR_STACK_OVERFLOW();
 8004f9c:	689a      	ldr	r2, [r3, #8]
 8004f9e:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8004fa2:	d1da      	bne.n	8004f5a <vTaskSwitchContext+0x32>
 8004fa4:	68db      	ldr	r3, [r3, #12]
 8004fa6:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 8004faa:	d1d6      	bne.n	8004f5a <vTaskSwitchContext+0x32>
 8004fac:	e7dd      	b.n	8004f6a <vTaskSwitchContext+0x42>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004fae:	4a10      	ldr	r2, [pc, #64]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004fb0:	0099      	lsls	r1, r3, #2
 8004fb2:	18cc      	adds	r4, r1, r3
 8004fb4:	00a0      	lsls	r0, r4, #2
 8004fb6:	4410      	add	r0, r2
 8004fb8:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8004fba:	6864      	ldr	r4, [r4, #4]
 8004fbc:	6344      	str	r4, [r0, #52]	; 0x34
 8004fbe:	3230      	adds	r2, #48	; 0x30
 8004fc0:	4419      	add	r1, r3
 8004fc2:	0088      	lsls	r0, r1, #2
 8004fc4:	3008      	adds	r0, #8
 8004fc6:	4402      	add	r2, r0
 8004fc8:	4294      	cmp	r4, r2
 8004fca:	d009      	beq.n	8004fe0 <vTaskSwitchContext+0xb8>
 8004fcc:	4908      	ldr	r1, [pc, #32]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004fce:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004fd2:	009a      	lsls	r2, r3, #2
 8004fd4:	440a      	add	r2, r1
 8004fd6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8004fd8:	68db      	ldr	r3, [r3, #12]
 8004fda:	f8c1 3100 	str.w	r3, [r1, #256]	; 0x100
}
 8004fde:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004fe0:	6861      	ldr	r1, [r4, #4]
 8004fe2:	4803      	ldr	r0, [pc, #12]	; (8004ff0 <vTaskSwitchContext+0xc8>)
 8004fe4:	2214      	movs	r2, #20
 8004fe6:	fb02 0203 	mla	r2, r2, r3, r0
 8004fea:	6351      	str	r1, [r2, #52]	; 0x34
 8004fec:	e7ee      	b.n	8004fcc <vTaskSwitchContext+0xa4>
 8004fee:	bf00      	nop
 8004ff0:	2000009c 	.word	0x2000009c

08004ff4 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 8004ff4:	b950      	cbnz	r0, 800500c <vTaskPlaceOnEventList+0x18>
 8004ff6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ffa:	b672      	cpsid	i
 8004ffc:	f383 8811 	msr	BASEPRI, r3
 8005000:	f3bf 8f6f 	isb	sy
 8005004:	f3bf 8f4f 	dsb	sy
 8005008:	b662      	cpsie	i
 800500a:	e7fe      	b.n	800500a <vTaskPlaceOnEventList+0x16>
{
 800500c:	b510      	push	{r4, lr}
 800500e:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8005010:	4b05      	ldr	r3, [pc, #20]	; (8005028 <vTaskPlaceOnEventList+0x34>)
 8005012:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
 8005016:	3118      	adds	r1, #24
 8005018:	f7fe ff7e 	bl	8003f18 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800501c:	2101      	movs	r1, #1
 800501e:	4620      	mov	r0, r4
 8005020:	f7ff fdae 	bl	8004b80 <prvAddCurrentTaskToDelayedList>
}
 8005024:	bd10      	pop	{r4, pc}
 8005026:	bf00      	nop
 8005028:	2000009c 	.word	0x2000009c

0800502c <xTaskRemoveFromEventList>:
{
 800502c:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800502e:	68c3      	ldr	r3, [r0, #12]
 8005030:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8005032:	b954      	cbnz	r4, 800504a <xTaskRemoveFromEventList+0x1e>
 8005034:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005038:	b672      	cpsid	i
 800503a:	f383 8811 	msr	BASEPRI, r3
 800503e:	f3bf 8f6f 	isb	sy
 8005042:	f3bf 8f4f 	dsb	sy
 8005046:	b662      	cpsie	i
 8005048:	e7fe      	b.n	8005048 <xTaskRemoveFromEventList+0x1c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800504a:	f104 0518 	add.w	r5, r4, #24
 800504e:	4628      	mov	r0, r5
 8005050:	f7fe ff7c 	bl	8003f4c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005054:	4b15      	ldr	r3, [pc, #84]	; (80050ac <xTaskRemoveFromEventList+0x80>)
 8005056:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800505a:	bb03      	cbnz	r3, 800509e <xTaskRemoveFromEventList+0x72>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800505c:	1d25      	adds	r5, r4, #4
 800505e:	4628      	mov	r0, r5
 8005060:	f7fe ff74 	bl	8003f4c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8005064:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005066:	2101      	movs	r1, #1
 8005068:	4099      	lsls	r1, r3
 800506a:	4a10      	ldr	r2, [pc, #64]	; (80050ac <xTaskRemoveFromEventList+0x80>)
 800506c:	f8d2 010c 	ldr.w	r0, [r2, #268]	; 0x10c
 8005070:	4301      	orrs	r1, r0
 8005072:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
 8005076:	3230      	adds	r2, #48	; 0x30
 8005078:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800507c:	0098      	lsls	r0, r3, #2
 800507e:	4629      	mov	r1, r5
 8005080:	4410      	add	r0, r2
 8005082:	f7fe ff3d 	bl	8003f00 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8005086:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005088:	4b08      	ldr	r3, [pc, #32]	; (80050ac <xTaskRemoveFromEventList+0x80>)
 800508a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800508e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005090:	429a      	cmp	r2, r3
 8005092:	d909      	bls.n	80050a8 <xTaskRemoveFromEventList+0x7c>
		xYieldPending = pdTRUE;
 8005094:	2001      	movs	r0, #1
 8005096:	4b05      	ldr	r3, [pc, #20]	; (80050ac <xTaskRemoveFromEventList+0x80>)
 8005098:	f8c3 0128 	str.w	r0, [r3, #296]	; 0x128
}
 800509c:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800509e:	4629      	mov	r1, r5
 80050a0:	4803      	ldr	r0, [pc, #12]	; (80050b0 <xTaskRemoveFromEventList+0x84>)
 80050a2:	f7fe ff2d 	bl	8003f00 <vListInsertEnd>
 80050a6:	e7ee      	b.n	8005086 <xTaskRemoveFromEventList+0x5a>
		xReturn = pdFALSE;
 80050a8:	2000      	movs	r0, #0
	return xReturn;
 80050aa:	e7f7      	b.n	800509c <xTaskRemoveFromEventList+0x70>
 80050ac:	2000009c 	.word	0x2000009c
 80050b0:	200000b0 	.word	0x200000b0

080050b4 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80050b4:	4b03      	ldr	r3, [pc, #12]	; (80050c4 <vTaskInternalSetTimeOutState+0x10>)
 80050b6:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
 80050ba:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80050bc:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 80050c0:	6043      	str	r3, [r0, #4]
}
 80050c2:	4770      	bx	lr
 80050c4:	2000009c 	.word	0x2000009c

080050c8 <xTaskCheckForTimeOut>:
{
 80050c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 80050ca:	b160      	cbz	r0, 80050e6 <xTaskCheckForTimeOut+0x1e>
 80050cc:	4605      	mov	r5, r0
	configASSERT( pxTicksToWait );
 80050ce:	b9a9      	cbnz	r1, 80050fc <xTaskCheckForTimeOut+0x34>
 80050d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80050d4:	b672      	cpsid	i
 80050d6:	f383 8811 	msr	BASEPRI, r3
 80050da:	f3bf 8f6f 	isb	sy
 80050de:	f3bf 8f4f 	dsb	sy
 80050e2:	b662      	cpsie	i
 80050e4:	e7fe      	b.n	80050e4 <xTaskCheckForTimeOut+0x1c>
 80050e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80050ea:	b672      	cpsid	i
 80050ec:	f383 8811 	msr	BASEPRI, r3
 80050f0:	f3bf 8f6f 	isb	sy
 80050f4:	f3bf 8f4f 	dsb	sy
 80050f8:	b662      	cpsie	i
 80050fa:	e7fe      	b.n	80050fa <xTaskCheckForTimeOut+0x32>
 80050fc:	460c      	mov	r4, r1
	taskENTER_CRITICAL();
 80050fe:	f000 f9f1 	bl	80054e4 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8005102:	4b12      	ldr	r3, [pc, #72]	; (800514c <xTaskCheckForTimeOut+0x84>)
 8005104:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8005108:	6868      	ldr	r0, [r5, #4]
 800510a:	1a0a      	subs	r2, r1, r0
			if( *pxTicksToWait == portMAX_DELAY )
 800510c:	6823      	ldr	r3, [r4, #0]
 800510e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005112:	d017      	beq.n	8005144 <xTaskCheckForTimeOut+0x7c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005114:	682f      	ldr	r7, [r5, #0]
 8005116:	4e0d      	ldr	r6, [pc, #52]	; (800514c <xTaskCheckForTimeOut+0x84>)
 8005118:	f8d6 6120 	ldr.w	r6, [r6, #288]	; 0x120
 800511c:	42b7      	cmp	r7, r6
 800511e:	d001      	beq.n	8005124 <xTaskCheckForTimeOut+0x5c>
 8005120:	4288      	cmp	r0, r1
 8005122:	d911      	bls.n	8005148 <xTaskCheckForTimeOut+0x80>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8005124:	4293      	cmp	r3, r2
 8005126:	d803      	bhi.n	8005130 <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait = 0;
 8005128:	2300      	movs	r3, #0
 800512a:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 800512c:	2401      	movs	r4, #1
 800512e:	e005      	b.n	800513c <xTaskCheckForTimeOut+0x74>
			*pxTicksToWait -= xElapsedTime;
 8005130:	1a9b      	subs	r3, r3, r2
 8005132:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 8005134:	4628      	mov	r0, r5
 8005136:	f7ff ffbd 	bl	80050b4 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 800513a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800513c:	f000 f9f8 	bl	8005530 <vPortExitCritical>
}
 8005140:	4620      	mov	r0, r4
 8005142:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				xReturn = pdFALSE;
 8005144:	2400      	movs	r4, #0
 8005146:	e7f9      	b.n	800513c <xTaskCheckForTimeOut+0x74>
			xReturn = pdTRUE;
 8005148:	2401      	movs	r4, #1
 800514a:	e7f7      	b.n	800513c <xTaskCheckForTimeOut+0x74>
 800514c:	2000009c 	.word	0x2000009c

08005150 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8005150:	4b02      	ldr	r3, [pc, #8]	; (800515c <vTaskMissedYield+0xc>)
 8005152:	2201      	movs	r2, #1
 8005154:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
}
 8005158:	4770      	bx	lr
 800515a:	bf00      	nop
 800515c:	2000009c 	.word	0x2000009c

08005160 <uxTaskGetStackHighWaterMark>:
	{
 8005160:	b508      	push	{r3, lr}
		pxTCB = prvGetTCBFromHandle( xTask );
 8005162:	4603      	mov	r3, r0
 8005164:	b118      	cbz	r0, 800516e <uxTaskGetStackHighWaterMark+0xe>
		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 8005166:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8005168:	f7ff fbe4 	bl	8004934 <prvTaskCheckFreeStackSpace>
	}
 800516c:	bd08      	pop	{r3, pc}
		pxTCB = prvGetTCBFromHandle( xTask );
 800516e:	4b02      	ldr	r3, [pc, #8]	; (8005178 <uxTaskGetStackHighWaterMark+0x18>)
 8005170:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8005174:	e7f7      	b.n	8005166 <uxTaskGetStackHighWaterMark+0x6>
 8005176:	bf00      	nop
 8005178:	2000009c 	.word	0x2000009c

0800517c <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 800517c:	4b06      	ldr	r3, [pc, #24]	; (8005198 <xTaskGetSchedulerState+0x1c>)
 800517e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8005182:	b13b      	cbz	r3, 8005194 <xTaskGetSchedulerState+0x18>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005184:	4b04      	ldr	r3, [pc, #16]	; (8005198 <xTaskGetSchedulerState+0x1c>)
 8005186:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800518a:	b10b      	cbz	r3, 8005190 <xTaskGetSchedulerState+0x14>
				xReturn = taskSCHEDULER_SUSPENDED;
 800518c:	2000      	movs	r0, #0
	}
 800518e:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
 8005190:	2002      	movs	r0, #2
 8005192:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8005194:	2001      	movs	r0, #1
 8005196:	4770      	bx	lr
 8005198:	2000009c 	.word	0x2000009c

0800519c <xTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 800519c:	2800      	cmp	r0, #0
 800519e:	d059      	beq.n	8005254 <xTaskPriorityInherit+0xb8>
	{
 80051a0:	b538      	push	{r3, r4, r5, lr}
 80051a2:	4604      	mov	r4, r0
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 80051a4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80051a6:	492c      	ldr	r1, [pc, #176]	; (8005258 <xTaskPriorityInherit+0xbc>)
 80051a8:	f8d1 1100 	ldr.w	r1, [r1, #256]	; 0x100
 80051ac:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80051ae:	428a      	cmp	r2, r1
 80051b0:	d245      	bcs.n	800523e <xTaskPriorityInherit+0xa2>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80051b2:	6981      	ldr	r1, [r0, #24]
 80051b4:	2900      	cmp	r1, #0
 80051b6:	db06      	blt.n	80051c6 <xTaskPriorityInherit+0x2a>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80051b8:	4927      	ldr	r1, [pc, #156]	; (8005258 <xTaskPriorityInherit+0xbc>)
 80051ba:	f8d1 1100 	ldr.w	r1, [r1, #256]	; 0x100
 80051be:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80051c0:	f1c1 0107 	rsb	r1, r1, #7
 80051c4:	6181      	str	r1, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80051c6:	6960      	ldr	r0, [r4, #20]
 80051c8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80051cc:	0091      	lsls	r1, r2, #2
 80051ce:	4a23      	ldr	r2, [pc, #140]	; (800525c <xTaskPriorityInherit+0xc0>)
 80051d0:	440a      	add	r2, r1
 80051d2:	4290      	cmp	r0, r2
 80051d4:	d006      	beq.n	80051e4 <xTaskPriorityInherit+0x48>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80051d6:	4a20      	ldr	r2, [pc, #128]	; (8005258 <xTaskPriorityInherit+0xbc>)
 80051d8:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
 80051dc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80051de:	62e2      	str	r2, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
 80051e0:	2001      	movs	r0, #1
	}
 80051e2:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80051e4:	1d25      	adds	r5, r4, #4
 80051e6:	4628      	mov	r0, r5
 80051e8:	f7fe feb0 	bl	8003f4c <uxListRemove>
 80051ec:	b980      	cbnz	r0, 8005210 <xTaskPriorityInherit+0x74>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 80051ee:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80051f0:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 80051f4:	0099      	lsls	r1, r3, #2
 80051f6:	4b18      	ldr	r3, [pc, #96]	; (8005258 <xTaskPriorityInherit+0xbc>)
 80051f8:	440b      	add	r3, r1
 80051fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80051fc:	b943      	cbnz	r3, 8005210 <xTaskPriorityInherit+0x74>
 80051fe:	2301      	movs	r3, #1
 8005200:	4093      	lsls	r3, r2
 8005202:	4915      	ldr	r1, [pc, #84]	; (8005258 <xTaskPriorityInherit+0xbc>)
 8005204:	f8d1 210c 	ldr.w	r2, [r1, #268]	; 0x10c
 8005208:	ea22 0203 	bic.w	r2, r2, r3
 800520c:	f8c1 210c 	str.w	r2, [r1, #268]	; 0x10c
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005210:	4811      	ldr	r0, [pc, #68]	; (8005258 <xTaskPriorityInherit+0xbc>)
 8005212:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
 8005216:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005218:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800521a:	2401      	movs	r4, #1
 800521c:	fa04 f203 	lsl.w	r2, r4, r3
 8005220:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8005224:	430a      	orrs	r2, r1
 8005226:	f8c0 210c 	str.w	r2, [r0, #268]	; 0x10c
 800522a:	3030      	adds	r0, #48	; 0x30
 800522c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8005230:	009a      	lsls	r2, r3, #2
 8005232:	4629      	mov	r1, r5
 8005234:	4410      	add	r0, r2
 8005236:	f7fe fe63 	bl	8003f00 <vListInsertEnd>
				xReturn = pdTRUE;
 800523a:	4620      	mov	r0, r4
 800523c:	e7d1      	b.n	80051e2 <xTaskPriorityInherit+0x46>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 800523e:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8005240:	4b05      	ldr	r3, [pc, #20]	; (8005258 <xTaskPriorityInherit+0xbc>)
 8005242:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8005246:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005248:	429a      	cmp	r2, r3
 800524a:	d201      	bcs.n	8005250 <xTaskPriorityInherit+0xb4>
					xReturn = pdTRUE;
 800524c:	2001      	movs	r0, #1
		return xReturn;
 800524e:	e7c8      	b.n	80051e2 <xTaskPriorityInherit+0x46>
	BaseType_t xReturn = pdFALSE;
 8005250:	2000      	movs	r0, #0
 8005252:	e7c6      	b.n	80051e2 <xTaskPriorityInherit+0x46>
 8005254:	2000      	movs	r0, #0
	}
 8005256:	4770      	bx	lr
 8005258:	2000009c 	.word	0x2000009c
 800525c:	200000cc 	.word	0x200000cc

08005260 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 8005260:	2800      	cmp	r0, #0
 8005262:	d051      	beq.n	8005308 <xTaskPriorityDisinherit+0xa8>
	{
 8005264:	b538      	push	{r3, r4, r5, lr}
 8005266:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 8005268:	4a2a      	ldr	r2, [pc, #168]	; (8005314 <xTaskPriorityDisinherit+0xb4>)
 800526a:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
 800526e:	4282      	cmp	r2, r0
 8005270:	d00a      	beq.n	8005288 <xTaskPriorityDisinherit+0x28>
 8005272:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005276:	b672      	cpsid	i
 8005278:	f383 8811 	msr	BASEPRI, r3
 800527c:	f3bf 8f6f 	isb	sy
 8005280:	f3bf 8f4f 	dsb	sy
 8005284:	b662      	cpsie	i
 8005286:	e7fe      	b.n	8005286 <xTaskPriorityDisinherit+0x26>
			configASSERT( pxTCB->uxMutexesHeld );
 8005288:	6d02      	ldr	r2, [r0, #80]	; 0x50
 800528a:	b952      	cbnz	r2, 80052a2 <xTaskPriorityDisinherit+0x42>
 800528c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005290:	b672      	cpsid	i
 8005292:	f383 8811 	msr	BASEPRI, r3
 8005296:	f3bf 8f6f 	isb	sy
 800529a:	f3bf 8f4f 	dsb	sy
 800529e:	b662      	cpsie	i
 80052a0:	e7fe      	b.n	80052a0 <xTaskPriorityDisinherit+0x40>
			( pxTCB->uxMutexesHeld )--;
 80052a2:	3a01      	subs	r2, #1
 80052a4:	6502      	str	r2, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80052a6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80052a8:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 80052aa:	4288      	cmp	r0, r1
 80052ac:	d02e      	beq.n	800530c <xTaskPriorityDisinherit+0xac>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80052ae:	bb7a      	cbnz	r2, 8005310 <xTaskPriorityDisinherit+0xb0>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80052b0:	1d25      	adds	r5, r4, #4
 80052b2:	4628      	mov	r0, r5
 80052b4:	f7fe fe4a 	bl	8003f4c <uxListRemove>
 80052b8:	b978      	cbnz	r0, 80052da <xTaskPriorityDisinherit+0x7a>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80052ba:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80052bc:	4915      	ldr	r1, [pc, #84]	; (8005314 <xTaskPriorityDisinherit+0xb4>)
 80052be:	2314      	movs	r3, #20
 80052c0:	fb03 1302 	mla	r3, r3, r2, r1
 80052c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80052c6:	b943      	cbnz	r3, 80052da <xTaskPriorityDisinherit+0x7a>
 80052c8:	2301      	movs	r3, #1
 80052ca:	fa03 f202 	lsl.w	r2, r3, r2
 80052ce:	f8d1 310c 	ldr.w	r3, [r1, #268]	; 0x10c
 80052d2:	ea23 0302 	bic.w	r3, r3, r2
 80052d6:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80052da:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80052dc:	62e2      	str	r2, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80052de:	f1c2 0307 	rsb	r3, r2, #7
 80052e2:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 80052e4:	2401      	movs	r4, #1
 80052e6:	fa04 f102 	lsl.w	r1, r4, r2
 80052ea:	4b0a      	ldr	r3, [pc, #40]	; (8005314 <xTaskPriorityDisinherit+0xb4>)
 80052ec:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
 80052f0:	4301      	orrs	r1, r0
 80052f2:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
 80052f6:	3330      	adds	r3, #48	; 0x30
 80052f8:	4629      	mov	r1, r5
 80052fa:	2014      	movs	r0, #20
 80052fc:	fb00 3002 	mla	r0, r0, r2, r3
 8005300:	f7fe fdfe 	bl	8003f00 <vListInsertEnd>
					xReturn = pdTRUE;
 8005304:	4620      	mov	r0, r4
	}
 8005306:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
 8005308:	2000      	movs	r0, #0
	}
 800530a:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
 800530c:	2000      	movs	r0, #0
 800530e:	e7fa      	b.n	8005306 <xTaskPriorityDisinherit+0xa6>
 8005310:	2000      	movs	r0, #0
		return xReturn;
 8005312:	e7f8      	b.n	8005306 <xTaskPriorityDisinherit+0xa6>
 8005314:	2000009c 	.word	0x2000009c

08005318 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 8005318:	2800      	cmp	r0, #0
 800531a:	d05d      	beq.n	80053d8 <vTaskPriorityDisinheritAfterTimeout+0xc0>
	{
 800531c:	b538      	push	{r3, r4, r5, lr}
 800531e:	4603      	mov	r3, r0
			configASSERT( pxTCB->uxMutexesHeld );
 8005320:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8005322:	b950      	cbnz	r0, 800533a <vTaskPriorityDisinheritAfterTimeout+0x22>
 8005324:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005328:	b672      	cpsid	i
 800532a:	f383 8811 	msr	BASEPRI, r3
 800532e:	f3bf 8f6f 	isb	sy
 8005332:	f3bf 8f4f 	dsb	sy
 8005336:	b662      	cpsie	i
 8005338:	e7fe      	b.n	8005338 <vTaskPriorityDisinheritAfterTimeout+0x20>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 800533a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800533c:	428a      	cmp	r2, r1
 800533e:	d200      	bcs.n	8005342 <vTaskPriorityDisinheritAfterTimeout+0x2a>
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 8005340:	460a      	mov	r2, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
 8005342:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8005344:	4291      	cmp	r1, r2
 8005346:	d001      	beq.n	800534c <vTaskPriorityDisinheritAfterTimeout+0x34>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8005348:	2801      	cmp	r0, #1
 800534a:	d000      	beq.n	800534e <vTaskPriorityDisinheritAfterTimeout+0x36>
	}
 800534c:	bd38      	pop	{r3, r4, r5, pc}
					configASSERT( pxTCB != pxCurrentTCB );
 800534e:	4823      	ldr	r0, [pc, #140]	; (80053dc <vTaskPriorityDisinheritAfterTimeout+0xc4>)
 8005350:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005354:	4298      	cmp	r0, r3
 8005356:	d10a      	bne.n	800536e <vTaskPriorityDisinheritAfterTimeout+0x56>
 8005358:	f04f 0350 	mov.w	r3, #80	; 0x50
 800535c:	b672      	cpsid	i
 800535e:	f383 8811 	msr	BASEPRI, r3
 8005362:	f3bf 8f6f 	isb	sy
 8005366:	f3bf 8f4f 	dsb	sy
 800536a:	b662      	cpsie	i
 800536c:	e7fe      	b.n	800536c <vTaskPriorityDisinheritAfterTimeout+0x54>
					pxTCB->uxPriority = uxPriorityToUse;
 800536e:	62da      	str	r2, [r3, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005370:	6998      	ldr	r0, [r3, #24]
 8005372:	2800      	cmp	r0, #0
 8005374:	db02      	blt.n	800537c <vTaskPriorityDisinheritAfterTimeout+0x64>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005376:	f1c2 0207 	rsb	r2, r2, #7
 800537a:	619a      	str	r2, [r3, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800537c:	695a      	ldr	r2, [r3, #20]
 800537e:	4818      	ldr	r0, [pc, #96]	; (80053e0 <vTaskPriorityDisinheritAfterTimeout+0xc8>)
 8005380:	2414      	movs	r4, #20
 8005382:	fb04 0101 	mla	r1, r4, r1, r0
 8005386:	428a      	cmp	r2, r1
 8005388:	d1e0      	bne.n	800534c <vTaskPriorityDisinheritAfterTimeout+0x34>
 800538a:	461c      	mov	r4, r3
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800538c:	1d1d      	adds	r5, r3, #4
 800538e:	4628      	mov	r0, r5
 8005390:	f7fe fddc 	bl	8003f4c <uxListRemove>
 8005394:	b978      	cbnz	r0, 80053b6 <vTaskPriorityDisinheritAfterTimeout+0x9e>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005396:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005398:	4910      	ldr	r1, [pc, #64]	; (80053dc <vTaskPriorityDisinheritAfterTimeout+0xc4>)
 800539a:	2314      	movs	r3, #20
 800539c:	fb03 1302 	mla	r3, r3, r2, r1
 80053a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80053a2:	b943      	cbnz	r3, 80053b6 <vTaskPriorityDisinheritAfterTimeout+0x9e>
 80053a4:	2301      	movs	r3, #1
 80053a6:	fa03 f202 	lsl.w	r2, r3, r2
 80053aa:	f8d1 310c 	ldr.w	r3, [r1, #268]	; 0x10c
 80053ae:	ea23 0302 	bic.w	r3, r3, r2
 80053b2:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
						prvAddTaskToReadyList( pxTCB );
 80053b6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80053b8:	2201      	movs	r2, #1
 80053ba:	4082      	lsls	r2, r0
 80053bc:	4b07      	ldr	r3, [pc, #28]	; (80053dc <vTaskPriorityDisinheritAfterTimeout+0xc4>)
 80053be:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80053c2:	430a      	orrs	r2, r1
 80053c4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
 80053c8:	3330      	adds	r3, #48	; 0x30
 80053ca:	4629      	mov	r1, r5
 80053cc:	2214      	movs	r2, #20
 80053ce:	fb02 3000 	mla	r0, r2, r0, r3
 80053d2:	f7fe fd95 	bl	8003f00 <vListInsertEnd>
	}
 80053d6:	e7b9      	b.n	800534c <vTaskPriorityDisinheritAfterTimeout+0x34>
 80053d8:	4770      	bx	lr
 80053da:	bf00      	nop
 80053dc:	2000009c 	.word	0x2000009c
 80053e0:	200000cc 	.word	0x200000cc

080053e4 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 80053e4:	4b06      	ldr	r3, [pc, #24]	; (8005400 <pvTaskIncrementMutexHeldCount+0x1c>)
 80053e6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 80053ea:	b12b      	cbz	r3, 80053f8 <pvTaskIncrementMutexHeldCount+0x14>
			( pxCurrentTCB->uxMutexesHeld )++;
 80053ec:	4b04      	ldr	r3, [pc, #16]	; (8005400 <pvTaskIncrementMutexHeldCount+0x1c>)
 80053ee:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 80053f2:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80053f4:	3301      	adds	r3, #1
 80053f6:	6513      	str	r3, [r2, #80]	; 0x50
		return pxCurrentTCB;
 80053f8:	4b01      	ldr	r3, [pc, #4]	; (8005400 <pvTaskIncrementMutexHeldCount+0x1c>)
 80053fa:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	}
 80053fe:	4770      	bx	lr
 8005400:	2000009c 	.word	0x2000009c

08005404 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8005404:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8005406:	2300      	movs	r3, #0
 8005408:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800540a:	4b0f      	ldr	r3, [pc, #60]	; (8005448 <prvTaskExitError+0x44>)
 800540c:	681b      	ldr	r3, [r3, #0]
 800540e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005412:	d00a      	beq.n	800542a <prvTaskExitError+0x26>
 8005414:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005418:	b672      	cpsid	i
 800541a:	f383 8811 	msr	BASEPRI, r3
 800541e:	f3bf 8f6f 	isb	sy
 8005422:	f3bf 8f4f 	dsb	sy
 8005426:	b662      	cpsie	i
 8005428:	e7fe      	b.n	8005428 <prvTaskExitError+0x24>
 800542a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800542e:	b672      	cpsid	i
 8005430:	f383 8811 	msr	BASEPRI, r3
 8005434:	f3bf 8f6f 	isb	sy
 8005438:	f3bf 8f4f 	dsb	sy
 800543c:	b662      	cpsie	i
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 800543e:	9b01      	ldr	r3, [sp, #4]
 8005440:	2b00      	cmp	r3, #0
 8005442:	d0fc      	beq.n	800543e <prvTaskExitError+0x3a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8005444:	b002      	add	sp, #8
 8005446:	4770      	bx	lr
 8005448:	20000008 	.word	0x20000008

0800544c <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 800544c:	4808      	ldr	r0, [pc, #32]	; (8005470 <prvPortStartFirstTask+0x24>)
 800544e:	6800      	ldr	r0, [r0, #0]
 8005450:	6800      	ldr	r0, [r0, #0]
 8005452:	f380 8808 	msr	MSP, r0
 8005456:	f04f 0000 	mov.w	r0, #0
 800545a:	f380 8814 	msr	CONTROL, r0
 800545e:	b662      	cpsie	i
 8005460:	b661      	cpsie	f
 8005462:	f3bf 8f4f 	dsb	sy
 8005466:	f3bf 8f6f 	isb	sy
 800546a:	df00      	svc	0
 800546c:	bf00      	nop
 800546e:	0000      	.short	0x0000
 8005470:	e000ed08 	.word	0xe000ed08

08005474 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8005474:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8005484 <vPortEnableVFP+0x10>
 8005478:	6801      	ldr	r1, [r0, #0]
 800547a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800547e:	6001      	str	r1, [r0, #0]
 8005480:	4770      	bx	lr
 8005482:	0000      	.short	0x0000
 8005484:	e000ed88 	.word	0xe000ed88

08005488 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8005488:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800548c:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8005490:	f021 0101 	bic.w	r1, r1, #1
 8005494:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8005498:	4b05      	ldr	r3, [pc, #20]	; (80054b0 <pxPortInitialiseStack+0x28>)
 800549a:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800549e:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 80054a2:	f06f 0302 	mvn.w	r3, #2
 80054a6:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80054aa:	3844      	subs	r0, #68	; 0x44
 80054ac:	4770      	bx	lr
 80054ae:	bf00      	nop
 80054b0:	08005405 	.word	0x08005405
	...

080054c0 <SVC_Handler>:
	__asm volatile (
 80054c0:	4b07      	ldr	r3, [pc, #28]	; (80054e0 <pxCurrentTCBConst2>)
 80054c2:	6819      	ldr	r1, [r3, #0]
 80054c4:	6808      	ldr	r0, [r1, #0]
 80054c6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80054ca:	f380 8809 	msr	PSP, r0
 80054ce:	f3bf 8f6f 	isb	sy
 80054d2:	f04f 0000 	mov.w	r0, #0
 80054d6:	f380 8811 	msr	BASEPRI, r0
 80054da:	4770      	bx	lr
 80054dc:	f3af 8000 	nop.w

080054e0 <pxCurrentTCBConst2>:
 80054e0:	2000019c 	.word	0x2000019c

080054e4 <vPortEnterCritical>:
 80054e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80054e8:	b672      	cpsid	i
 80054ea:	f383 8811 	msr	BASEPRI, r3
 80054ee:	f3bf 8f6f 	isb	sy
 80054f2:	f3bf 8f4f 	dsb	sy
 80054f6:	b662      	cpsie	i
	uxCriticalNesting++;
 80054f8:	4a0b      	ldr	r2, [pc, #44]	; (8005528 <vPortEnterCritical+0x44>)
 80054fa:	6813      	ldr	r3, [r2, #0]
 80054fc:	3301      	adds	r3, #1
 80054fe:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8005500:	2b01      	cmp	r3, #1
 8005502:	d000      	beq.n	8005506 <vPortEnterCritical+0x22>
}
 8005504:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8005506:	4b09      	ldr	r3, [pc, #36]	; (800552c <vPortEnterCritical+0x48>)
 8005508:	681b      	ldr	r3, [r3, #0]
 800550a:	f013 0fff 	tst.w	r3, #255	; 0xff
 800550e:	d0f9      	beq.n	8005504 <vPortEnterCritical+0x20>
 8005510:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005514:	b672      	cpsid	i
 8005516:	f383 8811 	msr	BASEPRI, r3
 800551a:	f3bf 8f6f 	isb	sy
 800551e:	f3bf 8f4f 	dsb	sy
 8005522:	b662      	cpsie	i
 8005524:	e7fe      	b.n	8005524 <vPortEnterCritical+0x40>
 8005526:	bf00      	nop
 8005528:	20000008 	.word	0x20000008
 800552c:	e000ed04 	.word	0xe000ed04

08005530 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8005530:	4b0a      	ldr	r3, [pc, #40]	; (800555c <vPortExitCritical+0x2c>)
 8005532:	681b      	ldr	r3, [r3, #0]
 8005534:	b953      	cbnz	r3, 800554c <vPortExitCritical+0x1c>
 8005536:	f04f 0350 	mov.w	r3, #80	; 0x50
 800553a:	b672      	cpsid	i
 800553c:	f383 8811 	msr	BASEPRI, r3
 8005540:	f3bf 8f6f 	isb	sy
 8005544:	f3bf 8f4f 	dsb	sy
 8005548:	b662      	cpsie	i
 800554a:	e7fe      	b.n	800554a <vPortExitCritical+0x1a>
	uxCriticalNesting--;
 800554c:	3b01      	subs	r3, #1
 800554e:	4a03      	ldr	r2, [pc, #12]	; (800555c <vPortExitCritical+0x2c>)
 8005550:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8005552:	b90b      	cbnz	r3, 8005558 <vPortExitCritical+0x28>
	__asm volatile
 8005554:	f383 8811 	msr	BASEPRI, r3
}
 8005558:	4770      	bx	lr
 800555a:	bf00      	nop
 800555c:	20000008 	.word	0x20000008

08005560 <PendSV_Handler>:
	__asm volatile
 8005560:	f3ef 8009 	mrs	r0, PSP
 8005564:	f3bf 8f6f 	isb	sy
 8005568:	4b15      	ldr	r3, [pc, #84]	; (80055c0 <pxCurrentTCBConst>)
 800556a:	681a      	ldr	r2, [r3, #0]
 800556c:	f01e 0f10 	tst.w	lr, #16
 8005570:	bf08      	it	eq
 8005572:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8005576:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800557a:	6010      	str	r0, [r2, #0]
 800557c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8005580:	f04f 0050 	mov.w	r0, #80	; 0x50
 8005584:	b672      	cpsid	i
 8005586:	f380 8811 	msr	BASEPRI, r0
 800558a:	f3bf 8f4f 	dsb	sy
 800558e:	f3bf 8f6f 	isb	sy
 8005592:	b662      	cpsie	i
 8005594:	f7ff fcc8 	bl	8004f28 <vTaskSwitchContext>
 8005598:	f04f 0000 	mov.w	r0, #0
 800559c:	f380 8811 	msr	BASEPRI, r0
 80055a0:	bc09      	pop	{r0, r3}
 80055a2:	6819      	ldr	r1, [r3, #0]
 80055a4:	6808      	ldr	r0, [r1, #0]
 80055a6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80055aa:	f01e 0f10 	tst.w	lr, #16
 80055ae:	bf08      	it	eq
 80055b0:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80055b4:	f380 8809 	msr	PSP, r0
 80055b8:	f3bf 8f6f 	isb	sy
 80055bc:	4770      	bx	lr
 80055be:	bf00      	nop

080055c0 <pxCurrentTCBConst>:
 80055c0:	2000019c 	.word	0x2000019c

080055c4 <SysTick_Handler>:
{
 80055c4:	b508      	push	{r3, lr}
	__asm volatile
 80055c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80055ca:	b672      	cpsid	i
 80055cc:	f383 8811 	msr	BASEPRI, r3
 80055d0:	f3bf 8f6f 	isb	sy
 80055d4:	f3bf 8f4f 	dsb	sy
 80055d8:	b662      	cpsie	i
		if( xTaskIncrementTick() != pdFALSE )
 80055da:	f7ff fba3 	bl	8004d24 <xTaskIncrementTick>
 80055de:	b118      	cbz	r0, 80055e8 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80055e0:	4b03      	ldr	r3, [pc, #12]	; (80055f0 <SysTick_Handler+0x2c>)
 80055e2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80055e6:	601a      	str	r2, [r3, #0]
	__asm volatile
 80055e8:	2300      	movs	r3, #0
 80055ea:	f383 8811 	msr	BASEPRI, r3
}
 80055ee:	bd08      	pop	{r3, pc}
 80055f0:	e000ed04 	.word	0xe000ed04

080055f4 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 80055f4:	4a08      	ldr	r2, [pc, #32]	; (8005618 <vPortSetupTimerInterrupt+0x24>)
 80055f6:	2300      	movs	r3, #0
 80055f8:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 80055fa:	4908      	ldr	r1, [pc, #32]	; (800561c <vPortSetupTimerInterrupt+0x28>)
 80055fc:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80055fe:	4b08      	ldr	r3, [pc, #32]	; (8005620 <vPortSetupTimerInterrupt+0x2c>)
 8005600:	681b      	ldr	r3, [r3, #0]
 8005602:	4908      	ldr	r1, [pc, #32]	; (8005624 <vPortSetupTimerInterrupt+0x30>)
 8005604:	fba1 1303 	umull	r1, r3, r1, r3
 8005608:	099b      	lsrs	r3, r3, #6
 800560a:	3b01      	subs	r3, #1
 800560c:	4906      	ldr	r1, [pc, #24]	; (8005628 <vPortSetupTimerInterrupt+0x34>)
 800560e:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8005610:	2307      	movs	r3, #7
 8005612:	6013      	str	r3, [r2, #0]
}
 8005614:	4770      	bx	lr
 8005616:	bf00      	nop
 8005618:	e000e010 	.word	0xe000e010
 800561c:	e000e018 	.word	0xe000e018
 8005620:	20000010 	.word	0x20000010
 8005624:	10624dd3 	.word	0x10624dd3
 8005628:	e000e014 	.word	0xe000e014

0800562c <xPortStartScheduler>:
{
 800562c:	b510      	push	{r4, lr}
 800562e:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005630:	4b2b      	ldr	r3, [pc, #172]	; (80056e0 <xPortStartScheduler+0xb4>)
 8005632:	781a      	ldrb	r2, [r3, #0]
 8005634:	b2d2      	uxtb	r2, r2
 8005636:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8005638:	22ff      	movs	r2, #255	; 0xff
 800563a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800563c:	781b      	ldrb	r3, [r3, #0]
 800563e:	b2db      	uxtb	r3, r3
 8005640:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005644:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005648:	f003 0350 	and.w	r3, r3, #80	; 0x50
 800564c:	4a25      	ldr	r2, [pc, #148]	; (80056e4 <xPortStartScheduler+0xb8>)
 800564e:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005650:	2307      	movs	r3, #7
 8005652:	6053      	str	r3, [r2, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005654:	e009      	b.n	800566a <xPortStartScheduler+0x3e>
			ulMaxPRIGROUPValue--;
 8005656:	4a23      	ldr	r2, [pc, #140]	; (80056e4 <xPortStartScheduler+0xb8>)
 8005658:	6853      	ldr	r3, [r2, #4]
 800565a:	3b01      	subs	r3, #1
 800565c:	6053      	str	r3, [r2, #4]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800565e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005662:	005b      	lsls	r3, r3, #1
 8005664:	b2db      	uxtb	r3, r3
 8005666:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800566a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800566e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005672:	d1f0      	bne.n	8005656 <xPortStartScheduler+0x2a>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8005674:	4b1b      	ldr	r3, [pc, #108]	; (80056e4 <xPortStartScheduler+0xb8>)
 8005676:	685b      	ldr	r3, [r3, #4]
 8005678:	2b03      	cmp	r3, #3
 800567a:	d00a      	beq.n	8005692 <xPortStartScheduler+0x66>
	__asm volatile
 800567c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005680:	b672      	cpsid	i
 8005682:	f383 8811 	msr	BASEPRI, r3
 8005686:	f3bf 8f6f 	isb	sy
 800568a:	f3bf 8f4f 	dsb	sy
 800568e:	b662      	cpsie	i
 8005690:	e7fe      	b.n	8005690 <xPortStartScheduler+0x64>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8005692:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8005694:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005698:	4a12      	ldr	r2, [pc, #72]	; (80056e4 <xPortStartScheduler+0xb8>)
 800569a:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800569c:	9b01      	ldr	r3, [sp, #4]
 800569e:	b2db      	uxtb	r3, r3
 80056a0:	4a0f      	ldr	r2, [pc, #60]	; (80056e0 <xPortStartScheduler+0xb4>)
 80056a2:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80056a4:	4b10      	ldr	r3, [pc, #64]	; (80056e8 <xPortStartScheduler+0xbc>)
 80056a6:	681a      	ldr	r2, [r3, #0]
 80056a8:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80056ac:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80056ae:	681a      	ldr	r2, [r3, #0]
 80056b0:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 80056b4:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 80056b6:	f7ff ff9d 	bl	80055f4 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80056ba:	2400      	movs	r4, #0
 80056bc:	4b0b      	ldr	r3, [pc, #44]	; (80056ec <xPortStartScheduler+0xc0>)
 80056be:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
 80056c0:	f7ff fed8 	bl	8005474 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 80056c4:	4a0a      	ldr	r2, [pc, #40]	; (80056f0 <xPortStartScheduler+0xc4>)
 80056c6:	6813      	ldr	r3, [r2, #0]
 80056c8:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80056cc:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 80056ce:	f7ff febd 	bl	800544c <prvPortStartFirstTask>
	vTaskSwitchContext();
 80056d2:	f7ff fc29 	bl	8004f28 <vTaskSwitchContext>
	prvTaskExitError();
 80056d6:	f7ff fe95 	bl	8005404 <prvTaskExitError>
}
 80056da:	4620      	mov	r0, r4
 80056dc:	b002      	add	sp, #8
 80056de:	bd10      	pop	{r4, pc}
 80056e0:	e000e400 	.word	0xe000e400
 80056e4:	200001c8 	.word	0x200001c8
 80056e8:	e000ed20 	.word	0xe000ed20
 80056ec:	20000008 	.word	0x20000008
 80056f0:	e000ef34 	.word	0xe000ef34

080056f4 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 80056f4:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 80056f8:	2b0f      	cmp	r3, #15
 80056fa:	d911      	bls.n	8005720 <vPortValidateInterruptPriority+0x2c>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 80056fc:	4a12      	ldr	r2, [pc, #72]	; (8005748 <vPortValidateInterruptPriority+0x54>)
 80056fe:	5c9b      	ldrb	r3, [r3, r2]
 8005700:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8005702:	4a12      	ldr	r2, [pc, #72]	; (800574c <vPortValidateInterruptPriority+0x58>)
 8005704:	7812      	ldrb	r2, [r2, #0]
 8005706:	429a      	cmp	r2, r3
 8005708:	d90a      	bls.n	8005720 <vPortValidateInterruptPriority+0x2c>
 800570a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800570e:	b672      	cpsid	i
 8005710:	f383 8811 	msr	BASEPRI, r3
 8005714:	f3bf 8f6f 	isb	sy
 8005718:	f3bf 8f4f 	dsb	sy
 800571c:	b662      	cpsie	i
 800571e:	e7fe      	b.n	800571e <vPortValidateInterruptPriority+0x2a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8005720:	4b0b      	ldr	r3, [pc, #44]	; (8005750 <vPortValidateInterruptPriority+0x5c>)
 8005722:	681b      	ldr	r3, [r3, #0]
 8005724:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005728:	4a08      	ldr	r2, [pc, #32]	; (800574c <vPortValidateInterruptPriority+0x58>)
 800572a:	6852      	ldr	r2, [r2, #4]
 800572c:	4293      	cmp	r3, r2
 800572e:	d90a      	bls.n	8005746 <vPortValidateInterruptPriority+0x52>
 8005730:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005734:	b672      	cpsid	i
 8005736:	f383 8811 	msr	BASEPRI, r3
 800573a:	f3bf 8f6f 	isb	sy
 800573e:	f3bf 8f4f 	dsb	sy
 8005742:	b662      	cpsie	i
 8005744:	e7fe      	b.n	8005744 <vPortValidateInterruptPriority+0x50>
	}
 8005746:	4770      	bx	lr
 8005748:	e000e3f0 	.word	0xe000e3f0
 800574c:	200001c8 	.word	0x200001c8
 8005750:	e000ed0c 	.word	0xe000ed0c

08005754 <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8005754:	4a11      	ldr	r2, [pc, #68]	; (800579c <prvHeapInit+0x48>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8005756:	f012 0f07 	tst.w	r2, #7
 800575a:	d01b      	beq.n	8005794 <prvHeapInit+0x40>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800575c:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800575e:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8005762:	f5c1 5342 	rsb	r3, r1, #12416	; 0x3080
 8005766:	332e      	adds	r3, #46	; 0x2e
 8005768:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800576a:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800576c:	490c      	ldr	r1, [pc, #48]	; (80057a0 <prvHeapInit+0x4c>)
 800576e:	600a      	str	r2, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8005770:	2000      	movs	r0, #0
 8005772:	6048      	str	r0, [r1, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8005774:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8005776:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005778:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 800577c:	608b      	str	r3, [r1, #8]
	pxEnd->xBlockSize = 0;
 800577e:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8005780:	6018      	str	r0, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8005782:	1a98      	subs	r0, r3, r2
 8005784:	6050      	str	r0, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8005786:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005788:	60c8      	str	r0, [r1, #12]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800578a:	6108      	str	r0, [r1, #16]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800578c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8005790:	614b      	str	r3, [r1, #20]
}
 8005792:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8005794:	f243 03ae 	movw	r3, #12462	; 0x30ae
 8005798:	e7e8      	b.n	800576c <prvHeapInit+0x18>
 800579a:	bf00      	nop
 800579c:	200001e8 	.word	0x200001e8
 80057a0:	200001d0 	.word	0x200001d0

080057a4 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 80057a4:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80057a6:	4b13      	ldr	r3, [pc, #76]	; (80057f4 <prvInsertBlockIntoFreeList+0x50>)
 80057a8:	681a      	ldr	r2, [r3, #0]
 80057aa:	4282      	cmp	r2, r0
 80057ac:	d31b      	bcc.n	80057e6 <prvInsertBlockIntoFreeList+0x42>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80057ae:	6859      	ldr	r1, [r3, #4]
 80057b0:	185c      	adds	r4, r3, r1
 80057b2:	4284      	cmp	r4, r0
 80057b4:	d103      	bne.n	80057be <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80057b6:	6840      	ldr	r0, [r0, #4]
 80057b8:	4401      	add	r1, r0
 80057ba:	6059      	str	r1, [r3, #4]
		pxBlockToInsert = pxIterator;
 80057bc:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80057be:	6841      	ldr	r1, [r0, #4]
 80057c0:	1844      	adds	r4, r0, r1
 80057c2:	42a2      	cmp	r2, r4
 80057c4:	d113      	bne.n	80057ee <prvInsertBlockIntoFreeList+0x4a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80057c6:	4c0b      	ldr	r4, [pc, #44]	; (80057f4 <prvInsertBlockIntoFreeList+0x50>)
 80057c8:	68a4      	ldr	r4, [r4, #8]
 80057ca:	42a2      	cmp	r2, r4
 80057cc:	d00d      	beq.n	80057ea <prvInsertBlockIntoFreeList+0x46>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80057ce:	6852      	ldr	r2, [r2, #4]
 80057d0:	4411      	add	r1, r2
 80057d2:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80057d4:	681a      	ldr	r2, [r3, #0]
 80057d6:	6812      	ldr	r2, [r2, #0]
 80057d8:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80057da:	4298      	cmp	r0, r3
 80057dc:	d000      	beq.n	80057e0 <prvInsertBlockIntoFreeList+0x3c>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80057de:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 80057e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80057e4:	4770      	bx	lr
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80057e6:	4613      	mov	r3, r2
 80057e8:	e7de      	b.n	80057a8 <prvInsertBlockIntoFreeList+0x4>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 80057ea:	6004      	str	r4, [r0, #0]
 80057ec:	e7f5      	b.n	80057da <prvInsertBlockIntoFreeList+0x36>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80057ee:	6002      	str	r2, [r0, #0]
 80057f0:	e7f3      	b.n	80057da <prvInsertBlockIntoFreeList+0x36>
 80057f2:	bf00      	nop
 80057f4:	200001d0 	.word	0x200001d0

080057f8 <pvPortMalloc>:
{
 80057f8:	b570      	push	{r4, r5, r6, lr}
 80057fa:	4604      	mov	r4, r0
	vTaskSuspendAll();
 80057fc:	f7ff fa78 	bl	8004cf0 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8005800:	4b42      	ldr	r3, [pc, #264]	; (800590c <pvPortMalloc+0x114>)
 8005802:	689b      	ldr	r3, [r3, #8]
 8005804:	b1b3      	cbz	r3, 8005834 <pvPortMalloc+0x3c>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8005806:	4b41      	ldr	r3, [pc, #260]	; (800590c <pvPortMalloc+0x114>)
 8005808:	695b      	ldr	r3, [r3, #20]
 800580a:	421c      	tst	r4, r3
 800580c:	d015      	beq.n	800583a <pvPortMalloc+0x42>
	( void ) xTaskResumeAll();
 800580e:	f7ff fb11 	bl	8004e34 <xTaskResumeAll>
void *pvReturn = NULL;
 8005812:	2600      	movs	r6, #0
			vApplicationMallocFailedHook();
 8005814:	f004 fb4e 	bl	8009eb4 <vApplicationMallocFailedHook>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8005818:	f016 0f07 	tst.w	r6, #7
 800581c:	d073      	beq.n	8005906 <pvPortMalloc+0x10e>
 800581e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005822:	b672      	cpsid	i
 8005824:	f383 8811 	msr	BASEPRI, r3
 8005828:	f3bf 8f6f 	isb	sy
 800582c:	f3bf 8f4f 	dsb	sy
 8005830:	b662      	cpsie	i
 8005832:	e7fe      	b.n	8005832 <pvPortMalloc+0x3a>
			prvHeapInit();
 8005834:	f7ff ff8e 	bl	8005754 <prvHeapInit>
 8005838:	e7e5      	b.n	8005806 <pvPortMalloc+0xe>
			if( xWantedSize > 0 )
 800583a:	b1a4      	cbz	r4, 8005866 <pvPortMalloc+0x6e>
				xWantedSize += xHeapStructSize;
 800583c:	3408      	adds	r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800583e:	f014 0f07 	tst.w	r4, #7
 8005842:	d010      	beq.n	8005866 <pvPortMalloc+0x6e>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8005844:	f024 0407 	bic.w	r4, r4, #7
 8005848:	3408      	adds	r4, #8
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 800584a:	f004 0307 	and.w	r3, r4, #7
 800584e:	b153      	cbz	r3, 8005866 <pvPortMalloc+0x6e>
 8005850:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005854:	b672      	cpsid	i
 8005856:	f383 8811 	msr	BASEPRI, r3
 800585a:	f3bf 8f6f 	isb	sy
 800585e:	f3bf 8f4f 	dsb	sy
 8005862:	b662      	cpsie	i
 8005864:	e7fe      	b.n	8005864 <pvPortMalloc+0x6c>
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8005866:	b134      	cbz	r4, 8005876 <pvPortMalloc+0x7e>
 8005868:	4b28      	ldr	r3, [pc, #160]	; (800590c <pvPortMalloc+0x114>)
 800586a:	691b      	ldr	r3, [r3, #16]
 800586c:	42a3      	cmp	r3, r4
 800586e:	d306      	bcc.n	800587e <pvPortMalloc+0x86>
				pxBlock = xStart.pxNextFreeBlock;
 8005870:	4b26      	ldr	r3, [pc, #152]	; (800590c <pvPortMalloc+0x114>)
 8005872:	681d      	ldr	r5, [r3, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005874:	e009      	b.n	800588a <pvPortMalloc+0x92>
	( void ) xTaskResumeAll();
 8005876:	f7ff fadd 	bl	8004e34 <xTaskResumeAll>
void *pvReturn = NULL;
 800587a:	2600      	movs	r6, #0
 800587c:	e7ca      	b.n	8005814 <pvPortMalloc+0x1c>
	( void ) xTaskResumeAll();
 800587e:	f7ff fad9 	bl	8004e34 <xTaskResumeAll>
void *pvReturn = NULL;
 8005882:	2600      	movs	r6, #0
 8005884:	e7c6      	b.n	8005814 <pvPortMalloc+0x1c>
					pxPreviousBlock = pxBlock;
 8005886:	462b      	mov	r3, r5
					pxBlock = pxBlock->pxNextFreeBlock;
 8005888:	4615      	mov	r5, r2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800588a:	686a      	ldr	r2, [r5, #4]
 800588c:	42a2      	cmp	r2, r4
 800588e:	d202      	bcs.n	8005896 <pvPortMalloc+0x9e>
 8005890:	682a      	ldr	r2, [r5, #0]
 8005892:	2a00      	cmp	r2, #0
 8005894:	d1f7      	bne.n	8005886 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 8005896:	4a1d      	ldr	r2, [pc, #116]	; (800590c <pvPortMalloc+0x114>)
 8005898:	6892      	ldr	r2, [r2, #8]
 800589a:	42aa      	cmp	r2, r5
 800589c:	d016      	beq.n	80058cc <pvPortMalloc+0xd4>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800589e:	681e      	ldr	r6, [r3, #0]
 80058a0:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80058a2:	682a      	ldr	r2, [r5, #0]
 80058a4:	601a      	str	r2, [r3, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80058a6:	686b      	ldr	r3, [r5, #4]
 80058a8:	1b1b      	subs	r3, r3, r4
 80058aa:	2b10      	cmp	r3, #16
 80058ac:	d916      	bls.n	80058dc <pvPortMalloc+0xe4>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80058ae:	1928      	adds	r0, r5, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80058b0:	f010 0f07 	tst.w	r0, #7
 80058b4:	d00e      	beq.n	80058d4 <pvPortMalloc+0xdc>
 80058b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80058ba:	b672      	cpsid	i
 80058bc:	f383 8811 	msr	BASEPRI, r3
 80058c0:	f3bf 8f6f 	isb	sy
 80058c4:	f3bf 8f4f 	dsb	sy
 80058c8:	b662      	cpsie	i
 80058ca:	e7fe      	b.n	80058ca <pvPortMalloc+0xd2>
	( void ) xTaskResumeAll();
 80058cc:	f7ff fab2 	bl	8004e34 <xTaskResumeAll>
void *pvReturn = NULL;
 80058d0:	2600      	movs	r6, #0
 80058d2:	e79f      	b.n	8005814 <pvPortMalloc+0x1c>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80058d4:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 80058d6:	606c      	str	r4, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 80058d8:	f7ff ff64 	bl	80057a4 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80058dc:	6869      	ldr	r1, [r5, #4]
 80058de:	4a0b      	ldr	r2, [pc, #44]	; (800590c <pvPortMalloc+0x114>)
 80058e0:	6913      	ldr	r3, [r2, #16]
 80058e2:	1a5b      	subs	r3, r3, r1
 80058e4:	6113      	str	r3, [r2, #16]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80058e6:	68d2      	ldr	r2, [r2, #12]
 80058e8:	4293      	cmp	r3, r2
 80058ea:	d201      	bcs.n	80058f0 <pvPortMalloc+0xf8>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80058ec:	4a07      	ldr	r2, [pc, #28]	; (800590c <pvPortMalloc+0x114>)
 80058ee:	60d3      	str	r3, [r2, #12]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80058f0:	4b06      	ldr	r3, [pc, #24]	; (800590c <pvPortMalloc+0x114>)
 80058f2:	695b      	ldr	r3, [r3, #20]
 80058f4:	430b      	orrs	r3, r1
 80058f6:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80058f8:	2300      	movs	r3, #0
 80058fa:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 80058fc:	f7ff fa9a 	bl	8004e34 <xTaskResumeAll>
		if( pvReturn == NULL )
 8005900:	2e00      	cmp	r6, #0
 8005902:	d189      	bne.n	8005818 <pvPortMalloc+0x20>
 8005904:	e786      	b.n	8005814 <pvPortMalloc+0x1c>
}
 8005906:	4630      	mov	r0, r6
 8005908:	bd70      	pop	{r4, r5, r6, pc}
 800590a:	bf00      	nop
 800590c:	200001d0 	.word	0x200001d0

08005910 <vPortFree>:
	if( pv != NULL )
 8005910:	2800      	cmp	r0, #0
 8005912:	d034      	beq.n	800597e <vPortFree+0x6e>
{
 8005914:	b538      	push	{r3, r4, r5, lr}
 8005916:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 8005918:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800591c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8005920:	4917      	ldr	r1, [pc, #92]	; (8005980 <vPortFree+0x70>)
 8005922:	6949      	ldr	r1, [r1, #20]
 8005924:	420a      	tst	r2, r1
 8005926:	d10a      	bne.n	800593e <vPortFree+0x2e>
 8005928:	f04f 0350 	mov.w	r3, #80	; 0x50
 800592c:	b672      	cpsid	i
 800592e:	f383 8811 	msr	BASEPRI, r3
 8005932:	f3bf 8f6f 	isb	sy
 8005936:	f3bf 8f4f 	dsb	sy
 800593a:	b662      	cpsie	i
 800593c:	e7fe      	b.n	800593c <vPortFree+0x2c>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800593e:	f850 0c08 	ldr.w	r0, [r0, #-8]
 8005942:	b150      	cbz	r0, 800595a <vPortFree+0x4a>
 8005944:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005948:	b672      	cpsid	i
 800594a:	f383 8811 	msr	BASEPRI, r3
 800594e:	f3bf 8f6f 	isb	sy
 8005952:	f3bf 8f4f 	dsb	sy
 8005956:	b662      	cpsie	i
 8005958:	e7fe      	b.n	8005958 <vPortFree+0x48>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800595a:	ea22 0201 	bic.w	r2, r2, r1
 800595e:	f844 2c04 	str.w	r2, [r4, #-4]
				vTaskSuspendAll();
 8005962:	f7ff f9c5 	bl	8004cf0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8005966:	f854 1c04 	ldr.w	r1, [r4, #-4]
 800596a:	4a05      	ldr	r2, [pc, #20]	; (8005980 <vPortFree+0x70>)
 800596c:	6913      	ldr	r3, [r2, #16]
 800596e:	440b      	add	r3, r1
 8005970:	6113      	str	r3, [r2, #16]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8005972:	4628      	mov	r0, r5
 8005974:	f7ff ff16 	bl	80057a4 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 8005978:	f7ff fa5c 	bl	8004e34 <xTaskResumeAll>
}
 800597c:	bd38      	pop	{r3, r4, r5, pc}
 800597e:	4770      	bx	lr
 8005980:	200001d0 	.word	0x200001d0

08005984 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 8005984:	b500      	push	{lr}
 8005986:	b083      	sub	sp, #12
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 8005988:	4b20      	ldr	r3, [pc, #128]	; (8005a0c <tcpip_thread+0x88>)
 800598a:	681b      	ldr	r3, [r3, #0]
 800598c:	b113      	cbz	r3, 8005994 <tcpip_thread+0x10>
    tcpip_init_done(tcpip_init_done_arg);
 800598e:	4a1f      	ldr	r2, [pc, #124]	; (8005a0c <tcpip_thread+0x88>)
 8005990:	6850      	ldr	r0, [r2, #4]
 8005992:	4798      	blx	r3
  }

  LOCK_TCPIP_CORE();
 8005994:	481e      	ldr	r0, [pc, #120]	; (8005a10 <tcpip_thread+0x8c>)
 8005996:	f003 fb75 	bl	8009084 <sys_mutex_lock>
 800599a:	e00e      	b.n	80059ba <tcpip_thread+0x36>
    /* wait for a message, timeouts are processed while waiting */
    TCPIP_MBOX_FETCH(&mbox, (void **)&msg);
    LOCK_TCPIP_CORE();
    if (msg == NULL) {
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: NULL\n"));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 800599c:	4b1d      	ldr	r3, [pc, #116]	; (8005a14 <tcpip_thread+0x90>)
 800599e:	2269      	movs	r2, #105	; 0x69
 80059a0:	491d      	ldr	r1, [pc, #116]	; (8005a18 <tcpip_thread+0x94>)
 80059a2:	481e      	ldr	r0, [pc, #120]	; (8005a1c <tcpip_thread+0x98>)
 80059a4:	f009 fd82 	bl	800f4ac <iprintf>
      continue;
 80059a8:	e007      	b.n	80059ba <tcpip_thread+0x36>
#endif /* !LWIP_TCPIP_CORE_LOCKING */

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
      msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif);
 80059aa:	68da      	ldr	r2, [r3, #12]
 80059ac:	6899      	ldr	r1, [r3, #8]
 80059ae:	6858      	ldr	r0, [r3, #4]
 80059b0:	4790      	blx	r2
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 80059b2:	9901      	ldr	r1, [sp, #4]
 80059b4:	2006      	movs	r0, #6
 80059b6:	f000 fbbb 	bl	8006130 <memp_free>
    UNLOCK_TCPIP_CORE();
 80059ba:	4c15      	ldr	r4, [pc, #84]	; (8005a10 <tcpip_thread+0x8c>)
 80059bc:	4620      	mov	r0, r4
 80059be:	f003 fb68 	bl	8009092 <sys_mutex_unlock>
    TCPIP_MBOX_FETCH(&mbox, (void **)&msg);
 80059c2:	a901      	add	r1, sp, #4
 80059c4:	4816      	ldr	r0, [pc, #88]	; (8005a20 <tcpip_thread+0x9c>)
 80059c6:	f001 f9a3 	bl	8006d10 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
 80059ca:	4620      	mov	r0, r4
 80059cc:	f003 fb5a 	bl	8009084 <sys_mutex_lock>
    if (msg == NULL) {
 80059d0:	9b01      	ldr	r3, [sp, #4]
 80059d2:	2b00      	cmp	r3, #0
 80059d4:	d0e2      	beq.n	800599c <tcpip_thread+0x18>
    switch (msg->type) {
 80059d6:	781a      	ldrb	r2, [r3, #0]
 80059d8:	2a03      	cmp	r2, #3
 80059da:	d00a      	beq.n	80059f2 <tcpip_thread+0x6e>
 80059dc:	2a04      	cmp	r2, #4
 80059de:	d010      	beq.n	8005a02 <tcpip_thread+0x7e>
 80059e0:	2a02      	cmp	r2, #2
 80059e2:	d0e2      	beq.n	80059aa <tcpip_thread+0x26>
      msg->msg.cb.function(msg->msg.cb.ctx);
      break;

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 80059e4:	4b0b      	ldr	r3, [pc, #44]	; (8005a14 <tcpip_thread+0x90>)
 80059e6:	229b      	movs	r2, #155	; 0x9b
 80059e8:	490b      	ldr	r1, [pc, #44]	; (8005a18 <tcpip_thread+0x94>)
 80059ea:	480c      	ldr	r0, [pc, #48]	; (8005a1c <tcpip_thread+0x98>)
 80059ec:	f009 fd5e 	bl	800f4ac <iprintf>
      break;
 80059f0:	e7e3      	b.n	80059ba <tcpip_thread+0x36>
      msg->msg.cb.function(msg->msg.cb.ctx);
 80059f2:	685a      	ldr	r2, [r3, #4]
 80059f4:	6898      	ldr	r0, [r3, #8]
 80059f6:	4790      	blx	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 80059f8:	9901      	ldr	r1, [sp, #4]
 80059fa:	2005      	movs	r0, #5
 80059fc:	f000 fb98 	bl	8006130 <memp_free>
      break;
 8005a00:	e7db      	b.n	80059ba <tcpip_thread+0x36>
      msg->msg.cb.function(msg->msg.cb.ctx);
 8005a02:	685a      	ldr	r2, [r3, #4]
 8005a04:	6898      	ldr	r0, [r3, #8]
 8005a06:	4790      	blx	r2
      break;
 8005a08:	e7d7      	b.n	80059ba <tcpip_thread+0x36>
 8005a0a:	bf00      	nop
 8005a0c:	20003298 	.word	0x20003298
 8005a10:	20005a2c 	.word	0x20005a2c
 8005a14:	080109a4 	.word	0x080109a4
 8005a18:	080109d4 	.word	0x080109d4
 8005a1c:	080109f4 	.word	0x080109f4
 8005a20:	200032a0 	.word	0x200032a0

08005a24 <tcpip_inpkt>:
 * @param inp the network interface on which the packet was received
 * @param input_fn input function to call
 */
err_t
tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn)
{
 8005a24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a26:	4607      	mov	r7, r0
 8005a28:	460e      	mov	r6, r1
 8005a2a:	4615      	mov	r5, r2
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(mbox));
 8005a2c:	4813      	ldr	r0, [pc, #76]	; (8005a7c <tcpip_inpkt+0x58>)
 8005a2e:	f003 faba 	bl	8008fa6 <sys_mbox_valid>
 8005a32:	b188      	cbz	r0, 8005a58 <tcpip_inpkt+0x34>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 8005a34:	2006      	movs	r0, #6
 8005a36:	f000 fb61 	bl	80060fc <memp_malloc>
  if (msg == NULL) {
 8005a3a:	4604      	mov	r4, r0
 8005a3c:	b1d0      	cbz	r0, 8005a74 <tcpip_inpkt+0x50>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
 8005a3e:	2302      	movs	r3, #2
 8005a40:	7003      	strb	r3, [r0, #0]
  msg->msg.inp.p = p;
 8005a42:	6047      	str	r7, [r0, #4]
  msg->msg.inp.netif = inp;
 8005a44:	6086      	str	r6, [r0, #8]
  msg->msg.inp.input_fn = input_fn;
 8005a46:	60c5      	str	r5, [r0, #12]
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 8005a48:	4601      	mov	r1, r0
 8005a4a:	480c      	ldr	r0, [pc, #48]	; (8005a7c <tcpip_inpkt+0x58>)
 8005a4c:	f003 fa74 	bl	8008f38 <sys_mbox_trypost>
 8005a50:	4603      	mov	r3, r0
 8005a52:	b940      	cbnz	r0, 8005a66 <tcpip_inpkt+0x42>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    return ERR_MEM;
  }
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 8005a54:	4618      	mov	r0, r3
 8005a56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(mbox));
 8005a58:	4b09      	ldr	r3, [pc, #36]	; (8005a80 <tcpip_inpkt+0x5c>)
 8005a5a:	22b5      	movs	r2, #181	; 0xb5
 8005a5c:	4909      	ldr	r1, [pc, #36]	; (8005a84 <tcpip_inpkt+0x60>)
 8005a5e:	480a      	ldr	r0, [pc, #40]	; (8005a88 <tcpip_inpkt+0x64>)
 8005a60:	f009 fd24 	bl	800f4ac <iprintf>
 8005a64:	e7e6      	b.n	8005a34 <tcpip_inpkt+0x10>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 8005a66:	4621      	mov	r1, r4
 8005a68:	2006      	movs	r0, #6
 8005a6a:	f000 fb61 	bl	8006130 <memp_free>
    return ERR_MEM;
 8005a6e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005a72:	e7ef      	b.n	8005a54 <tcpip_inpkt+0x30>
    return ERR_MEM;
 8005a74:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005a78:	e7ec      	b.n	8005a54 <tcpip_inpkt+0x30>
 8005a7a:	bf00      	nop
 8005a7c:	200032a0 	.word	0x200032a0
 8005a80:	080109a4 	.word	0x080109a4
 8005a84:	08010a1c 	.word	0x08010a1c
 8005a88:	080109f4 	.word	0x080109f4

08005a8c <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 8005a8c:	b508      	push	{r3, lr}
#if LWIP_ETHERNET
  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 8005a8e:	f891 302f 	ldrb.w	r3, [r1, #47]	; 0x2f
 8005a92:	f013 0f18 	tst.w	r3, #24
 8005a96:	d103      	bne.n	8005aa0 <tcpip_input+0x14>
    return tcpip_inpkt(p, inp, ethernet_input);
  } else
#endif /* LWIP_ETHERNET */
  return tcpip_inpkt(p, inp, ip_input);
 8005a98:	4a03      	ldr	r2, [pc, #12]	; (8005aa8 <tcpip_input+0x1c>)
 8005a9a:	f7ff ffc3 	bl	8005a24 <tcpip_inpkt>
}
 8005a9e:	bd08      	pop	{r3, pc}
    return tcpip_inpkt(p, inp, ethernet_input);
 8005aa0:	4a02      	ldr	r2, [pc, #8]	; (8005aac <tcpip_input+0x20>)
 8005aa2:	f7ff ffbf 	bl	8005a24 <tcpip_inpkt>
 8005aa6:	e7fa      	b.n	8005a9e <tcpip_input+0x12>
 8005aa8:	08008249 	.word	0x08008249
 8005aac:	08008dfd 	.word	0x08008dfd

08005ab0 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 8005ab0:	b530      	push	{r4, r5, lr}
 8005ab2:	b083      	sub	sp, #12
 8005ab4:	4605      	mov	r5, r0
 8005ab6:	460c      	mov	r4, r1
  lwip_init();
 8005ab8:	f000 f875 	bl	8005ba6 <lwip_init>

  tcpip_init_done = initfunc;
 8005abc:	4813      	ldr	r0, [pc, #76]	; (8005b0c <tcpip_init+0x5c>)
 8005abe:	6005      	str	r5, [r0, #0]
  tcpip_init_done_arg = arg;
 8005ac0:	6044      	str	r4, [r0, #4]
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 8005ac2:	2106      	movs	r1, #6
 8005ac4:	3008      	adds	r0, #8
 8005ac6:	f003 fa25 	bl	8008f14 <sys_mbox_new>
 8005aca:	b970      	cbnz	r0, 8005aea <tcpip_init+0x3a>
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
  }
#if LWIP_TCPIP_CORE_LOCKING
  if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
 8005acc:	4810      	ldr	r0, [pc, #64]	; (8005b10 <tcpip_init+0x60>)
 8005ace:	f003 fac3 	bl	8009058 <sys_mutex_new>
 8005ad2:	b990      	cbnz	r0, 8005afa <tcpip_init+0x4a>
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 8005ad4:	2303      	movs	r3, #3
 8005ad6:	9300      	str	r3, [sp, #0]
 8005ad8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005adc:	2200      	movs	r2, #0
 8005ade:	490d      	ldr	r1, [pc, #52]	; (8005b14 <tcpip_init+0x64>)
 8005ae0:	480d      	ldr	r0, [pc, #52]	; (8005b18 <tcpip_init+0x68>)
 8005ae2:	f003 fadb 	bl	800909c <sys_thread_new>
}
 8005ae6:	b003      	add	sp, #12
 8005ae8:	bd30      	pop	{r4, r5, pc}
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
 8005aea:	4b0c      	ldr	r3, [pc, #48]	; (8005b1c <tcpip_init+0x6c>)
 8005aec:	f240 12d5 	movw	r2, #469	; 0x1d5
 8005af0:	490b      	ldr	r1, [pc, #44]	; (8005b20 <tcpip_init+0x70>)
 8005af2:	480c      	ldr	r0, [pc, #48]	; (8005b24 <tcpip_init+0x74>)
 8005af4:	f009 fcda 	bl	800f4ac <iprintf>
 8005af8:	e7e8      	b.n	8005acc <tcpip_init+0x1c>
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
 8005afa:	4b08      	ldr	r3, [pc, #32]	; (8005b1c <tcpip_init+0x6c>)
 8005afc:	f240 12d9 	movw	r2, #473	; 0x1d9
 8005b00:	4909      	ldr	r1, [pc, #36]	; (8005b28 <tcpip_init+0x78>)
 8005b02:	4808      	ldr	r0, [pc, #32]	; (8005b24 <tcpip_init+0x74>)
 8005b04:	f009 fcd2 	bl	800f4ac <iprintf>
 8005b08:	e7e4      	b.n	8005ad4 <tcpip_init+0x24>
 8005b0a:	bf00      	nop
 8005b0c:	20003298 	.word	0x20003298
 8005b10:	20005a2c 	.word	0x20005a2c
 8005b14:	08005985 	.word	0x08005985
 8005b18:	08010a74 	.word	0x08010a74
 8005b1c:	080109a4 	.word	0x080109a4
 8005b20:	08010a2c 	.word	0x08010a2c
 8005b24:	080109f4 	.word	0x080109f4
 8005b28:	08010a50 	.word	0x08010a50

08005b2c <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return (u16_t)PP_HTONS(n);
 8005b2c:	ba40      	rev16	r0, r0
}
 8005b2e:	b280      	uxth	r0, r0
 8005b30:	4770      	bx	lr

08005b32 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 8005b32:	b410      	push	{r4}
 8005b34:	b083      	sub	sp, #12
  const u8_t *pb = (const u8_t *)dataptr;
  const u16_t *ps;
  u16_t t = 0;
 8005b36:	2300      	movs	r3, #0
 8005b38:	f8ad 3006 	strh.w	r3, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);
 8005b3c:	f000 0401 	and.w	r4, r0, #1

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8005b40:	460b      	mov	r3, r1
 8005b42:	2900      	cmp	r1, #0
 8005b44:	bfd4      	ite	le
 8005b46:	2100      	movle	r1, #0
 8005b48:	f004 0101 	andgt.w	r1, r4, #1
 8005b4c:	b121      	cbz	r1, 8005b58 <lwip_standard_chksum+0x26>
    ((u8_t *)&t)[1] = *pb++;
 8005b4e:	7802      	ldrb	r2, [r0, #0]
 8005b50:	f88d 2007 	strb.w	r2, [sp, #7]
    len--;
 8005b54:	3b01      	subs	r3, #1
    ((u8_t *)&t)[1] = *pb++;
 8005b56:	3001      	adds	r0, #1
  u32_t sum = 0;
 8005b58:	2200      	movs	r2, #0
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
  while (len > 1) {
 8005b5a:	e003      	b.n	8005b64 <lwip_standard_chksum+0x32>
    sum += *ps++;
 8005b5c:	8801      	ldrh	r1, [r0, #0]
 8005b5e:	440a      	add	r2, r1
    len -= 2;
 8005b60:	3b02      	subs	r3, #2
    sum += *ps++;
 8005b62:	3002      	adds	r0, #2
  while (len > 1) {
 8005b64:	2b01      	cmp	r3, #1
 8005b66:	dcf9      	bgt.n	8005b5c <lwip_standard_chksum+0x2a>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 8005b68:	2b00      	cmp	r3, #0
 8005b6a:	dd02      	ble.n	8005b72 <lwip_standard_chksum+0x40>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 8005b6c:	7803      	ldrb	r3, [r0, #0]
 8005b6e:	f88d 3006 	strb.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
 8005b72:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8005b76:	4402      	add	r2, r0

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 8005b78:	b290      	uxth	r0, r2
 8005b7a:	eb00 4212 	add.w	r2, r0, r2, lsr #16
  sum = FOLD_U32T(sum);
 8005b7e:	b290      	uxth	r0, r2
 8005b80:	eb00 4012 	add.w	r0, r0, r2, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 8005b84:	b124      	cbz	r4, 8005b90 <lwip_standard_chksum+0x5e>
    sum = SWAP_BYTES_IN_WORD(sum);
 8005b86:	0203      	lsls	r3, r0, #8
 8005b88:	b29b      	uxth	r3, r3
 8005b8a:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8005b8e:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
}
 8005b90:	b280      	uxth	r0, r0
 8005b92:	b003      	add	sp, #12
 8005b94:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005b98:	4770      	bx	lr

08005b9a <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 8005b9a:	b508      	push	{r3, lr}
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 8005b9c:	f7ff ffc9 	bl	8005b32 <lwip_standard_chksum>
 8005ba0:	43c0      	mvns	r0, r0
}
 8005ba2:	b280      	uxth	r0, r0
 8005ba4:	bd08      	pop	{r3, pc}

08005ba6 <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 8005ba6:	b508      	push	{r3, lr}
#endif

  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
 8005ba8:	f003 fa4a 	bl	8009040 <sys_init>
#endif /* !NO_SYS */
  mem_init();
 8005bac:	f000 f878 	bl	8005ca0 <mem_init>
  memp_init();
 8005bb0:	f000 fa94 	bl	80060dc <memp_init>
  pbuf_init();
  netif_init();
 8005bb4:	f000 faf1 	bl	800619a <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 8005bb8:	f001 f918 	bl	8006dec <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
 8005bbc:	f002 f95a 	bl	8007e74 <igmp_init>
#if PPP_SUPPORT
  ppp_init();
#endif
 
#if LWIP_TIMERS
  sys_timeouts_init();
 8005bc0:	f001 f880 	bl	8006cc4 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 8005bc4:	bd08      	pop	{r3, pc}
	...

08005bc8 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 8005bc8:	b510      	push	{r4, lr}
 8005bca:	4604      	mov	r4, r0
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 8005bcc:	4b2d      	ldr	r3, [pc, #180]	; (8005c84 <plug_holes+0xbc>)
 8005bce:	681b      	ldr	r3, [r3, #0]
 8005bd0:	4283      	cmp	r3, r0
 8005bd2:	d831      	bhi.n	8005c38 <plug_holes+0x70>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 8005bd4:	4b2b      	ldr	r3, [pc, #172]	; (8005c84 <plug_holes+0xbc>)
 8005bd6:	685b      	ldr	r3, [r3, #4]
 8005bd8:	42a3      	cmp	r3, r4
 8005bda:	d935      	bls.n	8005c48 <plug_holes+0x80>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 8005bdc:	7923      	ldrb	r3, [r4, #4]
 8005bde:	2b00      	cmp	r3, #0
 8005be0:	d13a      	bne.n	8005c58 <plug_holes+0x90>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8005be2:	8823      	ldrh	r3, [r4, #0]
 8005be4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005be8:	d83e      	bhi.n	8005c68 <plug_holes+0xa0>

  nmem = (struct mem *)(void *)&ram[mem->next];
 8005bea:	4b26      	ldr	r3, [pc, #152]	; (8005c84 <plug_holes+0xbc>)
 8005bec:	681b      	ldr	r3, [r3, #0]
 8005bee:	8821      	ldrh	r1, [r4, #0]
 8005bf0:	185a      	adds	r2, r3, r1
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 8005bf2:	4294      	cmp	r4, r2
 8005bf4:	d00f      	beq.n	8005c16 <plug_holes+0x4e>
 8005bf6:	7910      	ldrb	r0, [r2, #4]
 8005bf8:	b968      	cbnz	r0, 8005c16 <plug_holes+0x4e>
 8005bfa:	4822      	ldr	r0, [pc, #136]	; (8005c84 <plug_holes+0xbc>)
 8005bfc:	6840      	ldr	r0, [r0, #4]
 8005bfe:	4290      	cmp	r0, r2
 8005c00:	d009      	beq.n	8005c16 <plug_holes+0x4e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8005c02:	4820      	ldr	r0, [pc, #128]	; (8005c84 <plug_holes+0xbc>)
 8005c04:	6880      	ldr	r0, [r0, #8]
 8005c06:	4290      	cmp	r0, r2
 8005c08:	d036      	beq.n	8005c78 <plug_holes+0xb0>
      lfree = mem;
    }
    mem->next = nmem->next;
 8005c0a:	5a5a      	ldrh	r2, [r3, r1]
 8005c0c:	8022      	strh	r2, [r4, #0]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 8005c0e:	1ae0      	subs	r0, r4, r3
 8005c10:	5a5a      	ldrh	r2, [r3, r1]
 8005c12:	441a      	add	r2, r3
 8005c14:	8050      	strh	r0, [r2, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 8005c16:	8861      	ldrh	r1, [r4, #2]
 8005c18:	185a      	adds	r2, r3, r1
  if (pmem != mem && pmem->used == 0) {
 8005c1a:	4294      	cmp	r4, r2
 8005c1c:	d00b      	beq.n	8005c36 <plug_holes+0x6e>
 8005c1e:	7910      	ldrb	r0, [r2, #4]
 8005c20:	b948      	cbnz	r0, 8005c36 <plug_holes+0x6e>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 8005c22:	4818      	ldr	r0, [pc, #96]	; (8005c84 <plug_holes+0xbc>)
 8005c24:	6880      	ldr	r0, [r0, #8]
 8005c26:	42a0      	cmp	r0, r4
 8005c28:	d029      	beq.n	8005c7e <plug_holes+0xb6>
      lfree = pmem;
    }
    pmem->next = mem->next;
 8005c2a:	8820      	ldrh	r0, [r4, #0]
 8005c2c:	5258      	strh	r0, [r3, r1]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 8005c2e:	1ad2      	subs	r2, r2, r3
 8005c30:	8821      	ldrh	r1, [r4, #0]
 8005c32:	440b      	add	r3, r1
 8005c34:	805a      	strh	r2, [r3, #2]
  }
}
 8005c36:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 8005c38:	4b13      	ldr	r3, [pc, #76]	; (8005c88 <plug_holes+0xc0>)
 8005c3a:	f240 125d 	movw	r2, #349	; 0x15d
 8005c3e:	4913      	ldr	r1, [pc, #76]	; (8005c8c <plug_holes+0xc4>)
 8005c40:	4813      	ldr	r0, [pc, #76]	; (8005c90 <plug_holes+0xc8>)
 8005c42:	f009 fc33 	bl	800f4ac <iprintf>
 8005c46:	e7c5      	b.n	8005bd4 <plug_holes+0xc>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 8005c48:	4b0f      	ldr	r3, [pc, #60]	; (8005c88 <plug_holes+0xc0>)
 8005c4a:	f44f 72af 	mov.w	r2, #350	; 0x15e
 8005c4e:	4911      	ldr	r1, [pc, #68]	; (8005c94 <plug_holes+0xcc>)
 8005c50:	480f      	ldr	r0, [pc, #60]	; (8005c90 <plug_holes+0xc8>)
 8005c52:	f009 fc2b 	bl	800f4ac <iprintf>
 8005c56:	e7c1      	b.n	8005bdc <plug_holes+0x14>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 8005c58:	4b0b      	ldr	r3, [pc, #44]	; (8005c88 <plug_holes+0xc0>)
 8005c5a:	f240 125f 	movw	r2, #351	; 0x15f
 8005c5e:	490e      	ldr	r1, [pc, #56]	; (8005c98 <plug_holes+0xd0>)
 8005c60:	480b      	ldr	r0, [pc, #44]	; (8005c90 <plug_holes+0xc8>)
 8005c62:	f009 fc23 	bl	800f4ac <iprintf>
 8005c66:	e7bc      	b.n	8005be2 <plug_holes+0x1a>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8005c68:	4b07      	ldr	r3, [pc, #28]	; (8005c88 <plug_holes+0xc0>)
 8005c6a:	f44f 72b1 	mov.w	r2, #354	; 0x162
 8005c6e:	490b      	ldr	r1, [pc, #44]	; (8005c9c <plug_holes+0xd4>)
 8005c70:	4807      	ldr	r0, [pc, #28]	; (8005c90 <plug_holes+0xc8>)
 8005c72:	f009 fc1b 	bl	800f4ac <iprintf>
 8005c76:	e7b8      	b.n	8005bea <plug_holes+0x22>
      lfree = mem;
 8005c78:	4a02      	ldr	r2, [pc, #8]	; (8005c84 <plug_holes+0xbc>)
 8005c7a:	6094      	str	r4, [r2, #8]
 8005c7c:	e7c5      	b.n	8005c0a <plug_holes+0x42>
      lfree = pmem;
 8005c7e:	4801      	ldr	r0, [pc, #4]	; (8005c84 <plug_holes+0xbc>)
 8005c80:	6082      	str	r2, [r0, #8]
 8005c82:	e7d2      	b.n	8005c2a <plug_holes+0x62>
 8005c84:	200032a4 	.word	0x200032a4
 8005c88:	08010a84 	.word	0x08010a84
 8005c8c:	08010ab4 	.word	0x08010ab4
 8005c90:	080109f4 	.word	0x080109f4
 8005c94:	08010acc 	.word	0x08010acc
 8005c98:	08010ae8 	.word	0x08010ae8
 8005c9c:	08010b04 	.word	0x08010b04

08005ca0 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8005ca0:	b510      	push	{r4, lr}

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8005ca2:	4b10      	ldr	r3, [pc, #64]	; (8005ce4 <mem_init+0x44>)
 8005ca4:	f023 0303 	bic.w	r3, r3, #3
 8005ca8:	480f      	ldr	r0, [pc, #60]	; (8005ce8 <mem_init+0x48>)
 8005caa:	6003      	str	r3, [r0, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 8005cac:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8005cb0:	8019      	strh	r1, [r3, #0]
  mem->prev = 0;
 8005cb2:	2200      	movs	r2, #0
 8005cb4:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 8005cb6:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 8005cb8:	185a      	adds	r2, r3, r1
 8005cba:	6042      	str	r2, [r0, #4]
  ram_end->used = 1;
 8005cbc:	2401      	movs	r4, #1
 8005cbe:	7114      	strb	r4, [r2, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8005cc0:	f8a3 1400 	strh.w	r1, [r3, #1024]	; 0x400
  ram_end->prev = MEM_SIZE_ALIGNED;
 8005cc4:	8051      	strh	r1, [r2, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 8005cc6:	6083      	str	r3, [r0, #8]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
 8005cc8:	300c      	adds	r0, #12
 8005cca:	f003 f9c5 	bl	8009058 <sys_mutex_new>
 8005cce:	b900      	cbnz	r0, 8005cd2 <mem_init+0x32>
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 8005cd0:	bd10      	pop	{r4, pc}
    LWIP_ASSERT("failed to create mem_mutex", 0);
 8005cd2:	4b06      	ldr	r3, [pc, #24]	; (8005cec <mem_init+0x4c>)
 8005cd4:	f44f 72cc 	mov.w	r2, #408	; 0x198
 8005cd8:	4905      	ldr	r1, [pc, #20]	; (8005cf0 <mem_init+0x50>)
 8005cda:	4806      	ldr	r0, [pc, #24]	; (8005cf4 <mem_init+0x54>)
 8005cdc:	f009 fbe6 	bl	800f4ac <iprintf>
}
 8005ce0:	e7f6      	b.n	8005cd0 <mem_init+0x30>
 8005ce2:	bf00      	nop
 8005ce4:	20005a4b 	.word	0x20005a4b
 8005ce8:	200032a4 	.word	0x200032a4
 8005cec:	08010a84 	.word	0x08010a84
 8005cf0:	08010b30 	.word	0x08010b30
 8005cf4:	080109f4 	.word	0x080109f4

08005cf8 <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 8005cf8:	2800      	cmp	r0, #0
 8005cfa:	d048      	beq.n	8005d8e <mem_free+0x96>
{
 8005cfc:	b538      	push	{r3, r4, r5, lr}
 8005cfe:	4604      	mov	r4, r0
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 8005d00:	f010 0f03 	tst.w	r0, #3
 8005d04:	d11b      	bne.n	8005d3e <mem_free+0x46>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8005d06:	4b22      	ldr	r3, [pc, #136]	; (8005d90 <mem_free+0x98>)
 8005d08:	681b      	ldr	r3, [r3, #0]
 8005d0a:	42a3      	cmp	r3, r4
 8005d0c:	d803      	bhi.n	8005d16 <mem_free+0x1e>
 8005d0e:	4b20      	ldr	r3, [pc, #128]	; (8005d90 <mem_free+0x98>)
 8005d10:	685b      	ldr	r3, [r3, #4]
 8005d12:	42a3      	cmp	r3, r4
 8005d14:	d806      	bhi.n	8005d24 <mem_free+0x2c>
 8005d16:	4b1f      	ldr	r3, [pc, #124]	; (8005d94 <mem_free+0x9c>)
 8005d18:	f240 12af 	movw	r2, #431	; 0x1af
 8005d1c:	491e      	ldr	r1, [pc, #120]	; (8005d98 <mem_free+0xa0>)
 8005d1e:	481f      	ldr	r0, [pc, #124]	; (8005d9c <mem_free+0xa4>)
 8005d20:	f009 fbc4 	bl	800f4ac <iprintf>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8005d24:	4b1a      	ldr	r3, [pc, #104]	; (8005d90 <mem_free+0x98>)
 8005d26:	681b      	ldr	r3, [r3, #0]
 8005d28:	42a3      	cmp	r3, r4
 8005d2a:	d803      	bhi.n	8005d34 <mem_free+0x3c>
 8005d2c:	4b18      	ldr	r3, [pc, #96]	; (8005d90 <mem_free+0x98>)
 8005d2e:	685b      	ldr	r3, [r3, #4]
 8005d30:	42a3      	cmp	r3, r4
 8005d32:	d80c      	bhi.n	8005d4e <mem_free+0x56>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 8005d34:	f003 f9ca 	bl	80090cc <sys_arch_protect>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
 8005d38:	f003 f9d4 	bl	80090e4 <sys_arch_unprotect>
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8005d3c:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 8005d3e:	4b15      	ldr	r3, [pc, #84]	; (8005d94 <mem_free+0x9c>)
 8005d40:	f44f 72d6 	mov.w	r2, #428	; 0x1ac
 8005d44:	4916      	ldr	r1, [pc, #88]	; (8005da0 <mem_free+0xa8>)
 8005d46:	4815      	ldr	r0, [pc, #84]	; (8005d9c <mem_free+0xa4>)
 8005d48:	f009 fbb0 	bl	800f4ac <iprintf>
 8005d4c:	e7db      	b.n	8005d06 <mem_free+0xe>
  LWIP_MEM_FREE_PROTECT();
 8005d4e:	4815      	ldr	r0, [pc, #84]	; (8005da4 <mem_free+0xac>)
 8005d50:	f003 f998 	bl	8009084 <sys_mutex_lock>
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8005d54:	f1a4 0508 	sub.w	r5, r4, #8
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 8005d58:	f814 3c04 	ldrb.w	r3, [r4, #-4]
 8005d5c:	b17b      	cbz	r3, 8005d7e <mem_free+0x86>
  mem->used = 0;
 8005d5e:	2300      	movs	r3, #0
 8005d60:	f804 3c04 	strb.w	r3, [r4, #-4]
  if (mem < lfree) {
 8005d64:	4b0a      	ldr	r3, [pc, #40]	; (8005d90 <mem_free+0x98>)
 8005d66:	689b      	ldr	r3, [r3, #8]
 8005d68:	42ab      	cmp	r3, r5
 8005d6a:	d901      	bls.n	8005d70 <mem_free+0x78>
    lfree = mem;
 8005d6c:	4b08      	ldr	r3, [pc, #32]	; (8005d90 <mem_free+0x98>)
 8005d6e:	609d      	str	r5, [r3, #8]
  plug_holes(mem);
 8005d70:	4628      	mov	r0, r5
 8005d72:	f7ff ff29 	bl	8005bc8 <plug_holes>
  LWIP_MEM_FREE_UNPROTECT();
 8005d76:	480b      	ldr	r0, [pc, #44]	; (8005da4 <mem_free+0xac>)
 8005d78:	f003 f98b 	bl	8009092 <sys_mutex_unlock>
 8005d7c:	e7de      	b.n	8005d3c <mem_free+0x44>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 8005d7e:	4b05      	ldr	r3, [pc, #20]	; (8005d94 <mem_free+0x9c>)
 8005d80:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 8005d84:	4908      	ldr	r1, [pc, #32]	; (8005da8 <mem_free+0xb0>)
 8005d86:	4805      	ldr	r0, [pc, #20]	; (8005d9c <mem_free+0xa4>)
 8005d88:	f009 fb90 	bl	800f4ac <iprintf>
 8005d8c:	e7e7      	b.n	8005d5e <mem_free+0x66>
 8005d8e:	4770      	bx	lr
 8005d90:	200032a4 	.word	0x200032a4
 8005d94:	08010a84 	.word	0x08010a84
 8005d98:	08010b70 	.word	0x08010b70
 8005d9c:	080109f4 	.word	0x080109f4
 8005da0:	08010b4c 	.word	0x08010b4c
 8005da4:	200032b0 	.word	0x200032b0
 8005da8:	08010b88 	.word	0x08010b88

08005dac <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 8005dac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005db0:	4605      	mov	r5, r0
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8005db2:	1ccc      	adds	r4, r1, #3
 8005db4:	b2a4      	uxth	r4, r4
 8005db6:	f024 0403 	bic.w	r4, r4, #3
 8005dba:	b2a4      	uxth	r4, r4

  if (newsize < MIN_SIZE_ALIGNED) {
 8005dbc:	2c0b      	cmp	r4, #11
 8005dbe:	d904      	bls.n	8005dca <mem_trim+0x1e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 8005dc0:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 8005dc4:	d902      	bls.n	8005dcc <mem_trim+0x20>
    return NULL;
 8005dc6:	2500      	movs	r5, #0
 8005dc8:	e051      	b.n	8005e6e <mem_trim+0xc2>
    newsize = MIN_SIZE_ALIGNED;
 8005dca:	240c      	movs	r4, #12
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8005dcc:	4b3f      	ldr	r3, [pc, #252]	; (8005ecc <mem_trim+0x120>)
 8005dce:	681b      	ldr	r3, [r3, #0]
 8005dd0:	42ab      	cmp	r3, r5
 8005dd2:	d803      	bhi.n	8005ddc <mem_trim+0x30>
 8005dd4:	4b3d      	ldr	r3, [pc, #244]	; (8005ecc <mem_trim+0x120>)
 8005dd6:	685b      	ldr	r3, [r3, #4]
 8005dd8:	42ab      	cmp	r3, r5
 8005dda:	d806      	bhi.n	8005dea <mem_trim+0x3e>
 8005ddc:	4b3c      	ldr	r3, [pc, #240]	; (8005ed0 <mem_trim+0x124>)
 8005dde:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8005de2:	493c      	ldr	r1, [pc, #240]	; (8005ed4 <mem_trim+0x128>)
 8005de4:	483c      	ldr	r0, [pc, #240]	; (8005ed8 <mem_trim+0x12c>)
 8005de6:	f009 fb61 	bl	800f4ac <iprintf>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8005dea:	4b38      	ldr	r3, [pc, #224]	; (8005ecc <mem_trim+0x120>)
 8005dec:	681b      	ldr	r3, [r3, #0]
 8005dee:	42ab      	cmp	r3, r5
 8005df0:	d839      	bhi.n	8005e66 <mem_trim+0xba>
 8005df2:	4a36      	ldr	r2, [pc, #216]	; (8005ecc <mem_trim+0x120>)
 8005df4:	6852      	ldr	r2, [r2, #4]
 8005df6:	42aa      	cmp	r2, r5
 8005df8:	d935      	bls.n	8005e66 <mem_trim+0xba>
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8005dfa:	f1a5 0708 	sub.w	r7, r5, #8
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 8005dfe:	1aff      	subs	r7, r7, r3
 8005e00:	b2bf      	uxth	r7, r7

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8005e02:	f835 6c08 	ldrh.w	r6, [r5, #-8]
 8005e06:	1bf6      	subs	r6, r6, r7
 8005e08:	b2b6      	uxth	r6, r6
 8005e0a:	3e08      	subs	r6, #8
 8005e0c:	b2b6      	uxth	r6, r6
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8005e0e:	42b4      	cmp	r4, r6
 8005e10:	d830      	bhi.n	8005e74 <mem_trim+0xc8>
  if (newsize > size) {
 8005e12:	42b4      	cmp	r4, r6
 8005e14:	d858      	bhi.n	8005ec8 <mem_trim+0x11c>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 8005e16:	d02a      	beq.n	8005e6e <mem_trim+0xc2>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 8005e18:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 8005ecc <mem_trim+0x120>
 8005e1c:	f108 000c 	add.w	r0, r8, #12
 8005e20:	f003 f930 	bl	8009084 <sys_mutex_lock>

  mem2 = (struct mem *)(void *)&ram[mem->next];
 8005e24:	f8d8 2000 	ldr.w	r2, [r8]
 8005e28:	f835 3c08 	ldrh.w	r3, [r5, #-8]
 8005e2c:	18d1      	adds	r1, r2, r3
  if (mem2->used == 0) {
 8005e2e:	7908      	ldrb	r0, [r1, #4]
 8005e30:	bb60      	cbnz	r0, 8005e8c <mem_trim+0xe0>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 8005e32:	5ad0      	ldrh	r0, [r2, r3]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8005e34:	19e3      	adds	r3, r4, r7
 8005e36:	b29b      	uxth	r3, r3
 8005e38:	3308      	adds	r3, #8
 8005e3a:	b29b      	uxth	r3, r3
    if (lfree == mem2) {
 8005e3c:	f8d8 4008 	ldr.w	r4, [r8, #8]
 8005e40:	428c      	cmp	r4, r1
 8005e42:	d01f      	beq.n	8005e84 <mem_trim+0xd8>
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8005e44:	18d1      	adds	r1, r2, r3
    mem2->used = 0;
 8005e46:	2400      	movs	r4, #0
 8005e48:	710c      	strb	r4, [r1, #4]
    /* restore the next pointer */
    mem2->next = next;
 8005e4a:	52d0      	strh	r0, [r2, r3]
    /* link it back to mem */
    mem2->prev = ptr;
 8005e4c:	804f      	strh	r7, [r1, #2]
    /* link mem to it */
    mem->next = ptr2;
 8005e4e:	f825 3c08 	strh.w	r3, [r5, #-8]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8005e52:	5ad1      	ldrh	r1, [r2, r3]
 8005e54:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8005e58:	d001      	beq.n	8005e5e <mem_trim+0xb2>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8005e5a:	440a      	add	r2, r1
 8005e5c:	8053      	strh	r3, [r2, #2]
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 8005e5e:	481f      	ldr	r0, [pc, #124]	; (8005edc <mem_trim+0x130>)
 8005e60:	f003 f917 	bl	8009092 <sys_mutex_unlock>
  return rmem;
 8005e64:	e003      	b.n	8005e6e <mem_trim+0xc2>
    SYS_ARCH_PROTECT(lev);
 8005e66:	f003 f931 	bl	80090cc <sys_arch_protect>
    SYS_ARCH_UNPROTECT(lev);
 8005e6a:	f003 f93b 	bl	80090e4 <sys_arch_unprotect>
}
 8005e6e:	4628      	mov	r0, r5
 8005e70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8005e74:	4b16      	ldr	r3, [pc, #88]	; (8005ed0 <mem_trim+0x124>)
 8005e76:	f240 2206 	movw	r2, #518	; 0x206
 8005e7a:	4919      	ldr	r1, [pc, #100]	; (8005ee0 <mem_trim+0x134>)
 8005e7c:	4816      	ldr	r0, [pc, #88]	; (8005ed8 <mem_trim+0x12c>)
 8005e7e:	f009 fb15 	bl	800f4ac <iprintf>
 8005e82:	e7c6      	b.n	8005e12 <mem_trim+0x66>
      lfree = (struct mem *)(void *)&ram[ptr2];
 8005e84:	18d1      	adds	r1, r2, r3
 8005e86:	f8c8 1008 	str.w	r1, [r8, #8]
 8005e8a:	e7db      	b.n	8005e44 <mem_trim+0x98>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8005e8c:	f104 0314 	add.w	r3, r4, #20
 8005e90:	42b3      	cmp	r3, r6
 8005e92:	d8e4      	bhi.n	8005e5e <mem_trim+0xb2>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8005e94:	19e3      	adds	r3, r4, r7
 8005e96:	b29b      	uxth	r3, r3
 8005e98:	3308      	adds	r3, #8
 8005e9a:	b29b      	uxth	r3, r3
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8005e9c:	18d1      	adds	r1, r2, r3
    if (mem2 < lfree) {
 8005e9e:	480b      	ldr	r0, [pc, #44]	; (8005ecc <mem_trim+0x120>)
 8005ea0:	6880      	ldr	r0, [r0, #8]
 8005ea2:	4288      	cmp	r0, r1
 8005ea4:	d901      	bls.n	8005eaa <mem_trim+0xfe>
      lfree = mem2;
 8005ea6:	4809      	ldr	r0, [pc, #36]	; (8005ecc <mem_trim+0x120>)
 8005ea8:	6081      	str	r1, [r0, #8]
    mem2->used = 0;
 8005eaa:	2000      	movs	r0, #0
 8005eac:	7108      	strb	r0, [r1, #4]
    mem2->next = mem->next;
 8005eae:	f835 0c08 	ldrh.w	r0, [r5, #-8]
 8005eb2:	52d0      	strh	r0, [r2, r3]
    mem2->prev = ptr;
 8005eb4:	804f      	strh	r7, [r1, #2]
    mem->next = ptr2;
 8005eb6:	f825 3c08 	strh.w	r3, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8005eba:	5ad1      	ldrh	r1, [r2, r3]
 8005ebc:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8005ec0:	d0cd      	beq.n	8005e5e <mem_trim+0xb2>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8005ec2:	440a      	add	r2, r1
 8005ec4:	8053      	strh	r3, [r2, #2]
 8005ec6:	e7ca      	b.n	8005e5e <mem_trim+0xb2>
    return NULL;
 8005ec8:	2500      	movs	r5, #0
 8005eca:	e7d0      	b.n	8005e6e <mem_trim+0xc2>
 8005ecc:	200032a4 	.word	0x200032a4
 8005ed0:	08010a84 	.word	0x08010a84
 8005ed4:	08010b9c 	.word	0x08010b9c
 8005ed8:	080109f4 	.word	0x080109f4
 8005edc:	200032b0 	.word	0x200032b0
 8005ee0:	08010bb4 	.word	0x08010bb4

08005ee4 <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 8005ee4:	2800      	cmp	r0, #0
 8005ee6:	f000 808e 	beq.w	8006006 <mem_malloc+0x122>
{
 8005eea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005eec:	4604      	mov	r4, r0
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 8005eee:	3403      	adds	r4, #3
 8005ef0:	b2a4      	uxth	r4, r4
 8005ef2:	f024 0403 	bic.w	r4, r4, #3
 8005ef6:	b2a4      	uxth	r4, r4

  if (size < MIN_SIZE_ALIGNED) {
 8005ef8:	2c0b      	cmp	r4, #11
 8005efa:	d90d      	bls.n	8005f18 <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 8005efc:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 8005f00:	f200 8083 	bhi.w	800600a <mem_malloc+0x126>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 8005f04:	4d42      	ldr	r5, [pc, #264]	; (8006010 <mem_malloc+0x12c>)
 8005f06:	f105 000c 	add.w	r0, r5, #12
 8005f0a:	f003 f8bb 	bl	8009084 <sys_mutex_lock>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8005f0e:	6828      	ldr	r0, [r5, #0]
 8005f10:	68ab      	ldr	r3, [r5, #8]
 8005f12:	1a1b      	subs	r3, r3, r0
 8005f14:	b29b      	uxth	r3, r3
 8005f16:	e04a      	b.n	8005fae <mem_malloc+0xca>
    size = MIN_SIZE_ALIGNED;
 8005f18:	240c      	movs	r4, #12
 8005f1a:	e7f3      	b.n	8005f04 <mem_malloc+0x20>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8005f1c:	2301      	movs	r3, #1
 8005f1e:	712b      	strb	r3, [r5, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8005f20:	4b3b      	ldr	r3, [pc, #236]	; (8006010 <mem_malloc+0x12c>)
 8005f22:	689b      	ldr	r3, [r3, #8]
 8005f24:	42ab      	cmp	r3, r5
 8005f26:	d014      	beq.n	8005f52 <mem_malloc+0x6e>
          }
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
 8005f28:	4c39      	ldr	r4, [pc, #228]	; (8006010 <mem_malloc+0x12c>)
 8005f2a:	f104 000c 	add.w	r0, r4, #12
 8005f2e:	f003 f8b0 	bl	8009092 <sys_mutex_unlock>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 8005f32:	442e      	add	r6, r5
 8005f34:	3608      	adds	r6, #8
 8005f36:	6863      	ldr	r3, [r4, #4]
 8005f38:	429e      	cmp	r6, r3
 8005f3a:	d81f      	bhi.n	8005f7c <mem_malloc+0x98>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8005f3c:	f015 0403 	ands.w	r4, r5, #3
 8005f40:	d124      	bne.n	8005f8c <mem_malloc+0xa8>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8005f42:	bb5c      	cbnz	r4, 8005f9c <mem_malloc+0xb8>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 8005f44:	f105 0008 	add.w	r0, r5, #8
 8005f48:	e05c      	b.n	8006004 <mem_malloc+0x120>
            cur = (struct mem *)(void *)&ram[cur->next];
 8005f4a:	4a31      	ldr	r2, [pc, #196]	; (8006010 <mem_malloc+0x12c>)
 8005f4c:	6812      	ldr	r2, [r2, #0]
 8005f4e:	881b      	ldrh	r3, [r3, #0]
 8005f50:	4413      	add	r3, r2
          while (cur->used && cur != ram_end) {
 8005f52:	791a      	ldrb	r2, [r3, #4]
 8005f54:	b11a      	cbz	r2, 8005f5e <mem_malloc+0x7a>
 8005f56:	492e      	ldr	r1, [pc, #184]	; (8006010 <mem_malloc+0x12c>)
 8005f58:	6849      	ldr	r1, [r1, #4]
 8005f5a:	4299      	cmp	r1, r3
 8005f5c:	d1f5      	bne.n	8005f4a <mem_malloc+0x66>
          lfree = cur;
 8005f5e:	492c      	ldr	r1, [pc, #176]	; (8006010 <mem_malloc+0x12c>)
 8005f60:	608b      	str	r3, [r1, #8]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 8005f62:	6849      	ldr	r1, [r1, #4]
 8005f64:	4299      	cmp	r1, r3
 8005f66:	d0df      	beq.n	8005f28 <mem_malloc+0x44>
 8005f68:	2a00      	cmp	r2, #0
 8005f6a:	d0dd      	beq.n	8005f28 <mem_malloc+0x44>
 8005f6c:	4b29      	ldr	r3, [pc, #164]	; (8006014 <mem_malloc+0x130>)
 8005f6e:	f240 22cf 	movw	r2, #719	; 0x2cf
 8005f72:	4929      	ldr	r1, [pc, #164]	; (8006018 <mem_malloc+0x134>)
 8005f74:	4829      	ldr	r0, [pc, #164]	; (800601c <mem_malloc+0x138>)
 8005f76:	f009 fa99 	bl	800f4ac <iprintf>
 8005f7a:	e7d5      	b.n	8005f28 <mem_malloc+0x44>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 8005f7c:	4b25      	ldr	r3, [pc, #148]	; (8006014 <mem_malloc+0x130>)
 8005f7e:	f44f 7235 	mov.w	r2, #724	; 0x2d4
 8005f82:	4927      	ldr	r1, [pc, #156]	; (8006020 <mem_malloc+0x13c>)
 8005f84:	4825      	ldr	r0, [pc, #148]	; (800601c <mem_malloc+0x138>)
 8005f86:	f009 fa91 	bl	800f4ac <iprintf>
 8005f8a:	e7d7      	b.n	8005f3c <mem_malloc+0x58>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8005f8c:	4b21      	ldr	r3, [pc, #132]	; (8006014 <mem_malloc+0x130>)
 8005f8e:	f240 22d6 	movw	r2, #726	; 0x2d6
 8005f92:	4924      	ldr	r1, [pc, #144]	; (8006024 <mem_malloc+0x140>)
 8005f94:	4821      	ldr	r0, [pc, #132]	; (800601c <mem_malloc+0x138>)
 8005f96:	f009 fa89 	bl	800f4ac <iprintf>
 8005f9a:	e7d2      	b.n	8005f42 <mem_malloc+0x5e>
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8005f9c:	4b1d      	ldr	r3, [pc, #116]	; (8006014 <mem_malloc+0x130>)
 8005f9e:	f44f 7236 	mov.w	r2, #728	; 0x2d8
 8005fa2:	4921      	ldr	r1, [pc, #132]	; (8006028 <mem_malloc+0x144>)
 8005fa4:	481d      	ldr	r0, [pc, #116]	; (800601c <mem_malloc+0x138>)
 8005fa6:	f009 fa81 	bl	800f4ac <iprintf>
 8005faa:	e7cb      	b.n	8005f44 <mem_malloc+0x60>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 8005fac:	882b      	ldrh	r3, [r5, #0]
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8005fae:	461f      	mov	r7, r3
 8005fb0:	4626      	mov	r6, r4
 8005fb2:	f5c4 6180 	rsb	r1, r4, #1024	; 0x400
 8005fb6:	428b      	cmp	r3, r1
 8005fb8:	d220      	bcs.n	8005ffc <mem_malloc+0x118>
      mem = (struct mem *)(void *)&ram[ptr];
 8005fba:	18c5      	adds	r5, r0, r3
      if ((!mem->used) &&
 8005fbc:	7929      	ldrb	r1, [r5, #4]
 8005fbe:	2900      	cmp	r1, #0
 8005fc0:	d1f4      	bne.n	8005fac <mem_malloc+0xc8>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8005fc2:	5ac2      	ldrh	r2, [r0, r3]
 8005fc4:	1bd2      	subs	r2, r2, r7
 8005fc6:	3a08      	subs	r2, #8
      if ((!mem->used) &&
 8005fc8:	42b2      	cmp	r2, r6
 8005fca:	d3ef      	bcc.n	8005fac <mem_malloc+0xc8>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8005fcc:	f106 0114 	add.w	r1, r6, #20
 8005fd0:	428a      	cmp	r2, r1
 8005fd2:	d3a3      	bcc.n	8005f1c <mem_malloc+0x38>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8005fd4:	18e2      	adds	r2, r4, r3
 8005fd6:	b292      	uxth	r2, r2
 8005fd8:	3208      	adds	r2, #8
 8005fda:	b292      	uxth	r2, r2
          mem2 = (struct mem *)(void *)&ram[ptr2];
 8005fdc:	1881      	adds	r1, r0, r2
          mem2->used = 0;
 8005fde:	2400      	movs	r4, #0
 8005fe0:	710c      	strb	r4, [r1, #4]
          mem2->next = mem->next;
 8005fe2:	882c      	ldrh	r4, [r5, #0]
 8005fe4:	5284      	strh	r4, [r0, r2]
          mem2->prev = ptr;
 8005fe6:	804b      	strh	r3, [r1, #2]
          mem->next = ptr2;
 8005fe8:	802a      	strh	r2, [r5, #0]
          mem->used = 1;
 8005fea:	2301      	movs	r3, #1
 8005fec:	712b      	strb	r3, [r5, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 8005fee:	5a83      	ldrh	r3, [r0, r2]
 8005ff0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005ff4:	d094      	beq.n	8005f20 <mem_malloc+0x3c>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8005ff6:	4418      	add	r0, r3
 8005ff8:	8042      	strh	r2, [r0, #2]
 8005ffa:	e791      	b.n	8005f20 <mem_malloc+0x3c>
  } while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 8005ffc:	480b      	ldr	r0, [pc, #44]	; (800602c <mem_malloc+0x148>)
 8005ffe:	f003 f848 	bl	8009092 <sys_mutex_unlock>
  return NULL;
 8006002:	2000      	movs	r0, #0
}
 8006004:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 8006006:	2000      	movs	r0, #0
}
 8006008:	4770      	bx	lr
    return NULL;
 800600a:	2000      	movs	r0, #0
 800600c:	e7fa      	b.n	8006004 <mem_malloc+0x120>
 800600e:	bf00      	nop
 8006010:	200032a4 	.word	0x200032a4
 8006014:	08010a84 	.word	0x08010a84
 8006018:	08010bd4 	.word	0x08010bd4
 800601c:	080109f4 	.word	0x080109f4
 8006020:	08010bf0 	.word	0x08010bf0
 8006024:	08010c20 	.word	0x08010c20
 8006028:	08010c50 	.word	0x08010c50
 800602c:	200032b0 	.word	0x200032b0

08006030 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char* file, const int line)
#endif
{
 8006030:	b538      	push	{r3, r4, r5, lr}
 8006032:	4604      	mov	r4, r0

#if MEMP_MEM_MALLOC
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);
 8006034:	f003 f84a 	bl	80090cc <sys_arch_protect>
 8006038:	4605      	mov	r5, r0

  memp = *desc->tab;
 800603a:	68a3      	ldr	r3, [r4, #8]
 800603c:	681c      	ldr	r4, [r3, #0]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 800603e:	b18c      	cbz	r4, 8006064 <do_memp_malloc_pool+0x34>
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element_overflow(memp, desc);
    memp_overflow_check_element_underflow(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 8006040:	6822      	ldr	r2, [r4, #0]
 8006042:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8006044:	f014 0f03 	tst.w	r4, #3
 8006048:	d104      	bne.n	8006054 <do_memp_malloc_pool+0x24>
    desc->stats->used++;
    if (desc->stats->used > desc->stats->max) {
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
 800604a:	4628      	mov	r0, r5
 800604c:	f003 f84a 	bl	80090e4 <sys_arch_unprotect>
#endif
  }

  SYS_ARCH_UNPROTECT(old_level);
  return NULL;
}
 8006050:	4620      	mov	r0, r4
 8006052:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8006054:	4b05      	ldr	r3, [pc, #20]	; (800606c <do_memp_malloc_pool+0x3c>)
 8006056:	f240 1249 	movw	r2, #329	; 0x149
 800605a:	4905      	ldr	r1, [pc, #20]	; (8006070 <do_memp_malloc_pool+0x40>)
 800605c:	4805      	ldr	r0, [pc, #20]	; (8006074 <do_memp_malloc_pool+0x44>)
 800605e:	f009 fa25 	bl	800f4ac <iprintf>
 8006062:	e7f2      	b.n	800604a <do_memp_malloc_pool+0x1a>
  SYS_ARCH_UNPROTECT(old_level);
 8006064:	f003 f83e 	bl	80090e4 <sys_arch_unprotect>
  return NULL;
 8006068:	2400      	movs	r4, #0
 800606a:	e7f1      	b.n	8006050 <do_memp_malloc_pool+0x20>
 800606c:	08010c74 	.word	0x08010c74
 8006070:	08010ca4 	.word	0x08010ca4
 8006074:	080109f4 	.word	0x080109f4

08006078 <do_memp_free_pool>:
  return memp;
}

static void
do_memp_free_pool(const struct memp_desc* desc, void *mem)
{
 8006078:	b538      	push	{r3, r4, r5, lr}
 800607a:	4605      	mov	r5, r0
 800607c:	460c      	mov	r4, r1
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 800607e:	f011 0f03 	tst.w	r1, #3
 8006082:	d109      	bne.n	8006098 <do_memp_free_pool+0x20>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);

  SYS_ARCH_PROTECT(old_level);
 8006084:	f003 f822 	bl	80090cc <sys_arch_protect>
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 8006088:	68ab      	ldr	r3, [r5, #8]
 800608a:	681b      	ldr	r3, [r3, #0]
 800608c:	6023      	str	r3, [r4, #0]
  *desc->tab = memp;
 800608e:	68ab      	ldr	r3, [r5, #8]
 8006090:	601c      	str	r4, [r3, #0]

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
 8006092:	f003 f827 	bl	80090e4 <sys_arch_unprotect>
#endif /* !MEMP_MEM_MALLOC */
}
 8006096:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("memp_free: mem properly aligned",
 8006098:	4b03      	ldr	r3, [pc, #12]	; (80060a8 <do_memp_free_pool+0x30>)
 800609a:	f240 129d 	movw	r2, #413	; 0x19d
 800609e:	4903      	ldr	r1, [pc, #12]	; (80060ac <do_memp_free_pool+0x34>)
 80060a0:	4803      	ldr	r0, [pc, #12]	; (80060b0 <do_memp_free_pool+0x38>)
 80060a2:	f009 fa03 	bl	800f4ac <iprintf>
 80060a6:	e7ed      	b.n	8006084 <do_memp_free_pool+0xc>
 80060a8:	08010c74 	.word	0x08010c74
 80060ac:	08010cc8 	.word	0x08010cc8
 80060b0:	080109f4 	.word	0x080109f4

080060b4 <memp_init_pool>:
  *desc->tab = NULL;
 80060b4:	6883      	ldr	r3, [r0, #8]
 80060b6:	2200      	movs	r2, #0
 80060b8:	601a      	str	r2, [r3, #0]
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 80060ba:	6843      	ldr	r3, [r0, #4]
 80060bc:	3303      	adds	r3, #3
 80060be:	f023 0303 	bic.w	r3, r3, #3
  for (i = 0; i < desc->num; ++i) {
 80060c2:	e007      	b.n	80060d4 <memp_init_pool+0x20>
    memp->next = *desc->tab;
 80060c4:	6881      	ldr	r1, [r0, #8]
 80060c6:	6809      	ldr	r1, [r1, #0]
 80060c8:	6019      	str	r1, [r3, #0]
    *desc->tab = memp;
 80060ca:	6881      	ldr	r1, [r0, #8]
 80060cc:	600b      	str	r3, [r1, #0]
   memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 80060ce:	8801      	ldrh	r1, [r0, #0]
 80060d0:	440b      	add	r3, r1
  for (i = 0; i < desc->num; ++i) {
 80060d2:	3201      	adds	r2, #1
 80060d4:	8841      	ldrh	r1, [r0, #2]
 80060d6:	4291      	cmp	r1, r2
 80060d8:	dcf4      	bgt.n	80060c4 <memp_init_pool+0x10>
}
 80060da:	4770      	bx	lr

080060dc <memp_init>:
{
 80060dc:	b510      	push	{r4, lr}
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 80060de:	2400      	movs	r4, #0
 80060e0:	e006      	b.n	80060f0 <memp_init+0x14>
    memp_init_pool(memp_pools[i]);
 80060e2:	4b05      	ldr	r3, [pc, #20]	; (80060f8 <memp_init+0x1c>)
 80060e4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80060e8:	f7ff ffe4 	bl	80060b4 <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 80060ec:	3401      	adds	r4, #1
 80060ee:	b2a4      	uxth	r4, r4
 80060f0:	2c0a      	cmp	r4, #10
 80060f2:	d9f6      	bls.n	80060e2 <memp_init+0x6>
}
 80060f4:	bd10      	pop	{r4, pc}
 80060f6:	bf00      	nop
 80060f8:	08010800 	.word	0x08010800

080060fc <memp_malloc>:
{
 80060fc:	b508      	push	{r3, lr}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 80060fe:	280a      	cmp	r0, #10
 8006100:	d805      	bhi.n	800610e <memp_malloc+0x12>
  memp = do_memp_malloc_pool(memp_pools[type]);
 8006102:	4b07      	ldr	r3, [pc, #28]	; (8006120 <memp_malloc+0x24>)
 8006104:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8006108:	f7ff ff92 	bl	8006030 <do_memp_malloc_pool>
}
 800610c:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800610e:	4b05      	ldr	r3, [pc, #20]	; (8006124 <memp_malloc+0x28>)
 8006110:	f240 1287 	movw	r2, #391	; 0x187
 8006114:	4904      	ldr	r1, [pc, #16]	; (8006128 <memp_malloc+0x2c>)
 8006116:	4805      	ldr	r0, [pc, #20]	; (800612c <memp_malloc+0x30>)
 8006118:	f009 f9c8 	bl	800f4ac <iprintf>
 800611c:	2000      	movs	r0, #0
 800611e:	e7f5      	b.n	800610c <memp_malloc+0x10>
 8006120:	08010800 	.word	0x08010800
 8006124:	08010c74 	.word	0x08010c74
 8006128:	08010cfc 	.word	0x08010cfc
 800612c:	080109f4 	.word	0x080109f4

08006130 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8006130:	b508      	push	{r3, lr}
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8006132:	280a      	cmp	r0, #10
 8006134:	d806      	bhi.n	8006144 <memp_free+0x14>

  if (mem == NULL) {
 8006136:	b121      	cbz	r1, 8006142 <memp_free+0x12>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 8006138:	4b06      	ldr	r3, [pc, #24]	; (8006154 <memp_free+0x24>)
 800613a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800613e:	f7ff ff9b 	bl	8006078 <do_memp_free_pool>
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 8006142:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8006144:	4b04      	ldr	r3, [pc, #16]	; (8006158 <memp_free+0x28>)
 8006146:	f240 12db 	movw	r2, #475	; 0x1db
 800614a:	4904      	ldr	r1, [pc, #16]	; (800615c <memp_free+0x2c>)
 800614c:	4804      	ldr	r0, [pc, #16]	; (8006160 <memp_free+0x30>)
 800614e:	f009 f9ad 	bl	800f4ac <iprintf>
 8006152:	e7f6      	b.n	8006142 <memp_free+0x12>
 8006154:	08010800 	.word	0x08010800
 8006158:	08010c74 	.word	0x08010c74
 800615c:	08010d1c 	.word	0x08010d1c
 8006160:	080109f4 	.word	0x080109f4

08006164 <netif_issue_reports>:
 */
static void
netif_issue_reports(struct netif* netif, u8_t report_type)
{
#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 8006164:	f011 0f01 	tst.w	r1, #1
 8006168:	d016      	beq.n	8006198 <netif_issue_reports+0x34>
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 800616a:	6843      	ldr	r3, [r0, #4]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 800616c:	b1a3      	cbz	r3, 8006198 <netif_issue_reports+0x34>
{
 800616e:	b510      	push	{r4, lr}
 8006170:	4604      	mov	r4, r0
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 8006172:	f890 302f 	ldrb.w	r3, [r0, #47]	; 0x2f
 8006176:	f013 0f08 	tst.w	r3, #8
 800617a:	d105      	bne.n	8006188 <netif_issue_reports+0x24>
    }
#endif /* LWIP_ARP */

#if LWIP_IGMP
    /* resend IGMP memberships */
    if (netif->flags & NETIF_FLAG_IGMP) {
 800617c:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006180:	f013 0f20 	tst.w	r3, #32
 8006184:	d104      	bne.n	8006190 <netif_issue_reports+0x2c>
    /* Send Router Solicitation messages. */
    netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
  }
#endif /* LWIP_IPV6 */
}
 8006186:	bd10      	pop	{r4, pc}
      etharp_gratuitous(netif);
 8006188:	1d01      	adds	r1, r0, #4
 800618a:	f001 fa8b 	bl	80076a4 <etharp_request>
 800618e:	e7f5      	b.n	800617c <netif_issue_reports+0x18>
      igmp_report_groups(netif);
 8006190:	4620      	mov	r0, r4
 8006192:	f001 fe7b 	bl	8007e8c <igmp_report_groups>
}
 8006196:	e7f6      	b.n	8006186 <netif_issue_reports+0x22>
 8006198:	4770      	bx	lr

0800619a <netif_init>:
}
 800619a:	4770      	bx	lr

0800619c <netif_set_ipaddr>:
{
 800619c:	b530      	push	{r4, r5, lr}
 800619e:	b083      	sub	sp, #12
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 80061a0:	460d      	mov	r5, r1
 80061a2:	b199      	cbz	r1, 80061cc <netif_set_ipaddr+0x30>
 80061a4:	680a      	ldr	r2, [r1, #0]
 80061a6:	9201      	str	r2, [sp, #4]
  if (ip4_addr_cmp(ip_2_ip4(&new_addr), netif_ip4_addr(netif)) == 0) {
 80061a8:	6842      	ldr	r2, [r0, #4]
 80061aa:	9901      	ldr	r1, [sp, #4]
 80061ac:	4291      	cmp	r1, r2
 80061ae:	d00b      	beq.n	80061c8 <netif_set_ipaddr+0x2c>
 80061b0:	4604      	mov	r4, r0
    udp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
 80061b2:	a901      	add	r1, sp, #4
 80061b4:	3004      	adds	r0, #4
 80061b6:	f001 f80b 	bl	80071d0 <udp_netif_ip_addr_changed>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 80061ba:	b15d      	cbz	r5, 80061d4 <netif_set_ipaddr+0x38>
 80061bc:	682b      	ldr	r3, [r5, #0]
 80061be:	6063      	str	r3, [r4, #4]
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 80061c0:	2101      	movs	r1, #1
 80061c2:	4620      	mov	r0, r4
 80061c4:	f7ff ffce 	bl	8006164 <netif_issue_reports>
}
 80061c8:	b003      	add	sp, #12
 80061ca:	bd30      	pop	{r4, r5, pc}
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 80061cc:	4a02      	ldr	r2, [pc, #8]	; (80061d8 <netif_set_ipaddr+0x3c>)
 80061ce:	6812      	ldr	r2, [r2, #0]
 80061d0:	9201      	str	r2, [sp, #4]
 80061d2:	e7e9      	b.n	80061a8 <netif_set_ipaddr+0xc>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 80061d4:	2300      	movs	r3, #0
 80061d6:	e7f2      	b.n	80061be <netif_set_ipaddr+0x22>
 80061d8:	080108cc 	.word	0x080108cc

080061dc <netif_set_gw>:
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 80061dc:	b111      	cbz	r1, 80061e4 <netif_set_gw+0x8>
 80061de:	680b      	ldr	r3, [r1, #0]
 80061e0:	60c3      	str	r3, [r0, #12]
}
 80061e2:	4770      	bx	lr
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 80061e4:	2300      	movs	r3, #0
 80061e6:	e7fb      	b.n	80061e0 <netif_set_gw+0x4>

080061e8 <netif_set_netmask>:
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 80061e8:	b111      	cbz	r1, 80061f0 <netif_set_netmask+0x8>
 80061ea:	680b      	ldr	r3, [r1, #0]
 80061ec:	6083      	str	r3, [r0, #8]
}
 80061ee:	4770      	bx	lr
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 80061f0:	2300      	movs	r3, #0
 80061f2:	e7fb      	b.n	80061ec <netif_set_netmask+0x4>

080061f4 <netif_set_addr>:
{
 80061f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80061f6:	4604      	mov	r4, r0
 80061f8:	4617      	mov	r7, r2
 80061fa:	461e      	mov	r6, r3
  if (ip4_addr_isany(ipaddr)) {
 80061fc:	460d      	mov	r5, r1
 80061fe:	b109      	cbz	r1, 8006204 <netif_set_addr+0x10>
 8006200:	680b      	ldr	r3, [r1, #0]
 8006202:	b963      	cbnz	r3, 800621e <netif_set_addr+0x2a>
    netif_set_ipaddr(netif, ipaddr);
 8006204:	4629      	mov	r1, r5
 8006206:	4620      	mov	r0, r4
 8006208:	f7ff ffc8 	bl	800619c <netif_set_ipaddr>
    netif_set_netmask(netif, netmask);
 800620c:	4639      	mov	r1, r7
 800620e:	4620      	mov	r0, r4
 8006210:	f7ff ffea 	bl	80061e8 <netif_set_netmask>
    netif_set_gw(netif, gw);
 8006214:	4631      	mov	r1, r6
 8006216:	4620      	mov	r0, r4
 8006218:	f7ff ffe0 	bl	80061dc <netif_set_gw>
}
 800621c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    netif_set_netmask(netif, netmask);
 800621e:	4611      	mov	r1, r2
 8006220:	f7ff ffe2 	bl	80061e8 <netif_set_netmask>
    netif_set_gw(netif, gw);
 8006224:	4631      	mov	r1, r6
 8006226:	4620      	mov	r0, r4
 8006228:	f7ff ffd8 	bl	80061dc <netif_set_gw>
    netif_set_ipaddr(netif, ipaddr);
 800622c:	4629      	mov	r1, r5
 800622e:	4620      	mov	r0, r4
 8006230:	f7ff ffb4 	bl	800619c <netif_set_ipaddr>
}
 8006234:	e7f2      	b.n	800621c <netif_set_addr+0x28>
	...

08006238 <netif_add>:
{
 8006238:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800623c:	4604      	mov	r4, r0
 800623e:	460e      	mov	r6, r1
 8006240:	4617      	mov	r7, r2
 8006242:	4698      	mov	r8, r3
 8006244:	9d07      	ldr	r5, [sp, #28]
  LWIP_ASSERT("No init function given", init != NULL);
 8006246:	b34d      	cbz	r5, 800629c <netif_add+0x64>
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8006248:	2300      	movs	r3, #0
 800624a:	6063      	str	r3, [r4, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 800624c:	60a3      	str	r3, [r4, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 800624e:	60e3      	str	r3, [r4, #12]
  netif->flags = 0;
 8006250:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
  memset(netif->client_data, 0, sizeof(netif->client_data));
 8006254:	6223      	str	r3, [r4, #32]
  netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
 8006256:	2203      	movs	r2, #3
 8006258:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
  netif->igmp_mac_filter = NULL;
 800625c:	6363      	str	r3, [r4, #52]	; 0x34
  netif->state = state;
 800625e:	9b06      	ldr	r3, [sp, #24]
 8006260:	61e3      	str	r3, [r4, #28]
  netif->num = netif_num++;
 8006262:	4a15      	ldr	r2, [pc, #84]	; (80062b8 <netif_add+0x80>)
 8006264:	7813      	ldrb	r3, [r2, #0]
 8006266:	1c59      	adds	r1, r3, #1
 8006268:	7011      	strb	r1, [r2, #0]
 800626a:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
  netif->input = input;
 800626e:	9b08      	ldr	r3, [sp, #32]
 8006270:	6123      	str	r3, [r4, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 8006272:	4643      	mov	r3, r8
 8006274:	463a      	mov	r2, r7
 8006276:	4631      	mov	r1, r6
 8006278:	4620      	mov	r0, r4
 800627a:	f7ff ffbb 	bl	80061f4 <netif_set_addr>
  if (init(netif) != ERR_OK) {
 800627e:	4620      	mov	r0, r4
 8006280:	47a8      	blx	r5
 8006282:	b9b0      	cbnz	r0, 80062b2 <netif_add+0x7a>
  netif->next = netif_list;
 8006284:	4b0d      	ldr	r3, [pc, #52]	; (80062bc <netif_add+0x84>)
 8006286:	681a      	ldr	r2, [r3, #0]
 8006288:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 800628a:	601c      	str	r4, [r3, #0]
  if (netif->flags & NETIF_FLAG_IGMP) {
 800628c:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006290:	f013 0f20 	tst.w	r3, #32
 8006294:	d109      	bne.n	80062aa <netif_add+0x72>
}
 8006296:	4620      	mov	r0, r4
 8006298:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("No init function given", init != NULL);
 800629c:	4b08      	ldr	r3, [pc, #32]	; (80062c0 <netif_add+0x88>)
 800629e:	22fb      	movs	r2, #251	; 0xfb
 80062a0:	4908      	ldr	r1, [pc, #32]	; (80062c4 <netif_add+0x8c>)
 80062a2:	4809      	ldr	r0, [pc, #36]	; (80062c8 <netif_add+0x90>)
 80062a4:	f009 f902 	bl	800f4ac <iprintf>
 80062a8:	e7ce      	b.n	8006248 <netif_add+0x10>
    igmp_start(netif);
 80062aa:	4620      	mov	r0, r4
 80062ac:	f001 fe4a 	bl	8007f44 <igmp_start>
 80062b0:	e7f1      	b.n	8006296 <netif_add+0x5e>
    return NULL;
 80062b2:	2400      	movs	r4, #0
 80062b4:	e7ef      	b.n	8006296 <netif_add+0x5e>
 80062b6:	bf00      	nop
 80062b8:	200032e0 	.word	0x200032e0
 80062bc:	20008610 	.word	0x20008610
 80062c0:	08010d38 	.word	0x08010d38
 80062c4:	08010d6c 	.word	0x08010d6c
 80062c8:	080109f4 	.word	0x080109f4

080062cc <netif_set_default>:
  netif_default = netif;
 80062cc:	4b01      	ldr	r3, [pc, #4]	; (80062d4 <netif_set_default+0x8>)
 80062ce:	6018      	str	r0, [r3, #0]
}
 80062d0:	4770      	bx	lr
 80062d2:	bf00      	nop
 80062d4:	20008614 	.word	0x20008614

080062d8 <netif_set_up>:
{
 80062d8:	b508      	push	{r3, lr}
  if (!(netif->flags & NETIF_FLAG_UP)) {
 80062da:	f890 302f 	ldrb.w	r3, [r0, #47]	; 0x2f
 80062de:	f013 0f01 	tst.w	r3, #1
 80062e2:	d106      	bne.n	80062f2 <netif_set_up+0x1a>
    netif->flags |= NETIF_FLAG_UP;
 80062e4:	f043 0301 	orr.w	r3, r3, #1
 80062e8:	f880 302f 	strb.w	r3, [r0, #47]	; 0x2f
    if (netif->flags & NETIF_FLAG_LINK_UP) {
 80062ec:	f013 0f04 	tst.w	r3, #4
 80062f0:	d100      	bne.n	80062f4 <netif_set_up+0x1c>
}
 80062f2:	bd08      	pop	{r3, pc}
      netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4|NETIF_REPORT_TYPE_IPV6);
 80062f4:	2103      	movs	r1, #3
 80062f6:	f7ff ff35 	bl	8006164 <netif_issue_reports>
}
 80062fa:	e7fa      	b.n	80062f2 <netif_set_up+0x1a>

080062fc <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 80062fc:	b508      	push	{r3, lr}
  if (netif->flags & NETIF_FLAG_UP) {
 80062fe:	f890 302f 	ldrb.w	r3, [r0, #47]	; 0x2f
 8006302:	f013 0f01 	tst.w	r3, #1
 8006306:	d006      	beq.n	8006316 <netif_set_down+0x1a>
    netif->flags &= ~NETIF_FLAG_UP;
 8006308:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 800630c:	f880 302f 	strb.w	r3, [r0, #47]	; 0x2f
    MIB2_COPY_SYSUPTIME_TO(&netif->ts);

#if LWIP_IPV4 && LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8006310:	f013 0f08 	tst.w	r3, #8
 8006314:	d100      	bne.n	8006318 <netif_set_down+0x1c>
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
  }
}
 8006316:	bd08      	pop	{r3, pc}
      etharp_cleanup_netif(netif);
 8006318:	f001 f94c 	bl	80075b4 <etharp_cleanup_netif>
}
 800631c:	e7fb      	b.n	8006316 <netif_set_down+0x1a>

0800631e <pbuf_skip_const>:
{
  u16_t offset_left = in_offset;
  const struct pbuf* q = in;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 800631e:	e002      	b.n	8006326 <pbuf_skip_const+0x8>
    offset_left -= q->len;
 8006320:	1ac9      	subs	r1, r1, r3
 8006322:	b289      	uxth	r1, r1
    q = q->next;
 8006324:	6800      	ldr	r0, [r0, #0]
  while ((q != NULL) && (q->len <= offset_left)) {
 8006326:	b110      	cbz	r0, 800632e <pbuf_skip_const+0x10>
 8006328:	8943      	ldrh	r3, [r0, #10]
 800632a:	428b      	cmp	r3, r1
 800632c:	d9f8      	bls.n	8006320 <pbuf_skip_const+0x2>
  }
  if (out_offset != NULL) {
 800632e:	b102      	cbz	r2, 8006332 <pbuf_skip_const+0x14>
    *out_offset = offset_left;
 8006330:	8011      	strh	r1, [r2, #0]
  }
  return q;
}
 8006332:	4770      	bx	lr

08006334 <pbuf_header_impl>:
{
 8006334:	b570      	push	{r4, r5, r6, lr}
 8006336:	460c      	mov	r4, r1
 8006338:	4616      	mov	r6, r2
  LWIP_ASSERT("p != NULL", p != NULL);
 800633a:	4605      	mov	r5, r0
 800633c:	b318      	cbz	r0, 8006386 <pbuf_header_impl+0x52>
  if ((header_size_increment == 0) || (p == NULL)) {
 800633e:	fab5 f385 	clz	r3, r5
 8006342:	095b      	lsrs	r3, r3, #5
 8006344:	2c00      	cmp	r4, #0
 8006346:	bf08      	it	eq
 8006348:	2301      	moveq	r3, #1
 800634a:	2b00      	cmp	r3, #0
 800634c:	d151      	bne.n	80063f2 <pbuf_header_impl+0xbe>
  if (header_size_increment < 0) {
 800634e:	2c00      	cmp	r4, #0
 8006350:	db21      	blt.n	8006396 <pbuf_header_impl+0x62>
    increment_magnitude = (u16_t)header_size_increment;
 8006352:	b2a1      	uxth	r1, r4
  type = p->type;
 8006354:	7b2b      	ldrb	r3, [r5, #12]
  payload = p->payload;
 8006356:	6868      	ldr	r0, [r5, #4]
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8006358:	2b03      	cmp	r3, #3
 800635a:	bf14      	ite	ne
 800635c:	2200      	movne	r2, #0
 800635e:	2201      	moveq	r2, #1
 8006360:	2b00      	cmp	r3, #0
 8006362:	bf08      	it	eq
 8006364:	2201      	moveq	r2, #1
 8006366:	b342      	cbz	r2, 80063ba <pbuf_header_impl+0x86>
    p->payload = (u8_t *)p->payload - header_size_increment;
 8006368:	1b03      	subs	r3, r0, r4
 800636a:	606b      	str	r3, [r5, #4]
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800636c:	f105 0210 	add.w	r2, r5, #16
 8006370:	4293      	cmp	r3, r2
 8006372:	d31f      	bcc.n	80063b4 <pbuf_header_impl+0x80>
  p->len += header_size_increment;
 8006374:	b2a4      	uxth	r4, r4
 8006376:	896b      	ldrh	r3, [r5, #10]
 8006378:	4423      	add	r3, r4
 800637a:	816b      	strh	r3, [r5, #10]
  p->tot_len += header_size_increment;
 800637c:	892b      	ldrh	r3, [r5, #8]
 800637e:	441c      	add	r4, r3
 8006380:	812c      	strh	r4, [r5, #8]
  return 0;
 8006382:	2000      	movs	r0, #0
 8006384:	e036      	b.n	80063f4 <pbuf_header_impl+0xc0>
  LWIP_ASSERT("p != NULL", p != NULL);
 8006386:	4b1d      	ldr	r3, [pc, #116]	; (80063fc <pbuf_header_impl+0xc8>)
 8006388:	f240 223f 	movw	r2, #575	; 0x23f
 800638c:	491c      	ldr	r1, [pc, #112]	; (8006400 <pbuf_header_impl+0xcc>)
 800638e:	481d      	ldr	r0, [pc, #116]	; (8006404 <pbuf_header_impl+0xd0>)
 8006390:	f009 f88c 	bl	800f4ac <iprintf>
 8006394:	e7d3      	b.n	800633e <pbuf_header_impl+0xa>
    increment_magnitude = (u16_t)-header_size_increment;
 8006396:	b2a1      	uxth	r1, r4
 8006398:	4249      	negs	r1, r1
 800639a:	b289      	uxth	r1, r1
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800639c:	896b      	ldrh	r3, [r5, #10]
 800639e:	428b      	cmp	r3, r1
 80063a0:	d2d8      	bcs.n	8006354 <pbuf_header_impl+0x20>
 80063a2:	4b16      	ldr	r3, [pc, #88]	; (80063fc <pbuf_header_impl+0xc8>)
 80063a4:	f240 2247 	movw	r2, #583	; 0x247
 80063a8:	4917      	ldr	r1, [pc, #92]	; (8006408 <pbuf_header_impl+0xd4>)
 80063aa:	4816      	ldr	r0, [pc, #88]	; (8006404 <pbuf_header_impl+0xd0>)
 80063ac:	f009 f87e 	bl	800f4ac <iprintf>
 80063b0:	2001      	movs	r0, #1
 80063b2:	e01f      	b.n	80063f4 <pbuf_header_impl+0xc0>
      p->payload = payload;
 80063b4:	6068      	str	r0, [r5, #4]
      return 1;
 80063b6:	2001      	movs	r0, #1
 80063b8:	e01c      	b.n	80063f4 <pbuf_header_impl+0xc0>
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 80063ba:	3b01      	subs	r3, #1
 80063bc:	b29b      	uxth	r3, r3
 80063be:	2b01      	cmp	r3, #1
 80063c0:	d80e      	bhi.n	80063e0 <pbuf_header_impl+0xac>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 80063c2:	2c00      	cmp	r4, #0
 80063c4:	db06      	blt.n	80063d4 <pbuf_header_impl+0xa0>
    } else if ((header_size_increment > 0) && force) {
 80063c6:	2e00      	cmp	r6, #0
 80063c8:	bf18      	it	ne
 80063ca:	2c00      	cmpne	r4, #0
 80063cc:	dd13      	ble.n	80063f6 <pbuf_header_impl+0xc2>
      p->payload = (u8_t *)p->payload - header_size_increment;
 80063ce:	1b00      	subs	r0, r0, r4
 80063d0:	6068      	str	r0, [r5, #4]
 80063d2:	e7cf      	b.n	8006374 <pbuf_header_impl+0x40>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 80063d4:	896b      	ldrh	r3, [r5, #10]
 80063d6:	428b      	cmp	r3, r1
 80063d8:	d3f5      	bcc.n	80063c6 <pbuf_header_impl+0x92>
      p->payload = (u8_t *)p->payload - header_size_increment;
 80063da:	1b00      	subs	r0, r0, r4
 80063dc:	6068      	str	r0, [r5, #4]
 80063de:	e7c9      	b.n	8006374 <pbuf_header_impl+0x40>
    LWIP_ASSERT("bad pbuf type", 0);
 80063e0:	4b06      	ldr	r3, [pc, #24]	; (80063fc <pbuf_header_impl+0xc8>)
 80063e2:	f240 2277 	movw	r2, #631	; 0x277
 80063e6:	4909      	ldr	r1, [pc, #36]	; (800640c <pbuf_header_impl+0xd8>)
 80063e8:	4806      	ldr	r0, [pc, #24]	; (8006404 <pbuf_header_impl+0xd0>)
 80063ea:	f009 f85f 	bl	800f4ac <iprintf>
    return 1;
 80063ee:	2001      	movs	r0, #1
 80063f0:	e000      	b.n	80063f4 <pbuf_header_impl+0xc0>
    return 0;
 80063f2:	2000      	movs	r0, #0
}
 80063f4:	bd70      	pop	{r4, r5, r6, pc}
      return 1;
 80063f6:	2001      	movs	r0, #1
 80063f8:	e7fc      	b.n	80063f4 <pbuf_header_impl+0xc0>
 80063fa:	bf00      	nop
 80063fc:	08010d84 	.word	0x08010d84
 8006400:	08010db4 	.word	0x08010db4
 8006404:	080109f4 	.word	0x080109f4
 8006408:	08010dc0 	.word	0x08010dc0
 800640c:	08010de0 	.word	0x08010de0

08006410 <pbuf_alloced_custom>:
{
 8006410:	b570      	push	{r4, r5, r6, lr}
 8006412:	9c04      	ldr	r4, [sp, #16]
  switch (l) {
 8006414:	2804      	cmp	r0, #4
 8006416:	d80a      	bhi.n	800642e <pbuf_alloced_custom+0x1e>
 8006418:	e8df f000 	tbb	[pc, r0]
 800641c:	05031412 	.word	0x05031412
 8006420:	07          	.byte	0x07
 8006421:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8006422:	200e      	movs	r0, #14
    break;
 8006424:	e00f      	b.n	8006446 <pbuf_alloced_custom+0x36>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8006426:	2000      	movs	r0, #0
    break;
 8006428:	e00d      	b.n	8006446 <pbuf_alloced_custom+0x36>
    offset = 0;
 800642a:	2000      	movs	r0, #0
    break;
 800642c:	e00b      	b.n	8006446 <pbuf_alloced_custom+0x36>
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
 800642e:	4b13      	ldr	r3, [pc, #76]	; (800647c <pbuf_alloced_custom+0x6c>)
 8006430:	f240 12c5 	movw	r2, #453	; 0x1c5
 8006434:	4912      	ldr	r1, [pc, #72]	; (8006480 <pbuf_alloced_custom+0x70>)
 8006436:	4813      	ldr	r0, [pc, #76]	; (8006484 <pbuf_alloced_custom+0x74>)
 8006438:	f009 f838 	bl	800f4ac <iprintf>
    return NULL;
 800643c:	2000      	movs	r0, #0
 800643e:	e017      	b.n	8006470 <pbuf_alloced_custom+0x60>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 8006440:	2036      	movs	r0, #54	; 0x36
 8006442:	e000      	b.n	8006446 <pbuf_alloced_custom+0x36>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8006444:	2022      	movs	r0, #34	; 0x22
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 8006446:	3003      	adds	r0, #3
 8006448:	f020 0003 	bic.w	r0, r0, #3
 800644c:	180e      	adds	r6, r1, r0
 800644e:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 8006452:	42ae      	cmp	r6, r5
 8006454:	d810      	bhi.n	8006478 <pbuf_alloced_custom+0x68>
  p->pbuf.next = NULL;
 8006456:	2500      	movs	r5, #0
 8006458:	601d      	str	r5, [r3, #0]
  if (payload_mem != NULL) {
 800645a:	b154      	cbz	r4, 8006472 <pbuf_alloced_custom+0x62>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 800645c:	4420      	add	r0, r4
 800645e:	6058      	str	r0, [r3, #4]
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 8006460:	2002      	movs	r0, #2
 8006462:	7358      	strb	r0, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
 8006464:	8119      	strh	r1, [r3, #8]
 8006466:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 8006468:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 800646a:	2201      	movs	r2, #1
 800646c:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 800646e:	4618      	mov	r0, r3
}
 8006470:	bd70      	pop	{r4, r5, r6, pc}
    p->pbuf.payload = NULL;
 8006472:	2000      	movs	r0, #0
 8006474:	6058      	str	r0, [r3, #4]
 8006476:	e7f3      	b.n	8006460 <pbuf_alloced_custom+0x50>
    return NULL;
 8006478:	2000      	movs	r0, #0
 800647a:	e7f9      	b.n	8006470 <pbuf_alloced_custom+0x60>
 800647c:	08010d84 	.word	0x08010d84
 8006480:	08010df0 	.word	0x08010df0
 8006484:	080109f4 	.word	0x080109f4

08006488 <pbuf_header>:
{
 8006488:	b508      	push	{r3, lr}
   return pbuf_header_impl(p, header_size_increment, 0);
 800648a:	2200      	movs	r2, #0
 800648c:	f7ff ff52 	bl	8006334 <pbuf_header_impl>
}
 8006490:	bd08      	pop	{r3, pc}

08006492 <pbuf_header_force>:
{
 8006492:	b508      	push	{r3, lr}
   return pbuf_header_impl(p, header_size_increment, 1);
 8006494:	2201      	movs	r2, #1
 8006496:	f7ff ff4d 	bl	8006334 <pbuf_header_impl>
}
 800649a:	bd08      	pop	{r3, pc}

0800649c <pbuf_free>:
{
 800649c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (p == NULL) {
 800649e:	b128      	cbz	r0, 80064ac <pbuf_free+0x10>
 80064a0:	4604      	mov	r4, r0
  LWIP_ASSERT("pbuf_free: sane type",
 80064a2:	7b03      	ldrb	r3, [r0, #12]
 80064a4:	2b03      	cmp	r3, #3
 80064a6:	d80b      	bhi.n	80064c0 <pbuf_free+0x24>
{
 80064a8:	2600      	movs	r6, #0
 80064aa:	e01f      	b.n	80064ec <pbuf_free+0x50>
    LWIP_ASSERT("p != NULL", p != NULL);
 80064ac:	4b2a      	ldr	r3, [pc, #168]	; (8006558 <pbuf_free+0xbc>)
 80064ae:	f240 22d2 	movw	r2, #722	; 0x2d2
 80064b2:	492a      	ldr	r1, [pc, #168]	; (800655c <pbuf_free+0xc0>)
 80064b4:	482a      	ldr	r0, [pc, #168]	; (8006560 <pbuf_free+0xc4>)
 80064b6:	f008 fff9 	bl	800f4ac <iprintf>
    return 0;
 80064ba:	2600      	movs	r6, #0
}
 80064bc:	4630      	mov	r0, r6
 80064be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ASSERT("pbuf_free: sane type",
 80064c0:	4b25      	ldr	r3, [pc, #148]	; (8006558 <pbuf_free+0xbc>)
 80064c2:	f240 22de 	movw	r2, #734	; 0x2de
 80064c6:	4927      	ldr	r1, [pc, #156]	; (8006564 <pbuf_free+0xc8>)
 80064c8:	4825      	ldr	r0, [pc, #148]	; (8006560 <pbuf_free+0xc4>)
 80064ca:	f008 ffef 	bl	800f4ac <iprintf>
 80064ce:	e7eb      	b.n	80064a8 <pbuf_free+0xc>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 80064d0:	4b21      	ldr	r3, [pc, #132]	; (8006558 <pbuf_free+0xbc>)
 80064d2:	f240 22eb 	movw	r2, #747	; 0x2eb
 80064d6:	4924      	ldr	r1, [pc, #144]	; (8006568 <pbuf_free+0xcc>)
 80064d8:	4821      	ldr	r0, [pc, #132]	; (8006560 <pbuf_free+0xc4>)
 80064da:	f008 ffe7 	bl	800f4ac <iprintf>
 80064de:	e00d      	b.n	80064fc <pbuf_free+0x60>
        pc->custom_free_function(p);
 80064e0:	6923      	ldr	r3, [r4, #16]
 80064e2:	4620      	mov	r0, r4
 80064e4:	4798      	blx	r3
      count++;
 80064e6:	3601      	adds	r6, #1
 80064e8:	b2f6      	uxtb	r6, r6
      p = q;
 80064ea:	462c      	mov	r4, r5
  while (p != NULL) {
 80064ec:	2c00      	cmp	r4, #0
 80064ee:	d0e5      	beq.n	80064bc <pbuf_free+0x20>
    SYS_ARCH_PROTECT(old_level);
 80064f0:	f002 fdec 	bl	80090cc <sys_arch_protect>
 80064f4:	4607      	mov	r7, r0
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 80064f6:	89e3      	ldrh	r3, [r4, #14]
 80064f8:	2b00      	cmp	r3, #0
 80064fa:	d0e9      	beq.n	80064d0 <pbuf_free+0x34>
    ref = --(p->ref);
 80064fc:	89e5      	ldrh	r5, [r4, #14]
 80064fe:	3d01      	subs	r5, #1
 8006500:	b2ad      	uxth	r5, r5
 8006502:	81e5      	strh	r5, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
 8006504:	4638      	mov	r0, r7
 8006506:	f002 fded 	bl	80090e4 <sys_arch_unprotect>
    if (ref == 0) {
 800650a:	2d00      	cmp	r5, #0
 800650c:	d1d6      	bne.n	80064bc <pbuf_free+0x20>
      q = p->next;
 800650e:	6825      	ldr	r5, [r4, #0]
      type = p->type;
 8006510:	7b23      	ldrb	r3, [r4, #12]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8006512:	7b62      	ldrb	r2, [r4, #13]
 8006514:	f012 0f02 	tst.w	r2, #2
 8006518:	d00a      	beq.n	8006530 <pbuf_free+0x94>
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 800651a:	6923      	ldr	r3, [r4, #16]
 800651c:	2b00      	cmp	r3, #0
 800651e:	d1df      	bne.n	80064e0 <pbuf_free+0x44>
 8006520:	4b0d      	ldr	r3, [pc, #52]	; (8006558 <pbuf_free+0xbc>)
 8006522:	f240 22f9 	movw	r2, #761	; 0x2f9
 8006526:	4911      	ldr	r1, [pc, #68]	; (800656c <pbuf_free+0xd0>)
 8006528:	480d      	ldr	r0, [pc, #52]	; (8006560 <pbuf_free+0xc4>)
 800652a:	f008 ffbf 	bl	800f4ac <iprintf>
 800652e:	e7d7      	b.n	80064e0 <pbuf_free+0x44>
        if (type == PBUF_POOL) {
 8006530:	2b03      	cmp	r3, #3
 8006532:	d007      	beq.n	8006544 <pbuf_free+0xa8>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8006534:	3b01      	subs	r3, #1
 8006536:	b29b      	uxth	r3, r3
 8006538:	2b01      	cmp	r3, #1
 800653a:	d908      	bls.n	800654e <pbuf_free+0xb2>
          mem_free(p);
 800653c:	4620      	mov	r0, r4
 800653e:	f7ff fbdb 	bl	8005cf8 <mem_free>
 8006542:	e7d0      	b.n	80064e6 <pbuf_free+0x4a>
          memp_free(MEMP_PBUF_POOL, p);
 8006544:	4621      	mov	r1, r4
 8006546:	200a      	movs	r0, #10
 8006548:	f7ff fdf2 	bl	8006130 <memp_free>
 800654c:	e7cb      	b.n	80064e6 <pbuf_free+0x4a>
          memp_free(MEMP_PBUF, p);
 800654e:	4621      	mov	r1, r4
 8006550:	2009      	movs	r0, #9
 8006552:	f7ff fded 	bl	8006130 <memp_free>
 8006556:	e7c6      	b.n	80064e6 <pbuf_free+0x4a>
 8006558:	08010d84 	.word	0x08010d84
 800655c:	08010db4 	.word	0x08010db4
 8006560:	080109f4 	.word	0x080109f4
 8006564:	08010e14 	.word	0x08010e14
 8006568:	08010e2c 	.word	0x08010e2c
 800656c:	08010e44 	.word	0x08010e44

08006570 <pbuf_alloc>:
{
 8006570:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006574:	460e      	mov	r6, r1
 8006576:	4617      	mov	r7, r2
  switch (layer) {
 8006578:	2804      	cmp	r0, #4
 800657a:	d80a      	bhi.n	8006592 <pbuf_alloc+0x22>
 800657c:	e8df f000 	tbb	[pc, r0]
 8006580:	05031412 	.word	0x05031412
 8006584:	07          	.byte	0x07
 8006585:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8006586:	240e      	movs	r4, #14
    break;
 8006588:	e00f      	b.n	80065aa <pbuf_alloc+0x3a>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 800658a:	2400      	movs	r4, #0
    break;
 800658c:	e00d      	b.n	80065aa <pbuf_alloc+0x3a>
    offset = 0;
 800658e:	2400      	movs	r4, #0
    break;
 8006590:	e00b      	b.n	80065aa <pbuf_alloc+0x3a>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 8006592:	4b63      	ldr	r3, [pc, #396]	; (8006720 <pbuf_alloc+0x1b0>)
 8006594:	f44f 728b 	mov.w	r2, #278	; 0x116
 8006598:	4962      	ldr	r1, [pc, #392]	; (8006724 <pbuf_alloc+0x1b4>)
 800659a:	4863      	ldr	r0, [pc, #396]	; (8006728 <pbuf_alloc+0x1b8>)
 800659c:	f008 ff86 	bl	800f4ac <iprintf>
    return NULL;
 80065a0:	2500      	movs	r5, #0
 80065a2:	e0ae      	b.n	8006702 <pbuf_alloc+0x192>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 80065a4:	2436      	movs	r4, #54	; 0x36
 80065a6:	e000      	b.n	80065aa <pbuf_alloc+0x3a>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 80065a8:	2422      	movs	r4, #34	; 0x22
  switch (type) {
 80065aa:	2f03      	cmp	r7, #3
 80065ac:	f200 80ac 	bhi.w	8006708 <pbuf_alloc+0x198>
 80065b0:	e8df f007 	tbb	[pc, r7]
 80065b4:	02989878 	.word	0x02989878
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 80065b8:	200a      	movs	r0, #10
 80065ba:	f7ff fd9f 	bl	80060fc <memp_malloc>
    if (p == NULL) {
 80065be:	4605      	mov	r5, r0
 80065c0:	2800      	cmp	r0, #0
 80065c2:	f000 809e 	beq.w	8006702 <pbuf_alloc+0x192>
    p->type = type;
 80065c6:	7307      	strb	r7, [r0, #12]
    p->next = NULL;
 80065c8:	2300      	movs	r3, #0
 80065ca:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 80065cc:	f104 0310 	add.w	r3, r4, #16
 80065d0:	4403      	add	r3, r0
 80065d2:	3303      	adds	r3, #3
 80065d4:	f023 0303 	bic.w	r3, r3, #3
 80065d8:	6043      	str	r3, [r0, #4]
    p->tot_len = length;
 80065da:	8106      	strh	r6, [r0, #8]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 80065dc:	1ce2      	adds	r2, r4, #3
 80065de:	f022 0203 	bic.w	r2, r2, #3
 80065e2:	f5c2 72c8 	rsb	r2, r2, #400	; 0x190
 80065e6:	42b2      	cmp	r2, r6
 80065e8:	bf28      	it	cs
 80065ea:	4632      	movcs	r2, r6
 80065ec:	b292      	uxth	r2, r2
 80065ee:	8142      	strh	r2, [r0, #10]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 80065f0:	4413      	add	r3, r2
 80065f2:	f500 78d0 	add.w	r8, r0, #416	; 0x1a0
 80065f6:	4543      	cmp	r3, r8
 80065f8:	d805      	bhi.n	8006606 <pbuf_alloc+0x96>
    p->ref = 1;
 80065fa:	2301      	movs	r3, #1
 80065fc:	81eb      	strh	r3, [r5, #14]
    rem_len = length - p->len;
 80065fe:	896b      	ldrh	r3, [r5, #10]
 8006600:	1af6      	subs	r6, r6, r3
    r = p;
 8006602:	46a9      	mov	r9, r5
    while (rem_len > 0) {
 8006604:	e028      	b.n	8006658 <pbuf_alloc+0xe8>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8006606:	4b46      	ldr	r3, [pc, #280]	; (8006720 <pbuf_alloc+0x1b0>)
 8006608:	f44f 7298 	mov.w	r2, #304	; 0x130
 800660c:	4947      	ldr	r1, [pc, #284]	; (800672c <pbuf_alloc+0x1bc>)
 800660e:	4846      	ldr	r0, [pc, #280]	; (8006728 <pbuf_alloc+0x1b8>)
 8006610:	f008 ff4c 	bl	800f4ac <iprintf>
 8006614:	e7f1      	b.n	80065fa <pbuf_alloc+0x8a>
        pbuf_free(p);
 8006616:	4628      	mov	r0, r5
 8006618:	f7ff ff40 	bl	800649c <pbuf_free>
        return NULL;
 800661c:	4625      	mov	r5, r4
 800661e:	e070      	b.n	8006702 <pbuf_alloc+0x192>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8006620:	4b3f      	ldr	r3, [pc, #252]	; (8006720 <pbuf_alloc+0x1b0>)
 8006622:	f44f 72a6 	mov.w	r2, #332	; 0x14c
 8006626:	4942      	ldr	r1, [pc, #264]	; (8006730 <pbuf_alloc+0x1c0>)
 8006628:	483f      	ldr	r0, [pc, #252]	; (8006728 <pbuf_alloc+0x1b8>)
 800662a:	f008 ff3f 	bl	800f4ac <iprintf>
 800662e:	e025      	b.n	800667c <pbuf_alloc+0x10c>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8006630:	4b3b      	ldr	r3, [pc, #236]	; (8006720 <pbuf_alloc+0x1b0>)
 8006632:	f44f 72a9 	mov.w	r2, #338	; 0x152
 8006636:	493f      	ldr	r1, [pc, #252]	; (8006734 <pbuf_alloc+0x1c4>)
 8006638:	483b      	ldr	r0, [pc, #236]	; (8006728 <pbuf_alloc+0x1b8>)
 800663a:	f008 ff37 	bl	800f4ac <iprintf>
 800663e:	e02b      	b.n	8006698 <pbuf_alloc+0x128>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8006640:	4b37      	ldr	r3, [pc, #220]	; (8006720 <pbuf_alloc+0x1b0>)
 8006642:	f240 1255 	movw	r2, #341	; 0x155
 8006646:	4939      	ldr	r1, [pc, #228]	; (800672c <pbuf_alloc+0x1bc>)
 8006648:	4837      	ldr	r0, [pc, #220]	; (8006728 <pbuf_alloc+0x1b8>)
 800664a:	f008 ff2f 	bl	800f4ac <iprintf>
      q->ref = 1;
 800664e:	2301      	movs	r3, #1
 8006650:	81e3      	strh	r3, [r4, #14]
      rem_len -= q->len;
 8006652:	8963      	ldrh	r3, [r4, #10]
 8006654:	1af6      	subs	r6, r6, r3
      r = q;
 8006656:	46a1      	mov	r9, r4
    while (rem_len > 0) {
 8006658:	2e00      	cmp	r6, #0
 800665a:	dd4e      	ble.n	80066fa <pbuf_alloc+0x18a>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 800665c:	200a      	movs	r0, #10
 800665e:	f7ff fd4d 	bl	80060fc <memp_malloc>
      if (q == NULL) {
 8006662:	4604      	mov	r4, r0
 8006664:	2800      	cmp	r0, #0
 8006666:	d0d6      	beq.n	8006616 <pbuf_alloc+0xa6>
      q->type = type;
 8006668:	7307      	strb	r7, [r0, #12]
      q->flags = 0;
 800666a:	2300      	movs	r3, #0
 800666c:	7343      	strb	r3, [r0, #13]
      q->next = NULL;
 800666e:	6003      	str	r3, [r0, #0]
      r->next = q;
 8006670:	f8c9 0000 	str.w	r0, [r9]
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8006674:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8006678:	429e      	cmp	r6, r3
 800667a:	dcd1      	bgt.n	8006620 <pbuf_alloc+0xb0>
      q->tot_len = (u16_t)rem_len;
 800667c:	b2b3      	uxth	r3, r6
 800667e:	8123      	strh	r3, [r4, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8006680:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 8006684:	bf28      	it	cs
 8006686:	f44f 73c8 	movcs.w	r3, #400	; 0x190
 800668a:	8163      	strh	r3, [r4, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 800668c:	f104 0310 	add.w	r3, r4, #16
 8006690:	6063      	str	r3, [r4, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8006692:	f013 0f03 	tst.w	r3, #3
 8006696:	d1cb      	bne.n	8006630 <pbuf_alloc+0xc0>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8006698:	686b      	ldr	r3, [r5, #4]
 800669a:	896a      	ldrh	r2, [r5, #10]
 800669c:	4413      	add	r3, r2
 800669e:	4598      	cmp	r8, r3
 80066a0:	d2d5      	bcs.n	800664e <pbuf_alloc+0xde>
 80066a2:	e7cd      	b.n	8006640 <pbuf_alloc+0xd0>
      mem_size_t alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);
 80066a4:	f104 0013 	add.w	r0, r4, #19
 80066a8:	f020 0003 	bic.w	r0, r0, #3
 80066ac:	b283      	uxth	r3, r0
 80066ae:	1cf2      	adds	r2, r6, #3
 80066b0:	b290      	uxth	r0, r2
 80066b2:	f020 0003 	bic.w	r0, r0, #3
 80066b6:	4418      	add	r0, r3
 80066b8:	b280      	uxth	r0, r0
      if (alloc_len < LWIP_MEM_ALIGN_SIZE(length)) {
 80066ba:	f022 0203 	bic.w	r2, r2, #3
 80066be:	4290      	cmp	r0, r2
 80066c0:	d32b      	bcc.n	800671a <pbuf_alloc+0x1aa>
      p = (struct pbuf*)mem_malloc(alloc_len);
 80066c2:	f7ff fc0f 	bl	8005ee4 <mem_malloc>
    if (p == NULL) {
 80066c6:	4605      	mov	r5, r0
 80066c8:	b1d8      	cbz	r0, 8006702 <pbuf_alloc+0x192>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 80066ca:	f104 0310 	add.w	r3, r4, #16
 80066ce:	4403      	add	r3, r0
 80066d0:	3303      	adds	r3, #3
 80066d2:	f023 0303 	bic.w	r3, r3, #3
 80066d6:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 80066d8:	8106      	strh	r6, [r0, #8]
 80066da:	8146      	strh	r6, [r0, #10]
    p->next = NULL;
 80066dc:	2300      	movs	r3, #0
 80066de:	6003      	str	r3, [r0, #0]
    p->type = type;
 80066e0:	7307      	strb	r7, [r0, #12]
 80066e2:	e00a      	b.n	80066fa <pbuf_alloc+0x18a>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 80066e4:	2009      	movs	r0, #9
 80066e6:	f7ff fd09 	bl	80060fc <memp_malloc>
    if (p == NULL) {
 80066ea:	4605      	mov	r5, r0
 80066ec:	b148      	cbz	r0, 8006702 <pbuf_alloc+0x192>
    p->payload = NULL;
 80066ee:	2300      	movs	r3, #0
 80066f0:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 80066f2:	8106      	strh	r6, [r0, #8]
 80066f4:	8146      	strh	r6, [r0, #10]
    p->next = NULL;
 80066f6:	6003      	str	r3, [r0, #0]
    p->type = type;
 80066f8:	7307      	strb	r7, [r0, #12]
  p->ref = 1;
 80066fa:	2301      	movs	r3, #1
 80066fc:	81eb      	strh	r3, [r5, #14]
  p->flags = 0;
 80066fe:	2300      	movs	r3, #0
 8006700:	736b      	strb	r3, [r5, #13]
}
 8006702:	4628      	mov	r0, r5
 8006704:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8006708:	4b05      	ldr	r3, [pc, #20]	; (8006720 <pbuf_alloc+0x1b0>)
 800670a:	f44f 72c6 	mov.w	r2, #396	; 0x18c
 800670e:	490a      	ldr	r1, [pc, #40]	; (8006738 <pbuf_alloc+0x1c8>)
 8006710:	4805      	ldr	r0, [pc, #20]	; (8006728 <pbuf_alloc+0x1b8>)
 8006712:	f008 fecb 	bl	800f4ac <iprintf>
    return NULL;
 8006716:	2500      	movs	r5, #0
 8006718:	e7f3      	b.n	8006702 <pbuf_alloc+0x192>
        return NULL;
 800671a:	2500      	movs	r5, #0
 800671c:	e7f1      	b.n	8006702 <pbuf_alloc+0x192>
 800671e:	bf00      	nop
 8006720:	08010d84 	.word	0x08010d84
 8006724:	08010e68 	.word	0x08010e68
 8006728:	080109f4 	.word	0x080109f4
 800672c:	08010e84 	.word	0x08010e84
 8006730:	08010eec 	.word	0x08010eec
 8006734:	08010f00 	.word	0x08010f00
 8006738:	08010f30 	.word	0x08010f30

0800673c <pbuf_realloc>:
{
 800673c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006740:	460e      	mov	r6, r1
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8006742:	4604      	mov	r4, r0
 8006744:	b170      	cbz	r0, 8006764 <pbuf_realloc+0x28>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8006746:	7b23      	ldrb	r3, [r4, #12]
 8006748:	2b03      	cmp	r3, #3
 800674a:	bf18      	it	ne
 800674c:	2b01      	cmpne	r3, #1
 800674e:	d002      	beq.n	8006756 <pbuf_realloc+0x1a>
 8006750:	b10b      	cbz	r3, 8006756 <pbuf_realloc+0x1a>
 8006752:	2b02      	cmp	r3, #2
 8006754:	d10e      	bne.n	8006774 <pbuf_realloc+0x38>
  if (new_len >= p->tot_len) {
 8006756:	8927      	ldrh	r7, [r4, #8]
 8006758:	42b7      	cmp	r7, r6
 800675a:	d943      	bls.n	80067e4 <pbuf_realloc+0xa8>
  grow = new_len - p->tot_len;
 800675c:	eba6 0807 	sub.w	r8, r6, r7
  rem_len = new_len;
 8006760:	4635      	mov	r5, r6
  while (rem_len > q->len) {
 8006762:	e016      	b.n	8006792 <pbuf_realloc+0x56>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8006764:	4b2a      	ldr	r3, [pc, #168]	; (8006810 <pbuf_realloc+0xd4>)
 8006766:	f240 12f3 	movw	r2, #499	; 0x1f3
 800676a:	492a      	ldr	r1, [pc, #168]	; (8006814 <pbuf_realloc+0xd8>)
 800676c:	482a      	ldr	r0, [pc, #168]	; (8006818 <pbuf_realloc+0xdc>)
 800676e:	f008 fe9d 	bl	800f4ac <iprintf>
 8006772:	e7e8      	b.n	8006746 <pbuf_realloc+0xa>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8006774:	4b26      	ldr	r3, [pc, #152]	; (8006810 <pbuf_realloc+0xd4>)
 8006776:	f240 12f7 	movw	r2, #503	; 0x1f7
 800677a:	4928      	ldr	r1, [pc, #160]	; (800681c <pbuf_realloc+0xe0>)
 800677c:	4826      	ldr	r0, [pc, #152]	; (8006818 <pbuf_realloc+0xdc>)
 800677e:	f008 fe95 	bl	800f4ac <iprintf>
 8006782:	e7e8      	b.n	8006756 <pbuf_realloc+0x1a>
    q->tot_len += (u16_t)grow;
 8006784:	1bf3      	subs	r3, r6, r7
 8006786:	8922      	ldrh	r2, [r4, #8]
 8006788:	fa12 f383 	uxtah	r3, r2, r3
 800678c:	8123      	strh	r3, [r4, #8]
    q = q->next;
 800678e:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8006790:	b184      	cbz	r4, 80067b4 <pbuf_realloc+0x78>
  while (rem_len > q->len) {
 8006792:	8963      	ldrh	r3, [r4, #10]
 8006794:	42ab      	cmp	r3, r5
 8006796:	d215      	bcs.n	80067c4 <pbuf_realloc+0x88>
    rem_len -= q->len;
 8006798:	1aed      	subs	r5, r5, r3
 800679a:	b2ad      	uxth	r5, r5
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 800679c:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80067a0:	4598      	cmp	r8, r3
 80067a2:	ddef      	ble.n	8006784 <pbuf_realloc+0x48>
 80067a4:	4b1a      	ldr	r3, [pc, #104]	; (8006810 <pbuf_realloc+0xd4>)
 80067a6:	f240 220b 	movw	r2, #523	; 0x20b
 80067aa:	491d      	ldr	r1, [pc, #116]	; (8006820 <pbuf_realloc+0xe4>)
 80067ac:	481a      	ldr	r0, [pc, #104]	; (8006818 <pbuf_realloc+0xdc>)
 80067ae:	f008 fe7d 	bl	800f4ac <iprintf>
 80067b2:	e7e7      	b.n	8006784 <pbuf_realloc+0x48>
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 80067b4:	4b16      	ldr	r3, [pc, #88]	; (8006810 <pbuf_realloc+0xd4>)
 80067b6:	f240 220f 	movw	r2, #527	; 0x20f
 80067ba:	491a      	ldr	r1, [pc, #104]	; (8006824 <pbuf_realloc+0xe8>)
 80067bc:	4816      	ldr	r0, [pc, #88]	; (8006818 <pbuf_realloc+0xdc>)
 80067be:	f008 fe75 	bl	800f4ac <iprintf>
 80067c2:	e7e6      	b.n	8006792 <pbuf_realloc+0x56>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)
 80067c4:	7b22      	ldrb	r2, [r4, #12]
 80067c6:	b92a      	cbnz	r2, 80067d4 <pbuf_realloc+0x98>
 80067c8:	42ab      	cmp	r3, r5
 80067ca:	d003      	beq.n	80067d4 <pbuf_realloc+0x98>
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 80067cc:	7b63      	ldrb	r3, [r4, #13]
 80067ce:	f013 0f02 	tst.w	r3, #2
 80067d2:	d009      	beq.n	80067e8 <pbuf_realloc+0xac>
  q->len = rem_len;
 80067d4:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 80067d6:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 80067d8:	6820      	ldr	r0, [r4, #0]
 80067da:	b108      	cbz	r0, 80067e0 <pbuf_realloc+0xa4>
    pbuf_free(q->next);
 80067dc:	f7ff fe5e 	bl	800649c <pbuf_free>
  q->next = NULL;
 80067e0:	2300      	movs	r3, #0
 80067e2:	6023      	str	r3, [r4, #0]
}
 80067e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 80067e8:	6863      	ldr	r3, [r4, #4]
 80067ea:	1b1b      	subs	r3, r3, r4
 80067ec:	fa15 f183 	uxtah	r1, r5, r3
 80067f0:	b289      	uxth	r1, r1
 80067f2:	4620      	mov	r0, r4
 80067f4:	f7ff fada 	bl	8005dac <mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 80067f8:	4604      	mov	r4, r0
 80067fa:	2800      	cmp	r0, #0
 80067fc:	d1ea      	bne.n	80067d4 <pbuf_realloc+0x98>
 80067fe:	4b04      	ldr	r3, [pc, #16]	; (8006810 <pbuf_realloc+0xd4>)
 8006800:	f240 221d 	movw	r2, #541	; 0x21d
 8006804:	4908      	ldr	r1, [pc, #32]	; (8006828 <pbuf_realloc+0xec>)
 8006806:	4804      	ldr	r0, [pc, #16]	; (8006818 <pbuf_realloc+0xdc>)
 8006808:	f008 fe50 	bl	800f4ac <iprintf>
 800680c:	e7e2      	b.n	80067d4 <pbuf_realloc+0x98>
 800680e:	bf00      	nop
 8006810:	08010d84 	.word	0x08010d84
 8006814:	08010f4c 	.word	0x08010f4c
 8006818:	080109f4 	.word	0x080109f4
 800681c:	08010f64 	.word	0x08010f64
 8006820:	08010f80 	.word	0x08010f80
 8006824:	08010f94 	.word	0x08010f94
 8006828:	08010fac 	.word	0x08010fac

0800682c <pbuf_clen>:
  len = 0;
 800682c:	2300      	movs	r3, #0
  while (p != NULL) {
 800682e:	e002      	b.n	8006836 <pbuf_clen+0xa>
    ++len;
 8006830:	3301      	adds	r3, #1
 8006832:	b29b      	uxth	r3, r3
    p = p->next;
 8006834:	6800      	ldr	r0, [r0, #0]
  while (p != NULL) {
 8006836:	2800      	cmp	r0, #0
 8006838:	d1fa      	bne.n	8006830 <pbuf_clen+0x4>
}
 800683a:	4618      	mov	r0, r3
 800683c:	4770      	bx	lr
	...

08006840 <pbuf_ref>:
  if (p != NULL) {
 8006840:	b198      	cbz	r0, 800686a <pbuf_ref+0x2a>
{
 8006842:	b510      	push	{r4, lr}
 8006844:	4604      	mov	r4, r0
    SYS_ARCH_INC(p->ref, 1);
 8006846:	f002 fc41 	bl	80090cc <sys_arch_protect>
 800684a:	89e3      	ldrh	r3, [r4, #14]
 800684c:	3301      	adds	r3, #1
 800684e:	81e3      	strh	r3, [r4, #14]
 8006850:	f002 fc48 	bl	80090e4 <sys_arch_unprotect>
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 8006854:	89e3      	ldrh	r3, [r4, #14]
 8006856:	b103      	cbz	r3, 800685a <pbuf_ref+0x1a>
}
 8006858:	bd10      	pop	{r4, pc}
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 800685a:	4b04      	ldr	r3, [pc, #16]	; (800686c <pbuf_ref+0x2c>)
 800685c:	f240 3239 	movw	r2, #825	; 0x339
 8006860:	4903      	ldr	r1, [pc, #12]	; (8006870 <pbuf_ref+0x30>)
 8006862:	4804      	ldr	r0, [pc, #16]	; (8006874 <pbuf_ref+0x34>)
 8006864:	f008 fe22 	bl	800f4ac <iprintf>
}
 8006868:	e7f6      	b.n	8006858 <pbuf_ref+0x18>
 800686a:	4770      	bx	lr
 800686c:	08010d84 	.word	0x08010d84
 8006870:	08010fc8 	.word	0x08010fc8
 8006874:	080109f4 	.word	0x080109f4

08006878 <pbuf_cat>:
{
 8006878:	b538      	push	{r3, r4, r5, lr}
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800687a:	4604      	mov	r4, r0
 800687c:	460d      	mov	r5, r1
 800687e:	fab1 f181 	clz	r1, r1
 8006882:	0949      	lsrs	r1, r1, #5
 8006884:	2800      	cmp	r0, #0
 8006886:	bf08      	it	eq
 8006888:	2101      	moveq	r1, #1
 800688a:	b161      	cbz	r1, 80068a6 <pbuf_cat+0x2e>
 800688c:	4b15      	ldr	r3, [pc, #84]	; (80068e4 <pbuf_cat+0x6c>)
 800688e:	f240 324d 	movw	r2, #845	; 0x34d
 8006892:	4915      	ldr	r1, [pc, #84]	; (80068e8 <pbuf_cat+0x70>)
 8006894:	4815      	ldr	r0, [pc, #84]	; (80068ec <pbuf_cat+0x74>)
 8006896:	f008 fe09 	bl	800f4ac <iprintf>
 800689a:	e019      	b.n	80068d0 <pbuf_cat+0x58>
    p->tot_len += t->tot_len;
 800689c:	892b      	ldrh	r3, [r5, #8]
 800689e:	8921      	ldrh	r1, [r4, #8]
 80068a0:	440b      	add	r3, r1
 80068a2:	8123      	strh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
 80068a4:	4614      	mov	r4, r2
 80068a6:	6822      	ldr	r2, [r4, #0]
 80068a8:	2a00      	cmp	r2, #0
 80068aa:	d1f7      	bne.n	800689c <pbuf_cat+0x24>
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 80068ac:	8922      	ldrh	r2, [r4, #8]
 80068ae:	8963      	ldrh	r3, [r4, #10]
 80068b0:	429a      	cmp	r2, r3
 80068b2:	d10e      	bne.n	80068d2 <pbuf_cat+0x5a>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 80068b4:	6823      	ldr	r3, [r4, #0]
 80068b6:	b133      	cbz	r3, 80068c6 <pbuf_cat+0x4e>
 80068b8:	4b0a      	ldr	r3, [pc, #40]	; (80068e4 <pbuf_cat+0x6c>)
 80068ba:	f240 3256 	movw	r2, #854	; 0x356
 80068be:	490c      	ldr	r1, [pc, #48]	; (80068f0 <pbuf_cat+0x78>)
 80068c0:	480a      	ldr	r0, [pc, #40]	; (80068ec <pbuf_cat+0x74>)
 80068c2:	f008 fdf3 	bl	800f4ac <iprintf>
  p->tot_len += t->tot_len;
 80068c6:	892b      	ldrh	r3, [r5, #8]
 80068c8:	8922      	ldrh	r2, [r4, #8]
 80068ca:	4413      	add	r3, r2
 80068cc:	8123      	strh	r3, [r4, #8]
  p->next = t;
 80068ce:	6025      	str	r5, [r4, #0]
}
 80068d0:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 80068d2:	4b04      	ldr	r3, [pc, #16]	; (80068e4 <pbuf_cat+0x6c>)
 80068d4:	f240 3255 	movw	r2, #853	; 0x355
 80068d8:	4906      	ldr	r1, [pc, #24]	; (80068f4 <pbuf_cat+0x7c>)
 80068da:	4804      	ldr	r0, [pc, #16]	; (80068ec <pbuf_cat+0x74>)
 80068dc:	f008 fde6 	bl	800f4ac <iprintf>
 80068e0:	e7e8      	b.n	80068b4 <pbuf_cat+0x3c>
 80068e2:	bf00      	nop
 80068e4:	08010d84 	.word	0x08010d84
 80068e8:	08010fdc 	.word	0x08010fdc
 80068ec:	080109f4 	.word	0x080109f4
 80068f0:	08011044 	.word	0x08011044
 80068f4:	08011014 	.word	0x08011014

080068f8 <pbuf_chain>:
{
 80068f8:	b510      	push	{r4, lr}
 80068fa:	460c      	mov	r4, r1
  pbuf_cat(h, t);
 80068fc:	f7ff ffbc 	bl	8006878 <pbuf_cat>
  pbuf_ref(t);
 8006900:	4620      	mov	r0, r4
 8006902:	f7ff ff9d 	bl	8006840 <pbuf_ref>
}
 8006906:	bd10      	pop	{r4, pc}

08006908 <pbuf_copy>:
{
 8006908:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 800690c:	460d      	mov	r5, r1
 800690e:	fab1 f181 	clz	r1, r1
 8006912:	0949      	lsrs	r1, r1, #5
 8006914:	2800      	cmp	r0, #0
 8006916:	bf08      	it	eq
 8006918:	2101      	moveq	r1, #1
 800691a:	b941      	cbnz	r1, 800692e <pbuf_copy+0x26>
 800691c:	4607      	mov	r7, r0
 800691e:	8902      	ldrh	r2, [r0, #8]
 8006920:	892b      	ldrh	r3, [r5, #8]
 8006922:	429a      	cmp	r2, r3
 8006924:	d303      	bcc.n	800692e <pbuf_copy+0x26>
  u16_t offset_to=0, offset_from=0, len;
 8006926:	f04f 0800 	mov.w	r8, #0
 800692a:	4646      	mov	r6, r8
 800692c:	e03f      	b.n	80069ae <pbuf_copy+0xa6>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 800692e:	4b3f      	ldr	r3, [pc, #252]	; (8006a2c <pbuf_copy+0x124>)
 8006930:	f240 32bd 	movw	r2, #957	; 0x3bd
 8006934:	493e      	ldr	r1, [pc, #248]	; (8006a30 <pbuf_copy+0x128>)
 8006936:	483f      	ldr	r0, [pc, #252]	; (8006a34 <pbuf_copy+0x12c>)
 8006938:	f008 fdb8 	bl	800f4ac <iprintf>
 800693c:	f06f 000f 	mvn.w	r0, #15
 8006940:	e071      	b.n	8006a26 <pbuf_copy+0x11e>
      len = p_to->len - offset_to;
 8006942:	1b9b      	subs	r3, r3, r6
 8006944:	b29c      	uxth	r4, r3
 8006946:	e03a      	b.n	80069be <pbuf_copy+0xb6>
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8006948:	4b38      	ldr	r3, [pc, #224]	; (8006a2c <pbuf_copy+0x124>)
 800694a:	f240 32cd 	movw	r2, #973	; 0x3cd
 800694e:	493a      	ldr	r1, [pc, #232]	; (8006a38 <pbuf_copy+0x130>)
 8006950:	4838      	ldr	r0, [pc, #224]	; (8006a34 <pbuf_copy+0x12c>)
 8006952:	f008 fdab 	bl	800f4ac <iprintf>
 8006956:	e041      	b.n	80069dc <pbuf_copy+0xd4>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 8006958:	4b34      	ldr	r3, [pc, #208]	; (8006a2c <pbuf_copy+0x124>)
 800695a:	f240 32ce 	movw	r2, #974	; 0x3ce
 800695e:	4937      	ldr	r1, [pc, #220]	; (8006a3c <pbuf_copy+0x134>)
 8006960:	4834      	ldr	r0, [pc, #208]	; (8006a34 <pbuf_copy+0x12c>)
 8006962:	f008 fda3 	bl	800f4ac <iprintf>
 8006966:	e03c      	b.n	80069e2 <pbuf_copy+0xda>
      p_to = p_to->next;
 8006968:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 800696a:	1c2b      	adds	r3, r5, #0
 800696c:	bf18      	it	ne
 800696e:	2301      	movne	r3, #1
 8006970:	2f00      	cmp	r7, #0
 8006972:	bf18      	it	ne
 8006974:	2300      	movne	r3, #0
 8006976:	b90b      	cbnz	r3, 800697c <pbuf_copy+0x74>
      offset_to = 0;
 8006978:	2600      	movs	r6, #0
 800697a:	e03b      	b.n	80069f4 <pbuf_copy+0xec>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 800697c:	4b2b      	ldr	r3, [pc, #172]	; (8006a2c <pbuf_copy+0x124>)
 800697e:	f44f 7276 	mov.w	r2, #984	; 0x3d8
 8006982:	492f      	ldr	r1, [pc, #188]	; (8006a40 <pbuf_copy+0x138>)
 8006984:	482b      	ldr	r0, [pc, #172]	; (8006a34 <pbuf_copy+0x12c>)
 8006986:	f008 fd91 	bl	800f4ac <iprintf>
 800698a:	f06f 000f 	mvn.w	r0, #15
 800698e:	e04a      	b.n	8006a26 <pbuf_copy+0x11e>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 8006990:	682b      	ldr	r3, [r5, #0]
 8006992:	2b00      	cmp	r3, #0
 8006994:	d033      	beq.n	80069fe <pbuf_copy+0xf6>
 8006996:	4b25      	ldr	r3, [pc, #148]	; (8006a2c <pbuf_copy+0x124>)
 8006998:	f240 32de 	movw	r2, #990	; 0x3de
 800699c:	4929      	ldr	r1, [pc, #164]	; (8006a44 <pbuf_copy+0x13c>)
 800699e:	4825      	ldr	r0, [pc, #148]	; (8006a34 <pbuf_copy+0x12c>)
 80069a0:	f008 fd84 	bl	800f4ac <iprintf>
 80069a4:	f06f 0005 	mvn.w	r0, #5
 80069a8:	e03d      	b.n	8006a26 <pbuf_copy+0x11e>
  } while (p_from);
 80069aa:	2d00      	cmp	r5, #0
 80069ac:	d03a      	beq.n	8006a24 <pbuf_copy+0x11c>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 80069ae:	897b      	ldrh	r3, [r7, #10]
 80069b0:	1b99      	subs	r1, r3, r6
 80069b2:	896c      	ldrh	r4, [r5, #10]
 80069b4:	eba4 0208 	sub.w	r2, r4, r8
 80069b8:	4291      	cmp	r1, r2
 80069ba:	dbc2      	blt.n	8006942 <pbuf_copy+0x3a>
      len = p_from->len - offset_from;
 80069bc:	b294      	uxth	r4, r2
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 80069be:	6878      	ldr	r0, [r7, #4]
 80069c0:	6869      	ldr	r1, [r5, #4]
 80069c2:	4622      	mov	r2, r4
 80069c4:	4441      	add	r1, r8
 80069c6:	4430      	add	r0, r6
 80069c8:	f008 fd5d 	bl	800f486 <memcpy>
    offset_to += len;
 80069cc:	4426      	add	r6, r4
 80069ce:	b2b6      	uxth	r6, r6
    offset_from += len;
 80069d0:	4444      	add	r4, r8
 80069d2:	fa1f f884 	uxth.w	r8, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 80069d6:	897b      	ldrh	r3, [r7, #10]
 80069d8:	42b3      	cmp	r3, r6
 80069da:	d3b5      	bcc.n	8006948 <pbuf_copy+0x40>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 80069dc:	896b      	ldrh	r3, [r5, #10]
 80069de:	4543      	cmp	r3, r8
 80069e0:	d3ba      	bcc.n	8006958 <pbuf_copy+0x50>
    if (offset_from >= p_from->len) {
 80069e2:	896b      	ldrh	r3, [r5, #10]
 80069e4:	4543      	cmp	r3, r8
 80069e6:	d802      	bhi.n	80069ee <pbuf_copy+0xe6>
      p_from = p_from->next;
 80069e8:	682d      	ldr	r5, [r5, #0]
      offset_from = 0;
 80069ea:	f04f 0800 	mov.w	r8, #0
    if (offset_to == p_to->len) {
 80069ee:	897b      	ldrh	r3, [r7, #10]
 80069f0:	42b3      	cmp	r3, r6
 80069f2:	d0b9      	beq.n	8006968 <pbuf_copy+0x60>
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 80069f4:	b11d      	cbz	r5, 80069fe <pbuf_copy+0xf6>
 80069f6:	896a      	ldrh	r2, [r5, #10]
 80069f8:	892b      	ldrh	r3, [r5, #8]
 80069fa:	429a      	cmp	r2, r3
 80069fc:	d0c8      	beq.n	8006990 <pbuf_copy+0x88>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 80069fe:	2f00      	cmp	r7, #0
 8006a00:	d0d3      	beq.n	80069aa <pbuf_copy+0xa2>
 8006a02:	897a      	ldrh	r2, [r7, #10]
 8006a04:	893b      	ldrh	r3, [r7, #8]
 8006a06:	429a      	cmp	r2, r3
 8006a08:	d1cf      	bne.n	80069aa <pbuf_copy+0xa2>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 8006a0a:	683b      	ldr	r3, [r7, #0]
 8006a0c:	2b00      	cmp	r3, #0
 8006a0e:	d0cc      	beq.n	80069aa <pbuf_copy+0xa2>
 8006a10:	4b06      	ldr	r3, [pc, #24]	; (8006a2c <pbuf_copy+0x124>)
 8006a12:	f240 32e3 	movw	r2, #995	; 0x3e3
 8006a16:	490b      	ldr	r1, [pc, #44]	; (8006a44 <pbuf_copy+0x13c>)
 8006a18:	4806      	ldr	r0, [pc, #24]	; (8006a34 <pbuf_copy+0x12c>)
 8006a1a:	f008 fd47 	bl	800f4ac <iprintf>
 8006a1e:	f06f 0005 	mvn.w	r0, #5
 8006a22:	e000      	b.n	8006a26 <pbuf_copy+0x11e>
  return ERR_OK;
 8006a24:	2000      	movs	r0, #0
}
 8006a26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006a2a:	bf00      	nop
 8006a2c:	08010d84 	.word	0x08010d84
 8006a30:	08011090 	.word	0x08011090
 8006a34:	080109f4 	.word	0x080109f4
 8006a38:	080110c0 	.word	0x080110c0
 8006a3c:	080110d8 	.word	0x080110d8
 8006a40:	080110f4 	.word	0x080110f4
 8006a44:	08011104 	.word	0x08011104

08006a48 <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf*
pbuf_skip(struct pbuf* in, u16_t in_offset, u16_t* out_offset)
{
 8006a48:	b508      	push	{r3, lr}
  const struct pbuf* out = pbuf_skip_const(in, in_offset, out_offset);
 8006a4a:	f7ff fc68 	bl	800631e <pbuf_skip_const>
  return LWIP_CONST_CAST(struct pbuf*, out);
}
 8006a4e:	bd08      	pop	{r3, pc}

08006a50 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 8006a50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 8006a54:	b148      	cbz	r0, 8006a6a <pbuf_take+0x1a>
 8006a56:	4688      	mov	r8, r1
 8006a58:	4691      	mov	r9, r2
 8006a5a:	4606      	mov	r6, r0
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 8006a5c:	b179      	cbz	r1, 8006a7e <pbuf_take+0x2e>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 8006a5e:	8903      	ldrh	r3, [r0, #8]
 8006a60:	4293      	cmp	r3, r2
 8006a62:	d316      	bcc.n	8006a92 <pbuf_take+0x42>
  u16_t total_copy_len = len;
 8006a64:	4614      	mov	r4, r2
  u16_t copied_total = 0;
 8006a66:	2700      	movs	r7, #0
 8006a68:	e030      	b.n	8006acc <pbuf_take+0x7c>
  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 8006a6a:	4b23      	ldr	r3, [pc, #140]	; (8006af8 <pbuf_take+0xa8>)
 8006a6c:	f240 4284 	movw	r2, #1156	; 0x484
 8006a70:	4922      	ldr	r1, [pc, #136]	; (8006afc <pbuf_take+0xac>)
 8006a72:	4823      	ldr	r0, [pc, #140]	; (8006b00 <pbuf_take+0xb0>)
 8006a74:	f008 fd1a 	bl	800f4ac <iprintf>
 8006a78:	f06f 000f 	mvn.w	r0, #15
 8006a7c:	e031      	b.n	8006ae2 <pbuf_take+0x92>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 8006a7e:	4b1e      	ldr	r3, [pc, #120]	; (8006af8 <pbuf_take+0xa8>)
 8006a80:	f240 4285 	movw	r2, #1157	; 0x485
 8006a84:	491f      	ldr	r1, [pc, #124]	; (8006b04 <pbuf_take+0xb4>)
 8006a86:	481e      	ldr	r0, [pc, #120]	; (8006b00 <pbuf_take+0xb0>)
 8006a88:	f008 fd10 	bl	800f4ac <iprintf>
 8006a8c:	f06f 000f 	mvn.w	r0, #15
 8006a90:	e027      	b.n	8006ae2 <pbuf_take+0x92>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 8006a92:	4b19      	ldr	r3, [pc, #100]	; (8006af8 <pbuf_take+0xa8>)
 8006a94:	f240 4286 	movw	r2, #1158	; 0x486
 8006a98:	491b      	ldr	r1, [pc, #108]	; (8006b08 <pbuf_take+0xb8>)
 8006a9a:	4819      	ldr	r0, [pc, #100]	; (8006b00 <pbuf_take+0xb0>)
 8006a9c:	f008 fd06 	bl	800f4ac <iprintf>
 8006aa0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006aa4:	e01d      	b.n	8006ae2 <pbuf_take+0x92>
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 8006aa6:	4b14      	ldr	r3, [pc, #80]	; (8006af8 <pbuf_take+0xa8>)
 8006aa8:	f240 428e 	movw	r2, #1166	; 0x48e
 8006aac:	4917      	ldr	r1, [pc, #92]	; (8006b0c <pbuf_take+0xbc>)
 8006aae:	4814      	ldr	r0, [pc, #80]	; (8006b00 <pbuf_take+0xb0>)
 8006ab0:	f008 fcfc 	bl	800f4ac <iprintf>
 8006ab4:	e00d      	b.n	8006ad2 <pbuf_take+0x82>
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char*)dataptr)[copied_total], buf_copy_len);
 8006ab6:	462a      	mov	r2, r5
 8006ab8:	eb08 0107 	add.w	r1, r8, r7
 8006abc:	6870      	ldr	r0, [r6, #4]
 8006abe:	f008 fce2 	bl	800f486 <memcpy>
    total_copy_len -= buf_copy_len;
 8006ac2:	1b64      	subs	r4, r4, r5
 8006ac4:	b2a4      	uxth	r4, r4
    copied_total += buf_copy_len;
 8006ac6:	442f      	add	r7, r5
 8006ac8:	b2bf      	uxth	r7, r7
  for (p = buf; total_copy_len != 0; p = p->next) {
 8006aca:	6836      	ldr	r6, [r6, #0]
 8006acc:	b134      	cbz	r4, 8006adc <pbuf_take+0x8c>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 8006ace:	2e00      	cmp	r6, #0
 8006ad0:	d0e9      	beq.n	8006aa6 <pbuf_take+0x56>
    if (buf_copy_len > p->len) {
 8006ad2:	8975      	ldrh	r5, [r6, #10]
 8006ad4:	42a5      	cmp	r5, r4
 8006ad6:	d3ee      	bcc.n	8006ab6 <pbuf_take+0x66>
    buf_copy_len = total_copy_len;
 8006ad8:	4625      	mov	r5, r4
 8006ada:	e7ec      	b.n	8006ab6 <pbuf_take+0x66>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 8006adc:	454f      	cmp	r7, r9
 8006ade:	d102      	bne.n	8006ae6 <pbuf_take+0x96>
  return ERR_OK;
 8006ae0:	2000      	movs	r0, #0
}
 8006ae2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 8006ae6:	4b04      	ldr	r3, [pc, #16]	; (8006af8 <pbuf_take+0xa8>)
 8006ae8:	f240 4299 	movw	r2, #1177	; 0x499
 8006aec:	4908      	ldr	r1, [pc, #32]	; (8006b10 <pbuf_take+0xc0>)
 8006aee:	4804      	ldr	r0, [pc, #16]	; (8006b00 <pbuf_take+0xb0>)
 8006af0:	f008 fcdc 	bl	800f4ac <iprintf>
  return ERR_OK;
 8006af4:	2000      	movs	r0, #0
 8006af6:	e7f4      	b.n	8006ae2 <pbuf_take+0x92>
 8006af8:	08010d84 	.word	0x08010d84
 8006afc:	08011174 	.word	0x08011174
 8006b00:	080109f4 	.word	0x080109f4
 8006b04:	0801118c 	.word	0x0801118c
 8006b08:	080111a8 	.word	0x080111a8
 8006b0c:	080111c8 	.word	0x080111c8
 8006b10:	080111e0 	.word	0x080111e0

08006b14 <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 8006b14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006b16:	b083      	sub	sp, #12
 8006b18:	460f      	mov	r7, r1
 8006b1a:	4615      	mov	r5, r2
  u16_t target_offset;
  struct pbuf* q = pbuf_skip(buf, offset, &target_offset);
 8006b1c:	f10d 0206 	add.w	r2, sp, #6
 8006b20:	4619      	mov	r1, r3
 8006b22:	f7ff ff91 	bl	8006a48 <pbuf_skip>

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 8006b26:	b1e8      	cbz	r0, 8006b64 <pbuf_take_at+0x50>
 8006b28:	4606      	mov	r6, r0
 8006b2a:	8901      	ldrh	r1, [r0, #8]
 8006b2c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8006b30:	195a      	adds	r2, r3, r5
 8006b32:	4291      	cmp	r1, r2
 8006b34:	db19      	blt.n	8006b6a <pbuf_take_at+0x56>
    u16_t remaining_len = len;
    const u8_t* src_ptr = (const u8_t*)dataptr;
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len = LWIP_MIN(q->len - target_offset, len);
 8006b36:	8944      	ldrh	r4, [r0, #10]
 8006b38:	1ae4      	subs	r4, r4, r3
 8006b3a:	42ac      	cmp	r4, r5
 8006b3c:	bfa8      	it	ge
 8006b3e:	462c      	movge	r4, r5
 8006b40:	b2a4      	uxth	r4, r4
    MEMCPY(((u8_t*)q->payload) + target_offset, dataptr, first_copy_len);
 8006b42:	6840      	ldr	r0, [r0, #4]
 8006b44:	4622      	mov	r2, r4
 8006b46:	4639      	mov	r1, r7
 8006b48:	4418      	add	r0, r3
 8006b4a:	f008 fc9c 	bl	800f486 <memcpy>
    remaining_len -= first_copy_len;
 8006b4e:	1b2a      	subs	r2, r5, r4
 8006b50:	b292      	uxth	r2, r2
    src_ptr += first_copy_len;
 8006b52:	1939      	adds	r1, r7, r4
    if (remaining_len > 0) {
 8006b54:	b912      	cbnz	r2, 8006b5c <pbuf_take_at+0x48>
      return pbuf_take(q->next, src_ptr, remaining_len);
    }
    return ERR_OK;
 8006b56:	2000      	movs	r0, #0
  }
  return ERR_MEM;
}
 8006b58:	b003      	add	sp, #12
 8006b5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return pbuf_take(q->next, src_ptr, remaining_len);
 8006b5c:	6830      	ldr	r0, [r6, #0]
 8006b5e:	f7ff ff77 	bl	8006a50 <pbuf_take>
 8006b62:	e7f9      	b.n	8006b58 <pbuf_take_at+0x44>
  return ERR_MEM;
 8006b64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006b68:	e7f6      	b.n	8006b58 <pbuf_take_at+0x44>
 8006b6a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006b6e:	e7f3      	b.n	8006b58 <pbuf_take_at+0x44>

08006b70 <sys_msleep>:
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  if (ms > 0) {
 8006b70:	b900      	cbnz	r0, 8006b74 <sys_msleep+0x4>
 8006b72:	4770      	bx	lr
{
 8006b74:	b510      	push	{r4, lr}
 8006b76:	b082      	sub	sp, #8
 8006b78:	4604      	mov	r4, r0
    sys_sem_t delaysem;
    err_t err = sys_sem_new(&delaysem, 0);
 8006b7a:	2100      	movs	r1, #0
 8006b7c:	a801      	add	r0, sp, #4
 8006b7e:	f002 fa18 	bl	8008fb2 <sys_sem_new>
    if (err == ERR_OK) {
 8006b82:	b108      	cbz	r0, 8006b88 <sys_msleep+0x18>
      sys_arch_sem_wait(&delaysem, ms);
      sys_sem_free(&delaysem);
    }
  }
}
 8006b84:	b002      	add	sp, #8
 8006b86:	bd10      	pop	{r4, pc}
      sys_arch_sem_wait(&delaysem, ms);
 8006b88:	4621      	mov	r1, r4
 8006b8a:	a801      	add	r0, sp, #4
 8006b8c:	f002 fa2a 	bl	8008fe4 <sys_arch_sem_wait>
      sys_sem_free(&delaysem);
 8006b90:	a801      	add	r0, sp, #4
 8006b92:	f002 fa4a 	bl	800902a <sys_sem_free>
}
 8006b96:	e7f5      	b.n	8006b84 <sys_msleep+0x14>

08006b98 <sys_timeouts_sleeptime>:
#if !NO_SYS
static
#endif /* !NO_SYS */
u32_t
sys_timeouts_sleeptime(void)
{
 8006b98:	b508      	push	{r3, lr}
  u32_t diff;
  if (next_timeout == NULL) {
 8006b9a:	4b09      	ldr	r3, [pc, #36]	; (8006bc0 <sys_timeouts_sleeptime+0x28>)
 8006b9c:	681b      	ldr	r3, [r3, #0]
 8006b9e:	b153      	cbz	r3, 8006bb6 <sys_timeouts_sleeptime+0x1e>
    return 0xffffffff;
  }
  diff = sys_now() - timeouts_last_time;
 8006ba0:	f002 fcdc 	bl	800955c <sys_now>
 8006ba4:	4a06      	ldr	r2, [pc, #24]	; (8006bc0 <sys_timeouts_sleeptime+0x28>)
 8006ba6:	6853      	ldr	r3, [r2, #4]
 8006ba8:	1ac0      	subs	r0, r0, r3
  if (diff > next_timeout->time) {
 8006baa:	6813      	ldr	r3, [r2, #0]
 8006bac:	685b      	ldr	r3, [r3, #4]
 8006bae:	4283      	cmp	r3, r0
 8006bb0:	d304      	bcc.n	8006bbc <sys_timeouts_sleeptime+0x24>
    return 0;
  } else {
    return next_timeout->time - diff;
 8006bb2:	1a18      	subs	r0, r3, r0
  }
}
 8006bb4:	bd08      	pop	{r3, pc}
    return 0xffffffff;
 8006bb6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006bba:	e7fb      	b.n	8006bb4 <sys_timeouts_sleeptime+0x1c>
    return 0;
 8006bbc:	2000      	movs	r0, #0
 8006bbe:	e7f9      	b.n	8006bb4 <sys_timeouts_sleeptime+0x1c>
 8006bc0:	200032e4 	.word	0x200032e4

08006bc4 <sys_check_timeouts>:
{
 8006bc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (next_timeout) {
 8006bc6:	4b13      	ldr	r3, [pc, #76]	; (8006c14 <sys_check_timeouts+0x50>)
 8006bc8:	681b      	ldr	r3, [r3, #0]
 8006bca:	b313      	cbz	r3, 8006c12 <sys_check_timeouts+0x4e>
    now = sys_now();
 8006bcc:	f002 fcc6 	bl	800955c <sys_now>
    diff = now - timeouts_last_time;
 8006bd0:	4b10      	ldr	r3, [pc, #64]	; (8006c14 <sys_check_timeouts+0x50>)
 8006bd2:	685c      	ldr	r4, [r3, #4]
 8006bd4:	1b04      	subs	r4, r0, r4
      tmptimeout = next_timeout;
 8006bd6:	4b0f      	ldr	r3, [pc, #60]	; (8006c14 <sys_check_timeouts+0x50>)
 8006bd8:	6819      	ldr	r1, [r3, #0]
      if (tmptimeout && (tmptimeout->time <= diff)) {
 8006bda:	b1d1      	cbz	r1, 8006c12 <sys_check_timeouts+0x4e>
 8006bdc:	684b      	ldr	r3, [r1, #4]
 8006bde:	42a3      	cmp	r3, r4
 8006be0:	d817      	bhi.n	8006c12 <sys_check_timeouts+0x4e>
        timeouts_last_time += tmptimeout->time;
 8006be2:	4a0c      	ldr	r2, [pc, #48]	; (8006c14 <sys_check_timeouts+0x50>)
 8006be4:	6850      	ldr	r0, [r2, #4]
 8006be6:	4418      	add	r0, r3
 8006be8:	6050      	str	r0, [r2, #4]
        diff -= tmptimeout->time;
 8006bea:	1ae4      	subs	r4, r4, r3
        next_timeout = tmptimeout->next;
 8006bec:	680b      	ldr	r3, [r1, #0]
 8006bee:	6013      	str	r3, [r2, #0]
        handler = tmptimeout->h;
 8006bf0:	688d      	ldr	r5, [r1, #8]
        arg = tmptimeout->arg;
 8006bf2:	68cf      	ldr	r7, [r1, #12]
        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 8006bf4:	2008      	movs	r0, #8
 8006bf6:	f7ff fa9b 	bl	8006130 <memp_free>
        if (handler != NULL) {
 8006bfa:	2d00      	cmp	r5, #0
 8006bfc:	d0eb      	beq.n	8006bd6 <sys_check_timeouts+0x12>
          LOCK_TCPIP_CORE();
 8006bfe:	4e06      	ldr	r6, [pc, #24]	; (8006c18 <sys_check_timeouts+0x54>)
 8006c00:	4630      	mov	r0, r6
 8006c02:	f002 fa3f 	bl	8009084 <sys_mutex_lock>
          handler(arg);
 8006c06:	4638      	mov	r0, r7
 8006c08:	47a8      	blx	r5
          UNLOCK_TCPIP_CORE();
 8006c0a:	4630      	mov	r0, r6
 8006c0c:	f002 fa41 	bl	8009092 <sys_mutex_unlock>
 8006c10:	e7e1      	b.n	8006bd6 <sys_check_timeouts+0x12>
}
 8006c12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006c14:	200032e4 	.word	0x200032e4
 8006c18:	20005a2c 	.word	0x20005a2c

08006c1c <sys_timeout>:
{
 8006c1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006c20:	4605      	mov	r5, r0
 8006c22:	4688      	mov	r8, r1
 8006c24:	4617      	mov	r7, r2
  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8006c26:	2008      	movs	r0, #8
 8006c28:	f7ff fa68 	bl	80060fc <memp_malloc>
  if (timeout == NULL) {
 8006c2c:	b300      	cbz	r0, 8006c70 <sys_timeout+0x54>
 8006c2e:	4604      	mov	r4, r0
  now = sys_now();
 8006c30:	f002 fc94 	bl	800955c <sys_now>
  if (next_timeout == NULL) {
 8006c34:	4b1f      	ldr	r3, [pc, #124]	; (8006cb4 <sys_timeout+0x98>)
 8006c36:	681e      	ldr	r6, [r3, #0]
 8006c38:	b316      	cbz	r6, 8006c80 <sys_timeout+0x64>
    diff = now - timeouts_last_time;
 8006c3a:	4b1e      	ldr	r3, [pc, #120]	; (8006cb4 <sys_timeout+0x98>)
 8006c3c:	685b      	ldr	r3, [r3, #4]
 8006c3e:	1ac0      	subs	r0, r0, r3
  timeout->next = NULL;
 8006c40:	2300      	movs	r3, #0
 8006c42:	6023      	str	r3, [r4, #0]
  timeout->h = handler;
 8006c44:	f8c4 8008 	str.w	r8, [r4, #8]
  timeout->arg = arg;
 8006c48:	60e7      	str	r7, [r4, #12]
  timeout->time = msecs + diff;
 8006c4a:	4428      	add	r0, r5
 8006c4c:	6060      	str	r0, [r4, #4]
  if (next_timeout == NULL) {
 8006c4e:	b1d6      	cbz	r6, 8006c86 <sys_timeout+0x6a>
  if (next_timeout->time > msecs) {
 8006c50:	6873      	ldr	r3, [r6, #4]
 8006c52:	42ab      	cmp	r3, r5
 8006c54:	d81a      	bhi.n	8006c8c <sys_timeout+0x70>
    for (t = next_timeout; t != NULL; t = t->next) {
 8006c56:	4632      	mov	r2, r6
 8006c58:	b182      	cbz	r2, 8006c7c <sys_timeout+0x60>
      timeout->time -= t->time;
 8006c5a:	6851      	ldr	r1, [r2, #4]
 8006c5c:	6863      	ldr	r3, [r4, #4]
 8006c5e:	1a5b      	subs	r3, r3, r1
 8006c60:	6063      	str	r3, [r4, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 8006c62:	6811      	ldr	r1, [r2, #0]
 8006c64:	b1c1      	cbz	r1, 8006c98 <sys_timeout+0x7c>
 8006c66:	6848      	ldr	r0, [r1, #4]
 8006c68:	4283      	cmp	r3, r0
 8006c6a:	d315      	bcc.n	8006c98 <sys_timeout+0x7c>
    for (t = next_timeout; t != NULL; t = t->next) {
 8006c6c:	460a      	mov	r2, r1
 8006c6e:	e7f3      	b.n	8006c58 <sys_timeout+0x3c>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 8006c70:	4b11      	ldr	r3, [pc, #68]	; (8006cb8 <sys_timeout+0x9c>)
 8006c72:	22d4      	movs	r2, #212	; 0xd4
 8006c74:	4911      	ldr	r1, [pc, #68]	; (8006cbc <sys_timeout+0xa0>)
 8006c76:	4812      	ldr	r0, [pc, #72]	; (8006cc0 <sys_timeout+0xa4>)
 8006c78:	f008 fc18 	bl	800f4ac <iprintf>
}
 8006c7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    timeouts_last_time = now;
 8006c80:	6058      	str	r0, [r3, #4]
    diff = 0;
 8006c82:	2000      	movs	r0, #0
 8006c84:	e7dc      	b.n	8006c40 <sys_timeout+0x24>
    next_timeout = timeout;
 8006c86:	4b0b      	ldr	r3, [pc, #44]	; (8006cb4 <sys_timeout+0x98>)
 8006c88:	601c      	str	r4, [r3, #0]
    return;
 8006c8a:	e7f7      	b.n	8006c7c <sys_timeout+0x60>
    next_timeout->time -= msecs;
 8006c8c:	1b5d      	subs	r5, r3, r5
 8006c8e:	6075      	str	r5, [r6, #4]
    timeout->next = next_timeout;
 8006c90:	6026      	str	r6, [r4, #0]
    next_timeout = timeout;
 8006c92:	4b08      	ldr	r3, [pc, #32]	; (8006cb4 <sys_timeout+0x98>)
 8006c94:	601c      	str	r4, [r3, #0]
 8006c96:	e7f1      	b.n	8006c7c <sys_timeout+0x60>
        if (t->next != NULL) {
 8006c98:	b131      	cbz	r1, 8006ca8 <sys_timeout+0x8c>
          t->next->time -= timeout->time;
 8006c9a:	6848      	ldr	r0, [r1, #4]
 8006c9c:	1ac3      	subs	r3, r0, r3
 8006c9e:	604b      	str	r3, [r1, #4]
        timeout->next = t->next;
 8006ca0:	6813      	ldr	r3, [r2, #0]
 8006ca2:	6023      	str	r3, [r4, #0]
        t->next = timeout;
 8006ca4:	6014      	str	r4, [r2, #0]
        break;
 8006ca6:	e7e9      	b.n	8006c7c <sys_timeout+0x60>
        } else if (timeout->time > msecs) {
 8006ca8:	42ab      	cmp	r3, r5
 8006caa:	d9f9      	bls.n	8006ca0 <sys_timeout+0x84>
          timeout->time = msecs + next_timeout->time;
 8006cac:	6873      	ldr	r3, [r6, #4]
 8006cae:	441d      	add	r5, r3
 8006cb0:	6065      	str	r5, [r4, #4]
 8006cb2:	e7f5      	b.n	8006ca0 <sys_timeout+0x84>
 8006cb4:	200032e4 	.word	0x200032e4
 8006cb8:	0801120c 	.word	0x0801120c
 8006cbc:	08011240 	.word	0x08011240
 8006cc0:	080109f4 	.word	0x080109f4

08006cc4 <sys_timeouts_init>:
{
 8006cc4:	b510      	push	{r4, lr}
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8006cc6:	2400      	movs	r4, #0
 8006cc8:	e008      	b.n	8006cdc <sys_timeouts_init+0x18>
    sys_timeout(lwip_cyclic_timers[i].interval_ms, cyclic_timer, LWIP_CONST_CAST(void*, &lwip_cyclic_timers[i]));
 8006cca:	4b08      	ldr	r3, [pc, #32]	; (8006cec <sys_timeouts_init+0x28>)
 8006ccc:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
 8006cd0:	4907      	ldr	r1, [pc, #28]	; (8006cf0 <sys_timeouts_init+0x2c>)
 8006cd2:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 8006cd6:	f7ff ffa1 	bl	8006c1c <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8006cda:	3401      	adds	r4, #1
 8006cdc:	2c02      	cmp	r4, #2
 8006cde:	d9f4      	bls.n	8006cca <sys_timeouts_init+0x6>
  timeouts_last_time = sys_now();
 8006ce0:	f002 fc3c 	bl	800955c <sys_now>
 8006ce4:	4b03      	ldr	r3, [pc, #12]	; (8006cf4 <sys_timeouts_init+0x30>)
 8006ce6:	6058      	str	r0, [r3, #4]
}
 8006ce8:	bd10      	pop	{r4, pc}
 8006cea:	bf00      	nop
 8006cec:	080108b0 	.word	0x080108b0
 8006cf0:	08006cf9 	.word	0x08006cf9
 8006cf4:	200032e4 	.word	0x200032e4

08006cf8 <cyclic_timer>:
{
 8006cf8:	b510      	push	{r4, lr}
 8006cfa:	4604      	mov	r4, r0
  cyclic->handler();
 8006cfc:	6843      	ldr	r3, [r0, #4]
 8006cfe:	4798      	blx	r3
  sys_timeout(cyclic->interval_ms, cyclic_timer, arg);
 8006d00:	4622      	mov	r2, r4
 8006d02:	4902      	ldr	r1, [pc, #8]	; (8006d0c <cyclic_timer+0x14>)
 8006d04:	6820      	ldr	r0, [r4, #0]
 8006d06:	f7ff ff89 	bl	8006c1c <sys_timeout>
}
 8006d0a:	bd10      	pop	{r4, pc}
 8006d0c:	08006cf9 	.word	0x08006cf9

08006d10 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 8006d10:	b538      	push	{r3, r4, r5, lr}
 8006d12:	4604      	mov	r4, r0
 8006d14:	460d      	mov	r5, r1
 8006d16:	e007      	b.n	8006d28 <sys_timeouts_mbox_fetch+0x18>
  u32_t sleeptime;

again:
  if (!next_timeout) {
    sys_arch_mbox_fetch(mbox, msg, 0);
 8006d18:	2200      	movs	r2, #0
 8006d1a:	4629      	mov	r1, r5
 8006d1c:	4620      	mov	r0, r4
 8006d1e:	f002 f915 	bl	8008f4c <sys_arch_mbox_fetch>
       before a message could be fetched. */
    sys_check_timeouts();
    /* We try again to fetch a message from the mbox. */
    goto again;
  }
}
 8006d22:	bd38      	pop	{r3, r4, r5, pc}
    sys_check_timeouts();
 8006d24:	f7ff ff4e 	bl	8006bc4 <sys_check_timeouts>
  if (!next_timeout) {
 8006d28:	4b08      	ldr	r3, [pc, #32]	; (8006d4c <sys_timeouts_mbox_fetch+0x3c>)
 8006d2a:	681b      	ldr	r3, [r3, #0]
 8006d2c:	2b00      	cmp	r3, #0
 8006d2e:	d0f3      	beq.n	8006d18 <sys_timeouts_mbox_fetch+0x8>
  sleeptime = sys_timeouts_sleeptime();
 8006d30:	f7ff ff32 	bl	8006b98 <sys_timeouts_sleeptime>
  if (sleeptime == 0 || sys_arch_mbox_fetch(mbox, msg, sleeptime) == SYS_ARCH_TIMEOUT) {
 8006d34:	4602      	mov	r2, r0
 8006d36:	2800      	cmp	r0, #0
 8006d38:	d0f4      	beq.n	8006d24 <sys_timeouts_mbox_fetch+0x14>
 8006d3a:	4629      	mov	r1, r5
 8006d3c:	4620      	mov	r0, r4
 8006d3e:	f002 f905 	bl	8008f4c <sys_arch_mbox_fetch>
 8006d42:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8006d46:	d0ed      	beq.n	8006d24 <sys_timeouts_mbox_fetch+0x14>
 8006d48:	e7eb      	b.n	8006d22 <sys_timeouts_mbox_fetch+0x12>
 8006d4a:	bf00      	nop
 8006d4c:	200032e4 	.word	0x200032e4

08006d50 <udp_new_port>:
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
  u16_t n = 0;
 8006d50:	2000      	movs	r0, #0
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8006d52:	4a10      	ldr	r2, [pc, #64]	; (8006d94 <udp_new_port+0x44>)
 8006d54:	8813      	ldrh	r3, [r2, #0]
 8006d56:	1c59      	adds	r1, r3, #1
 8006d58:	8011      	strh	r1, [r2, #0]
 8006d5a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006d5e:	4293      	cmp	r3, r2
 8006d60:	d009      	beq.n	8006d76 <udp_new_port+0x26>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8006d62:	4b0d      	ldr	r3, [pc, #52]	; (8006d98 <udp_new_port+0x48>)
 8006d64:	681b      	ldr	r3, [r3, #0]
 8006d66:	b193      	cbz	r3, 8006d8e <udp_new_port+0x3e>
    if (pcb->local_port == udp_port) {
 8006d68:	8a59      	ldrh	r1, [r3, #18]
 8006d6a:	4a0a      	ldr	r2, [pc, #40]	; (8006d94 <udp_new_port+0x44>)
 8006d6c:	8812      	ldrh	r2, [r2, #0]
 8006d6e:	4291      	cmp	r1, r2
 8006d70:	d006      	beq.n	8006d80 <udp_new_port+0x30>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8006d72:	68db      	ldr	r3, [r3, #12]
 8006d74:	e7f7      	b.n	8006d66 <udp_new_port+0x16>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8006d76:	4b07      	ldr	r3, [pc, #28]	; (8006d94 <udp_new_port+0x44>)
 8006d78:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8006d7c:	801a      	strh	r2, [r3, #0]
 8006d7e:	e7f0      	b.n	8006d62 <udp_new_port+0x12>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 8006d80:	3001      	adds	r0, #1
 8006d82:	b280      	uxth	r0, r0
 8006d84:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 8006d88:	d3e3      	bcc.n	8006d52 <udp_new_port+0x2>
        return 0;
 8006d8a:	2000      	movs	r0, #0
      }
      goto again;
    }
  }
  return udp_port;
}
 8006d8c:	4770      	bx	lr
  return udp_port;
 8006d8e:	4b01      	ldr	r3, [pc, #4]	; (8006d94 <udp_new_port+0x44>)
 8006d90:	8818      	ldrh	r0, [r3, #0]
 8006d92:	4770      	bx	lr
 8006d94:	2000000c 	.word	0x2000000c
 8006d98:	20008618 	.word	0x20008618

08006d9c <udp_input_local_match>:
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 8006d9c:	b16a      	cbz	r2, 8006dba <udp_input_local_match+0x1e>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8006d9e:	b1a8      	cbz	r0, 8006dcc <udp_input_local_match+0x30>
 8006da0:	6803      	ldr	r3, [r0, #0]
 8006da2:	b1ab      	cbz	r3, 8006dd0 <udp_input_local_match+0x34>
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8006da4:	4a10      	ldr	r2, [pc, #64]	; (8006de8 <udp_input_local_match+0x4c>)
 8006da6:	6952      	ldr	r2, [r2, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8006da8:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
 8006dac:	d012      	beq.n	8006dd4 <udp_input_local_match+0x38>
           ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 8006dae:	6889      	ldr	r1, [r1, #8]
 8006db0:	4053      	eors	r3, r2
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8006db2:	420b      	tst	r3, r1
 8006db4:	d010      	beq.n	8006dd8 <udp_input_local_match+0x3c>
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
      return 1;
    }
  }

  return 0;
 8006db6:	2000      	movs	r0, #0
 8006db8:	4770      	bx	lr
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8006dba:	b178      	cbz	r0, 8006ddc <udp_input_local_match+0x40>
 8006dbc:	6803      	ldr	r3, [r0, #0]
 8006dbe:	b17b      	cbz	r3, 8006de0 <udp_input_local_match+0x44>
 8006dc0:	4a09      	ldr	r2, [pc, #36]	; (8006de8 <udp_input_local_match+0x4c>)
 8006dc2:	6952      	ldr	r2, [r2, #20]
 8006dc4:	4293      	cmp	r3, r2
 8006dc6:	d00d      	beq.n	8006de4 <udp_input_local_match+0x48>
  return 0;
 8006dc8:	2000      	movs	r0, #0
 8006dca:	4770      	bx	lr
          return 1;
 8006dcc:	2001      	movs	r0, #1
 8006dce:	4770      	bx	lr
 8006dd0:	2001      	movs	r0, #1
 8006dd2:	4770      	bx	lr
 8006dd4:	2001      	movs	r0, #1
 8006dd6:	4770      	bx	lr
 8006dd8:	2001      	movs	r0, #1
 8006dda:	4770      	bx	lr
      return 1;
 8006ddc:	2001      	movs	r0, #1
 8006dde:	4770      	bx	lr
 8006de0:	2001      	movs	r0, #1
 8006de2:	4770      	bx	lr
 8006de4:	2001      	movs	r0, #1
}
 8006de6:	4770      	bx	lr
 8006de8:	20005a30 	.word	0x20005a30

08006dec <udp_init>:
}
 8006dec:	4770      	bx	lr
	...

08006df0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8006df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006df4:	b085      	sub	sp, #20
 8006df6:	4680      	mov	r8, r0
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 8006df8:	8943      	ldrh	r3, [r0, #10]
 8006dfa:	2b07      	cmp	r3, #7
 8006dfc:	d917      	bls.n	8006e2e <udp_input+0x3e>
 8006dfe:	460f      	mov	r7, r1
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
 8006e00:	6844      	ldr	r4, [r0, #4]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8006e02:	4b42      	ldr	r3, [pc, #264]	; (8006f0c <udp_input+0x11c>)
 8006e04:	6819      	ldr	r1, [r3, #0]
 8006e06:	6958      	ldr	r0, [r3, #20]
 8006e08:	f001 fbe8 	bl	80085dc <ip4_addr_isbroadcast_u32>
 8006e0c:	9003      	str	r0, [sp, #12]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 8006e0e:	8820      	ldrh	r0, [r4, #0]
 8006e10:	f7fe fe8c 	bl	8005b2c <lwip_htons>
 8006e14:	4682      	mov	sl, r0
  dest = lwip_ntohs(udphdr->dest);
 8006e16:	8860      	ldrh	r0, [r4, #2]
 8006e18:	f7fe fe88 	bl	8005b2c <lwip_htons>
 8006e1c:	4606      	mov	r6, r0
  uncon_pcb = NULL;
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8006e1e:	4b3c      	ldr	r3, [pc, #240]	; (8006f10 <udp_input+0x120>)
 8006e20:	f8d3 9000 	ldr.w	r9, [r3]
 8006e24:	464c      	mov	r4, r9
  uncon_pcb = NULL;
 8006e26:	f04f 0b00 	mov.w	fp, #0
  prev = NULL;
 8006e2a:	465d      	mov	r5, fp
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8006e2c:	e009      	b.n	8006e42 <udp_input+0x52>
    pbuf_free(p);
 8006e2e:	f7ff fb35 	bl	800649c <pbuf_free>
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 8006e32:	b005      	add	sp, #20
 8006e34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if ((pcb->remote_port == src) &&
 8006e38:	8aa3      	ldrh	r3, [r4, #20]
 8006e3a:	4553      	cmp	r3, sl
 8006e3c:	d015      	beq.n	8006e6a <udp_input+0x7a>
    prev = pcb;
 8006e3e:	4625      	mov	r5, r4
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8006e40:	68e4      	ldr	r4, [r4, #12]
 8006e42:	b1fc      	cbz	r4, 8006e84 <udp_input+0x94>
    if ((pcb->local_port == dest) &&
 8006e44:	8a63      	ldrh	r3, [r4, #18]
 8006e46:	42b3      	cmp	r3, r6
 8006e48:	d1f9      	bne.n	8006e3e <udp_input+0x4e>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 8006e4a:	9a03      	ldr	r2, [sp, #12]
 8006e4c:	4639      	mov	r1, r7
 8006e4e:	4620      	mov	r0, r4
 8006e50:	f7ff ffa4 	bl	8006d9c <udp_input_local_match>
    if ((pcb->local_port == dest) &&
 8006e54:	2800      	cmp	r0, #0
 8006e56:	d0f2      	beq.n	8006e3e <udp_input+0x4e>
      if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
 8006e58:	7c23      	ldrb	r3, [r4, #16]
 8006e5a:	f013 0f04 	tst.w	r3, #4
 8006e5e:	d1eb      	bne.n	8006e38 <udp_input+0x48>
 8006e60:	f1bb 0f00 	cmp.w	fp, #0
 8006e64:	d1e8      	bne.n	8006e38 <udp_input+0x48>
        uncon_pcb = pcb;
 8006e66:	46a3      	mov	fp, r4
 8006e68:	e7e6      	b.n	8006e38 <udp_input+0x48>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8006e6a:	6863      	ldr	r3, [r4, #4]
      if ((pcb->remote_port == src) &&
 8006e6c:	b11b      	cbz	r3, 8006e76 <udp_input+0x86>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 8006e6e:	4a27      	ldr	r2, [pc, #156]	; (8006f0c <udp_input+0x11c>)
 8006e70:	6912      	ldr	r2, [r2, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8006e72:	4293      	cmp	r3, r2
 8006e74:	d1e3      	bne.n	8006e3e <udp_input+0x4e>
        if (prev != NULL) {
 8006e76:	b12d      	cbz	r5, 8006e84 <udp_input+0x94>
          prev->next = pcb->next;
 8006e78:	68e3      	ldr	r3, [r4, #12]
 8006e7a:	60eb      	str	r3, [r5, #12]
          pcb->next = udp_pcbs;
 8006e7c:	f8c4 900c 	str.w	r9, [r4, #12]
          udp_pcbs = pcb;
 8006e80:	4b23      	ldr	r3, [pc, #140]	; (8006f10 <udp_input+0x120>)
 8006e82:	601c      	str	r4, [r3, #0]
  if (pcb == NULL) {
 8006e84:	b18c      	cbz	r4, 8006eaa <udp_input+0xba>
  if (pcb != NULL) {
 8006e86:	b194      	cbz	r4, 8006eae <udp_input+0xbe>
    if (pbuf_header(p, -UDP_HLEN)) {
 8006e88:	f06f 0107 	mvn.w	r1, #7
 8006e8c:	4640      	mov	r0, r8
 8006e8e:	f7ff fafb 	bl	8006488 <pbuf_header>
 8006e92:	b9a8      	cbnz	r0, 8006ec0 <udp_input+0xd0>
    if (pcb != NULL) {
 8006e94:	b31c      	cbz	r4, 8006ede <udp_input+0xee>
      if (pcb->recv != NULL) {
 8006e96:	6a25      	ldr	r5, [r4, #32]
 8006e98:	b1ed      	cbz	r5, 8006ed6 <udp_input+0xe6>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8006e9a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006e9c:	f8cd a000 	str.w	sl, [sp]
 8006ea0:	4b1c      	ldr	r3, [pc, #112]	; (8006f14 <udp_input+0x124>)
 8006ea2:	4642      	mov	r2, r8
 8006ea4:	4621      	mov	r1, r4
 8006ea6:	47a8      	blx	r5
 8006ea8:	e7c3      	b.n	8006e32 <udp_input+0x42>
    pcb = uncon_pcb;
 8006eaa:	465c      	mov	r4, fp
 8006eac:	e7eb      	b.n	8006e86 <udp_input+0x96>
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 8006eae:	687a      	ldr	r2, [r7, #4]
 8006eb0:	4b16      	ldr	r3, [pc, #88]	; (8006f0c <udp_input+0x11c>)
 8006eb2:	695b      	ldr	r3, [r3, #20]
  if (for_us) {
 8006eb4:	429a      	cmp	r2, r3
 8006eb6:	d0e7      	beq.n	8006e88 <udp_input+0x98>
    pbuf_free(p);
 8006eb8:	4640      	mov	r0, r8
 8006eba:	f7ff faef 	bl	800649c <pbuf_free>
  return;
 8006ebe:	e7b8      	b.n	8006e32 <udp_input+0x42>
      LWIP_ASSERT("pbuf_header failed\n", 0);
 8006ec0:	4b15      	ldr	r3, [pc, #84]	; (8006f18 <udp_input+0x128>)
 8006ec2:	f240 1255 	movw	r2, #341	; 0x155
 8006ec6:	4915      	ldr	r1, [pc, #84]	; (8006f1c <udp_input+0x12c>)
 8006ec8:	4815      	ldr	r0, [pc, #84]	; (8006f20 <udp_input+0x130>)
 8006eca:	f008 faef 	bl	800f4ac <iprintf>
      pbuf_free(p);
 8006ece:	4640      	mov	r0, r8
 8006ed0:	f7ff fae4 	bl	800649c <pbuf_free>
      goto end;
 8006ed4:	e7ad      	b.n	8006e32 <udp_input+0x42>
        pbuf_free(p);
 8006ed6:	4640      	mov	r0, r8
 8006ed8:	f7ff fae0 	bl	800649c <pbuf_free>
        goto end;
 8006edc:	e7a9      	b.n	8006e32 <udp_input+0x42>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 8006ede:	9b03      	ldr	r3, [sp, #12]
 8006ee0:	b983      	cbnz	r3, 8006f04 <udp_input+0x114>
 8006ee2:	4b0a      	ldr	r3, [pc, #40]	; (8006f0c <udp_input+0x11c>)
 8006ee4:	695b      	ldr	r3, [r3, #20]
 8006ee6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8006eea:	2be0      	cmp	r3, #224	; 0xe0
 8006eec:	d00a      	beq.n	8006f04 <udp_input+0x114>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 8006eee:	4b07      	ldr	r3, [pc, #28]	; (8006f0c <udp_input+0x11c>)
 8006ef0:	8999      	ldrh	r1, [r3, #12]
 8006ef2:	3108      	adds	r1, #8
 8006ef4:	b209      	sxth	r1, r1
 8006ef6:	4640      	mov	r0, r8
 8006ef8:	f7ff facb 	bl	8006492 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 8006efc:	2103      	movs	r1, #3
 8006efe:	4640      	mov	r0, r8
 8006f00:	f000 ff04 	bl	8007d0c <icmp_dest_unreach>
      pbuf_free(p);
 8006f04:	4640      	mov	r0, r8
 8006f06:	f7ff fac9 	bl	800649c <pbuf_free>
 8006f0a:	e792      	b.n	8006e32 <udp_input+0x42>
 8006f0c:	20005a30 	.word	0x20005a30
 8006f10:	20008618 	.word	0x20008618
 8006f14:	20005a40 	.word	0x20005a40
 8006f18:	08011280 	.word	0x08011280
 8006f1c:	080112b0 	.word	0x080112b0
 8006f20:	080109f4 	.word	0x080109f4

08006f24 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 8006f24:	b570      	push	{r4, r5, r6, lr}
 8006f26:	4604      	mov	r4, r0
  struct udp_pcb *ipcb;
  u8_t rebind;

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8006f28:	460d      	mov	r5, r1
 8006f2a:	b171      	cbz	r1, 8006f4a <udp_bind+0x26>
    ipaddr = IP4_ADDR_ANY;
  }
#endif /* LWIP_IPV4 */

  /* still need to check for ipaddr == NULL in IPv6 only case */
  if ((pcb == NULL) || (ipaddr == NULL)) {
 8006f2c:	fab5 f385 	clz	r3, r5
 8006f30:	095b      	lsrs	r3, r3, #5
 8006f32:	2c00      	cmp	r4, #0
 8006f34:	bf08      	it	eq
 8006f36:	2301      	moveq	r3, #1
 8006f38:	bb6b      	cbnz	r3, 8006f96 <udp_bind+0x72>
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8006f3a:	4b1b      	ldr	r3, [pc, #108]	; (8006fa8 <udp_bind+0x84>)
 8006f3c:	681b      	ldr	r3, [r3, #0]
 8006f3e:	4619      	mov	r1, r3
 8006f40:	b129      	cbz	r1, 8006f4e <udp_bind+0x2a>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 8006f42:	42a1      	cmp	r1, r4
 8006f44:	d014      	beq.n	8006f70 <udp_bind+0x4c>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8006f46:	68c9      	ldr	r1, [r1, #12]
 8006f48:	e7fa      	b.n	8006f40 <udp_bind+0x1c>
    ipaddr = IP4_ADDR_ANY;
 8006f4a:	4d18      	ldr	r5, [pc, #96]	; (8006fac <udp_bind+0x88>)
 8006f4c:	e7ee      	b.n	8006f2c <udp_bind+0x8>
  rebind = 0;
 8006f4e:	2600      	movs	r6, #0
      break;
    }
  }

  /* no port specified? */
  if (port == 0) {
 8006f50:	b98a      	cbnz	r2, 8006f76 <udp_bind+0x52>
    port = udp_new_port();
 8006f52:	f7ff fefd 	bl	8006d50 <udp_new_port>
    if (port == 0) {
 8006f56:	4602      	mov	r2, r0
 8006f58:	b300      	cbz	r0, 8006f9c <udp_bind+0x78>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 8006f5a:	b1d5      	cbz	r5, 8006f92 <udp_bind+0x6e>
 8006f5c:	682b      	ldr	r3, [r5, #0]
 8006f5e:	6023      	str	r3, [r4, #0]

  pcb->local_port = port;
 8006f60:	8262      	strh	r2, [r4, #18]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8006f62:	b9f6      	cbnz	r6, 8006fa2 <udp_bind+0x7e>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8006f64:	4b10      	ldr	r3, [pc, #64]	; (8006fa8 <udp_bind+0x84>)
 8006f66:	681a      	ldr	r2, [r3, #0]
 8006f68:	60e2      	str	r2, [r4, #12]
    udp_pcbs = pcb;
 8006f6a:	601c      	str	r4, [r3, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, &pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 8006f6c:	2000      	movs	r0, #0
}
 8006f6e:	bd70      	pop	{r4, r5, r6, pc}
      rebind = 1;
 8006f70:	2601      	movs	r6, #1
 8006f72:	e7ed      	b.n	8006f50 <udp_bind+0x2c>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8006f74:	68db      	ldr	r3, [r3, #12]
 8006f76:	2b00      	cmp	r3, #0
 8006f78:	d0ef      	beq.n	8006f5a <udp_bind+0x36>
      if (pcb != ipcb) {
 8006f7a:	42a3      	cmp	r3, r4
 8006f7c:	d0fa      	beq.n	8006f74 <udp_bind+0x50>
          if ((ipcb->local_port == port) &&
 8006f7e:	8a59      	ldrh	r1, [r3, #18]
 8006f80:	4291      	cmp	r1, r2
 8006f82:	d1f7      	bne.n	8006f74 <udp_bind+0x50>
              ip_addr_cmp(&ipcb->local_ip, ipaddr)) {
 8006f84:	6818      	ldr	r0, [r3, #0]
 8006f86:	6829      	ldr	r1, [r5, #0]
          if ((ipcb->local_port == port) &&
 8006f88:	4288      	cmp	r0, r1
 8006f8a:	d1f3      	bne.n	8006f74 <udp_bind+0x50>
            return ERR_USE;
 8006f8c:	f06f 0007 	mvn.w	r0, #7
 8006f90:	e7ed      	b.n	8006f6e <udp_bind+0x4a>
  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 8006f92:	2300      	movs	r3, #0
 8006f94:	e7e3      	b.n	8006f5e <udp_bind+0x3a>
    return ERR_VAL;
 8006f96:	f06f 0005 	mvn.w	r0, #5
 8006f9a:	e7e8      	b.n	8006f6e <udp_bind+0x4a>
      return ERR_USE;
 8006f9c:	f06f 0007 	mvn.w	r0, #7
 8006fa0:	e7e5      	b.n	8006f6e <udp_bind+0x4a>
  return ERR_OK;
 8006fa2:	2000      	movs	r0, #0
 8006fa4:	e7e3      	b.n	8006f6e <udp_bind+0x4a>
 8006fa6:	bf00      	nop
 8006fa8:	20008618 	.word	0x20008618
 8006fac:	080108cc 	.word	0x080108cc

08006fb0 <udp_sendto_if_src>:
{
 8006fb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006fb4:	b085      	sub	sp, #20
  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
 8006fb6:	fab2 f582 	clz	r5, r2
 8006fba:	096d      	lsrs	r5, r5, #5
 8006fbc:	2800      	cmp	r0, #0
 8006fbe:	bf08      	it	eq
 8006fc0:	2501      	moveq	r5, #1
 8006fc2:	2d00      	cmp	r5, #0
 8006fc4:	d16c      	bne.n	80070a0 <udp_sendto_if_src+0xf0>
 8006fc6:	4604      	mov	r4, r0
 8006fc8:	4617      	mov	r7, r2
 8006fca:	4699      	mov	r9, r3
 8006fcc:	460d      	mov	r5, r1
  if (pcb->local_port == 0) {
 8006fce:	8a42      	ldrh	r2, [r0, #18]
 8006fd0:	b92a      	cbnz	r2, 8006fde <udp_sendto_if_src+0x2e>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 8006fd2:	4601      	mov	r1, r0
 8006fd4:	f7ff ffa6 	bl	8006f24 <udp_bind>
    if (err != ERR_OK) {
 8006fd8:	4680      	mov	r8, r0
 8006fda:	2800      	cmp	r0, #0
 8006fdc:	d13f      	bne.n	800705e <udp_sendto_if_src+0xae>
  if (pbuf_header(p, UDP_HLEN)) {
 8006fde:	2108      	movs	r1, #8
 8006fe0:	4628      	mov	r0, r5
 8006fe2:	f7ff fa51 	bl	8006488 <pbuf_header>
 8006fe6:	2800      	cmp	r0, #0
 8006fe8:	d13d      	bne.n	8007066 <udp_sendto_if_src+0xb6>
    q = p;
 8006fea:	462e      	mov	r6, r5
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 8006fec:	8973      	ldrh	r3, [r6, #10]
 8006fee:	2b07      	cmp	r3, #7
 8006ff0:	d947      	bls.n	8007082 <udp_sendto_if_src+0xd2>
  udphdr = (struct udp_hdr *)q->payload;
 8006ff2:	f8d6 8004 	ldr.w	r8, [r6, #4]
  udphdr->src = lwip_htons(pcb->local_port);
 8006ff6:	8a60      	ldrh	r0, [r4, #18]
 8006ff8:	f7fe fd98 	bl	8005b2c <lwip_htons>
 8006ffc:	f8a8 0000 	strh.w	r0, [r8]
  udphdr->dest = lwip_htons(dst_port);
 8007000:	4648      	mov	r0, r9
 8007002:	f7fe fd93 	bl	8005b2c <lwip_htons>
 8007006:	f8a8 0002 	strh.w	r0, [r8, #2]
  udphdr->chksum = 0x0000;
 800700a:	2300      	movs	r3, #0
 800700c:	f888 3006 	strb.w	r3, [r8, #6]
 8007010:	f888 3007 	strb.w	r3, [r8, #7]
  if (((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) && ip_addr_ismulticast(dst_ip)) {
 8007014:	7c23      	ldrb	r3, [r4, #16]
 8007016:	f013 0f08 	tst.w	r3, #8
 800701a:	d004      	beq.n	8007026 <udp_sendto_if_src+0x76>
 800701c:	683b      	ldr	r3, [r7, #0]
 800701e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8007022:	2be0      	cmp	r3, #224	; 0xe0
 8007024:	d035      	beq.n	8007092 <udp_sendto_if_src+0xe2>
    udphdr->len = lwip_htons(q->tot_len);
 8007026:	8930      	ldrh	r0, [r6, #8]
 8007028:	f7fe fd80 	bl	8005b2c <lwip_htons>
 800702c:	f8a8 0004 	strh.w	r0, [r8, #4]
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
 8007030:	683b      	ldr	r3, [r7, #0]
 8007032:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8007036:	2be0      	cmp	r3, #224	; 0xe0
 8007038:	d030      	beq.n	800709c <udp_sendto_if_src+0xec>
 800703a:	7aa3      	ldrb	r3, [r4, #10]
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 800703c:	7a62      	ldrb	r2, [r4, #9]
 800703e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007040:	9102      	str	r1, [sp, #8]
 8007042:	2111      	movs	r1, #17
 8007044:	9101      	str	r1, [sp, #4]
 8007046:	9200      	str	r2, [sp, #0]
 8007048:	463a      	mov	r2, r7
 800704a:	990d      	ldr	r1, [sp, #52]	; 0x34
 800704c:	4630      	mov	r0, r6
 800704e:	f001 fab4 	bl	80085ba <ip4_output_if_src>
 8007052:	4680      	mov	r8, r0
  if (q != p) {
 8007054:	42ae      	cmp	r6, r5
 8007056:	d002      	beq.n	800705e <udp_sendto_if_src+0xae>
    pbuf_free(q);
 8007058:	4630      	mov	r0, r6
 800705a:	f7ff fa1f 	bl	800649c <pbuf_free>
}
 800705e:	4640      	mov	r0, r8
 8007060:	b005      	add	sp, #20
 8007062:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8007066:	2200      	movs	r2, #0
 8007068:	2108      	movs	r1, #8
 800706a:	2001      	movs	r0, #1
 800706c:	f7ff fa80 	bl	8006570 <pbuf_alloc>
    if (q == NULL) {
 8007070:	4606      	mov	r6, r0
 8007072:	b1c0      	cbz	r0, 80070a6 <udp_sendto_if_src+0xf6>
    if (p->tot_len != 0) {
 8007074:	892b      	ldrh	r3, [r5, #8]
 8007076:	2b00      	cmp	r3, #0
 8007078:	d0b8      	beq.n	8006fec <udp_sendto_if_src+0x3c>
      pbuf_chain(q, p);
 800707a:	4629      	mov	r1, r5
 800707c:	f7ff fc3c 	bl	80068f8 <pbuf_chain>
 8007080:	e7b4      	b.n	8006fec <udp_sendto_if_src+0x3c>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 8007082:	4b0a      	ldr	r3, [pc, #40]	; (80070ac <udp_sendto_if_src+0xfc>)
 8007084:	f44f 7237 	mov.w	r2, #732	; 0x2dc
 8007088:	4909      	ldr	r1, [pc, #36]	; (80070b0 <udp_sendto_if_src+0x100>)
 800708a:	480a      	ldr	r0, [pc, #40]	; (80070b4 <udp_sendto_if_src+0x104>)
 800708c:	f008 fa0e 	bl	800f4ac <iprintf>
 8007090:	e7af      	b.n	8006ff2 <udp_sendto_if_src+0x42>
    q->flags |= PBUF_FLAG_MCASTLOOP;
 8007092:	7b73      	ldrb	r3, [r6, #13]
 8007094:	f043 0304 	orr.w	r3, r3, #4
 8007098:	7373      	strb	r3, [r6, #13]
 800709a:	e7c4      	b.n	8007026 <udp_sendto_if_src+0x76>
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
 800709c:	7f23      	ldrb	r3, [r4, #28]
 800709e:	e7cd      	b.n	800703c <udp_sendto_if_src+0x8c>
    return ERR_VAL;
 80070a0:	f06f 0805 	mvn.w	r8, #5
 80070a4:	e7db      	b.n	800705e <udp_sendto_if_src+0xae>
      return ERR_MEM;
 80070a6:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 80070aa:	e7d8      	b.n	800705e <udp_sendto_if_src+0xae>
 80070ac:	08011280 	.word	0x08011280
 80070b0:	080112c4 	.word	0x080112c4
 80070b4:	080109f4 	.word	0x080109f4

080070b8 <udp_sendto_if>:
{
 80070b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80070ba:	b083      	sub	sp, #12
 80070bc:	9f08      	ldr	r7, [sp, #32]
  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 80070be:	4604      	mov	r4, r0
 80070c0:	4616      	mov	r6, r2
 80070c2:	fab2 f282 	clz	r2, r2
 80070c6:	0952      	lsrs	r2, r2, #5
 80070c8:	2800      	cmp	r0, #0
 80070ca:	bf14      	ite	ne
 80070cc:	4610      	movne	r0, r2
 80070ce:	2001      	moveq	r0, #1
 80070d0:	b9b0      	cbnz	r0, 8007100 <udp_sendto_if+0x48>
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80070d2:	4625      	mov	r5, r4
 80070d4:	b15c      	cbz	r4, 80070ee <udp_sendto_if+0x36>
 80070d6:	6822      	ldr	r2, [r4, #0]
 80070d8:	b14a      	cbz	r2, 80070ee <udp_sendto_if+0x36>
      ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 80070da:	f002 00f0 	and.w	r0, r2, #240	; 0xf0
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80070de:	28e0      	cmp	r0, #224	; 0xe0
 80070e0:	d005      	beq.n	80070ee <udp_sendto_if+0x36>
    if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 80070e2:	6878      	ldr	r0, [r7, #4]
 80070e4:	4282      	cmp	r2, r0
 80070e6:	d003      	beq.n	80070f0 <udp_sendto_if+0x38>
      return ERR_RTE;
 80070e8:	f06f 0003 	mvn.w	r0, #3
 80070ec:	e006      	b.n	80070fc <udp_sendto_if+0x44>
    src_ip = netif_ip_addr4(netif);
 80070ee:	1d3d      	adds	r5, r7, #4
 80070f0:	4632      	mov	r2, r6
 80070f2:	4620      	mov	r0, r4
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
 80070f4:	9501      	str	r5, [sp, #4]
 80070f6:	9700      	str	r7, [sp, #0]
 80070f8:	f7ff ff5a 	bl	8006fb0 <udp_sendto_if_src>
}
 80070fc:	b003      	add	sp, #12
 80070fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_VAL;
 8007100:	f06f 0005 	mvn.w	r0, #5
 8007104:	e7fa      	b.n	80070fc <udp_sendto_if+0x44>
	...

08007108 <udp_sendto>:
{
 8007108:	b5f0      	push	{r4, r5, r6, r7, lr}
 800710a:	b083      	sub	sp, #12
  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 800710c:	fab2 f482 	clz	r4, r2
 8007110:	0964      	lsrs	r4, r4, #5
 8007112:	2800      	cmp	r0, #0
 8007114:	bf08      	it	eq
 8007116:	2401      	moveq	r4, #1
 8007118:	bb14      	cbnz	r4, 8007160 <udp_sendto+0x58>
 800711a:	4605      	mov	r5, r0
 800711c:	4616      	mov	r6, r2
  if (ip_addr_ismulticast(dst_ip_route)) {
 800711e:	6810      	ldr	r0, [r2, #0]
 8007120:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 8007124:	28e0      	cmp	r0, #224	; 0xe0
 8007126:	d00e      	beq.n	8007146 <udp_sendto+0x3e>
  const ip_addr_t *dst_ip_route = dst_ip;
 8007128:	4610      	mov	r0, r2
 800712a:	461f      	mov	r7, r3
 800712c:	460c      	mov	r4, r1
    netif = ip_route(&pcb->local_ip, dst_ip_route);
 800712e:	f001 f84b 	bl	80081c8 <ip4_route>
  if (netif == NULL) {
 8007132:	b1c0      	cbz	r0, 8007166 <udp_sendto+0x5e>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 8007134:	9000      	str	r0, [sp, #0]
 8007136:	463b      	mov	r3, r7
 8007138:	4632      	mov	r2, r6
 800713a:	4621      	mov	r1, r4
 800713c:	4628      	mov	r0, r5
 800713e:	f7ff ffbb 	bl	80070b8 <udp_sendto_if>
}
 8007142:	b003      	add	sp, #12
 8007144:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (!ip_addr_isany_val(pcb->multicast_ip) &&
 8007146:	69aa      	ldr	r2, [r5, #24]
 8007148:	b132      	cbz	r2, 8007158 <udp_sendto+0x50>
          !ip4_addr_cmp(ip_2_ip4(&pcb->multicast_ip), IP4_ADDR_BROADCAST)) {
 800714a:	4808      	ldr	r0, [pc, #32]	; (800716c <udp_sendto+0x64>)
 800714c:	6800      	ldr	r0, [r0, #0]
      if (!ip_addr_isany_val(pcb->multicast_ip) &&
 800714e:	4282      	cmp	r2, r0
 8007150:	d004      	beq.n	800715c <udp_sendto+0x54>
        dst_ip_route = &pcb->multicast_ip;
 8007152:	f105 0018 	add.w	r0, r5, #24
 8007156:	e7e8      	b.n	800712a <udp_sendto+0x22>
  const ip_addr_t *dst_ip_route = dst_ip;
 8007158:	4630      	mov	r0, r6
 800715a:	e7e6      	b.n	800712a <udp_sendto+0x22>
 800715c:	4630      	mov	r0, r6
 800715e:	e7e4      	b.n	800712a <udp_sendto+0x22>
    return ERR_VAL;
 8007160:	f06f 0005 	mvn.w	r0, #5
 8007164:	e7ed      	b.n	8007142 <udp_sendto+0x3a>
    return ERR_RTE;
 8007166:	f06f 0003 	mvn.w	r0, #3
 800716a:	e7ea      	b.n	8007142 <udp_sendto+0x3a>
 800716c:	080108c8 	.word	0x080108c8

08007170 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 8007170:	6201      	str	r1, [r0, #32]
  pcb->recv_arg = recv_arg;
 8007172:	6242      	str	r2, [r0, #36]	; 0x24
}
 8007174:	4770      	bx	lr
	...

08007178 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8007178:	b508      	push	{r3, lr}
 800717a:	4601      	mov	r1, r0
  struct udp_pcb *pcb2;

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 800717c:	4b0b      	ldr	r3, [pc, #44]	; (80071ac <udp_remove+0x34>)
 800717e:	681a      	ldr	r2, [r3, #0]
 8007180:	4282      	cmp	r2, r0
 8007182:	d109      	bne.n	8007198 <udp_remove+0x20>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 8007184:	68d2      	ldr	r2, [r2, #12]
 8007186:	601a      	str	r2, [r3, #0]
 8007188:	e001      	b.n	800718e <udp_remove+0x16>
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
 800718a:	68cb      	ldr	r3, [r1, #12]
 800718c:	60d3      	str	r3, [r2, #12]
        break;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 800718e:	2000      	movs	r0, #0
 8007190:	f7fe ffce 	bl	8006130 <memp_free>
}
 8007194:	bd08      	pop	{r3, pc}
 8007196:	461a      	mov	r2, r3
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8007198:	2a00      	cmp	r2, #0
 800719a:	d0f8      	beq.n	800718e <udp_remove+0x16>
      if (pcb2->next != NULL && pcb2->next == pcb) {
 800719c:	68d3      	ldr	r3, [r2, #12]
 800719e:	2b00      	cmp	r3, #0
 80071a0:	d0f9      	beq.n	8007196 <udp_remove+0x1e>
 80071a2:	428b      	cmp	r3, r1
 80071a4:	d0f1      	beq.n	800718a <udp_remove+0x12>
 80071a6:	461a      	mov	r2, r3
 80071a8:	e7f6      	b.n	8007198 <udp_remove+0x20>
 80071aa:	bf00      	nop
 80071ac:	20008618 	.word	0x20008618

080071b0 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 80071b0:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 80071b2:	2000      	movs	r0, #0
 80071b4:	f7fe ffa2 	bl	80060fc <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 80071b8:	4604      	mov	r4, r0
 80071ba:	b130      	cbz	r0, 80071ca <udp_new+0x1a>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 80071bc:	2228      	movs	r2, #40	; 0x28
 80071be:	2100      	movs	r1, #0
 80071c0:	f008 f96c 	bl	800f49c <memset>
    pcb->ttl = UDP_TTL;
 80071c4:	23ff      	movs	r3, #255	; 0xff
 80071c6:	72a3      	strb	r3, [r4, #10]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
 80071c8:	7723      	strb	r3, [r4, #28]
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
}
 80071ca:	4620      	mov	r0, r4
 80071cc:	bd10      	pop	{r4, pc}
	...

080071d0 <udp_netif_ip_addr_changed>:
 */
void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  struct udp_pcb* upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 80071d0:	b1b8      	cbz	r0, 8007202 <udp_netif_ip_addr_changed+0x32>
 80071d2:	4602      	mov	r2, r0
 80071d4:	6803      	ldr	r3, [r0, #0]
 80071d6:	b1a3      	cbz	r3, 8007202 <udp_netif_ip_addr_changed+0x32>
 80071d8:	b199      	cbz	r1, 8007202 <udp_netif_ip_addr_changed+0x32>
 80071da:	680b      	ldr	r3, [r1, #0]
 80071dc:	b18b      	cbz	r3, 8007202 <udp_netif_ip_addr_changed+0x32>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 80071de:	4b09      	ldr	r3, [pc, #36]	; (8007204 <udp_netif_ip_addr_changed+0x34>)
 80071e0:	681b      	ldr	r3, [r3, #0]
 80071e2:	b16b      	cbz	r3, 8007200 <udp_netif_ip_addr_changed+0x30>
{
 80071e4:	b410      	push	{r4}
 80071e6:	e001      	b.n	80071ec <udp_netif_ip_addr_changed+0x1c>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 80071e8:	68db      	ldr	r3, [r3, #12]
 80071ea:	b133      	cbz	r3, 80071fa <udp_netif_ip_addr_changed+0x2a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 80071ec:	681c      	ldr	r4, [r3, #0]
 80071ee:	6810      	ldr	r0, [r2, #0]
 80071f0:	4284      	cmp	r4, r0
 80071f2:	d1f9      	bne.n	80071e8 <udp_netif_ip_addr_changed+0x18>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 80071f4:	6808      	ldr	r0, [r1, #0]
 80071f6:	6018      	str	r0, [r3, #0]
 80071f8:	e7f6      	b.n	80071e8 <udp_netif_ip_addr_changed+0x18>
      }
    }
  }
}
 80071fa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80071fe:	4770      	bx	lr
 8007200:	4770      	bx	lr
 8007202:	4770      	bx	lr
 8007204:	20008618 	.word	0x20008618

08007208 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 8007208:	b510      	push	{r4, lr}
 800720a:	4604      	mov	r4, r0
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800720c:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8007210:	00d3      	lsls	r3, r2, #3
 8007212:	4a09      	ldr	r2, [pc, #36]	; (8007238 <etharp_free_entry+0x30>)
 8007214:	58d0      	ldr	r0, [r2, r3]
 8007216:	b138      	cbz	r0, 8007228 <etharp_free_entry+0x20>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8007218:	f7ff f940 	bl	800649c <pbuf_free>
    arp_table[i].q = NULL;
 800721c:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8007220:	00d3      	lsls	r3, r2, #3
 8007222:	4a05      	ldr	r2, [pc, #20]	; (8007238 <etharp_free_entry+0x30>)
 8007224:	2100      	movs	r1, #0
 8007226:	50d1      	str	r1, [r2, r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8007228:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 800722c:	00e2      	lsls	r2, r4, #3
 800722e:	4b02      	ldr	r3, [pc, #8]	; (8007238 <etharp_free_entry+0x30>)
 8007230:	4413      	add	r3, r2
 8007232:	2200      	movs	r2, #0
 8007234:	751a      	strb	r2, [r3, #20]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip4_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
 8007236:	bd10      	pop	{r4, pc}
 8007238:	200032ec 	.word	0x200032ec

0800723c <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
{
 800723c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 8007240:	f04f 0c00 	mov.w	ip, #0
 8007244:	46e3      	mov	fp, ip
 8007246:	46e1      	mov	r9, ip
  s8_t old_queue = ARP_TABLE_SIZE;
 8007248:	f04f 0e0a 	mov.w	lr, #10
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800724c:	4663      	mov	r3, ip
  s8_t empty = ARP_TABLE_SIZE;
 800724e:	4675      	mov	r5, lr
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8007250:	46f0      	mov	r8, lr
 8007252:	46f2      	mov	sl, lr
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8007254:	e01b      	b.n	800728e <etharp_find_entry+0x52>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 8007256:	b1c2      	cbz	r2, 800728a <etharp_find_entry+0x4e>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 8007258:	b140      	cbz	r0, 800726c <etharp_find_entry+0x30>
 800725a:	eb03 0643 	add.w	r6, r3, r3, lsl #1
 800725e:	00f7      	lsls	r7, r6, #3
 8007260:	4e59      	ldr	r6, [pc, #356]	; (80073c8 <etharp_find_entry+0x18c>)
 8007262:	443e      	add	r6, r7
 8007264:	6876      	ldr	r6, [r6, #4]
 8007266:	6807      	ldr	r7, [r0, #0]
 8007268:	42b7      	cmp	r7, r6
 800726a:	d01f      	beq.n	80072ac <etharp_find_entry+0x70>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 800726c:	2a01      	cmp	r2, #1
 800726e:	d01f      	beq.n	80072b0 <etharp_find_entry+0x74>
            old_pending = i;
            age_pending = arp_table[i].ctime;
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 8007270:	2a01      	cmp	r2, #1
 8007272:	d90a      	bls.n	800728a <etharp_find_entry+0x4e>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8007274:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8007278:	00e6      	lsls	r6, r4, #3
 800727a:	4a53      	ldr	r2, [pc, #332]	; (80073c8 <etharp_find_entry+0x18c>)
 800727c:	4432      	add	r2, r6
 800727e:	8a52      	ldrh	r2, [r2, #18]
 8007280:	4562      	cmp	r2, ip
 8007282:	d302      	bcc.n	800728a <etharp_find_entry+0x4e>
            old_stable = i;
 8007284:	fa4f f883 	sxtb.w	r8, r3
            age_stable = arp_table[i].ctime;
 8007288:	4694      	mov	ip, r2
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800728a:	3301      	adds	r3, #1
 800728c:	b2db      	uxtb	r3, r3
 800728e:	2b09      	cmp	r3, #9
 8007290:	d82c      	bhi.n	80072ec <etharp_find_entry+0xb0>
    u8_t state = arp_table[i].state;
 8007292:	461c      	mov	r4, r3
 8007294:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8007298:	00d6      	lsls	r6, r2, #3
 800729a:	4a4b      	ldr	r2, [pc, #300]	; (80073c8 <etharp_find_entry+0x18c>)
 800729c:	4432      	add	r2, r6
 800729e:	7d12      	ldrb	r2, [r2, #20]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80072a0:	2d0a      	cmp	r5, #10
 80072a2:	bf08      	it	eq
 80072a4:	2a00      	cmpeq	r2, #0
 80072a6:	d1d6      	bne.n	8007256 <etharp_find_entry+0x1a>
      empty = i;
 80072a8:	b25d      	sxtb	r5, r3
 80072aa:	e7ee      	b.n	800728a <etharp_find_entry+0x4e>
        return i;
 80072ac:	b258      	sxtb	r0, r3
 80072ae:	e041      	b.n	8007334 <etharp_find_entry+0xf8>
        if (arp_table[i].q != NULL) {
 80072b0:	eb04 0644 	add.w	r6, r4, r4, lsl #1
 80072b4:	00f2      	lsls	r2, r6, #3
 80072b6:	4e44      	ldr	r6, [pc, #272]	; (80073c8 <etharp_find_entry+0x18c>)
 80072b8:	58b2      	ldr	r2, [r6, r2]
 80072ba:	b15a      	cbz	r2, 80072d4 <etharp_find_entry+0x98>
          if (arp_table[i].ctime >= age_queue) {
 80072bc:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80072c0:	00e6      	lsls	r6, r4, #3
 80072c2:	4a41      	ldr	r2, [pc, #260]	; (80073c8 <etharp_find_entry+0x18c>)
 80072c4:	4432      	add	r2, r6
 80072c6:	8a52      	ldrh	r2, [r2, #18]
 80072c8:	454a      	cmp	r2, r9
 80072ca:	d3de      	bcc.n	800728a <etharp_find_entry+0x4e>
            old_queue = i;
 80072cc:	fa4f fe83 	sxtb.w	lr, r3
            age_queue = arp_table[i].ctime;
 80072d0:	4691      	mov	r9, r2
 80072d2:	e7da      	b.n	800728a <etharp_find_entry+0x4e>
          if (arp_table[i].ctime >= age_pending) {
 80072d4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80072d8:	00e6      	lsls	r6, r4, #3
 80072da:	4a3b      	ldr	r2, [pc, #236]	; (80073c8 <etharp_find_entry+0x18c>)
 80072dc:	4432      	add	r2, r6
 80072de:	8a52      	ldrh	r2, [r2, #18]
 80072e0:	455a      	cmp	r2, fp
 80072e2:	d3d2      	bcc.n	800728a <etharp_find_entry+0x4e>
            old_pending = i;
 80072e4:	fa4f fa83 	sxtb.w	sl, r3
            age_pending = arp_table[i].ctime;
 80072e8:	4693      	mov	fp, r2
 80072ea:	e7ce      	b.n	800728a <etharp_find_entry+0x4e>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 80072ec:	f011 0f02 	tst.w	r1, #2
 80072f0:	d164      	bne.n	80073bc <etharp_find_entry+0x180>
 80072f2:	2d0a      	cmp	r5, #10
 80072f4:	d020      	beq.n	8007338 <etharp_find_entry+0xfc>
 80072f6:	4606      	mov	r6, r0
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 80072f8:	2d09      	cmp	r5, #9
 80072fa:	dc23      	bgt.n	8007344 <etharp_find_entry+0x108>
    i = empty;
 80072fc:	b2ed      	uxtb	r5, r5
    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 80072fe:	2d09      	cmp	r5, #9
 8007300:	d84c      	bhi.n	800739c <etharp_find_entry+0x160>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8007302:	462c      	mov	r4, r5
 8007304:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8007308:	00da      	lsls	r2, r3, #3
 800730a:	4b2f      	ldr	r3, [pc, #188]	; (80073c8 <etharp_find_entry+0x18c>)
 800730c:	4413      	add	r3, r2
 800730e:	7d1b      	ldrb	r3, [r3, #20]
 8007310:	2b00      	cmp	r3, #0
 8007312:	d14b      	bne.n	80073ac <etharp_find_entry+0x170>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 8007314:	b136      	cbz	r6, 8007324 <etharp_find_entry+0xe8>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8007316:	6831      	ldr	r1, [r6, #0]
 8007318:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 800731c:	00da      	lsls	r2, r3, #3
 800731e:	4b2a      	ldr	r3, [pc, #168]	; (80073c8 <etharp_find_entry+0x18c>)
 8007320:	4413      	add	r3, r2
 8007322:	6059      	str	r1, [r3, #4]
  }
  arp_table[i].ctime = 0;
 8007324:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8007328:	00e2      	lsls	r2, r4, #3
 800732a:	4b27      	ldr	r3, [pc, #156]	; (80073c8 <etharp_find_entry+0x18c>)
 800732c:	4413      	add	r3, r2
 800732e:	2200      	movs	r2, #0
 8007330:	825a      	strh	r2, [r3, #18]
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
#endif /* ETHARP_TABLE_MATCH_NETIF*/
  return (err_t)i;
 8007332:	b268      	sxtb	r0, r5
}
 8007334:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8007338:	f011 0f01 	tst.w	r1, #1
 800733c:	d1db      	bne.n	80072f6 <etharp_find_entry+0xba>
    return (s8_t)ERR_MEM;
 800733e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007342:	e7f7      	b.n	8007334 <etharp_find_entry+0xf8>
    if (old_stable < ARP_TABLE_SIZE) {
 8007344:	f1b8 0f09 	cmp.w	r8, #9
 8007348:	dc14      	bgt.n	8007374 <etharp_find_entry+0x138>
      i = old_stable;
 800734a:	fa5f f588 	uxtb.w	r5, r8
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 800734e:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 8007352:	00d3      	lsls	r3, r2, #3
 8007354:	4a1c      	ldr	r2, [pc, #112]	; (80073c8 <etharp_find_entry+0x18c>)
 8007356:	58d3      	ldr	r3, [r2, r3]
 8007358:	b133      	cbz	r3, 8007368 <etharp_find_entry+0x12c>
 800735a:	4b1c      	ldr	r3, [pc, #112]	; (80073cc <etharp_find_entry+0x190>)
 800735c:	f240 126f 	movw	r2, #367	; 0x16f
 8007360:	491b      	ldr	r1, [pc, #108]	; (80073d0 <etharp_find_entry+0x194>)
 8007362:	481c      	ldr	r0, [pc, #112]	; (80073d4 <etharp_find_entry+0x198>)
 8007364:	f008 f8a2 	bl	800f4ac <iprintf>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8007368:	2d09      	cmp	r5, #9
 800736a:	d80f      	bhi.n	800738c <etharp_find_entry+0x150>
    etharp_free_entry(i);
 800736c:	4628      	mov	r0, r5
 800736e:	f7ff ff4b 	bl	8007208 <etharp_free_entry>
 8007372:	e7c4      	b.n	80072fe <etharp_find_entry+0xc2>
    } else if (old_pending < ARP_TABLE_SIZE) {
 8007374:	f1ba 0f09 	cmp.w	sl, #9
 8007378:	dc02      	bgt.n	8007380 <etharp_find_entry+0x144>
      i = old_pending;
 800737a:	fa5f f58a 	uxtb.w	r5, sl
 800737e:	e7f3      	b.n	8007368 <etharp_find_entry+0x12c>
    } else if (old_queue < ARP_TABLE_SIZE) {
 8007380:	f1be 0f09 	cmp.w	lr, #9
 8007384:	dc1d      	bgt.n	80073c2 <etharp_find_entry+0x186>
      i = old_queue;
 8007386:	fa5f f58e 	uxtb.w	r5, lr
 800738a:	e7ed      	b.n	8007368 <etharp_find_entry+0x12c>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 800738c:	4b0f      	ldr	r3, [pc, #60]	; (80073cc <etharp_find_entry+0x190>)
 800738e:	f240 1281 	movw	r2, #385	; 0x181
 8007392:	4911      	ldr	r1, [pc, #68]	; (80073d8 <etharp_find_entry+0x19c>)
 8007394:	480f      	ldr	r0, [pc, #60]	; (80073d4 <etharp_find_entry+0x198>)
 8007396:	f008 f889 	bl	800f4ac <iprintf>
 800739a:	e7e7      	b.n	800736c <etharp_find_entry+0x130>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 800739c:	4b0b      	ldr	r3, [pc, #44]	; (80073cc <etharp_find_entry+0x190>)
 800739e:	f240 1285 	movw	r2, #389	; 0x185
 80073a2:	490d      	ldr	r1, [pc, #52]	; (80073d8 <etharp_find_entry+0x19c>)
 80073a4:	480b      	ldr	r0, [pc, #44]	; (80073d4 <etharp_find_entry+0x198>)
 80073a6:	f008 f881 	bl	800f4ac <iprintf>
 80073aa:	e7aa      	b.n	8007302 <etharp_find_entry+0xc6>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 80073ac:	4b07      	ldr	r3, [pc, #28]	; (80073cc <etharp_find_entry+0x190>)
 80073ae:	f240 1287 	movw	r2, #391	; 0x187
 80073b2:	490a      	ldr	r1, [pc, #40]	; (80073dc <etharp_find_entry+0x1a0>)
 80073b4:	4807      	ldr	r0, [pc, #28]	; (80073d4 <etharp_find_entry+0x198>)
 80073b6:	f008 f879 	bl	800f4ac <iprintf>
 80073ba:	e7ab      	b.n	8007314 <etharp_find_entry+0xd8>
    return (s8_t)ERR_MEM;
 80073bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80073c0:	e7b8      	b.n	8007334 <etharp_find_entry+0xf8>
      return (s8_t)ERR_MEM;
 80073c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80073c6:	e7b5      	b.n	8007334 <etharp_find_entry+0xf8>
 80073c8:	200032ec 	.word	0x200032ec
 80073cc:	080112f4 	.word	0x080112f4
 80073d0:	0801132c 	.word	0x0801132c
 80073d4:	080109f4 	.word	0x080109f4
 80073d8:	08011344 	.word	0x08011344
 80073dc:	08011358 	.word	0x08011358

080073e0 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 80073e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80073e2:	b083      	sub	sp, #12
 80073e4:	4604      	mov	r4, r0
 80073e6:	460d      	mov	r5, r1
 80073e8:	4616      	mov	r6, r2
 80073ea:	461f      	mov	r7, r3
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 80073ec:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
 80073f0:	2b06      	cmp	r3, #6
 80073f2:	d13b      	bne.n	800746c <etharp_update_arp_entry+0x8c>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
    (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
 80073f4:	2d00      	cmp	r5, #0
 80073f6:	d041      	beq.n	800747c <etharp_update_arp_entry+0x9c>
 80073f8:	6828      	ldr	r0, [r5, #0]
 80073fa:	2800      	cmp	r0, #0
 80073fc:	d041      	beq.n	8007482 <etharp_update_arp_entry+0xa2>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 80073fe:	4621      	mov	r1, r4
 8007400:	f001 f8ec 	bl	80085dc <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
 8007404:	2800      	cmp	r0, #0
 8007406:	d13f      	bne.n	8007488 <etharp_update_arp_entry+0xa8>
      ip4_addr_ismulticast(ipaddr)) {
 8007408:	682b      	ldr	r3, [r5, #0]
 800740a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
 800740e:	2be0      	cmp	r3, #224	; 0xe0
 8007410:	d03d      	beq.n	800748e <etharp_update_arp_entry+0xae>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
 8007412:	4622      	mov	r2, r4
 8007414:	4639      	mov	r1, r7
 8007416:	4628      	mov	r0, r5
 8007418:	f7ff ff10 	bl	800723c <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 800741c:	2800      	cmp	r0, #0
 800741e:	db23      	blt.n	8007468 <etharp_update_arp_entry+0x88>
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 8007420:	4d1d      	ldr	r5, [pc, #116]	; (8007498 <etharp_update_arp_entry+0xb8>)
 8007422:	0042      	lsls	r2, r0, #1
 8007424:	1813      	adds	r3, r2, r0
 8007426:	00d9      	lsls	r1, r3, #3
 8007428:	186f      	adds	r7, r5, r1
 800742a:	2302      	movs	r3, #2
 800742c:	753b      	strb	r3, [r7, #20]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 800742e:	60bc      	str	r4, [r7, #8]
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 8007430:	460b      	mov	r3, r1
 8007432:	3308      	adds	r3, #8
 8007434:	442b      	add	r3, r5
 8007436:	6832      	ldr	r2, [r6, #0]
 8007438:	605a      	str	r2, [r3, #4]
 800743a:	88b2      	ldrh	r2, [r6, #4]
 800743c:	811a      	strh	r2, [r3, #8]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 800743e:	2300      	movs	r3, #0
 8007440:	827b      	strh	r3, [r7, #18]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 8007442:	586d      	ldr	r5, [r5, r1]
 8007444:	b335      	cbz	r5, 8007494 <etharp_update_arp_entry+0xb4>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 8007446:	2700      	movs	r7, #0
 8007448:	4a13      	ldr	r2, [pc, #76]	; (8007498 <etharp_update_arp_entry+0xb8>)
 800744a:	5057      	str	r7, [r2, r1]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 800744c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007450:	9300      	str	r3, [sp, #0]
 8007452:	4633      	mov	r3, r6
 8007454:	f104 0229 	add.w	r2, r4, #41	; 0x29
 8007458:	4629      	mov	r1, r5
 800745a:	4620      	mov	r0, r4
 800745c:	f001 fd22 	bl	8008ea4 <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
 8007460:	4628      	mov	r0, r5
 8007462:	f7ff f81b 	bl	800649c <pbuf_free>
  }
  return ERR_OK;
 8007466:	4638      	mov	r0, r7
}
 8007468:	b003      	add	sp, #12
 800746a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 800746c:	4b0b      	ldr	r3, [pc, #44]	; (800749c <etharp_update_arp_entry+0xbc>)
 800746e:	f240 12ab 	movw	r2, #427	; 0x1ab
 8007472:	490b      	ldr	r1, [pc, #44]	; (80074a0 <etharp_update_arp_entry+0xc0>)
 8007474:	480b      	ldr	r0, [pc, #44]	; (80074a4 <etharp_update_arp_entry+0xc4>)
 8007476:	f008 f819 	bl	800f4ac <iprintf>
 800747a:	e7bb      	b.n	80073f4 <etharp_update_arp_entry+0x14>
    return ERR_ARG;
 800747c:	f06f 000f 	mvn.w	r0, #15
 8007480:	e7f2      	b.n	8007468 <etharp_update_arp_entry+0x88>
 8007482:	f06f 000f 	mvn.w	r0, #15
 8007486:	e7ef      	b.n	8007468 <etharp_update_arp_entry+0x88>
 8007488:	f06f 000f 	mvn.w	r0, #15
 800748c:	e7ec      	b.n	8007468 <etharp_update_arp_entry+0x88>
 800748e:	f06f 000f 	mvn.w	r0, #15
 8007492:	e7e9      	b.n	8007468 <etharp_update_arp_entry+0x88>
  return ERR_OK;
 8007494:	2000      	movs	r0, #0
 8007496:	e7e7      	b.n	8007468 <etharp_update_arp_entry+0x88>
 8007498:	200032ec 	.word	0x200032ec
 800749c:	080112f4 	.word	0x080112f4
 80074a0:	08011384 	.word	0x08011384
 80074a4:	080109f4 	.word	0x080109f4

080074a8 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
 80074a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80074ac:	b082      	sub	sp, #8
 80074ae:	4689      	mov	r9, r1
 80074b0:	4692      	mov	sl, r2
 80074b2:	4698      	mov	r8, r3
 80074b4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  struct pbuf *p;
  err_t result = ERR_OK;
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 80074b6:	4607      	mov	r7, r0
 80074b8:	2800      	cmp	r0, #0
 80074ba:	d041      	beq.n	8007540 <etharp_raw+0x98>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
 80074bc:	2200      	movs	r2, #0
 80074be:	211c      	movs	r1, #28
 80074c0:	2002      	movs	r0, #2
 80074c2:	f7ff f855 	bl	8006570 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 80074c6:	4606      	mov	r6, r0
 80074c8:	2800      	cmp	r0, #0
 80074ca:	d051      	beq.n	8007570 <etharp_raw+0xc8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 80074cc:	8943      	ldrh	r3, [r0, #10]
 80074ce:	2b1b      	cmp	r3, #27
 80074d0:	d93e      	bls.n	8007550 <etharp_raw+0xa8>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
 80074d2:	6874      	ldr	r4, [r6, #4]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
 80074d4:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
 80074d8:	f7fe fb28 	bl	8005b2c <lwip_htons>
 80074dc:	80e0      	strh	r0, [r4, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 80074de:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80074e2:	2b06      	cmp	r3, #6
 80074e4:	d13c      	bne.n	8007560 <etharp_raw+0xb8>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 80074e6:	f8d8 3000 	ldr.w	r3, [r8]
 80074ea:	60a3      	str	r3, [r4, #8]
 80074ec:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 80074f0:	81a3      	strh	r3, [r4, #12]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 80074f2:	682b      	ldr	r3, [r5, #0]
 80074f4:	f8c4 3012 	str.w	r3, [r4, #18]
 80074f8:	88ab      	ldrh	r3, [r5, #4]
 80074fa:	82e3      	strh	r3, [r4, #22]
  /* Copy struct ip4_addr2 to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 80074fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80074fe:	681b      	ldr	r3, [r3, #0]
 8007500:	f8c4 300e 	str.w	r3, [r4, #14]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 8007504:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007506:	681b      	ldr	r3, [r3, #0]
 8007508:	61a3      	str	r3, [r4, #24]

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800750a:	2500      	movs	r5, #0
 800750c:	7025      	strb	r5, [r4, #0]
 800750e:	2301      	movs	r3, #1
 8007510:	7063      	strb	r3, [r4, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8007512:	2308      	movs	r3, #8
 8007514:	70a3      	strb	r3, [r4, #2]
 8007516:	70e5      	strb	r5, [r4, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
 8007518:	2306      	movs	r3, #6
 800751a:	7123      	strb	r3, [r4, #4]
  hdr->protolen = sizeof(ip4_addr_t);
 800751c:	2304      	movs	r3, #4
 800751e:	7163      	strb	r3, [r4, #5]
  if(ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 8007520:	f640 0306 	movw	r3, #2054	; 0x806
 8007524:	9300      	str	r3, [sp, #0]
 8007526:	4653      	mov	r3, sl
 8007528:	464a      	mov	r2, r9
 800752a:	4631      	mov	r1, r6
 800752c:	4638      	mov	r0, r7
 800752e:	f001 fcb9 	bl	8008ea4 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 8007532:	4630      	mov	r0, r6
 8007534:	f7fe ffb2 	bl	800649c <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 8007538:	4628      	mov	r0, r5
}
 800753a:	b002      	add	sp, #8
 800753c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  LWIP_ASSERT("netif != NULL", netif != NULL);
 8007540:	4b0d      	ldr	r3, [pc, #52]	; (8007578 <etharp_raw+0xd0>)
 8007542:	f44f 628b 	mov.w	r2, #1112	; 0x458
 8007546:	490d      	ldr	r1, [pc, #52]	; (800757c <etharp_raw+0xd4>)
 8007548:	480d      	ldr	r0, [pc, #52]	; (8007580 <etharp_raw+0xd8>)
 800754a:	f007 ffaf 	bl	800f4ac <iprintf>
 800754e:	e7b5      	b.n	80074bc <etharp_raw+0x14>
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 8007550:	4b09      	ldr	r3, [pc, #36]	; (8007578 <etharp_raw+0xd0>)
 8007552:	f240 4264 	movw	r2, #1124	; 0x464
 8007556:	490b      	ldr	r1, [pc, #44]	; (8007584 <etharp_raw+0xdc>)
 8007558:	4809      	ldr	r0, [pc, #36]	; (8007580 <etharp_raw+0xd8>)
 800755a:	f007 ffa7 	bl	800f4ac <iprintf>
 800755e:	e7b8      	b.n	80074d2 <etharp_raw+0x2a>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 8007560:	4b05      	ldr	r3, [pc, #20]	; (8007578 <etharp_raw+0xd0>)
 8007562:	f240 426b 	movw	r2, #1131	; 0x46b
 8007566:	4908      	ldr	r1, [pc, #32]	; (8007588 <etharp_raw+0xe0>)
 8007568:	4805      	ldr	r0, [pc, #20]	; (8007580 <etharp_raw+0xd8>)
 800756a:	f007 ff9f 	bl	800f4ac <iprintf>
 800756e:	e7ba      	b.n	80074e6 <etharp_raw+0x3e>
    return ERR_MEM;
 8007570:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007574:	e7e1      	b.n	800753a <etharp_raw+0x92>
 8007576:	bf00      	nop
 8007578:	080112f4 	.word	0x080112f4
 800757c:	080113a8 	.word	0x080113a8
 8007580:	080109f4 	.word	0x080109f4
 8007584:	080113b8 	.word	0x080113b8
 8007588:	080113ec 	.word	0x080113ec

0800758c <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr* hw_dst_addr)
{
 800758c:	b530      	push	{r4, r5, lr}
 800758e:	b085      	sub	sp, #20
 8007590:	4603      	mov	r3, r0
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 8007592:	f100 0429 	add.w	r4, r0, #41	; 0x29
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 8007596:	3304      	adds	r3, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 8007598:	2501      	movs	r5, #1
 800759a:	9503      	str	r5, [sp, #12]
 800759c:	9102      	str	r1, [sp, #8]
 800759e:	4904      	ldr	r1, [pc, #16]	; (80075b0 <etharp_request_dst+0x24>)
 80075a0:	9101      	str	r1, [sp, #4]
 80075a2:	9300      	str	r3, [sp, #0]
 80075a4:	4623      	mov	r3, r4
 80075a6:	4621      	mov	r1, r4
 80075a8:	f7ff ff7e 	bl	80074a8 <etharp_raw>
                    ipaddr, ARP_REQUEST);
}
 80075ac:	b005      	add	sp, #20
 80075ae:	bd30      	pop	{r4, r5, pc}
 80075b0:	080108d8 	.word	0x080108d8

080075b4 <etharp_cleanup_netif>:
{
 80075b4:	b538      	push	{r3, r4, r5, lr}
 80075b6:	4605      	mov	r5, r0
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80075b8:	2400      	movs	r4, #0
 80075ba:	e001      	b.n	80075c0 <etharp_cleanup_netif+0xc>
 80075bc:	3401      	adds	r4, #1
 80075be:	b2e4      	uxtb	r4, r4
 80075c0:	2c09      	cmp	r4, #9
 80075c2:	d810      	bhi.n	80075e6 <etharp_cleanup_netif+0x32>
    u8_t state = arp_table[i].state;
 80075c4:	4620      	mov	r0, r4
 80075c6:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80075ca:	00da      	lsls	r2, r3, #3
 80075cc:	4b06      	ldr	r3, [pc, #24]	; (80075e8 <etharp_cleanup_netif+0x34>)
 80075ce:	4413      	add	r3, r2
 80075d0:	7d1b      	ldrb	r3, [r3, #20]
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 80075d2:	2b00      	cmp	r3, #0
 80075d4:	d0f2      	beq.n	80075bc <etharp_cleanup_netif+0x8>
 80075d6:	4b04      	ldr	r3, [pc, #16]	; (80075e8 <etharp_cleanup_netif+0x34>)
 80075d8:	4413      	add	r3, r2
 80075da:	689b      	ldr	r3, [r3, #8]
 80075dc:	42ab      	cmp	r3, r5
 80075de:	d1ed      	bne.n	80075bc <etharp_cleanup_netif+0x8>
      etharp_free_entry(i);
 80075e0:	f7ff fe12 	bl	8007208 <etharp_free_entry>
 80075e4:	e7ea      	b.n	80075bc <etharp_cleanup_netif+0x8>
}
 80075e6:	bd38      	pop	{r3, r4, r5, pc}
 80075e8:	200032ec 	.word	0x200032ec

080075ec <etharp_input>:
{
 80075ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80075f0:	b086      	sub	sp, #24
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 80075f2:	b179      	cbz	r1, 8007614 <etharp_input+0x28>
 80075f4:	4604      	mov	r4, r0
 80075f6:	460e      	mov	r6, r1
  hdr = (struct etharp_hdr *)p->payload;
 80075f8:	6845      	ldr	r5, [r0, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 80075fa:	882b      	ldrh	r3, [r5, #0]
 80075fc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007600:	d102      	bne.n	8007608 <etharp_input+0x1c>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 8007602:	792b      	ldrb	r3, [r5, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8007604:	2b06      	cmp	r3, #6
 8007606:	d00d      	beq.n	8007624 <etharp_input+0x38>
    pbuf_free(p);
 8007608:	4620      	mov	r0, r4
 800760a:	f7fe ff47 	bl	800649c <pbuf_free>
}
 800760e:	b006      	add	sp, #24
 8007610:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8007614:	4b20      	ldr	r3, [pc, #128]	; (8007698 <etharp_input+0xac>)
 8007616:	f44f 7222 	mov.w	r2, #648	; 0x288
 800761a:	4920      	ldr	r1, [pc, #128]	; (800769c <etharp_input+0xb0>)
 800761c:	4820      	ldr	r0, [pc, #128]	; (80076a0 <etharp_input+0xb4>)
 800761e:	f007 ff45 	bl	800f4ac <iprintf>
 8007622:	e7f4      	b.n	800760e <etharp_input+0x22>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 8007624:	796b      	ldrb	r3, [r5, #5]
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 8007626:	2b04      	cmp	r3, #4
 8007628:	d1ee      	bne.n	8007608 <etharp_input+0x1c>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 800762a:	886b      	ldrh	r3, [r5, #2]
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 800762c:	2b08      	cmp	r3, #8
 800762e:	d1eb      	bne.n	8007608 <etharp_input+0x1c>
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8007630:	f8d5 300e 	ldr.w	r3, [r5, #14]
 8007634:	9305      	str	r3, [sp, #20]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 8007636:	69af      	ldr	r7, [r5, #24]
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8007638:	684b      	ldr	r3, [r1, #4]
 800763a:	b98b      	cbnz	r3, 8007660 <etharp_input+0x74>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800763c:	f105 0808 	add.w	r8, r5, #8
    for_us = 0;
 8007640:	2700      	movs	r7, #0
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8007642:	2302      	movs	r3, #2
 8007644:	4642      	mov	r2, r8
 8007646:	a905      	add	r1, sp, #20
 8007648:	4630      	mov	r0, r6
 800764a:	f7ff fec9 	bl	80073e0 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 800764e:	88eb      	ldrh	r3, [r5, #6]
 8007650:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007654:	d100      	bne.n	8007658 <etharp_input+0x6c>
    if (for_us) {
 8007656:	b977      	cbnz	r7, 8007676 <etharp_input+0x8a>
  pbuf_free(p);
 8007658:	4620      	mov	r0, r4
 800765a:	f7fe ff1f 	bl	800649c <pbuf_free>
 800765e:	e7d6      	b.n	800760e <etharp_input+0x22>
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 8007660:	42bb      	cmp	r3, r7
 8007662:	bf14      	ite	ne
 8007664:	2700      	movne	r7, #0
 8007666:	2701      	moveq	r7, #1
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8007668:	f105 0808 	add.w	r8, r5, #8
 800766c:	b10f      	cbz	r7, 8007672 <etharp_input+0x86>
 800766e:	2301      	movs	r3, #1
 8007670:	e7e8      	b.n	8007644 <etharp_input+0x58>
 8007672:	2302      	movs	r3, #2
 8007674:	e7e6      	b.n	8007644 <etharp_input+0x58>
                 (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 8007676:	f106 0129 	add.w	r1, r6, #41	; 0x29
                 (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 800767a:	1d33      	adds	r3, r6, #4
      etharp_raw(netif,
 800767c:	2202      	movs	r2, #2
 800767e:	9203      	str	r2, [sp, #12]
 8007680:	aa05      	add	r2, sp, #20
 8007682:	9202      	str	r2, [sp, #8]
 8007684:	f8cd 8004 	str.w	r8, [sp, #4]
 8007688:	9300      	str	r3, [sp, #0]
 800768a:	460b      	mov	r3, r1
 800768c:	4642      	mov	r2, r8
 800768e:	4630      	mov	r0, r6
 8007690:	f7ff ff0a 	bl	80074a8 <etharp_raw>
 8007694:	e7e0      	b.n	8007658 <etharp_input+0x6c>
 8007696:	bf00      	nop
 8007698:	080112f4 	.word	0x080112f4
 800769c:	080113a8 	.word	0x080113a8
 80076a0:	080109f4 	.word	0x080109f4

080076a4 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 80076a4:	b508      	push	{r3, lr}
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 80076a6:	4a02      	ldr	r2, [pc, #8]	; (80076b0 <etharp_request+0xc>)
 80076a8:	f7ff ff70 	bl	800758c <etharp_request_dst>
}
 80076ac:	bd08      	pop	{r3, pc}
 80076ae:	bf00      	nop
 80076b0:	080108d0 	.word	0x080108d0

080076b4 <etharp_tmr>:
{
 80076b4:	b538      	push	{r3, r4, r5, lr}
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80076b6:	2400      	movs	r4, #0
 80076b8:	e005      	b.n	80076c6 <etharp_tmr+0x12>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 80076ba:	2b04      	cmp	r3, #4
 80076bc:	d91d      	bls.n	80076fa <etharp_tmr+0x46>
        etharp_free_entry(i);
 80076be:	f7ff fda3 	bl	8007208 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80076c2:	3401      	adds	r4, #1
 80076c4:	b2e4      	uxtb	r4, r4
 80076c6:	2c09      	cmp	r4, #9
 80076c8:	d838      	bhi.n	800773c <etharp_tmr+0x88>
    u8_t state = arp_table[i].state;
 80076ca:	4620      	mov	r0, r4
 80076cc:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80076d0:	00da      	lsls	r2, r3, #3
 80076d2:	4b1b      	ldr	r3, [pc, #108]	; (8007740 <etharp_tmr+0x8c>)
 80076d4:	4413      	add	r3, r2
 80076d6:	7d1b      	ldrb	r3, [r3, #20]
    if (state != ETHARP_STATE_EMPTY
 80076d8:	2b00      	cmp	r3, #0
 80076da:	d0f2      	beq.n	80076c2 <etharp_tmr+0xe>
      arp_table[i].ctime++;
 80076dc:	4611      	mov	r1, r2
 80076de:	4a18      	ldr	r2, [pc, #96]	; (8007740 <etharp_tmr+0x8c>)
 80076e0:	440a      	add	r2, r1
 80076e2:	8a53      	ldrh	r3, [r2, #18]
 80076e4:	3301      	adds	r3, #1
 80076e6:	b29b      	uxth	r3, r3
 80076e8:	8253      	strh	r3, [r2, #18]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 80076ea:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80076ee:	d2e6      	bcs.n	80076be <etharp_tmr+0xa>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 80076f0:	4a13      	ldr	r2, [pc, #76]	; (8007740 <etharp_tmr+0x8c>)
 80076f2:	440a      	add	r2, r1
 80076f4:	7d12      	ldrb	r2, [r2, #20]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 80076f6:	2a01      	cmp	r2, #1
 80076f8:	d0df      	beq.n	80076ba <etharp_tmr+0x6>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 80076fa:	2a03      	cmp	r2, #3
 80076fc:	d00e      	beq.n	800771c <etharp_tmr+0x68>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 80076fe:	2a04      	cmp	r2, #4
 8007700:	d014      	beq.n	800772c <etharp_tmr+0x78>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 8007702:	2a01      	cmp	r2, #1
 8007704:	d1dd      	bne.n	80076c2 <etharp_tmr+0xe>
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 8007706:	4a0e      	ldr	r2, [pc, #56]	; (8007740 <etharp_tmr+0x8c>)
 8007708:	0043      	lsls	r3, r0, #1
 800770a:	181d      	adds	r5, r3, r0
 800770c:	00e9      	lsls	r1, r5, #3
 800770e:	4411      	add	r1, r2
 8007710:	460a      	mov	r2, r1
 8007712:	3104      	adds	r1, #4
 8007714:	6890      	ldr	r0, [r2, #8]
 8007716:	f7ff ffc5 	bl	80076a4 <etharp_request>
 800771a:	e7d2      	b.n	80076c2 <etharp_tmr+0xe>
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 800771c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8007720:	00c2      	lsls	r2, r0, #3
 8007722:	4b07      	ldr	r3, [pc, #28]	; (8007740 <etharp_tmr+0x8c>)
 8007724:	4413      	add	r3, r2
 8007726:	2204      	movs	r2, #4
 8007728:	751a      	strb	r2, [r3, #20]
 800772a:	e7ca      	b.n	80076c2 <etharp_tmr+0xe>
        arp_table[i].state = ETHARP_STATE_STABLE;
 800772c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8007730:	00c2      	lsls	r2, r0, #3
 8007732:	4b03      	ldr	r3, [pc, #12]	; (8007740 <etharp_tmr+0x8c>)
 8007734:	4413      	add	r3, r2
 8007736:	2202      	movs	r2, #2
 8007738:	751a      	strb	r2, [r3, #20]
 800773a:	e7c2      	b.n	80076c2 <etharp_tmr+0xe>
}
 800773c:	bd38      	pop	{r3, r4, r5, pc}
 800773e:	bf00      	nop
 8007740:	200032ec 	.word	0x200032ec

08007744 <etharp_output_to_arp_index>:
{
 8007744:	b570      	push	{r4, r5, r6, lr}
 8007746:	b082      	sub	sp, #8
 8007748:	4605      	mov	r5, r0
 800774a:	460e      	mov	r6, r1
 800774c:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800774e:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8007752:	00da      	lsls	r2, r3, #3
 8007754:	4b2c      	ldr	r3, [pc, #176]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 8007756:	4413      	add	r3, r2
 8007758:	7d1b      	ldrb	r3, [r3, #20]
 800775a:	2b01      	cmp	r3, #1
 800775c:	d919      	bls.n	8007792 <etharp_output_to_arp_index+0x4e>
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 800775e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8007762:	00da      	lsls	r2, r3, #3
 8007764:	4b28      	ldr	r3, [pc, #160]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 8007766:	4413      	add	r3, r2
 8007768:	7d1b      	ldrb	r3, [r3, #20]
 800776a:	2b02      	cmp	r3, #2
 800776c:	d019      	beq.n	80077a2 <etharp_output_to_arp_index+0x5e>
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 800776e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8007772:	00e3      	lsls	r3, r4, #3
 8007774:	3308      	adds	r3, #8
 8007776:	4a24      	ldr	r2, [pc, #144]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 8007778:	4413      	add	r3, r2
 800777a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800777e:	9200      	str	r2, [sp, #0]
 8007780:	3304      	adds	r3, #4
 8007782:	f105 0229 	add.w	r2, r5, #41	; 0x29
 8007786:	4631      	mov	r1, r6
 8007788:	4628      	mov	r0, r5
 800778a:	f001 fb8b 	bl	8008ea4 <ethernet_output>
}
 800778e:	b002      	add	sp, #8
 8007790:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 8007792:	4b1e      	ldr	r3, [pc, #120]	; (800780c <etharp_output_to_arp_index+0xc8>)
 8007794:	f240 22ed 	movw	r2, #749	; 0x2ed
 8007798:	491d      	ldr	r1, [pc, #116]	; (8007810 <etharp_output_to_arp_index+0xcc>)
 800779a:	481e      	ldr	r0, [pc, #120]	; (8007814 <etharp_output_to_arp_index+0xd0>)
 800779c:	f007 fe86 	bl	800f4ac <iprintf>
 80077a0:	e7dd      	b.n	800775e <etharp_output_to_arp_index+0x1a>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 80077a2:	4b19      	ldr	r3, [pc, #100]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 80077a4:	4413      	add	r3, r2
 80077a6:	8a5b      	ldrh	r3, [r3, #18]
 80077a8:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
 80077ac:	d819      	bhi.n	80077e2 <etharp_output_to_arp_index+0x9e>
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 80077ae:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 80077b2:	d3dc      	bcc.n	800776e <etharp_output_to_arp_index+0x2a>
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 80077b4:	4a14      	ldr	r2, [pc, #80]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 80077b6:	0063      	lsls	r3, r4, #1
 80077b8:	1918      	adds	r0, r3, r4
 80077ba:	00c1      	lsls	r1, r0, #3
 80077bc:	4608      	mov	r0, r1
 80077be:	4411      	add	r1, r2
 80077c0:	3008      	adds	r0, #8
 80077c2:	4402      	add	r2, r0
 80077c4:	3204      	adds	r2, #4
 80077c6:	3104      	adds	r1, #4
 80077c8:	4628      	mov	r0, r5
 80077ca:	f7ff fedf 	bl	800758c <etharp_request_dst>
 80077ce:	2800      	cmp	r0, #0
 80077d0:	d1cd      	bne.n	800776e <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 80077d2:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80077d6:	00da      	lsls	r2, r3, #3
 80077d8:	4b0b      	ldr	r3, [pc, #44]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 80077da:	4413      	add	r3, r2
 80077dc:	2203      	movs	r2, #3
 80077de:	751a      	strb	r2, [r3, #20]
 80077e0:	e7c5      	b.n	800776e <etharp_output_to_arp_index+0x2a>
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 80077e2:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80077e6:	00d3      	lsls	r3, r2, #3
 80077e8:	4907      	ldr	r1, [pc, #28]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 80077ea:	4419      	add	r1, r3
 80077ec:	3104      	adds	r1, #4
 80077ee:	4628      	mov	r0, r5
 80077f0:	f7ff ff58 	bl	80076a4 <etharp_request>
 80077f4:	2800      	cmp	r0, #0
 80077f6:	d1ba      	bne.n	800776e <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 80077f8:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80077fc:	00da      	lsls	r2, r3, #3
 80077fe:	4b02      	ldr	r3, [pc, #8]	; (8007808 <etharp_output_to_arp_index+0xc4>)
 8007800:	4413      	add	r3, r2
 8007802:	2203      	movs	r2, #3
 8007804:	751a      	strb	r2, [r3, #20]
 8007806:	e7b2      	b.n	800776e <etharp_output_to_arp_index+0x2a>
 8007808:	200032ec 	.word	0x200032ec
 800780c:	080112f4 	.word	0x080112f4
 8007810:	08011474 	.word	0x08011474
 8007814:	080109f4 	.word	0x080109f4

08007818 <etharp_query>:
{
 8007818:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800781c:	b082      	sub	sp, #8
 800781e:	4607      	mov	r7, r0
 8007820:	460d      	mov	r5, r1
 8007822:	4691      	mov	r9, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 8007824:	f100 0a29 	add.w	sl, r0, #41	; 0x29
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 8007828:	4601      	mov	r1, r0
 800782a:	6828      	ldr	r0, [r5, #0]
 800782c:	f000 fed6 	bl	80085dc <ip4_addr_isbroadcast_u32>
 8007830:	2800      	cmp	r0, #0
 8007832:	f040 80b2 	bne.w	800799a <etharp_query+0x182>
      ip4_addr_ismulticast(ipaddr) ||
 8007836:	682b      	ldr	r3, [r5, #0]
 8007838:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 800783c:	2ae0      	cmp	r2, #224	; 0xe0
 800783e:	f000 80af 	beq.w	80079a0 <etharp_query+0x188>
      ip4_addr_ismulticast(ipaddr) ||
 8007842:	2d00      	cmp	r5, #0
 8007844:	f000 80af 	beq.w	80079a6 <etharp_query+0x18e>
      ip4_addr_isany(ipaddr)) {
 8007848:	2b00      	cmp	r3, #0
 800784a:	f000 80af 	beq.w	80079ac <etharp_query+0x194>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 800784e:	463a      	mov	r2, r7
 8007850:	2101      	movs	r1, #1
 8007852:	4628      	mov	r0, r5
 8007854:	f7ff fcf2 	bl	800723c <etharp_find_entry>
  if (i < 0) {
 8007858:	1e04      	subs	r4, r0, #0
 800785a:	db5b      	blt.n	8007914 <etharp_query+0xfc>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 800785c:	4626      	mov	r6, r4
 800785e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8007862:	00da      	lsls	r2, r3, #3
 8007864:	4b54      	ldr	r3, [pc, #336]	; (80079b8 <etharp_query+0x1a0>)
 8007866:	4413      	add	r3, r2
 8007868:	7d1b      	ldrb	r3, [r3, #20]
 800786a:	bb3b      	cbnz	r3, 80078bc <etharp_query+0xa4>
    arp_table[i].state = ETHARP_STATE_PENDING;
 800786c:	0062      	lsls	r2, r4, #1
 800786e:	4422      	add	r2, r4
 8007870:	00d1      	lsls	r1, r2, #3
 8007872:	4b51      	ldr	r3, [pc, #324]	; (80079b8 <etharp_query+0x1a0>)
 8007874:	440b      	add	r3, r1
 8007876:	f04f 0801 	mov.w	r8, #1
 800787a:	f883 8014 	strb.w	r8, [r3, #20]
    arp_table[i].netif = netif;
 800787e:	609f      	str	r7, [r3, #8]
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 8007880:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 8007884:	00da      	lsls	r2, r3, #3
 8007886:	4b4c      	ldr	r3, [pc, #304]	; (80079b8 <etharp_query+0x1a0>)
 8007888:	4413      	add	r3, r2
 800788a:	7d1b      	ldrb	r3, [r3, #20]
 800788c:	b1cb      	cbz	r3, 80078c2 <etharp_query+0xaa>
  if (is_new_entry || (q == NULL)) {
 800788e:	f1b9 0f00 	cmp.w	r9, #0
 8007892:	bf14      	ite	ne
 8007894:	4643      	movne	r3, r8
 8007896:	2301      	moveq	r3, #1
 8007898:	b9db      	cbnz	r3, 80078d2 <etharp_query+0xba>
  err_t result = ERR_MEM;
 800789a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  LWIP_ASSERT("q != NULL", q != NULL);
 800789e:	f1b9 0f00 	cmp.w	r9, #0
 80078a2:	d020      	beq.n	80078e6 <etharp_query+0xce>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 80078a4:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 80078a8:	00da      	lsls	r2, r3, #3
 80078aa:	4b43      	ldr	r3, [pc, #268]	; (80079b8 <etharp_query+0x1a0>)
 80078ac:	4413      	add	r3, r2
 80078ae:	7d1b      	ldrb	r3, [r3, #20]
 80078b0:	2b01      	cmp	r3, #1
 80078b2:	d820      	bhi.n	80078f6 <etharp_query+0xde>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 80078b4:	2b01      	cmp	r3, #1
 80078b6:	d045      	beq.n	8007944 <etharp_query+0x12c>
 80078b8:	462c      	mov	r4, r5
 80078ba:	e02b      	b.n	8007914 <etharp_query+0xfc>
  int is_new_entry = 0;
 80078bc:	f04f 0800 	mov.w	r8, #0
 80078c0:	e7de      	b.n	8007880 <etharp_query+0x68>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 80078c2:	4b3e      	ldr	r3, [pc, #248]	; (80079bc <etharp_query+0x1a4>)
 80078c4:	f240 32c9 	movw	r2, #969	; 0x3c9
 80078c8:	493d      	ldr	r1, [pc, #244]	; (80079c0 <etharp_query+0x1a8>)
 80078ca:	483e      	ldr	r0, [pc, #248]	; (80079c4 <etharp_query+0x1ac>)
 80078cc:	f007 fdee 	bl	800f4ac <iprintf>
 80078d0:	e7dd      	b.n	800788e <etharp_query+0x76>
    result = etharp_request(netif, ipaddr);
 80078d2:	4629      	mov	r1, r5
 80078d4:	4638      	mov	r0, r7
 80078d6:	f7ff fee5 	bl	80076a4 <etharp_request>
 80078da:	4605      	mov	r5, r0
    if (q == NULL) {
 80078dc:	f1b9 0f00 	cmp.w	r9, #0
 80078e0:	d1dd      	bne.n	800789e <etharp_query+0x86>
      return result;
 80078e2:	4604      	mov	r4, r0
 80078e4:	e016      	b.n	8007914 <etharp_query+0xfc>
  LWIP_ASSERT("q != NULL", q != NULL);
 80078e6:	4b35      	ldr	r3, [pc, #212]	; (80079bc <etharp_query+0x1a4>)
 80078e8:	f240 32db 	movw	r2, #987	; 0x3db
 80078ec:	4936      	ldr	r1, [pc, #216]	; (80079c8 <etharp_query+0x1b0>)
 80078ee:	4835      	ldr	r0, [pc, #212]	; (80079c4 <etharp_query+0x1ac>)
 80078f0:	f007 fddc 	bl	800f4ac <iprintf>
 80078f4:	e7d6      	b.n	80078a4 <etharp_query+0x8c>
    ETHARP_SET_HINT(netif, i);
 80078f6:	4b30      	ldr	r3, [pc, #192]	; (80079b8 <etharp_query+0x1a0>)
 80078f8:	f883 40f0 	strb.w	r4, [r3, #240]	; 0xf0
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
 80078fc:	3208      	adds	r2, #8
 80078fe:	4413      	add	r3, r2
 8007900:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8007904:	9200      	str	r2, [sp, #0]
 8007906:	3304      	adds	r3, #4
 8007908:	4652      	mov	r2, sl
 800790a:	4649      	mov	r1, r9
 800790c:	4638      	mov	r0, r7
 800790e:	f001 fac9 	bl	8008ea4 <ethernet_output>
 8007912:	4604      	mov	r4, r0
}
 8007914:	4620      	mov	r0, r4
 8007916:	b002      	add	sp, #8
 8007918:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 800791c:	4b27      	ldr	r3, [pc, #156]	; (80079bc <etharp_query+0x1a4>)
 800791e:	f44f 727b 	mov.w	r2, #1004	; 0x3ec
 8007922:	492a      	ldr	r1, [pc, #168]	; (80079cc <etharp_query+0x1b4>)
 8007924:	4827      	ldr	r0, [pc, #156]	; (80079c4 <etharp_query+0x1ac>)
 8007926:	f007 fdc1 	bl	800f4ac <iprintf>
      if (p->type != PBUF_ROM) {
 800792a:	7b23      	ldrb	r3, [r4, #12]
 800792c:	2b01      	cmp	r3, #1
 800792e:	d11e      	bne.n	800796e <etharp_query+0x156>
      p = p->next;
 8007930:	6824      	ldr	r4, [r4, #0]
    while (p) {
 8007932:	b14c      	cbz	r4, 8007948 <etharp_query+0x130>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 8007934:	8962      	ldrh	r2, [r4, #10]
 8007936:	8923      	ldrh	r3, [r4, #8]
 8007938:	429a      	cmp	r2, r3
 800793a:	d1f6      	bne.n	800792a <etharp_query+0x112>
 800793c:	6823      	ldr	r3, [r4, #0]
 800793e:	2b00      	cmp	r3, #0
 8007940:	d1ec      	bne.n	800791c <etharp_query+0x104>
 8007942:	e7f2      	b.n	800792a <etharp_query+0x112>
    p = q;
 8007944:	464c      	mov	r4, r9
 8007946:	e7f4      	b.n	8007932 <etharp_query+0x11a>
    int copy_needed = 0;
 8007948:	2300      	movs	r3, #0
    if (copy_needed) {
 800794a:	b193      	cbz	r3, 8007972 <etharp_query+0x15a>
      p = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 800794c:	2200      	movs	r2, #0
 800794e:	8921      	ldrh	r1, [r4, #8]
 8007950:	2002      	movs	r0, #2
 8007952:	f7fe fe0d 	bl	8006570 <pbuf_alloc>
      if (p != NULL) {
 8007956:	4604      	mov	r4, r0
 8007958:	b178      	cbz	r0, 800797a <etharp_query+0x162>
        if (pbuf_copy(p, q) != ERR_OK) {
 800795a:	4649      	mov	r1, r9
 800795c:	f7fe ffd4 	bl	8006908 <pbuf_copy>
 8007960:	b158      	cbz	r0, 800797a <etharp_query+0x162>
          pbuf_free(p);
 8007962:	4620      	mov	r0, r4
 8007964:	f7fe fd9a 	bl	800649c <pbuf_free>
      result = ERR_MEM;
 8007968:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 800796c:	e7d2      	b.n	8007914 <etharp_query+0xfc>
        copy_needed = 1;
 800796e:	2301      	movs	r3, #1
 8007970:	e7eb      	b.n	800794a <etharp_query+0x132>
      pbuf_ref(p);
 8007972:	4648      	mov	r0, r9
 8007974:	f7fe ff64 	bl	8006840 <pbuf_ref>
      p = q;
 8007978:	464c      	mov	r4, r9
    if (p != NULL) {
 800797a:	b1d4      	cbz	r4, 80079b2 <etharp_query+0x19a>
      if (arp_table[i].q != NULL) {
 800797c:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 8007980:	00d3      	lsls	r3, r2, #3
 8007982:	4a0d      	ldr	r2, [pc, #52]	; (80079b8 <etharp_query+0x1a0>)
 8007984:	58d0      	ldr	r0, [r2, r3]
 8007986:	b108      	cbz	r0, 800798c <etharp_query+0x174>
        pbuf_free(arp_table[i].q);
 8007988:	f7fe fd88 	bl	800649c <pbuf_free>
      arp_table[i].q = p;
 800798c:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8007990:	00f3      	lsls	r3, r6, #3
 8007992:	4a09      	ldr	r2, [pc, #36]	; (80079b8 <etharp_query+0x1a0>)
 8007994:	50d4      	str	r4, [r2, r3]
      result = ERR_OK;
 8007996:	2400      	movs	r4, #0
 8007998:	e7bc      	b.n	8007914 <etharp_query+0xfc>
    return ERR_ARG;
 800799a:	f06f 040f 	mvn.w	r4, #15
 800799e:	e7b9      	b.n	8007914 <etharp_query+0xfc>
 80079a0:	f06f 040f 	mvn.w	r4, #15
 80079a4:	e7b6      	b.n	8007914 <etharp_query+0xfc>
 80079a6:	f06f 040f 	mvn.w	r4, #15
 80079aa:	e7b3      	b.n	8007914 <etharp_query+0xfc>
 80079ac:	f06f 040f 	mvn.w	r4, #15
 80079b0:	e7b0      	b.n	8007914 <etharp_query+0xfc>
      result = ERR_MEM;
 80079b2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80079b6:	e7ad      	b.n	8007914 <etharp_query+0xfc>
 80079b8:	200032ec 	.word	0x200032ec
 80079bc:	080112f4 	.word	0x080112f4
 80079c0:	080114a4 	.word	0x080114a4
 80079c4:	080109f4 	.word	0x080109f4
 80079c8:	080114cc 	.word	0x080114cc
 80079cc:	080114d8 	.word	0x080114d8

080079d0 <etharp_output>:
{
 80079d0:	b570      	push	{r4, r5, r6, lr}
 80079d2:	b084      	sub	sp, #16
 80079d4:	460e      	mov	r6, r1
 80079d6:	4614      	mov	r4, r2
  LWIP_ASSERT("netif != NULL", netif != NULL);
 80079d8:	4605      	mov	r5, r0
 80079da:	2800      	cmp	r0, #0
 80079dc:	d02f      	beq.n	8007a3e <etharp_output+0x6e>
  LWIP_ASSERT("q != NULL", q != NULL);
 80079de:	2e00      	cmp	r6, #0
 80079e0:	d035      	beq.n	8007a4e <etharp_output+0x7e>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 80079e2:	2c00      	cmp	r4, #0
 80079e4:	d03b      	beq.n	8007a5e <etharp_output+0x8e>
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 80079e6:	4629      	mov	r1, r5
 80079e8:	6820      	ldr	r0, [r4, #0]
 80079ea:	f000 fdf7 	bl	80085dc <ip4_addr_isbroadcast_u32>
 80079ee:	2800      	cmp	r0, #0
 80079f0:	d17b      	bne.n	8007aea <etharp_output+0x11a>
  } else if (ip4_addr_ismulticast(ipaddr)) {
 80079f2:	6823      	ldr	r3, [r4, #0]
 80079f4:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80079f8:	2ae0      	cmp	r2, #224	; 0xe0
 80079fa:	d038      	beq.n	8007a6e <etharp_output+0x9e>
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 80079fc:	686a      	ldr	r2, [r5, #4]
 80079fe:	68a9      	ldr	r1, [r5, #8]
 8007a00:	405a      	eors	r2, r3
 8007a02:	420a      	tst	r2, r1
 8007a04:	d009      	beq.n	8007a1a <etharp_output+0x4a>
        !ip4_addr_islinklocal(ipaddr)) {
 8007a06:	b29b      	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 8007a08:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 8007a0c:	4293      	cmp	r3, r2
 8007a0e:	d004      	beq.n	8007a1a <etharp_output+0x4a>
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 8007a10:	68eb      	ldr	r3, [r5, #12]
 8007a12:	2b00      	cmp	r3, #0
 8007a14:	d075      	beq.n	8007b02 <etharp_output+0x132>
            dst_addr = netif_ip4_gw(netif);
 8007a16:	f105 040c 	add.w	r4, r5, #12
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8007a1a:	4b3b      	ldr	r3, [pc, #236]	; (8007b08 <etharp_output+0x138>)
 8007a1c:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
 8007a20:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 8007a24:	00c1      	lsls	r1, r0, #3
 8007a26:	440b      	add	r3, r1
 8007a28:	7d1b      	ldrb	r3, [r3, #20]
 8007a2a:	2b01      	cmp	r3, #1
 8007a2c:	d955      	bls.n	8007ada <etharp_output+0x10a>
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 8007a2e:	6820      	ldr	r0, [r4, #0]
 8007a30:	4b35      	ldr	r3, [pc, #212]	; (8007b08 <etharp_output+0x138>)
 8007a32:	440b      	add	r3, r1
 8007a34:	685b      	ldr	r3, [r3, #4]
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8007a36:	4298      	cmp	r0, r3
 8007a38:	d02f      	beq.n	8007a9a <etharp_output+0xca>
 8007a3a:	2200      	movs	r2, #0
 8007a3c:	e034      	b.n	8007aa8 <etharp_output+0xd8>
  LWIP_ASSERT("netif != NULL", netif != NULL);
 8007a3e:	4b33      	ldr	r3, [pc, #204]	; (8007b0c <etharp_output+0x13c>)
 8007a40:	f240 321b 	movw	r2, #795	; 0x31b
 8007a44:	4932      	ldr	r1, [pc, #200]	; (8007b10 <etharp_output+0x140>)
 8007a46:	4833      	ldr	r0, [pc, #204]	; (8007b14 <etharp_output+0x144>)
 8007a48:	f007 fd30 	bl	800f4ac <iprintf>
 8007a4c:	e7c7      	b.n	80079de <etharp_output+0xe>
  LWIP_ASSERT("q != NULL", q != NULL);
 8007a4e:	4b2f      	ldr	r3, [pc, #188]	; (8007b0c <etharp_output+0x13c>)
 8007a50:	f44f 7247 	mov.w	r2, #796	; 0x31c
 8007a54:	4930      	ldr	r1, [pc, #192]	; (8007b18 <etharp_output+0x148>)
 8007a56:	482f      	ldr	r0, [pc, #188]	; (8007b14 <etharp_output+0x144>)
 8007a58:	f007 fd28 	bl	800f4ac <iprintf>
 8007a5c:	e7c1      	b.n	80079e2 <etharp_output+0x12>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 8007a5e:	4b2b      	ldr	r3, [pc, #172]	; (8007b0c <etharp_output+0x13c>)
 8007a60:	f240 321d 	movw	r2, #797	; 0x31d
 8007a64:	492d      	ldr	r1, [pc, #180]	; (8007b1c <etharp_output+0x14c>)
 8007a66:	482b      	ldr	r0, [pc, #172]	; (8007b14 <etharp_output+0x144>)
 8007a68:	f007 fd20 	bl	800f4ac <iprintf>
 8007a6c:	e7bb      	b.n	80079e6 <etharp_output+0x16>
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 8007a6e:	2301      	movs	r3, #1
 8007a70:	f88d 3008 	strb.w	r3, [sp, #8]
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 8007a74:	2300      	movs	r3, #0
 8007a76:	f88d 3009 	strb.w	r3, [sp, #9]
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 8007a7a:	235e      	movs	r3, #94	; 0x5e
 8007a7c:	f88d 300a 	strb.w	r3, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8007a80:	7863      	ldrb	r3, [r4, #1]
 8007a82:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007a86:	f88d 300b 	strb.w	r3, [sp, #11]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 8007a8a:	78a3      	ldrb	r3, [r4, #2]
 8007a8c:	f88d 300c 	strb.w	r3, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8007a90:	78e3      	ldrb	r3, [r4, #3]
 8007a92:	f88d 300d 	strb.w	r3, [sp, #13]
    dest = &mcastaddr;
 8007a96:	ab02      	add	r3, sp, #8
 8007a98:	e028      	b.n	8007aec <etharp_output+0x11c>
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8007a9a:	4631      	mov	r1, r6
 8007a9c:	4628      	mov	r0, r5
 8007a9e:	f7ff fe51 	bl	8007744 <etharp_output_to_arp_index>
 8007aa2:	e02c      	b.n	8007afe <etharp_output+0x12e>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8007aa4:	3201      	adds	r2, #1
 8007aa6:	b252      	sxtb	r2, r2
 8007aa8:	2a09      	cmp	r2, #9
 8007aaa:	dc18      	bgt.n	8007ade <etharp_output+0x10e>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8007aac:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8007ab0:	00d9      	lsls	r1, r3, #3
 8007ab2:	4b15      	ldr	r3, [pc, #84]	; (8007b08 <etharp_output+0x138>)
 8007ab4:	440b      	add	r3, r1
 8007ab6:	7d1b      	ldrb	r3, [r3, #20]
 8007ab8:	2b01      	cmp	r3, #1
 8007aba:	d9f3      	bls.n	8007aa4 <etharp_output+0xd4>
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 8007abc:	6820      	ldr	r0, [r4, #0]
 8007abe:	4b12      	ldr	r3, [pc, #72]	; (8007b08 <etharp_output+0x138>)
 8007ac0:	440b      	add	r3, r1
 8007ac2:	685b      	ldr	r3, [r3, #4]
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8007ac4:	4298      	cmp	r0, r3
 8007ac6:	d1ed      	bne.n	8007aa4 <etharp_output+0xd4>
        ETHARP_SET_HINT(netif, i);
 8007ac8:	b2d2      	uxtb	r2, r2
 8007aca:	4b0f      	ldr	r3, [pc, #60]	; (8007b08 <etharp_output+0x138>)
 8007acc:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
        return etharp_output_to_arp_index(netif, q, i);
 8007ad0:	4631      	mov	r1, r6
 8007ad2:	4628      	mov	r0, r5
 8007ad4:	f7ff fe36 	bl	8007744 <etharp_output_to_arp_index>
 8007ad8:	e011      	b.n	8007afe <etharp_output+0x12e>
 8007ada:	2200      	movs	r2, #0
 8007adc:	e7e4      	b.n	8007aa8 <etharp_output+0xd8>
    return etharp_query(netif, dst_addr, q);
 8007ade:	4632      	mov	r2, r6
 8007ae0:	4621      	mov	r1, r4
 8007ae2:	4628      	mov	r0, r5
 8007ae4:	f7ff fe98 	bl	8007818 <etharp_query>
 8007ae8:	e009      	b.n	8007afe <etharp_output+0x12e>
    dest = (const struct eth_addr *)&ethbroadcast;
 8007aea:	4b0d      	ldr	r3, [pc, #52]	; (8007b20 <etharp_output+0x150>)
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), dest, ETHTYPE_IP);
 8007aec:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8007af0:	9200      	str	r2, [sp, #0]
 8007af2:	f105 0229 	add.w	r2, r5, #41	; 0x29
 8007af6:	4631      	mov	r1, r6
 8007af8:	4628      	mov	r0, r5
 8007afa:	f001 f9d3 	bl	8008ea4 <ethernet_output>
}
 8007afe:	b004      	add	sp, #16
 8007b00:	bd70      	pop	{r4, r5, r6, pc}
            return ERR_RTE;
 8007b02:	f06f 0003 	mvn.w	r0, #3
 8007b06:	e7fa      	b.n	8007afe <etharp_output+0x12e>
 8007b08:	200032ec 	.word	0x200032ec
 8007b0c:	080112f4 	.word	0x080112f4
 8007b10:	080113a8 	.word	0x080113a8
 8007b14:	080109f4 	.word	0x080109f4
 8007b18:	080114cc 	.word	0x080114cc
 8007b1c:	08011454 	.word	0x08011454
 8007b20:	080108d0 	.word	0x080108d0

08007b24 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8007b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007b28:	b086      	sub	sp, #24
 8007b2a:	4606      	mov	r6, r0
 8007b2c:	4688      	mov	r8, r1
 8007b2e:	4617      	mov	r7, r2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8007b30:	2200      	movs	r2, #0
 8007b32:	2124      	movs	r1, #36	; 0x24
 8007b34:	2001      	movs	r0, #1
 8007b36:	f7fe fd1b 	bl	8006570 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 8007b3a:	2800      	cmp	r0, #0
 8007b3c:	d037      	beq.n	8007bae <icmp_send_response+0x8a>
 8007b3e:	4605      	mov	r5, r0
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 8007b40:	8943      	ldrh	r3, [r0, #10]
 8007b42:	2b23      	cmp	r3, #35	; 0x23
 8007b44:	d936      	bls.n	8007bb4 <icmp_send_response+0x90>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 8007b46:	f8d6 c004 	ldr.w	ip, [r6, #4]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8007b4a:	686c      	ldr	r4, [r5, #4]
  icmphdr->type = type;
 8007b4c:	f884 8000 	strb.w	r8, [r4]
  icmphdr->code = code;
 8007b50:	7067      	strb	r7, [r4, #1]
  icmphdr->id = 0;
 8007b52:	2300      	movs	r3, #0
 8007b54:	7123      	strb	r3, [r4, #4]
 8007b56:	7163      	strb	r3, [r4, #5]
  icmphdr->seqno = 0;
 8007b58:	71a3      	strb	r3, [r4, #6]
 8007b5a:	71e3      	strb	r3, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8007b5c:	686f      	ldr	r7, [r5, #4]
 8007b5e:	6873      	ldr	r3, [r6, #4]
 8007b60:	681e      	ldr	r6, [r3, #0]
 8007b62:	6858      	ldr	r0, [r3, #4]
 8007b64:	6899      	ldr	r1, [r3, #8]
 8007b66:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 8007b6a:	60be      	str	r6, [r7, #8]
 8007b6c:	60f8      	str	r0, [r7, #12]
 8007b6e:	6139      	str	r1, [r7, #16]
 8007b70:	f8c7 e014 	str.w	lr, [r7, #20]
 8007b74:	691e      	ldr	r6, [r3, #16]
 8007b76:	6958      	ldr	r0, [r3, #20]
 8007b78:	6999      	ldr	r1, [r3, #24]
 8007b7a:	61be      	str	r6, [r7, #24]
 8007b7c:	61f8      	str	r0, [r7, #28]
 8007b7e:	6239      	str	r1, [r7, #32]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 8007b80:	f8dc 300c 	ldr.w	r3, [ip, #12]
 8007b84:	a806      	add	r0, sp, #24
 8007b86:	f840 3d04 	str.w	r3, [r0, #-4]!
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_src, &iphdr_dst);
  }
#else
  netif = ip4_route(&iphdr_src);
 8007b8a:	f000 fb1d 	bl	80081c8 <ip4_route>
#endif
  if (netif != NULL) {
 8007b8e:	b158      	cbz	r0, 8007ba8 <icmp_send_response+0x84>
    /* calculate checksum */
    icmphdr->chksum = 0;
 8007b90:	2100      	movs	r1, #0
 8007b92:	70a1      	strb	r1, [r4, #2]
 8007b94:	70e1      	strb	r1, [r4, #3]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8007b96:	9002      	str	r0, [sp, #8]
 8007b98:	2301      	movs	r3, #1
 8007b9a:	9301      	str	r3, [sp, #4]
 8007b9c:	9100      	str	r1, [sp, #0]
 8007b9e:	23ff      	movs	r3, #255	; 0xff
 8007ba0:	aa05      	add	r2, sp, #20
 8007ba2:	4628      	mov	r0, r5
 8007ba4:	f000 fcf8 	bl	8008598 <ip4_output_if>
  }
  pbuf_free(q);
 8007ba8:	4628      	mov	r0, r5
 8007baa:	f7fe fc77 	bl	800649c <pbuf_free>
}
 8007bae:	b006      	add	sp, #24
 8007bb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 8007bb4:	4b03      	ldr	r3, [pc, #12]	; (8007bc4 <icmp_send_response+0xa0>)
 8007bb6:	f44f 72b1 	mov.w	r2, #354	; 0x162
 8007bba:	4903      	ldr	r1, [pc, #12]	; (8007bc8 <icmp_send_response+0xa4>)
 8007bbc:	4803      	ldr	r0, [pc, #12]	; (8007bcc <icmp_send_response+0xa8>)
 8007bbe:	f007 fc75 	bl	800f4ac <iprintf>
 8007bc2:	e7c0      	b.n	8007b46 <icmp_send_response+0x22>
 8007bc4:	080114f4 	.word	0x080114f4
 8007bc8:	0801152c 	.word	0x0801152c
 8007bcc:	080109f4 	.word	0x080109f4

08007bd0 <icmp_input>:
{
 8007bd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007bd4:	b084      	sub	sp, #16
 8007bd6:	4605      	mov	r5, r0
  iphdr_in = ip4_current_header();
 8007bd8:	4b47      	ldr	r3, [pc, #284]	; (8007cf8 <icmp_input+0x128>)
 8007bda:	689e      	ldr	r6, [r3, #8]
  hlen = IPH_HL(iphdr_in) * 4;
 8007bdc:	7834      	ldrb	r4, [r6, #0]
 8007bde:	f004 040f 	and.w	r4, r4, #15
 8007be2:	00a4      	lsls	r4, r4, #2
  if (hlen < IP_HLEN) {
 8007be4:	2c13      	cmp	r4, #19
 8007be6:	d915      	bls.n	8007c14 <icmp_input+0x44>
 8007be8:	460f      	mov	r7, r1
  if (p->len < sizeof(u16_t)*2) {
 8007bea:	8943      	ldrh	r3, [r0, #10]
 8007bec:	2b03      	cmp	r3, #3
 8007bee:	d911      	bls.n	8007c14 <icmp_input+0x44>
  type = *((u8_t *)p->payload);
 8007bf0:	6843      	ldr	r3, [r0, #4]
 8007bf2:	781b      	ldrb	r3, [r3, #0]
  switch (type) {
 8007bf4:	2b08      	cmp	r3, #8
 8007bf6:	d15d      	bne.n	8007cb4 <icmp_input+0xe4>
    if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8007bf8:	4b3f      	ldr	r3, [pc, #252]	; (8007cf8 <icmp_input+0x128>)
 8007bfa:	6958      	ldr	r0, [r3, #20]
 8007bfc:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 8007c00:	2be0      	cmp	r3, #224	; 0xe0
 8007c02:	d023      	beq.n	8007c4c <icmp_input+0x7c>
    if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 8007c04:	4b3c      	ldr	r3, [pc, #240]	; (8007cf8 <icmp_input+0x128>)
 8007c06:	6819      	ldr	r1, [r3, #0]
 8007c08:	f000 fce8 	bl	80085dc <ip4_addr_isbroadcast_u32>
 8007c0c:	b9f0      	cbnz	r0, 8007c4c <icmp_input+0x7c>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8007c0e:	892b      	ldrh	r3, [r5, #8]
 8007c10:	2b07      	cmp	r3, #7
 8007c12:	d805      	bhi.n	8007c20 <icmp_input+0x50>
  pbuf_free(p);
 8007c14:	4628      	mov	r0, r5
 8007c16:	f7fe fc41 	bl	800649c <pbuf_free>
}
 8007c1a:	b004      	add	sp, #16
 8007c1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pbuf_header(p, (s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 8007c20:	f104 010e 	add.w	r1, r4, #14
 8007c24:	4628      	mov	r0, r5
 8007c26:	f7fe fc2f 	bl	8006488 <pbuf_header>
 8007c2a:	b3a8      	cbz	r0, 8007c98 <icmp_input+0xc8>
      r = pbuf_alloc(PBUF_LINK, p->tot_len + hlen, PBUF_RAM);
 8007c2c:	8929      	ldrh	r1, [r5, #8]
 8007c2e:	4421      	add	r1, r4
 8007c30:	2200      	movs	r2, #0
 8007c32:	b289      	uxth	r1, r1
 8007c34:	2002      	movs	r0, #2
 8007c36:	f7fe fc9b 	bl	8006570 <pbuf_alloc>
      if (r == NULL) {
 8007c3a:	4680      	mov	r8, r0
 8007c3c:	b130      	cbz	r0, 8007c4c <icmp_input+0x7c>
      if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 8007c3e:	8942      	ldrh	r2, [r0, #10]
 8007c40:	f104 0308 	add.w	r3, r4, #8
 8007c44:	429a      	cmp	r2, r3
 8007c46:	d205      	bcs.n	8007c54 <icmp_input+0x84>
        pbuf_free(r);
 8007c48:	f7fe fc28 	bl	800649c <pbuf_free>
  pbuf_free(p);
 8007c4c:	4628      	mov	r0, r5
 8007c4e:	f7fe fc25 	bl	800649c <pbuf_free>
  return;
 8007c52:	e7e2      	b.n	8007c1a <icmp_input+0x4a>
      MEMCPY(r->payload, iphdr_in, hlen);
 8007c54:	4622      	mov	r2, r4
 8007c56:	4631      	mov	r1, r6
 8007c58:	6840      	ldr	r0, [r0, #4]
 8007c5a:	f007 fc14 	bl	800f486 <memcpy>
      if (pbuf_header(r, (s16_t)-hlen)) {
 8007c5e:	4261      	negs	r1, r4
 8007c60:	4640      	mov	r0, r8
 8007c62:	f7fe fc11 	bl	8006488 <pbuf_header>
 8007c66:	b148      	cbz	r0, 8007c7c <icmp_input+0xac>
        LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 8007c68:	4b24      	ldr	r3, [pc, #144]	; (8007cfc <icmp_input+0x12c>)
 8007c6a:	22af      	movs	r2, #175	; 0xaf
 8007c6c:	4924      	ldr	r1, [pc, #144]	; (8007d00 <icmp_input+0x130>)
 8007c6e:	4825      	ldr	r0, [pc, #148]	; (8007d04 <icmp_input+0x134>)
 8007c70:	f007 fc1c 	bl	800f4ac <iprintf>
        pbuf_free(r);
 8007c74:	4640      	mov	r0, r8
 8007c76:	f7fe fc11 	bl	800649c <pbuf_free>
        goto icmperr;
 8007c7a:	e7e7      	b.n	8007c4c <icmp_input+0x7c>
      if (pbuf_copy(r, p) != ERR_OK) {
 8007c7c:	4629      	mov	r1, r5
 8007c7e:	4640      	mov	r0, r8
 8007c80:	f7fe fe42 	bl	8006908 <pbuf_copy>
 8007c84:	b118      	cbz	r0, 8007c8e <icmp_input+0xbe>
        pbuf_free(r);
 8007c86:	4640      	mov	r0, r8
 8007c88:	f7fe fc08 	bl	800649c <pbuf_free>
        goto icmperr;
 8007c8c:	e7de      	b.n	8007c4c <icmp_input+0x7c>
      pbuf_free(p);
 8007c8e:	4628      	mov	r0, r5
 8007c90:	f7fe fc04 	bl	800649c <pbuf_free>
      p = r;
 8007c94:	4645      	mov	r5, r8
 8007c96:	e007      	b.n	8007ca8 <icmp_input+0xd8>
      if (pbuf_header(p, -(s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 8007c98:	f64f 71f2 	movw	r1, #65522	; 0xfff2
 8007c9c:	1b09      	subs	r1, r1, r4
 8007c9e:	b209      	sxth	r1, r1
 8007ca0:	4628      	mov	r0, r5
 8007ca2:	f7fe fbf1 	bl	8006488 <pbuf_header>
 8007ca6:	b948      	cbnz	r0, 8007cbc <icmp_input+0xec>
    iecho = (struct icmp_echo_hdr *)p->payload;
 8007ca8:	686e      	ldr	r6, [r5, #4]
    if (pbuf_header(p, (s16_t)hlen)) {
 8007caa:	4621      	mov	r1, r4
 8007cac:	4628      	mov	r0, r5
 8007cae:	f7fe fbeb 	bl	8006488 <pbuf_header>
 8007cb2:	b150      	cbz	r0, 8007cca <icmp_input+0xfa>
  pbuf_free(p);
 8007cb4:	4628      	mov	r0, r5
 8007cb6:	f7fe fbf1 	bl	800649c <pbuf_free>
  return;
 8007cba:	e7ae      	b.n	8007c1a <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 8007cbc:	4b0f      	ldr	r3, [pc, #60]	; (8007cfc <icmp_input+0x12c>)
 8007cbe:	22c0      	movs	r2, #192	; 0xc0
 8007cc0:	4911      	ldr	r1, [pc, #68]	; (8007d08 <icmp_input+0x138>)
 8007cc2:	4810      	ldr	r0, [pc, #64]	; (8007d04 <icmp_input+0x134>)
 8007cc4:	f007 fbf2 	bl	800f4ac <iprintf>
        goto icmperr;
 8007cc8:	e7c0      	b.n	8007c4c <icmp_input+0x7c>
      struct ip_hdr *iphdr = (struct ip_hdr*)p->payload;
 8007cca:	6868      	ldr	r0, [r5, #4]
      ip4_addr_copy(iphdr->src, *src);
 8007ccc:	490a      	ldr	r1, [pc, #40]	; (8007cf8 <icmp_input+0x128>)
 8007cce:	694b      	ldr	r3, [r1, #20]
 8007cd0:	60c3      	str	r3, [r0, #12]
      ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8007cd2:	690b      	ldr	r3, [r1, #16]
 8007cd4:	6103      	str	r3, [r0, #16]
      ICMPH_TYPE_SET(iecho, ICMP_ER);
 8007cd6:	2200      	movs	r2, #0
 8007cd8:	7032      	strb	r2, [r6, #0]
      iecho->chksum = 0;
 8007cda:	70b2      	strb	r2, [r6, #2]
 8007cdc:	70f2      	strb	r2, [r6, #3]
      IPH_TTL_SET(iphdr, ICMP_TTL);
 8007cde:	23ff      	movs	r3, #255	; 0xff
 8007ce0:	7203      	strb	r3, [r0, #8]
      IPH_CHKSUM_SET(iphdr, 0);
 8007ce2:	7282      	strb	r2, [r0, #10]
 8007ce4:	72c2      	strb	r2, [r0, #11]
      ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 8007ce6:	9702      	str	r7, [sp, #8]
 8007ce8:	2001      	movs	r0, #1
 8007cea:	9001      	str	r0, [sp, #4]
 8007cec:	9200      	str	r2, [sp, #0]
 8007cee:	3114      	adds	r1, #20
 8007cf0:	4628      	mov	r0, r5
 8007cf2:	f000 fc51 	bl	8008598 <ip4_output_if>
 8007cf6:	e7dd      	b.n	8007cb4 <icmp_input+0xe4>
 8007cf8:	20005a30 	.word	0x20005a30
 8007cfc:	080114f4 	.word	0x080114f4
 8007d00:	08011558 	.word	0x08011558
 8007d04:	080109f4 	.word	0x080109f4
 8007d08:	08011590 	.word	0x08011590

08007d0c <icmp_dest_unreach>:
{
 8007d0c:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_DUR, t);
 8007d0e:	460a      	mov	r2, r1
 8007d10:	2103      	movs	r1, #3
 8007d12:	f7ff ff07 	bl	8007b24 <icmp_send_response>
}
 8007d16:	bd08      	pop	{r3, pc}

08007d18 <icmp_time_exceeded>:
{
 8007d18:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_TE, t);
 8007d1a:	460a      	mov	r2, r1
 8007d1c:	210b      	movs	r1, #11
 8007d1e:	f7ff ff01 	bl	8007b24 <icmp_send_response>
}
 8007d22:	bd08      	pop	{r3, pc}

08007d24 <igmp_start_timer>:
 * @param max_time the time in multiples of IGMP_TMR_INTERVAL (decrease with
 *        every call to igmp_tmr())
 */
static void
igmp_start_timer(struct igmp_group *group, u8_t max_time)
{
 8007d24:	b538      	push	{r3, r4, r5, lr}
 8007d26:	4605      	mov	r5, r0
#ifdef LWIP_RAND
  group->timer = max_time > 2 ? (LWIP_RAND() % max_time) : 1;
 8007d28:	2902      	cmp	r1, #2
 8007d2a:	d805      	bhi.n	8007d38 <igmp_start_timer+0x14>
 8007d2c:	2001      	movs	r0, #1
 8007d2e:	8168      	strh	r0, [r5, #10]
#else /* LWIP_RAND */
  /* ATTENTION: use this only if absolutely necessary! */
  group->timer = max_time / 2;
#endif /* LWIP_RAND */

  if (group->timer == 0) {
 8007d30:	b908      	cbnz	r0, 8007d36 <igmp_start_timer+0x12>
    group->timer = 1;
 8007d32:	2301      	movs	r3, #1
 8007d34:	816b      	strh	r3, [r5, #10]
  }
}
 8007d36:	bd38      	pop	{r3, r4, r5, pc}
 8007d38:	460c      	mov	r4, r1
  group->timer = max_time > 2 ? (LWIP_RAND() % max_time) : 1;
 8007d3a:	f007 fbcf 	bl	800f4dc <rand>
 8007d3e:	fbb0 f3f4 	udiv	r3, r0, r4
 8007d42:	fb04 0013 	mls	r0, r4, r3, r0
 8007d46:	b280      	uxth	r0, r0
 8007d48:	e7f1      	b.n	8007d2e <igmp_start_timer+0xa>

08007d4a <igmp_delaying_member>:
 * @param maxresp query delay
 */
static void
igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
{
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
 8007d4a:	7a43      	ldrb	r3, [r0, #9]
 8007d4c:	2b02      	cmp	r3, #2
 8007d4e:	d007      	beq.n	8007d60 <igmp_delaying_member+0x16>
 8007d50:	2b01      	cmp	r3, #1
 8007d52:	d000      	beq.n	8007d56 <igmp_delaying_member+0xc>
 8007d54:	4770      	bx	lr
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
      ((group->timer == 0) || (maxresp < group->timer)))) {
 8007d56:	8943      	ldrh	r3, [r0, #10]
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 8007d58:	b113      	cbz	r3, 8007d60 <igmp_delaying_member+0x16>
      ((group->timer == 0) || (maxresp < group->timer)))) {
 8007d5a:	b28a      	uxth	r2, r1
 8007d5c:	4293      	cmp	r3, r2
 8007d5e:	d9f9      	bls.n	8007d54 <igmp_delaying_member+0xa>
{
 8007d60:	b510      	push	{r4, lr}
 8007d62:	4604      	mov	r4, r0
    igmp_start_timer(group, maxresp);
 8007d64:	f7ff ffde 	bl	8007d24 <igmp_start_timer>
    group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 8007d68:	2301      	movs	r3, #1
 8007d6a:	7263      	strb	r3, [r4, #9]
  }
}
 8007d6c:	bd10      	pop	{r4, pc}

08007d6e <igmp_ip_output_if>:
 *         ERR_BUF if p doesn't have enough space for IP/LINK headers
 *         returns errors returned by netif->output
 */
static err_t
igmp_ip_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest, struct netif *netif)
{
 8007d6e:	b530      	push	{r4, r5, lr}
 8007d70:	b089      	sub	sp, #36	; 0x24
  /* This is the "router alert" option */
  u16_t ra[2];
  ra[0] = PP_HTONS(ROUTER_ALERT);
 8007d72:	f240 4494 	movw	r4, #1172	; 0x494
 8007d76:	f8ad 401c 	strh.w	r4, [sp, #28]
  ra[1] = 0x0000; /* Router shall examine packet */
 8007d7a:	2400      	movs	r4, #0
 8007d7c:	f8ad 401e 	strh.w	r4, [sp, #30]
  IGMP_STATS_INC(igmp.xmit);
  return ip4_output_if_opt(p, src, dest, IGMP_TTL, 0, IP_PROTO_IGMP, netif, ra, ROUTER_ALERTLEN);
 8007d80:	2504      	movs	r5, #4
 8007d82:	9504      	str	r5, [sp, #16]
 8007d84:	ad07      	add	r5, sp, #28
 8007d86:	9503      	str	r5, [sp, #12]
 8007d88:	9302      	str	r3, [sp, #8]
 8007d8a:	2302      	movs	r3, #2
 8007d8c:	9301      	str	r3, [sp, #4]
 8007d8e:	9400      	str	r4, [sp, #0]
 8007d90:	2301      	movs	r3, #1
 8007d92:	f000 fbe7 	bl	8008564 <ip4_output_if_opt>
}
 8007d96:	b009      	add	sp, #36	; 0x24
 8007d98:	bd30      	pop	{r4, r5, pc}
	...

08007d9c <igmp_send>:
 * @param group the group to which to send the packet
 * @param type the type of igmp packet to send
 */
static void
igmp_send(struct netif *netif, struct igmp_group *group, u8_t type)
{
 8007d9c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007da0:	b083      	sub	sp, #12
 8007da2:	4607      	mov	r7, r0
 8007da4:	4688      	mov	r8, r1
 8007da6:	4615      	mov	r5, r2
  struct pbuf*     p    = NULL;
  struct igmp_msg* igmp = NULL;
  ip4_addr_t   src  = *IP4_ADDR_ANY4;
 8007da8:	4b24      	ldr	r3, [pc, #144]	; (8007e3c <igmp_send+0xa0>)
 8007daa:	681b      	ldr	r3, [r3, #0]
 8007dac:	9301      	str	r3, [sp, #4]
  ip4_addr_t*  dest = NULL;

  /* IP header + "router alert" option + IGMP header */
  p = pbuf_alloc(PBUF_TRANSPORT, IGMP_MINLEN, PBUF_RAM);
 8007dae:	2200      	movs	r2, #0
 8007db0:	2108      	movs	r1, #8
 8007db2:	4610      	mov	r0, r2
 8007db4:	f7fe fbdc 	bl	8006570 <pbuf_alloc>

  if (p) {
 8007db8:	b1a0      	cbz	r0, 8007de4 <igmp_send+0x48>
 8007dba:	4604      	mov	r4, r0
    igmp = (struct igmp_msg *)p->payload;
 8007dbc:	6846      	ldr	r6, [r0, #4]
    LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
 8007dbe:	8943      	ldrh	r3, [r0, #10]
 8007dc0:	2b07      	cmp	r3, #7
 8007dc2:	d912      	bls.n	8007dea <igmp_send+0x4e>
               (p->len >= sizeof(struct igmp_msg)));
    ip4_addr_copy(src, *netif_ip4_addr(netif));
 8007dc4:	687b      	ldr	r3, [r7, #4]
 8007dc6:	9301      	str	r3, [sp, #4]

    if (type == IGMP_V2_MEMB_REPORT) {
 8007dc8:	2d16      	cmp	r5, #22
 8007dca:	d016      	beq.n	8007dfa <igmp_send+0x5e>
      dest = &(group->group_address);
      ip4_addr_copy(igmp->igmp_group_address, group->group_address);
      group->last_reporter_flag = 1; /* Remember we were the last to report */
    } else {
      if (type == IGMP_LEAVE_GROUP) {
 8007dcc:	2d17      	cmp	r5, #23
 8007dce:	d01d      	beq.n	8007e0c <igmp_send+0x70>
  ip4_addr_t*  dest = NULL;
 8007dd0:	f04f 0900 	mov.w	r9, #0
        dest = &allrouters;
        ip4_addr_copy(igmp->igmp_group_address, group->group_address);
      }
    }

    if ((type == IGMP_V2_MEMB_REPORT) || (type == IGMP_LEAVE_GROUP)) {
 8007dd4:	f1a5 0316 	sub.w	r3, r5, #22
 8007dd8:	b2db      	uxtb	r3, r3
 8007dda:	2b01      	cmp	r3, #1
 8007ddc:	d91c      	bls.n	8007e18 <igmp_send+0x7c>
      igmp->igmp_checksum = inet_chksum(igmp, IGMP_MINLEN);

      igmp_ip_output_if(p, &src, dest, netif);
    }

    pbuf_free(p);
 8007dde:	4620      	mov	r0, r4
 8007de0:	f7fe fb5c 	bl	800649c <pbuf_free>
  } else {
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_send: not enough memory for igmp_send\n"));
    IGMP_STATS_INC(igmp.memerr);
  }
}
 8007de4:	b003      	add	sp, #12
 8007de6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
 8007dea:	4b15      	ldr	r3, [pc, #84]	; (8007e40 <igmp_send+0xa4>)
 8007dec:	f240 3202 	movw	r2, #770	; 0x302
 8007df0:	4914      	ldr	r1, [pc, #80]	; (8007e44 <igmp_send+0xa8>)
 8007df2:	4815      	ldr	r0, [pc, #84]	; (8007e48 <igmp_send+0xac>)
 8007df4:	f007 fb5a 	bl	800f4ac <iprintf>
 8007df8:	e7e4      	b.n	8007dc4 <igmp_send+0x28>
      dest = &(group->group_address);
 8007dfa:	f108 0904 	add.w	r9, r8, #4
      ip4_addr_copy(igmp->igmp_group_address, group->group_address);
 8007dfe:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8007e02:	6073      	str	r3, [r6, #4]
      group->last_reporter_flag = 1; /* Remember we were the last to report */
 8007e04:	2301      	movs	r3, #1
 8007e06:	f888 3008 	strb.w	r3, [r8, #8]
 8007e0a:	e7e3      	b.n	8007dd4 <igmp_send+0x38>
        ip4_addr_copy(igmp->igmp_group_address, group->group_address);
 8007e0c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8007e10:	6073      	str	r3, [r6, #4]
        dest = &allrouters;
 8007e12:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8007e4c <igmp_send+0xb0>
 8007e16:	e7dd      	b.n	8007dd4 <igmp_send+0x38>
      igmp->igmp_msgtype  = type;
 8007e18:	7035      	strb	r5, [r6, #0]
      igmp->igmp_maxresp  = 0;
 8007e1a:	2300      	movs	r3, #0
 8007e1c:	7073      	strb	r3, [r6, #1]
      igmp->igmp_checksum = 0;
 8007e1e:	70b3      	strb	r3, [r6, #2]
 8007e20:	70f3      	strb	r3, [r6, #3]
      igmp->igmp_checksum = inet_chksum(igmp, IGMP_MINLEN);
 8007e22:	2108      	movs	r1, #8
 8007e24:	4630      	mov	r0, r6
 8007e26:	f7fd feb8 	bl	8005b9a <inet_chksum>
 8007e2a:	8070      	strh	r0, [r6, #2]
      igmp_ip_output_if(p, &src, dest, netif);
 8007e2c:	463b      	mov	r3, r7
 8007e2e:	464a      	mov	r2, r9
 8007e30:	a901      	add	r1, sp, #4
 8007e32:	4620      	mov	r0, r4
 8007e34:	f7ff ff9b 	bl	8007d6e <igmp_ip_output_if>
 8007e38:	e7d1      	b.n	8007dde <igmp_send+0x42>
 8007e3a:	bf00      	nop
 8007e3c:	080108cc 	.word	0x080108cc
 8007e40:	080115c4 	.word	0x080115c4
 8007e44:	080115fc 	.word	0x080115fc
 8007e48:	080109f4 	.word	0x080109f4
 8007e4c:	200033e0 	.word	0x200033e0

08007e50 <igmp_timeout>:
{
 8007e50:	b508      	push	{r3, lr}
  if ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 8007e52:	7a4b      	ldrb	r3, [r1, #9]
 8007e54:	2b01      	cmp	r3, #1
 8007e56:	d000      	beq.n	8007e5a <igmp_timeout+0xa>
}
 8007e58:	bd08      	pop	{r3, pc}
      (!(ip4_addr_cmp(&(group->group_address), &allsystems)))) {
 8007e5a:	684a      	ldr	r2, [r1, #4]
 8007e5c:	4b04      	ldr	r3, [pc, #16]	; (8007e70 <igmp_timeout+0x20>)
 8007e5e:	685b      	ldr	r3, [r3, #4]
  if ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 8007e60:	429a      	cmp	r2, r3
 8007e62:	d0f9      	beq.n	8007e58 <igmp_timeout+0x8>
    group->group_state = IGMP_GROUP_IDLE_MEMBER;
 8007e64:	2302      	movs	r3, #2
 8007e66:	724b      	strb	r3, [r1, #9]
    igmp_send(netif, group, IGMP_V2_MEMB_REPORT);
 8007e68:	2216      	movs	r2, #22
 8007e6a:	f7ff ff97 	bl	8007d9c <igmp_send>
}
 8007e6e:	e7f3      	b.n	8007e58 <igmp_timeout+0x8>
 8007e70:	200033e0 	.word	0x200033e0

08007e74 <igmp_init>:
  IP4_ADDR(&allsystems, 224, 0, 0, 1);
 8007e74:	4b03      	ldr	r3, [pc, #12]	; (8007e84 <igmp_init+0x10>)
 8007e76:	4a04      	ldr	r2, [pc, #16]	; (8007e88 <igmp_init+0x14>)
 8007e78:	605a      	str	r2, [r3, #4]
  IP4_ADDR(&allrouters, 224, 0, 0, 2);
 8007e7a:	f102 7280 	add.w	r2, r2, #16777216	; 0x1000000
 8007e7e:	601a      	str	r2, [r3, #0]
}
 8007e80:	4770      	bx	lr
 8007e82:	bf00      	nop
 8007e84:	200033e0 	.word	0x200033e0
 8007e88:	010000e0 	.word	0x010000e0

08007e8c <igmp_report_groups>:
{
 8007e8c:	b510      	push	{r4, lr}
  struct igmp_group *group = netif_igmp_data(netif);
 8007e8e:	6a04      	ldr	r4, [r0, #32]
  if(group != NULL) {
 8007e90:	b134      	cbz	r4, 8007ea0 <igmp_report_groups+0x14>
    group = group->next;
 8007e92:	6824      	ldr	r4, [r4, #0]
 8007e94:	e004      	b.n	8007ea0 <igmp_report_groups+0x14>
    igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 8007e96:	2105      	movs	r1, #5
 8007e98:	4620      	mov	r0, r4
 8007e9a:	f7ff ff56 	bl	8007d4a <igmp_delaying_member>
    group = group->next;
 8007e9e:	6824      	ldr	r4, [r4, #0]
  while (group != NULL) {
 8007ea0:	2c00      	cmp	r4, #0
 8007ea2:	d1f8      	bne.n	8007e96 <igmp_report_groups+0xa>
}
 8007ea4:	bd10      	pop	{r4, pc}

08007ea6 <igmp_lookfor_group>:
  struct igmp_group *group = netif_igmp_data(ifp);
 8007ea6:	6a00      	ldr	r0, [r0, #32]
  while (group != NULL) {
 8007ea8:	b128      	cbz	r0, 8007eb6 <igmp_lookfor_group+0x10>
    if (ip4_addr_cmp(&(group->group_address), addr)) {
 8007eaa:	6842      	ldr	r2, [r0, #4]
 8007eac:	680b      	ldr	r3, [r1, #0]
 8007eae:	429a      	cmp	r2, r3
 8007eb0:	d001      	beq.n	8007eb6 <igmp_lookfor_group+0x10>
    group = group->next;
 8007eb2:	6800      	ldr	r0, [r0, #0]
 8007eb4:	e7f8      	b.n	8007ea8 <igmp_lookfor_group+0x2>
}
 8007eb6:	4770      	bx	lr

08007eb8 <igmp_lookup_group>:
{
 8007eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007eba:	4605      	mov	r5, r0
 8007ebc:	460e      	mov	r6, r1
  struct igmp_group *list_head = netif_igmp_data(ifp);
 8007ebe:	6a07      	ldr	r7, [r0, #32]
  group = igmp_lookfor_group(ifp, addr);
 8007ec0:	f7ff fff1 	bl	8007ea6 <igmp_lookfor_group>
  if (group != NULL) {
 8007ec4:	4604      	mov	r4, r0
 8007ec6:	b108      	cbz	r0, 8007ecc <igmp_lookup_group+0x14>
}
 8007ec8:	4620      	mov	r0, r4
 8007eca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  group = (struct igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
 8007ecc:	2007      	movs	r0, #7
 8007ece:	f7fe f915 	bl	80060fc <memp_malloc>
  if (group != NULL) {
 8007ed2:	4604      	mov	r4, r0
 8007ed4:	2800      	cmp	r0, #0
 8007ed6:	d0f7      	beq.n	8007ec8 <igmp_lookup_group+0x10>
    ip4_addr_set(&(group->group_address), addr);
 8007ed8:	b186      	cbz	r6, 8007efc <igmp_lookup_group+0x44>
 8007eda:	6833      	ldr	r3, [r6, #0]
 8007edc:	6063      	str	r3, [r4, #4]
    group->timer              = 0; /* Not running */
 8007ede:	2300      	movs	r3, #0
 8007ee0:	8163      	strh	r3, [r4, #10]
    group->group_state        = IGMP_GROUP_NON_MEMBER;
 8007ee2:	7263      	strb	r3, [r4, #9]
    group->last_reporter_flag = 0;
 8007ee4:	7223      	strb	r3, [r4, #8]
    group->use                = 0;
 8007ee6:	7323      	strb	r3, [r4, #12]
    if (list_head == NULL) {
 8007ee8:	b157      	cbz	r7, 8007f00 <igmp_lookup_group+0x48>
      LWIP_ASSERT("igmp_lookup_group: all except first group must not be allsystems",
 8007eea:	6832      	ldr	r2, [r6, #0]
 8007eec:	4b10      	ldr	r3, [pc, #64]	; (8007f30 <igmp_lookup_group+0x78>)
 8007eee:	685b      	ldr	r3, [r3, #4]
 8007ef0:	429a      	cmp	r2, r3
 8007ef2:	d015      	beq.n	8007f20 <igmp_lookup_group+0x68>
      group->next = list_head->next;
 8007ef4:	683b      	ldr	r3, [r7, #0]
 8007ef6:	6023      	str	r3, [r4, #0]
      list_head->next = group;
 8007ef8:	603c      	str	r4, [r7, #0]
 8007efa:	e7e5      	b.n	8007ec8 <igmp_lookup_group+0x10>
    ip4_addr_set(&(group->group_address), addr);
 8007efc:	2300      	movs	r3, #0
 8007efe:	e7ed      	b.n	8007edc <igmp_lookup_group+0x24>
      LWIP_ASSERT("igmp_lookup_group: first group must be allsystems",
 8007f00:	6832      	ldr	r2, [r6, #0]
 8007f02:	4b0b      	ldr	r3, [pc, #44]	; (8007f30 <igmp_lookup_group+0x78>)
 8007f04:	685b      	ldr	r3, [r3, #4]
 8007f06:	429a      	cmp	r2, r3
 8007f08:	d006      	beq.n	8007f18 <igmp_lookup_group+0x60>
 8007f0a:	4b0a      	ldr	r3, [pc, #40]	; (8007f34 <igmp_lookup_group+0x7c>)
 8007f0c:	f240 120d 	movw	r2, #269	; 0x10d
 8007f10:	4909      	ldr	r1, [pc, #36]	; (8007f38 <igmp_lookup_group+0x80>)
 8007f12:	480a      	ldr	r0, [pc, #40]	; (8007f3c <igmp_lookup_group+0x84>)
 8007f14:	f007 faca 	bl	800f4ac <iprintf>
      group->next = NULL;
 8007f18:	2300      	movs	r3, #0
 8007f1a:	6023      	str	r3, [r4, #0]
      netif_set_client_data(ifp, LWIP_NETIF_CLIENT_DATA_INDEX_IGMP, group);
 8007f1c:	622c      	str	r4, [r5, #32]
 8007f1e:	e7d3      	b.n	8007ec8 <igmp_lookup_group+0x10>
      LWIP_ASSERT("igmp_lookup_group: all except first group must not be allsystems",
 8007f20:	4b04      	ldr	r3, [pc, #16]	; (8007f34 <igmp_lookup_group+0x7c>)
 8007f22:	f240 1213 	movw	r2, #275	; 0x113
 8007f26:	4906      	ldr	r1, [pc, #24]	; (8007f40 <igmp_lookup_group+0x88>)
 8007f28:	4804      	ldr	r0, [pc, #16]	; (8007f3c <igmp_lookup_group+0x84>)
 8007f2a:	f007 fabf 	bl	800f4ac <iprintf>
 8007f2e:	e7e1      	b.n	8007ef4 <igmp_lookup_group+0x3c>
 8007f30:	200033e0 	.word	0x200033e0
 8007f34:	080115c4 	.word	0x080115c4
 8007f38:	08011638 	.word	0x08011638
 8007f3c:	080109f4 	.word	0x080109f4
 8007f40:	0801166c 	.word	0x0801166c

08007f44 <igmp_start>:
{
 8007f44:	b510      	push	{r4, lr}
 8007f46:	4604      	mov	r4, r0
  group = igmp_lookup_group(netif, &allsystems);
 8007f48:	490a      	ldr	r1, [pc, #40]	; (8007f74 <igmp_start+0x30>)
 8007f4a:	f7ff ffb5 	bl	8007eb8 <igmp_lookup_group>
  if (group != NULL) {
 8007f4e:	b160      	cbz	r0, 8007f6a <igmp_start+0x26>
    group->group_state = IGMP_GROUP_IDLE_MEMBER;
 8007f50:	2202      	movs	r2, #2
 8007f52:	7242      	strb	r2, [r0, #9]
    group->use++;
 8007f54:	7b02      	ldrb	r2, [r0, #12]
 8007f56:	3201      	adds	r2, #1
 8007f58:	7302      	strb	r2, [r0, #12]
    if (netif->igmp_mac_filter != NULL) {
 8007f5a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8007f5c:	b143      	cbz	r3, 8007f70 <igmp_start+0x2c>
      netif->igmp_mac_filter(netif, &allsystems, NETIF_ADD_MAC_FILTER);
 8007f5e:	2201      	movs	r2, #1
 8007f60:	4904      	ldr	r1, [pc, #16]	; (8007f74 <igmp_start+0x30>)
 8007f62:	4620      	mov	r0, r4
 8007f64:	4798      	blx	r3
    return ERR_OK;
 8007f66:	2000      	movs	r0, #0
}
 8007f68:	bd10      	pop	{r4, pc}
  return ERR_MEM;
 8007f6a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007f6e:	e7fb      	b.n	8007f68 <igmp_start+0x24>
    return ERR_OK;
 8007f70:	2000      	movs	r0, #0
 8007f72:	e7f9      	b.n	8007f68 <igmp_start+0x24>
 8007f74:	200033e4 	.word	0x200033e4

08007f78 <igmp_input>:
{
 8007f78:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007f7a:	b083      	sub	sp, #12
 8007f7c:	4604      	mov	r4, r0
 8007f7e:	460f      	mov	r7, r1
  if (p->len < IGMP_MINLEN) {
 8007f80:	8941      	ldrh	r1, [r0, #10]
 8007f82:	2907      	cmp	r1, #7
 8007f84:	d914      	bls.n	8007fb0 <igmp_input+0x38>
 8007f86:	4616      	mov	r6, r2
  igmp = (struct igmp_msg *)p->payload;
 8007f88:	6845      	ldr	r5, [r0, #4]
  if (inet_chksum(igmp, p->len)) {
 8007f8a:	4628      	mov	r0, r5
 8007f8c:	f7fd fe05 	bl	8005b9a <inet_chksum>
 8007f90:	b990      	cbnz	r0, 8007fb8 <igmp_input+0x40>
  group = igmp_lookfor_group(inp, dest); /* use the destination IP address of incoming packet */
 8007f92:	4631      	mov	r1, r6
 8007f94:	4638      	mov	r0, r7
 8007f96:	f7ff ff86 	bl	8007ea6 <igmp_lookfor_group>
  if (!group) {
 8007f9a:	4602      	mov	r2, r0
 8007f9c:	b180      	cbz	r0, 8007fc0 <igmp_input+0x48>
  switch (igmp->igmp_msgtype) {
 8007f9e:	782b      	ldrb	r3, [r5, #0]
 8007fa0:	2b11      	cmp	r3, #17
 8007fa2:	d011      	beq.n	8007fc8 <igmp_input+0x50>
 8007fa4:	2b16      	cmp	r3, #22
 8007fa6:	d041      	beq.n	800802c <igmp_input+0xb4>
  pbuf_free(p);
 8007fa8:	4620      	mov	r0, r4
 8007faa:	f7fe fa77 	bl	800649c <pbuf_free>
  return;
 8007fae:	e001      	b.n	8007fb4 <igmp_input+0x3c>
    pbuf_free(p);
 8007fb0:	f7fe fa74 	bl	800649c <pbuf_free>
}
 8007fb4:	b003      	add	sp, #12
 8007fb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pbuf_free(p);
 8007fb8:	4620      	mov	r0, r4
 8007fba:	f7fe fa6f 	bl	800649c <pbuf_free>
    return;
 8007fbe:	e7f9      	b.n	8007fb4 <igmp_input+0x3c>
    pbuf_free(p);
 8007fc0:	4620      	mov	r0, r4
 8007fc2:	f7fe fa6b 	bl	800649c <pbuf_free>
    return;
 8007fc6:	e7f5      	b.n	8007fb4 <igmp_input+0x3c>
    if ((ip4_addr_cmp(dest, &allsystems)) && ip4_addr_isany(&igmp->igmp_group_address)) {
 8007fc8:	6831      	ldr	r1, [r6, #0]
 8007fca:	4b1d      	ldr	r3, [pc, #116]	; (8008040 <igmp_input+0xc8>)
 8007fcc:	685b      	ldr	r3, [r3, #4]
 8007fce:	4299      	cmp	r1, r3
 8007fd0:	d00e      	beq.n	8007ff0 <igmp_input+0x78>
      if (!ip4_addr_isany(&igmp->igmp_group_address)) {
 8007fd2:	f115 0f04 	cmn.w	r5, #4
 8007fd6:	d0e7      	beq.n	8007fa8 <igmp_input+0x30>
 8007fd8:	6868      	ldr	r0, [r5, #4]
 8007fda:	2800      	cmp	r0, #0
 8007fdc:	d0e4      	beq.n	8007fa8 <igmp_input+0x30>
        if (ip4_addr_cmp(dest, &allsystems)) {
 8007fde:	4299      	cmp	r1, r3
 8007fe0:	d01c      	beq.n	800801c <igmp_input+0xa4>
        if (group != NULL) {
 8007fe2:	2a00      	cmp	r2, #0
 8007fe4:	d0e0      	beq.n	8007fa8 <igmp_input+0x30>
          igmp_delaying_member(group, igmp->igmp_maxresp);
 8007fe6:	7869      	ldrb	r1, [r5, #1]
 8007fe8:	4610      	mov	r0, r2
 8007fea:	f7ff feae 	bl	8007d4a <igmp_delaying_member>
 8007fee:	e7db      	b.n	8007fa8 <igmp_input+0x30>
    if ((ip4_addr_cmp(dest, &allsystems)) && ip4_addr_isany(&igmp->igmp_group_address)) {
 8007ff0:	f115 0f04 	cmn.w	r5, #4
 8007ff4:	d002      	beq.n	8007ffc <igmp_input+0x84>
 8007ff6:	6868      	ldr	r0, [r5, #4]
 8007ff8:	2800      	cmp	r0, #0
 8007ffa:	d1ea      	bne.n	8007fd2 <igmp_input+0x5a>
      if (igmp->igmp_maxresp == 0) {
 8007ffc:	786b      	ldrb	r3, [r5, #1]
 8007ffe:	b90b      	cbnz	r3, 8008004 <igmp_input+0x8c>
        igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;
 8008000:	230a      	movs	r3, #10
 8008002:	706b      	strb	r3, [r5, #1]
      groupref = netif_igmp_data(inp);
 8008004:	6a3e      	ldr	r6, [r7, #32]
      if(groupref != NULL) {
 8008006:	b136      	cbz	r6, 8008016 <igmp_input+0x9e>
        groupref = groupref->next;
 8008008:	6836      	ldr	r6, [r6, #0]
 800800a:	e004      	b.n	8008016 <igmp_input+0x9e>
        igmp_delaying_member(groupref, igmp->igmp_maxresp);
 800800c:	7869      	ldrb	r1, [r5, #1]
 800800e:	4630      	mov	r0, r6
 8008010:	f7ff fe9b 	bl	8007d4a <igmp_delaying_member>
        groupref = groupref->next;
 8008014:	6836      	ldr	r6, [r6, #0]
      while (groupref) {
 8008016:	2e00      	cmp	r6, #0
 8008018:	d1f8      	bne.n	800800c <igmp_input+0x94>
 800801a:	e7c5      	b.n	8007fa8 <igmp_input+0x30>
          ip4_addr_copy(groupaddr, igmp->igmp_group_address);
 800801c:	a902      	add	r1, sp, #8
 800801e:	f841 0d04 	str.w	r0, [r1, #-4]!
          group = igmp_lookfor_group(inp, &groupaddr);
 8008022:	4638      	mov	r0, r7
 8008024:	f7ff ff3f 	bl	8007ea6 <igmp_lookfor_group>
 8008028:	4602      	mov	r2, r0
 800802a:	e7da      	b.n	8007fe2 <igmp_input+0x6a>
    if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
 800802c:	7a43      	ldrb	r3, [r0, #9]
 800802e:	2b01      	cmp	r3, #1
 8008030:	d1ba      	bne.n	8007fa8 <igmp_input+0x30>
      group->timer = 0; /* stopped */
 8008032:	2300      	movs	r3, #0
 8008034:	8143      	strh	r3, [r0, #10]
      group->group_state = IGMP_GROUP_IDLE_MEMBER;
 8008036:	2102      	movs	r1, #2
 8008038:	7241      	strb	r1, [r0, #9]
      group->last_reporter_flag = 0;
 800803a:	7203      	strb	r3, [r0, #8]
 800803c:	e7b4      	b.n	8007fa8 <igmp_input+0x30>
 800803e:	bf00      	nop
 8008040:	200033e0 	.word	0x200033e0

08008044 <igmp_joingroup_netif>:
{
 8008044:	b570      	push	{r4, r5, r6, lr}
  LWIP_ERROR("igmp_joingroup_netif: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
 8008046:	680b      	ldr	r3, [r1, #0]
 8008048:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800804c:	2ae0      	cmp	r2, #224	; 0xe0
 800804e:	d129      	bne.n	80080a4 <igmp_joingroup_netif+0x60>
 8008050:	4605      	mov	r5, r0
 8008052:	460e      	mov	r6, r1
  LWIP_ERROR("igmp_joingroup_netif: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 8008054:	4a24      	ldr	r2, [pc, #144]	; (80080e8 <igmp_joingroup_netif+0xa4>)
 8008056:	6852      	ldr	r2, [r2, #4]
 8008058:	4293      	cmp	r3, r2
 800805a:	d02d      	beq.n	80080b8 <igmp_joingroup_netif+0x74>
  LWIP_ERROR("igmp_joingroup_netif: attempt to join on non-IGMP netif", netif->flags & NETIF_FLAG_IGMP, return ERR_VAL;);
 800805c:	f890 302f 	ldrb.w	r3, [r0, #47]	; 0x2f
 8008060:	f013 0f20 	tst.w	r3, #32
 8008064:	d032      	beq.n	80080cc <igmp_joingroup_netif+0x88>
  group = igmp_lookup_group(netif, groupaddr);
 8008066:	f7ff ff27 	bl	8007eb8 <igmp_lookup_group>
  if (group != NULL) {
 800806a:	4604      	mov	r4, r0
 800806c:	2800      	cmp	r0, #0
 800806e:	d037      	beq.n	80080e0 <igmp_joingroup_netif+0x9c>
    if (group->group_state != IGMP_GROUP_NON_MEMBER) {
 8008070:	7a43      	ldrb	r3, [r0, #9]
 8008072:	b993      	cbnz	r3, 800809a <igmp_joingroup_netif+0x56>
      if ((group->use==0) && (netif->igmp_mac_filter != NULL)) {
 8008074:	7b03      	ldrb	r3, [r0, #12]
 8008076:	b92b      	cbnz	r3, 8008084 <igmp_joingroup_netif+0x40>
 8008078:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800807a:	b11b      	cbz	r3, 8008084 <igmp_joingroup_netif+0x40>
        netif->igmp_mac_filter(netif, groupaddr, NETIF_ADD_MAC_FILTER);
 800807c:	2201      	movs	r2, #1
 800807e:	4631      	mov	r1, r6
 8008080:	4628      	mov	r0, r5
 8008082:	4798      	blx	r3
      igmp_send(netif, group, IGMP_V2_MEMB_REPORT);
 8008084:	2216      	movs	r2, #22
 8008086:	4621      	mov	r1, r4
 8008088:	4628      	mov	r0, r5
 800808a:	f7ff fe87 	bl	8007d9c <igmp_send>
      igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 800808e:	2105      	movs	r1, #5
 8008090:	4620      	mov	r0, r4
 8008092:	f7ff fe47 	bl	8007d24 <igmp_start_timer>
      group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 8008096:	2301      	movs	r3, #1
 8008098:	7263      	strb	r3, [r4, #9]
    group->use++;
 800809a:	7b23      	ldrb	r3, [r4, #12]
 800809c:	3301      	adds	r3, #1
 800809e:	7323      	strb	r3, [r4, #12]
    return ERR_OK;
 80080a0:	2000      	movs	r0, #0
}
 80080a2:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ERROR("igmp_joingroup_netif: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
 80080a4:	4b11      	ldr	r3, [pc, #68]	; (80080ec <igmp_joingroup_netif+0xa8>)
 80080a6:	f240 12eb 	movw	r2, #491	; 0x1eb
 80080aa:	4911      	ldr	r1, [pc, #68]	; (80080f0 <igmp_joingroup_netif+0xac>)
 80080ac:	4811      	ldr	r0, [pc, #68]	; (80080f4 <igmp_joingroup_netif+0xb0>)
 80080ae:	f007 f9fd 	bl	800f4ac <iprintf>
 80080b2:	f06f 0005 	mvn.w	r0, #5
 80080b6:	e7f4      	b.n	80080a2 <igmp_joingroup_netif+0x5e>
  LWIP_ERROR("igmp_joingroup_netif: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 80080b8:	4b0c      	ldr	r3, [pc, #48]	; (80080ec <igmp_joingroup_netif+0xa8>)
 80080ba:	f44f 72f6 	mov.w	r2, #492	; 0x1ec
 80080be:	490e      	ldr	r1, [pc, #56]	; (80080f8 <igmp_joingroup_netif+0xb4>)
 80080c0:	480c      	ldr	r0, [pc, #48]	; (80080f4 <igmp_joingroup_netif+0xb0>)
 80080c2:	f007 f9f3 	bl	800f4ac <iprintf>
 80080c6:	f06f 0005 	mvn.w	r0, #5
 80080ca:	e7ea      	b.n	80080a2 <igmp_joingroup_netif+0x5e>
  LWIP_ERROR("igmp_joingroup_netif: attempt to join on non-IGMP netif", netif->flags & NETIF_FLAG_IGMP, return ERR_VAL;);
 80080cc:	4b07      	ldr	r3, [pc, #28]	; (80080ec <igmp_joingroup_netif+0xa8>)
 80080ce:	f240 12ef 	movw	r2, #495	; 0x1ef
 80080d2:	490a      	ldr	r1, [pc, #40]	; (80080fc <igmp_joingroup_netif+0xb8>)
 80080d4:	4807      	ldr	r0, [pc, #28]	; (80080f4 <igmp_joingroup_netif+0xb0>)
 80080d6:	f007 f9e9 	bl	800f4ac <iprintf>
 80080da:	f06f 0005 	mvn.w	r0, #5
 80080de:	e7e0      	b.n	80080a2 <igmp_joingroup_netif+0x5e>
    return ERR_MEM;
 80080e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80080e4:	e7dd      	b.n	80080a2 <igmp_joingroup_netif+0x5e>
 80080e6:	bf00      	nop
 80080e8:	200033e0 	.word	0x200033e0
 80080ec:	080115c4 	.word	0x080115c4
 80080f0:	080116b0 	.word	0x080116b0
 80080f4:	080109f4 	.word	0x080109f4
 80080f8:	080116ec 	.word	0x080116ec
 80080fc:	08011728 	.word	0x08011728

08008100 <igmp_joingroup>:
{
 8008100:	b570      	push	{r4, r5, r6, lr}
  LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
 8008102:	680b      	ldr	r3, [r1, #0]
 8008104:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8008108:	2ae0      	cmp	r2, #224	; 0xe0
 800810a:	d10a      	bne.n	8008122 <igmp_joingroup+0x22>
 800810c:	4605      	mov	r5, r0
 800810e:	460e      	mov	r6, r1
  LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 8008110:	4a1a      	ldr	r2, [pc, #104]	; (800817c <igmp_joingroup+0x7c>)
 8008112:	6852      	ldr	r2, [r2, #4]
 8008114:	4293      	cmp	r3, r2
 8008116:	d00f      	beq.n	8008138 <igmp_joingroup+0x38>
  netif = netif_list;
 8008118:	4b19      	ldr	r3, [pc, #100]	; (8008180 <igmp_joingroup+0x80>)
 800811a:	681c      	ldr	r4, [r3, #0]
  err_t err = ERR_VAL; /* no matching interface */
 800811c:	f06f 0205 	mvn.w	r2, #5
  while (netif != NULL) {
 8008120:	e01c      	b.n	800815c <igmp_joingroup+0x5c>
  LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
 8008122:	4b18      	ldr	r3, [pc, #96]	; (8008184 <igmp_joingroup+0x84>)
 8008124:	f240 12c7 	movw	r2, #455	; 0x1c7
 8008128:	4917      	ldr	r1, [pc, #92]	; (8008188 <igmp_joingroup+0x88>)
 800812a:	4818      	ldr	r0, [pc, #96]	; (800818c <igmp_joingroup+0x8c>)
 800812c:	f007 f9be 	bl	800f4ac <iprintf>
 8008130:	f06f 0205 	mvn.w	r2, #5
}
 8008134:	4610      	mov	r0, r2
 8008136:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 8008138:	4b12      	ldr	r3, [pc, #72]	; (8008184 <igmp_joingroup+0x84>)
 800813a:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 800813e:	4914      	ldr	r1, [pc, #80]	; (8008190 <igmp_joingroup+0x90>)
 8008140:	4812      	ldr	r0, [pc, #72]	; (800818c <igmp_joingroup+0x8c>)
 8008142:	f007 f9b3 	bl	800f4ac <iprintf>
 8008146:	f06f 0205 	mvn.w	r2, #5
 800814a:	e7f3      	b.n	8008134 <igmp_joingroup+0x34>
      err = igmp_joingroup_netif(netif, groupaddr);
 800814c:	4631      	mov	r1, r6
 800814e:	4620      	mov	r0, r4
 8008150:	f7ff ff78 	bl	8008044 <igmp_joingroup_netif>
      if (err != ERR_OK) {
 8008154:	4602      	mov	r2, r0
 8008156:	2800      	cmp	r0, #0
 8008158:	d1ec      	bne.n	8008134 <igmp_joingroup+0x34>
    netif = netif->next;
 800815a:	6824      	ldr	r4, [r4, #0]
  while (netif != NULL) {
 800815c:	2c00      	cmp	r4, #0
 800815e:	d0e9      	beq.n	8008134 <igmp_joingroup+0x34>
    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip4_addr_isany(ifaddr) || ip4_addr_cmp(netif_ip4_addr(netif), ifaddr)))) {
 8008160:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8008164:	f013 0f20 	tst.w	r3, #32
 8008168:	d0f7      	beq.n	800815a <igmp_joingroup+0x5a>
 800816a:	2d00      	cmp	r5, #0
 800816c:	d0ee      	beq.n	800814c <igmp_joingroup+0x4c>
 800816e:	682b      	ldr	r3, [r5, #0]
 8008170:	2b00      	cmp	r3, #0
 8008172:	d0eb      	beq.n	800814c <igmp_joingroup+0x4c>
 8008174:	6861      	ldr	r1, [r4, #4]
 8008176:	428b      	cmp	r3, r1
 8008178:	d1ef      	bne.n	800815a <igmp_joingroup+0x5a>
 800817a:	e7e7      	b.n	800814c <igmp_joingroup+0x4c>
 800817c:	200033e0 	.word	0x200033e0
 8008180:	20008610 	.word	0x20008610
 8008184:	080115c4 	.word	0x080115c4
 8008188:	08011760 	.word	0x08011760
 800818c:	080109f4 	.word	0x080109f4
 8008190:	08011798 	.word	0x08011798

08008194 <igmp_tmr>:
{
 8008194:	b538      	push	{r3, r4, r5, lr}
  struct netif *netif = netif_list;
 8008196:	4b0b      	ldr	r3, [pc, #44]	; (80081c4 <igmp_tmr+0x30>)
 8008198:	681d      	ldr	r5, [r3, #0]
  while (netif != NULL) {
 800819a:	e00f      	b.n	80081bc <igmp_tmr+0x28>
      group = group->next;
 800819c:	6824      	ldr	r4, [r4, #0]
    while (group != NULL) {
 800819e:	b164      	cbz	r4, 80081ba <igmp_tmr+0x26>
      if (group->timer > 0) {
 80081a0:	8963      	ldrh	r3, [r4, #10]
 80081a2:	2b00      	cmp	r3, #0
 80081a4:	d0fa      	beq.n	800819c <igmp_tmr+0x8>
        group->timer--;
 80081a6:	3b01      	subs	r3, #1
 80081a8:	b29b      	uxth	r3, r3
 80081aa:	8163      	strh	r3, [r4, #10]
        if (group->timer == 0) {
 80081ac:	2b00      	cmp	r3, #0
 80081ae:	d1f5      	bne.n	800819c <igmp_tmr+0x8>
          igmp_timeout(netif, group);
 80081b0:	4621      	mov	r1, r4
 80081b2:	4628      	mov	r0, r5
 80081b4:	f7ff fe4c 	bl	8007e50 <igmp_timeout>
 80081b8:	e7f0      	b.n	800819c <igmp_tmr+0x8>
    netif = netif->next;
 80081ba:	682d      	ldr	r5, [r5, #0]
  while (netif != NULL) {
 80081bc:	b10d      	cbz	r5, 80081c2 <igmp_tmr+0x2e>
    struct igmp_group *group = netif_igmp_data(netif);
 80081be:	6a2c      	ldr	r4, [r5, #32]
    while (group != NULL) {
 80081c0:	e7ed      	b.n	800819e <igmp_tmr+0xa>
}
 80081c2:	bd38      	pop	{r3, r4, r5, pc}
 80081c4:	20008610 	.word	0x20008610

080081c8 <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 80081c8:	b410      	push	{r4}
  struct netif *netif;

#if LWIP_MULTICAST_TX_OPTIONS
  /* Use administratively selected interface for multicast by default */
  if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
 80081ca:	6804      	ldr	r4, [r0, #0]
 80081cc:	f004 03f0 	and.w	r3, r4, #240	; 0xf0
 80081d0:	2be0      	cmp	r3, #224	; 0xe0
 80081d2:	d002      	beq.n	80081da <ip4_route+0x12>
    return ip4_default_multicast_netif;
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80081d4:	4b19      	ldr	r3, [pc, #100]	; (800823c <ip4_route+0x74>)
 80081d6:	681b      	ldr	r3, [r3, #0]
 80081d8:	e004      	b.n	80081e4 <ip4_route+0x1c>
  if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
 80081da:	4b19      	ldr	r3, [pc, #100]	; (8008240 <ip4_route+0x78>)
 80081dc:	6818      	ldr	r0, [r3, #0]
 80081de:	bb20      	cbnz	r0, 800822a <ip4_route+0x62>
 80081e0:	e7f8      	b.n	80081d4 <ip4_route+0xc>
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80081e2:	681b      	ldr	r3, [r3, #0]
 80081e4:	b1b3      	cbz	r3, 8008214 <ip4_route+0x4c>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 80081e6:	f893 202f 	ldrb.w	r2, [r3, #47]	; 0x2f
 80081ea:	f012 0f01 	tst.w	r2, #1
 80081ee:	d0f8      	beq.n	80081e2 <ip4_route+0x1a>
 80081f0:	f012 0f04 	tst.w	r2, #4
 80081f4:	d0f5      	beq.n	80081e2 <ip4_route+0x1a>
 80081f6:	6859      	ldr	r1, [r3, #4]
 80081f8:	2900      	cmp	r1, #0
 80081fa:	d0f2      	beq.n	80081e2 <ip4_route+0x1a>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 80081fc:	6898      	ldr	r0, [r3, #8]
 80081fe:	4061      	eors	r1, r4
 8008200:	4201      	tst	r1, r0
 8008202:	d017      	beq.n	8008234 <ip4_route+0x6c>
        /* return netif on which to forward IP packet */
        return netif;
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 8008204:	f012 0f02 	tst.w	r2, #2
 8008208:	d1eb      	bne.n	80081e2 <ip4_route+0x1a>
 800820a:	68da      	ldr	r2, [r3, #12]
 800820c:	4294      	cmp	r4, r2
 800820e:	d1e8      	bne.n	80081e2 <ip4_route+0x1a>
        /* return netif on which to forward IP packet */
        return netif;
 8008210:	4618      	mov	r0, r3
 8008212:	e00a      	b.n	800822a <ip4_route+0x62>
  if (netif != NULL) {
    return netif;
  }
#endif

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8008214:	4a0b      	ldr	r2, [pc, #44]	; (8008244 <ip4_route+0x7c>)
 8008216:	6810      	ldr	r0, [r2, #0]
 8008218:	b138      	cbz	r0, 800822a <ip4_route+0x62>
 800821a:	f890 202f 	ldrb.w	r2, [r0, #47]	; 0x2f
 800821e:	f002 0205 	and.w	r2, r2, #5
 8008222:	2a05      	cmp	r2, #5
 8008224:	d108      	bne.n	8008238 <ip4_route+0x70>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default))) {
 8008226:	6842      	ldr	r2, [r0, #4]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8008228:	b112      	cbz	r2, 8008230 <ip4_route+0x68>
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
  }

  return netif_default;
}
 800822a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800822e:	4770      	bx	lr
    return NULL;
 8008230:	4618      	mov	r0, r3
 8008232:	e7fa      	b.n	800822a <ip4_route+0x62>
        return netif;
 8008234:	4618      	mov	r0, r3
 8008236:	e7f8      	b.n	800822a <ip4_route+0x62>
    return NULL;
 8008238:	4618      	mov	r0, r3
 800823a:	e7f6      	b.n	800822a <ip4_route+0x62>
 800823c:	20008610 	.word	0x20008610
 8008240:	200033e8 	.word	0x200033e8
 8008244:	20008614 	.word	0x20008614

08008248 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 8008248:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800824c:	4604      	mov	r4, r0

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 800824e:	6847      	ldr	r7, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 8008250:	783b      	ldrb	r3, [r7, #0]
 8008252:	091a      	lsrs	r2, r3, #4
 8008254:	2a04      	cmp	r2, #4
 8008256:	d004      	beq.n	8008262 <ip4_input+0x1a>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 8008258:	f7fe f920 	bl	800649c <pbuf_free>
  ip_data.current_ip_header_tot_len = 0;
  ip4_addr_set_any(ip4_current_src_addr());
  ip4_addr_set_any(ip4_current_dest_addr());

  return ERR_OK;
}
 800825c:	2000      	movs	r0, #0
 800825e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008262:	4688      	mov	r8, r1
  iphdr_hlen = IPH_HL(iphdr);
 8008264:	f003 030f 	and.w	r3, r3, #15
  iphdr_hlen *= 4;
 8008268:	009e      	lsls	r6, r3, #2
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 800826a:	8878      	ldrh	r0, [r7, #2]
 800826c:	f7fd fc5e 	bl	8005b2c <lwip_htons>
 8008270:	4605      	mov	r5, r0
  if (iphdr_len < p->tot_len) {
 8008272:	8923      	ldrh	r3, [r4, #8]
 8008274:	4283      	cmp	r3, r0
 8008276:	d814      	bhi.n	80082a2 <ip4_input+0x5a>
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 8008278:	8963      	ldrh	r3, [r4, #10]
 800827a:	42b3      	cmp	r3, r6
 800827c:	d316      	bcc.n	80082ac <ip4_input+0x64>
 800827e:	8923      	ldrh	r3, [r4, #8]
 8008280:	42ab      	cmp	r3, r5
 8008282:	d313      	bcc.n	80082ac <ip4_input+0x64>
 8008284:	2e13      	cmp	r6, #19
 8008286:	d911      	bls.n	80082ac <ip4_input+0x64>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 8008288:	693b      	ldr	r3, [r7, #16]
 800828a:	4a60      	ldr	r2, [pc, #384]	; (800840c <ip4_input+0x1c4>)
 800828c:	6153      	str	r3, [r2, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 800828e:	68f9      	ldr	r1, [r7, #12]
 8008290:	6111      	str	r1, [r2, #16]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8008292:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008296:	2be0      	cmp	r3, #224	; 0xe0
 8008298:	d00c      	beq.n	80082b4 <ip4_input+0x6c>
    netif = inp;
 800829a:	4645      	mov	r5, r8
    int first = 1;
 800829c:	f04f 0901 	mov.w	r9, #1
 80082a0:	e066      	b.n	8008370 <ip4_input+0x128>
    pbuf_realloc(p, iphdr_len);
 80082a2:	4601      	mov	r1, r0
 80082a4:	4620      	mov	r0, r4
 80082a6:	f7fe fa49 	bl	800673c <pbuf_realloc>
 80082aa:	e7e5      	b.n	8008278 <ip4_input+0x30>
    pbuf_free(p);
 80082ac:	4620      	mov	r0, r4
 80082ae:	f7fe f8f5 	bl	800649c <pbuf_free>
    return ERR_OK;
 80082b2:	e7d3      	b.n	800825c <ip4_input+0x14>
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
 80082b4:	f898 302f 	ldrb.w	r3, [r8, #47]	; 0x2f
 80082b8:	f013 0f20 	tst.w	r3, #32
 80082bc:	d140      	bne.n	8008340 <ip4_input+0xf8>
      netif = NULL;
 80082be:	2500      	movs	r5, #0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 80082c0:	4641      	mov	r1, r8
 80082c2:	4b52      	ldr	r3, [pc, #328]	; (800840c <ip4_input+0x1c4>)
 80082c4:	6918      	ldr	r0, [r3, #16]
 80082c6:	f000 f989 	bl	80085dc <ip4_addr_isbroadcast_u32>
 80082ca:	2800      	cmp	r0, #0
 80082cc:	d172      	bne.n	80083b4 <ip4_input+0x16c>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 80082ce:	4b4f      	ldr	r3, [pc, #316]	; (800840c <ip4_input+0x1c4>)
 80082d0:	691b      	ldr	r3, [r3, #16]
 80082d2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 80082d6:	2be0      	cmp	r3, #224	; 0xe0
 80082d8:	d06c      	beq.n	80083b4 <ip4_input+0x16c>
  if (netif == NULL) {
 80082da:	2d00      	cmp	r5, #0
 80082dc:	d070      	beq.n	80083c0 <ip4_input+0x178>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 80082de:	88fb      	ldrh	r3, [r7, #6]
 80082e0:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80082e4:	b29b      	uxth	r3, r3
 80082e6:	b133      	cbz	r3, 80082f6 <ip4_input+0xae>
    p = ip4_reass(p);
 80082e8:	4620      	mov	r0, r4
 80082ea:	f000 fbbf 	bl	8008a6c <ip4_reass>
    if (p == NULL) {
 80082ee:	4604      	mov	r4, r0
 80082f0:	2800      	cmp	r0, #0
 80082f2:	d0b3      	beq.n	800825c <ip4_input+0x14>
    iphdr = (struct ip_hdr *)p->payload;
 80082f4:	6847      	ldr	r7, [r0, #4]
  ip_data.current_netif = netif;
 80082f6:	4a45      	ldr	r2, [pc, #276]	; (800840c <ip4_input+0x1c4>)
 80082f8:	6015      	str	r5, [r2, #0]
  ip_data.current_input_netif = inp;
 80082fa:	f8c2 8004 	str.w	r8, [r2, #4]
  ip_data.current_ip4_header = iphdr;
 80082fe:	6097      	str	r7, [r2, #8]
  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
 8008300:	783b      	ldrb	r3, [r7, #0]
 8008302:	f003 030f 	and.w	r3, r3, #15
 8008306:	009b      	lsls	r3, r3, #2
 8008308:	8193      	strh	r3, [r2, #12]
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
 800830a:	4271      	negs	r1, r6
 800830c:	4620      	mov	r0, r4
 800830e:	f7fe f8bb 	bl	8006488 <pbuf_header>
    switch (IPH_PROTO(iphdr)) {
 8008312:	7a7b      	ldrb	r3, [r7, #9]
 8008314:	2b02      	cmp	r3, #2
 8008316:	d069      	beq.n	80083ec <ip4_input+0x1a4>
 8008318:	2b11      	cmp	r3, #17
 800831a:	d055      	beq.n	80083c8 <ip4_input+0x180>
 800831c:	2b01      	cmp	r3, #1
 800831e:	d060      	beq.n	80083e2 <ip4_input+0x19a>
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8008320:	4629      	mov	r1, r5
 8008322:	4b3a      	ldr	r3, [pc, #232]	; (800840c <ip4_input+0x1c4>)
 8008324:	6958      	ldr	r0, [r3, #20]
 8008326:	f000 f959 	bl	80085dc <ip4_addr_isbroadcast_u32>
 800832a:	b928      	cbnz	r0, 8008338 <ip4_input+0xf0>
          !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 800832c:	4b37      	ldr	r3, [pc, #220]	; (800840c <ip4_input+0x1c4>)
 800832e:	695b      	ldr	r3, [r3, #20]
 8008330:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8008334:	2be0      	cmp	r3, #224	; 0xe0
 8008336:	d15f      	bne.n	80083f8 <ip4_input+0x1b0>
      pbuf_free(p);
 8008338:	4620      	mov	r0, r4
 800833a:	f7fe f8af 	bl	800649c <pbuf_free>
 800833e:	e047      	b.n	80083d0 <ip4_input+0x188>
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
 8008340:	f102 0114 	add.w	r1, r2, #20
 8008344:	4640      	mov	r0, r8
 8008346:	f7ff fdae 	bl	8007ea6 <igmp_lookfor_group>
 800834a:	2800      	cmp	r0, #0
 800834c:	d02e      	beq.n	80083ac <ip4_input+0x164>
      if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
 800834e:	4b2f      	ldr	r3, [pc, #188]	; (800840c <ip4_input+0x1c4>)
 8008350:	695a      	ldr	r2, [r3, #20]
 8008352:	4b2f      	ldr	r3, [pc, #188]	; (8008410 <ip4_input+0x1c8>)
 8008354:	429a      	cmp	r2, r3
 8008356:	d001      	beq.n	800835c <ip4_input+0x114>
      netif = inp;
 8008358:	4645      	mov	r5, r8
 800835a:	e7b1      	b.n	80082c0 <ip4_input+0x78>
          ip4_addr_isany(ip4_current_src_addr())) {
 800835c:	4b2b      	ldr	r3, [pc, #172]	; (800840c <ip4_input+0x1c4>)
 800835e:	691b      	ldr	r3, [r3, #16]
      if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
 8008360:	b363      	cbz	r3, 80083bc <ip4_input+0x174>
      netif = inp;
 8008362:	4645      	mov	r5, r8
 8008364:	e7ac      	b.n	80082c0 <ip4_input+0x78>
        netif = netif->next;
 8008366:	682d      	ldr	r5, [r5, #0]
      if (netif == inp) {
 8008368:	4545      	cmp	r5, r8
 800836a:	d01d      	beq.n	80083a8 <ip4_input+0x160>
    } while (netif != NULL);
 800836c:	2d00      	cmp	r5, #0
 800836e:	d0a7      	beq.n	80082c0 <ip4_input+0x78>
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 8008370:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 8008374:	f013 0f01 	tst.w	r3, #1
 8008378:	d00a      	beq.n	8008390 <ip4_input+0x148>
 800837a:	686b      	ldr	r3, [r5, #4]
 800837c:	b143      	cbz	r3, 8008390 <ip4_input+0x148>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 800837e:	4a23      	ldr	r2, [pc, #140]	; (800840c <ip4_input+0x1c4>)
 8008380:	6950      	ldr	r0, [r2, #20]
 8008382:	4283      	cmp	r3, r0
 8008384:	d09c      	beq.n	80082c0 <ip4_input+0x78>
            ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 8008386:	4629      	mov	r1, r5
 8008388:	f000 f928 	bl	80085dc <ip4_addr_isbroadcast_u32>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 800838c:	2800      	cmp	r0, #0
 800838e:	d197      	bne.n	80082c0 <ip4_input+0x78>
      if (first) {
 8008390:	f1b9 0f00 	cmp.w	r9, #0
 8008394:	d0e7      	beq.n	8008366 <ip4_input+0x11e>
        if (ip4_addr_isloopback(ip4_current_dest_addr())) {
 8008396:	4b1d      	ldr	r3, [pc, #116]	; (800840c <ip4_input+0x1c4>)
 8008398:	7d1b      	ldrb	r3, [r3, #20]
 800839a:	2b7f      	cmp	r3, #127	; 0x7f
 800839c:	d008      	beq.n	80083b0 <ip4_input+0x168>
        netif = netif_list;
 800839e:	4b1d      	ldr	r3, [pc, #116]	; (8008414 <ip4_input+0x1cc>)
 80083a0:	681d      	ldr	r5, [r3, #0]
        first = 0;
 80083a2:	f04f 0900 	mov.w	r9, #0
 80083a6:	e7df      	b.n	8008368 <ip4_input+0x120>
        netif = netif->next;
 80083a8:	682d      	ldr	r5, [r5, #0]
 80083aa:	e7df      	b.n	800836c <ip4_input+0x124>
      netif = NULL;
 80083ac:	2500      	movs	r5, #0
 80083ae:	e787      	b.n	80082c0 <ip4_input+0x78>
          netif = NULL;
 80083b0:	2500      	movs	r5, #0
 80083b2:	e785      	b.n	80082c0 <ip4_input+0x78>
      pbuf_free(p);
 80083b4:	4620      	mov	r0, r4
 80083b6:	f7fe f871 	bl	800649c <pbuf_free>
      return ERR_OK;
 80083ba:	e74f      	b.n	800825c <ip4_input+0x14>
      netif = inp;
 80083bc:	4645      	mov	r5, r8
 80083be:	e78c      	b.n	80082da <ip4_input+0x92>
    pbuf_free(p);
 80083c0:	4620      	mov	r0, r4
 80083c2:	f7fe f86b 	bl	800649c <pbuf_free>
    return ERR_OK;
 80083c6:	e749      	b.n	800825c <ip4_input+0x14>
      udp_input(p, inp);
 80083c8:	4641      	mov	r1, r8
 80083ca:	4620      	mov	r0, r4
 80083cc:	f7fe fd10 	bl	8006df0 <udp_input>
  ip_data.current_netif = NULL;
 80083d0:	4b0e      	ldr	r3, [pc, #56]	; (800840c <ip4_input+0x1c4>)
 80083d2:	2200      	movs	r2, #0
 80083d4:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 80083d6:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 80083d8:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 80083da:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 80083dc:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 80083de:	615a      	str	r2, [r3, #20]
  return ERR_OK;
 80083e0:	e73c      	b.n	800825c <ip4_input+0x14>
      icmp_input(p, inp);
 80083e2:	4641      	mov	r1, r8
 80083e4:	4620      	mov	r0, r4
 80083e6:	f7ff fbf3 	bl	8007bd0 <icmp_input>
      break;
 80083ea:	e7f1      	b.n	80083d0 <ip4_input+0x188>
      igmp_input(p, inp, ip4_current_dest_addr());
 80083ec:	4a0a      	ldr	r2, [pc, #40]	; (8008418 <ip4_input+0x1d0>)
 80083ee:	4641      	mov	r1, r8
 80083f0:	4620      	mov	r0, r4
 80083f2:	f7ff fdc1 	bl	8007f78 <igmp_input>
      break;
 80083f6:	e7eb      	b.n	80083d0 <ip4_input+0x188>
        pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
 80083f8:	4631      	mov	r1, r6
 80083fa:	4620      	mov	r0, r4
 80083fc:	f7fe f849 	bl	8006492 <pbuf_header_force>
        p->payload = iphdr;
 8008400:	6067      	str	r7, [r4, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8008402:	2102      	movs	r1, #2
 8008404:	4620      	mov	r0, r4
 8008406:	f7ff fc81 	bl	8007d0c <icmp_dest_unreach>
 800840a:	e795      	b.n	8008338 <ip4_input+0xf0>
 800840c:	20005a30 	.word	0x20005a30
 8008410:	010000e0 	.word	0x010000e0
 8008414:	20008610 	.word	0x20008610
 8008418:	20005a44 	.word	0x20005a44

0800841c <ip4_output_if_opt_src>:
 */
err_t
ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
       u16_t optlen)
{
 800841c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008420:	b083      	sub	sp, #12
 8008422:	4605      	mov	r5, r0
 8008424:	4689      	mov	r9, r1
 8008426:	4617      	mov	r7, r2
 8008428:	469a      	mov	sl, r3
 800842a:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 800842e:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 8008432:	89c3      	ldrh	r3, [r0, #14]
 8008434:	2b01      	cmp	r3, #1
 8008436:	d122      	bne.n	800847e <ip4_output_if_opt_src+0x62>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 8008438:	2f00      	cmp	r7, #0
 800843a:	d071      	beq.n	8008520 <ip4_output_if_opt_src+0x104>
    u16_t ip_hlen = IP_HLEN;
#if IP_OPTIONS_SEND
    u16_t optlen_aligned = 0;
    if (optlen != 0) {
 800843c:	f1bb 0f00 	cmp.w	fp, #0
 8008440:	d025      	beq.n	800848e <ip4_output_if_opt_src+0x72>
#if CHECKSUM_GEN_IP_INLINE
      int i;
#endif /* CHECKSUM_GEN_IP_INLINE */
      /* round up to a multiple of 4 */
      optlen_aligned = ((optlen + 3) & ~3);
 8008442:	f10b 0403 	add.w	r4, fp, #3
 8008446:	b2a4      	uxth	r4, r4
 8008448:	f024 0403 	bic.w	r4, r4, #3
 800844c:	b2a4      	uxth	r4, r4
      ip_hlen += optlen_aligned;
 800844e:	f104 0614 	add.w	r6, r4, #20
 8008452:	b2b6      	uxth	r6, r6
      /* First write in the IP options */
      if (pbuf_header(p, optlen_aligned)) {
 8008454:	b221      	sxth	r1, r4
 8008456:	4628      	mov	r0, r5
 8008458:	f7fe f816 	bl	8006488 <pbuf_header>
 800845c:	2800      	cmp	r0, #0
 800845e:	d16e      	bne.n	800853e <ip4_output_if_opt_src+0x122>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: not enough room for IP options in pbuf\n"));
        IP_STATS_INC(ip.err);
        MIB2_STATS_INC(mib2.ipoutdiscards);
        return ERR_BUF;
      }
      MEMCPY(p->payload, ip_options, optlen);
 8008460:	465a      	mov	r2, fp
 8008462:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8008464:	6868      	ldr	r0, [r5, #4]
 8008466:	f007 f80e 	bl	800f486 <memcpy>
      if (optlen < optlen_aligned) {
 800846a:	45a3      	cmp	fp, r4
 800846c:	d210      	bcs.n	8008490 <ip4_output_if_opt_src+0x74>
        /* zero the remaining bytes */
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
 800846e:	6868      	ldr	r0, [r5, #4]
 8008470:	eba4 020b 	sub.w	r2, r4, fp
 8008474:	2100      	movs	r1, #0
 8008476:	4458      	add	r0, fp
 8008478:	f007 f810 	bl	800f49c <memset>
 800847c:	e008      	b.n	8008490 <ip4_output_if_opt_src+0x74>
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 800847e:	4b33      	ldr	r3, [pc, #204]	; (800854c <ip4_output_if_opt_src+0x130>)
 8008480:	f240 3233 	movw	r2, #819	; 0x333
 8008484:	4932      	ldr	r1, [pc, #200]	; (8008550 <ip4_output_if_opt_src+0x134>)
 8008486:	4833      	ldr	r0, [pc, #204]	; (8008554 <ip4_output_if_opt_src+0x138>)
 8008488:	f007 f810 	bl	800f4ac <iprintf>
 800848c:	e7d4      	b.n	8008438 <ip4_output_if_opt_src+0x1c>
    u16_t ip_hlen = IP_HLEN;
 800848e:	2614      	movs	r6, #20
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 8008490:	2114      	movs	r1, #20
 8008492:	4628      	mov	r0, r5
 8008494:	f7fd fff8 	bl	8006488 <pbuf_header>
 8008498:	2800      	cmp	r0, #0
 800849a:	d153      	bne.n	8008544 <ip4_output_if_opt_src+0x128>
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 800849c:	686c      	ldr	r4, [r5, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800849e:	896b      	ldrh	r3, [r5, #10]
 80084a0:	2b13      	cmp	r3, #19
 80084a2:	d931      	bls.n	8008508 <ip4_output_if_opt_src+0xec>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 80084a4:	f884 a008 	strb.w	sl, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 80084a8:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
 80084ac:	7263      	strb	r3, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 80084ae:	683b      	ldr	r3, [r7, #0]
 80084b0:	6123      	str	r3, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 80084b2:	08b6      	lsrs	r6, r6, #2
 80084b4:	f046 0640 	orr.w	r6, r6, #64	; 0x40
 80084b8:	7026      	strb	r6, [r4, #0]
    IPH_TOS_SET(iphdr, tos);
 80084ba:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 80084be:	7063      	strb	r3, [r4, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 80084c0:	8928      	ldrh	r0, [r5, #8]
 80084c2:	f7fd fb33 	bl	8005b2c <lwip_htons>
 80084c6:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 80084c8:	2300      	movs	r3, #0
 80084ca:	71a3      	strb	r3, [r4, #6]
 80084cc:	71e3      	strb	r3, [r4, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 80084ce:	4e22      	ldr	r6, [pc, #136]	; (8008558 <ip4_output_if_opt_src+0x13c>)
 80084d0:	88b0      	ldrh	r0, [r6, #4]
 80084d2:	f7fd fb2b 	bl	8005b2c <lwip_htons>
 80084d6:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 80084d8:	88b3      	ldrh	r3, [r6, #4]
 80084da:	3301      	adds	r3, #1
 80084dc:	80b3      	strh	r3, [r6, #4]

    if (src == NULL) {
 80084de:	f1b9 0f00 	cmp.w	r9, #0
 80084e2:	d019      	beq.n	8008518 <ip4_output_if_opt_src+0xfc>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 80084e4:	f8d9 3000 	ldr.w	r3, [r9]
 80084e8:	60e3      	str	r3, [r4, #12]
    else {
      IPH_CHKSUM_SET(iphdr, 0);
    }
#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 80084ea:	2300      	movs	r3, #0
 80084ec:	72a3      	strb	r3, [r4, #10]
 80084ee:	72e3      	strb	r3, [r4, #11]
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 80084f0:	f8b8 3026 	ldrh.w	r3, [r8, #38]	; 0x26
 80084f4:	b9d3      	cbnz	r3, 800852c <ip4_output_if_opt_src+0x110>
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 80084f6:	f8d8 3014 	ldr.w	r3, [r8, #20]
 80084fa:	463a      	mov	r2, r7
 80084fc:	4629      	mov	r1, r5
 80084fe:	4640      	mov	r0, r8
 8008500:	4798      	blx	r3
}
 8008502:	b003      	add	sp, #12
 8008504:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 8008508:	4b10      	ldr	r3, [pc, #64]	; (800854c <ip4_output_if_opt_src+0x130>)
 800850a:	f240 3261 	movw	r2, #865	; 0x361
 800850e:	4913      	ldr	r1, [pc, #76]	; (800855c <ip4_output_if_opt_src+0x140>)
 8008510:	4810      	ldr	r0, [pc, #64]	; (8008554 <ip4_output_if_opt_src+0x138>)
 8008512:	f006 ffcb 	bl	800f4ac <iprintf>
 8008516:	e7c5      	b.n	80084a4 <ip4_output_if_opt_src+0x88>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 8008518:	4b11      	ldr	r3, [pc, #68]	; (8008560 <ip4_output_if_opt_src+0x144>)
 800851a:	681b      	ldr	r3, [r3, #0]
 800851c:	60e3      	str	r3, [r4, #12]
 800851e:	e7e4      	b.n	80084ea <ip4_output_if_opt_src+0xce>
    iphdr = (struct ip_hdr *)p->payload;
 8008520:	686b      	ldr	r3, [r5, #4]
    ip4_addr_copy(dest_addr, iphdr->dest);
 8008522:	691b      	ldr	r3, [r3, #16]
 8008524:	af02      	add	r7, sp, #8
 8008526:	f847 3d04 	str.w	r3, [r7, #-4]!
 800852a:	e7e1      	b.n	80084f0 <ip4_output_if_opt_src+0xd4>
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 800852c:	892a      	ldrh	r2, [r5, #8]
 800852e:	4293      	cmp	r3, r2
 8008530:	d2e1      	bcs.n	80084f6 <ip4_output_if_opt_src+0xda>
    return ip4_frag(p, netif, dest);
 8008532:	463a      	mov	r2, r7
 8008534:	4641      	mov	r1, r8
 8008536:	4628      	mov	r0, r5
 8008538:	f000 fb6a 	bl	8008c10 <ip4_frag>
 800853c:	e7e1      	b.n	8008502 <ip4_output_if_opt_src+0xe6>
        return ERR_BUF;
 800853e:	f06f 0001 	mvn.w	r0, #1
 8008542:	e7de      	b.n	8008502 <ip4_output_if_opt_src+0xe6>
      return ERR_BUF;
 8008544:	f06f 0001 	mvn.w	r0, #1
 8008548:	e7db      	b.n	8008502 <ip4_output_if_opt_src+0xe6>
 800854a:	bf00      	nop
 800854c:	080118f4 	.word	0x080118f4
 8008550:	08011928 	.word	0x08011928
 8008554:	080109f4 	.word	0x080109f4
 8008558:	200033e8 	.word	0x200033e8
 800855c:	08011934 	.word	0x08011934
 8008560:	080108cc 	.word	0x080108cc

08008564 <ip4_output_if_opt>:
{
 8008564:	b530      	push	{r4, r5, lr}
 8008566:	b087      	sub	sp, #28
 8008568:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  if (dest != LWIP_IP_HDRINCL) {
 800856a:	4615      	mov	r5, r2
 800856c:	b11a      	cbz	r2, 8008576 <ip4_output_if_opt+0x12>
    if (ip4_addr_isany(src)) {
 800856e:	b109      	cbz	r1, 8008574 <ip4_output_if_opt+0x10>
 8008570:	680a      	ldr	r2, [r1, #0]
 8008572:	b902      	cbnz	r2, 8008576 <ip4_output_if_opt+0x12>
      src_used = netif_ip4_addr(netif);
 8008574:	1d21      	adds	r1, r4, #4
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
 8008576:	f8bd 2038 	ldrh.w	r2, [sp, #56]	; 0x38
 800857a:	9204      	str	r2, [sp, #16]
 800857c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800857e:	9203      	str	r2, [sp, #12]
 8008580:	9402      	str	r4, [sp, #8]
 8008582:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 8008586:	9201      	str	r2, [sp, #4]
 8008588:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
 800858c:	9200      	str	r2, [sp, #0]
 800858e:	462a      	mov	r2, r5
 8008590:	f7ff ff44 	bl	800841c <ip4_output_if_opt_src>
}
 8008594:	b007      	add	sp, #28
 8008596:	bd30      	pop	{r4, r5, pc}

08008598 <ip4_output_if>:
{
 8008598:	b510      	push	{r4, lr}
 800859a:	b086      	sub	sp, #24
  return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 800859c:	2400      	movs	r4, #0
 800859e:	9404      	str	r4, [sp, #16]
 80085a0:	9403      	str	r4, [sp, #12]
 80085a2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80085a4:	9402      	str	r4, [sp, #8]
 80085a6:	f89d 4024 	ldrb.w	r4, [sp, #36]	; 0x24
 80085aa:	9401      	str	r4, [sp, #4]
 80085ac:	f89d 4020 	ldrb.w	r4, [sp, #32]
 80085b0:	9400      	str	r4, [sp, #0]
 80085b2:	f7ff ffd7 	bl	8008564 <ip4_output_if_opt>
}
 80085b6:	b006      	add	sp, #24
 80085b8:	bd10      	pop	{r4, pc}

080085ba <ip4_output_if_src>:
{
 80085ba:	b510      	push	{r4, lr}
 80085bc:	b086      	sub	sp, #24
  return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 80085be:	2400      	movs	r4, #0
 80085c0:	9404      	str	r4, [sp, #16]
 80085c2:	9403      	str	r4, [sp, #12]
 80085c4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80085c6:	9402      	str	r4, [sp, #8]
 80085c8:	f89d 4024 	ldrb.w	r4, [sp, #36]	; 0x24
 80085cc:	9401      	str	r4, [sp, #4]
 80085ce:	f89d 4020 	ldrb.w	r4, [sp, #32]
 80085d2:	9400      	str	r4, [sp, #0]
 80085d4:	f7ff ff22 	bl	800841c <ip4_output_if_opt_src>
}
 80085d8:	b006      	add	sp, #24
 80085da:	bd10      	pop	{r4, pc}

080085dc <ip4_addr_isbroadcast_u32>:
{
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 80085dc:	1e43      	subs	r3, r0, #1
 80085de:	f113 0f03 	cmn.w	r3, #3
 80085e2:	d811      	bhi.n	8008608 <ip4_addr_isbroadcast_u32+0x2c>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 80085e4:	f891 302f 	ldrb.w	r3, [r1, #47]	; 0x2f
 80085e8:	f013 0f02 	tst.w	r3, #2
 80085ec:	d00e      	beq.n	800860c <ip4_addr_isbroadcast_u32+0x30>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 80085ee:	684b      	ldr	r3, [r1, #4]
 80085f0:	4283      	cmp	r3, r0
 80085f2:	d00d      	beq.n	8008610 <ip4_addr_isbroadcast_u32+0x34>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 80085f4:	688a      	ldr	r2, [r1, #8]
 80085f6:	4043      	eors	r3, r0
 80085f8:	4213      	tst	r3, r2
 80085fa:	d10b      	bne.n	8008614 <ip4_addr_isbroadcast_u32+0x38>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 80085fc:	43d2      	mvns	r2, r2
 80085fe:	ea32 0300 	bics.w	r3, r2, r0
 8008602:	d009      	beq.n	8008618 <ip4_addr_isbroadcast_u32+0x3c>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 8008604:	2000      	movs	r0, #0
 8008606:	4770      	bx	lr
    return 1;
 8008608:	2001      	movs	r0, #1
 800860a:	4770      	bx	lr
    return 0;
 800860c:	2000      	movs	r0, #0
 800860e:	4770      	bx	lr
    return 0;
 8008610:	2000      	movs	r0, #0
 8008612:	4770      	bx	lr
    return 0;
 8008614:	2000      	movs	r0, #0
 8008616:	4770      	bx	lr
    return 1;
 8008618:	2001      	movs	r0, #1
  }
}
 800861a:	4770      	bx	lr

0800861c <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800861c:	b538      	push	{r3, r4, r5, lr}
 800861e:	4604      	mov	r4, r0
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 8008620:	4b0c      	ldr	r3, [pc, #48]	; (8008654 <ip_reass_dequeue_datagram+0x38>)
 8008622:	681b      	ldr	r3, [r3, #0]
 8008624:	4283      	cmp	r3, r0
 8008626:	d008      	beq.n	800863a <ip_reass_dequeue_datagram+0x1e>
 8008628:	460d      	mov	r5, r1
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 800862a:	b151      	cbz	r1, 8008642 <ip_reass_dequeue_datagram+0x26>
    prev->next = ipr->next;
 800862c:	6823      	ldr	r3, [r4, #0]
 800862e:	602b      	str	r3, [r5, #0]
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
 8008630:	4621      	mov	r1, r4
 8008632:	2001      	movs	r0, #1
 8008634:	f7fd fd7c 	bl	8006130 <memp_free>
}
 8008638:	bd38      	pop	{r3, r4, r5, pc}
    reassdatagrams = ipr->next;
 800863a:	6802      	ldr	r2, [r0, #0]
 800863c:	4b05      	ldr	r3, [pc, #20]	; (8008654 <ip_reass_dequeue_datagram+0x38>)
 800863e:	601a      	str	r2, [r3, #0]
 8008640:	e7f6      	b.n	8008630 <ip_reass_dequeue_datagram+0x14>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 8008642:	4b05      	ldr	r3, [pc, #20]	; (8008658 <ip_reass_dequeue_datagram+0x3c>)
 8008644:	f240 1245 	movw	r2, #325	; 0x145
 8008648:	4904      	ldr	r1, [pc, #16]	; (800865c <ip_reass_dequeue_datagram+0x40>)
 800864a:	4805      	ldr	r0, [pc, #20]	; (8008660 <ip_reass_dequeue_datagram+0x44>)
 800864c:	f006 ff2e 	bl	800f4ac <iprintf>
 8008650:	e7ec      	b.n	800862c <ip_reass_dequeue_datagram+0x10>
 8008652:	bf00      	nop
 8008654:	200033f0 	.word	0x200033f0
 8008658:	08011964 	.word	0x08011964
 800865c:	080119a0 	.word	0x080119a0
 8008660:	080109f4 	.word	0x080109f4

08008664 <ip_reass_free_complete_datagram>:
{
 8008664:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008668:	4680      	mov	r8, r0
 800866a:	4689      	mov	r9, r1
  LWIP_ASSERT("prev != ipr", prev != ipr);
 800866c:	4281      	cmp	r1, r0
 800866e:	d015      	beq.n	800869c <ip_reass_free_complete_datagram+0x38>
  if (prev != NULL) {
 8008670:	f1b9 0f00 	cmp.w	r9, #0
 8008674:	d009      	beq.n	800868a <ip_reass_free_complete_datagram+0x26>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 8008676:	f8d9 3000 	ldr.w	r3, [r9]
 800867a:	4543      	cmp	r3, r8
 800867c:	d005      	beq.n	800868a <ip_reass_free_complete_datagram+0x26>
 800867e:	4b30      	ldr	r3, [pc, #192]	; (8008740 <ip_reass_free_complete_datagram+0xdc>)
 8008680:	22ad      	movs	r2, #173	; 0xad
 8008682:	4930      	ldr	r1, [pc, #192]	; (8008744 <ip_reass_free_complete_datagram+0xe0>)
 8008684:	4830      	ldr	r0, [pc, #192]	; (8008748 <ip_reass_free_complete_datagram+0xe4>)
 8008686:	f006 ff11 	bl	800f4ac <iprintf>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 800868a:	f8d8 4004 	ldr.w	r4, [r8, #4]
 800868e:	6863      	ldr	r3, [r4, #4]
  if (iprh->start == 0) {
 8008690:	889a      	ldrh	r2, [r3, #4]
 8008692:	b152      	cbz	r2, 80086aa <ip_reass_free_complete_datagram+0x46>
  u16_t pbufs_freed = 0;
 8008694:	2600      	movs	r6, #0
  p = ipr->p;
 8008696:	f8d8 4004 	ldr.w	r4, [r8, #4]
  while (p != NULL) {
 800869a:	e028      	b.n	80086ee <ip_reass_free_complete_datagram+0x8a>
  LWIP_ASSERT("prev != ipr", prev != ipr);
 800869c:	4b28      	ldr	r3, [pc, #160]	; (8008740 <ip_reass_free_complete_datagram+0xdc>)
 800869e:	22ab      	movs	r2, #171	; 0xab
 80086a0:	492a      	ldr	r1, [pc, #168]	; (800874c <ip_reass_free_complete_datagram+0xe8>)
 80086a2:	4829      	ldr	r0, [pc, #164]	; (8008748 <ip_reass_free_complete_datagram+0xe4>)
 80086a4:	f006 ff02 	bl	800f4ac <iprintf>
 80086a8:	e7e2      	b.n	8008670 <ip_reass_free_complete_datagram+0xc>
    ipr->p = iprh->next_pbuf;
 80086aa:	681b      	ldr	r3, [r3, #0]
 80086ac:	f8c8 3004 	str.w	r3, [r8, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 80086b0:	4643      	mov	r3, r8
 80086b2:	6862      	ldr	r2, [r4, #4]
 80086b4:	f853 1f08 	ldr.w	r1, [r3, #8]!
 80086b8:	685e      	ldr	r6, [r3, #4]
 80086ba:	689d      	ldr	r5, [r3, #8]
 80086bc:	68d8      	ldr	r0, [r3, #12]
 80086be:	6011      	str	r1, [r2, #0]
 80086c0:	6056      	str	r6, [r2, #4]
 80086c2:	6095      	str	r5, [r2, #8]
 80086c4:	60d0      	str	r0, [r2, #12]
 80086c6:	6919      	ldr	r1, [r3, #16]
 80086c8:	6111      	str	r1, [r2, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 80086ca:	2101      	movs	r1, #1
 80086cc:	4620      	mov	r0, r4
 80086ce:	f7ff fb23 	bl	8007d18 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 80086d2:	4620      	mov	r0, r4
 80086d4:	f7fe f8aa 	bl	800682c <pbuf_clen>
 80086d8:	4606      	mov	r6, r0
    pbuf_free(p);
 80086da:	4620      	mov	r0, r4
 80086dc:	f7fd fede 	bl	800649c <pbuf_free>
 80086e0:	e7d9      	b.n	8008696 <ip_reass_free_complete_datagram+0x32>
    pbufs_freed += clen;
 80086e2:	4435      	add	r5, r6
 80086e4:	b2ae      	uxth	r6, r5
    pbuf_free(pcur);
 80086e6:	4620      	mov	r0, r4
 80086e8:	f7fd fed8 	bl	800649c <pbuf_free>
    p = iprh->next_pbuf;
 80086ec:	463c      	mov	r4, r7
  while (p != NULL) {
 80086ee:	b184      	cbz	r4, 8008712 <ip_reass_free_complete_datagram+0xae>
    iprh = (struct ip_reass_helper *)p->payload;
 80086f0:	6863      	ldr	r3, [r4, #4]
    p = iprh->next_pbuf;
 80086f2:	681f      	ldr	r7, [r3, #0]
    clen = pbuf_clen(pcur);
 80086f4:	4620      	mov	r0, r4
 80086f6:	f7fe f899 	bl	800682c <pbuf_clen>
 80086fa:	4605      	mov	r5, r0
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 80086fc:	1833      	adds	r3, r6, r0
 80086fe:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8008702:	dbee      	blt.n	80086e2 <ip_reass_free_complete_datagram+0x7e>
 8008704:	4b0e      	ldr	r3, [pc, #56]	; (8008740 <ip_reass_free_complete_datagram+0xdc>)
 8008706:	22cc      	movs	r2, #204	; 0xcc
 8008708:	4911      	ldr	r1, [pc, #68]	; (8008750 <ip_reass_free_complete_datagram+0xec>)
 800870a:	480f      	ldr	r0, [pc, #60]	; (8008748 <ip_reass_free_complete_datagram+0xe4>)
 800870c:	f006 fece 	bl	800f4ac <iprintf>
 8008710:	e7e7      	b.n	80086e2 <ip_reass_free_complete_datagram+0x7e>
  ip_reass_dequeue_datagram(ipr, prev);
 8008712:	4649      	mov	r1, r9
 8008714:	4640      	mov	r0, r8
 8008716:	f7ff ff81 	bl	800861c <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 800871a:	4b0e      	ldr	r3, [pc, #56]	; (8008754 <ip_reass_free_complete_datagram+0xf0>)
 800871c:	889b      	ldrh	r3, [r3, #4]
 800871e:	42b3      	cmp	r3, r6
 8008720:	d306      	bcc.n	8008730 <ip_reass_free_complete_datagram+0xcc>
  ip_reass_pbufcount -= pbufs_freed;
 8008722:	4a0c      	ldr	r2, [pc, #48]	; (8008754 <ip_reass_free_complete_datagram+0xf0>)
 8008724:	8893      	ldrh	r3, [r2, #4]
 8008726:	1b9b      	subs	r3, r3, r6
 8008728:	8093      	strh	r3, [r2, #4]
}
 800872a:	4630      	mov	r0, r6
 800872c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 8008730:	4b03      	ldr	r3, [pc, #12]	; (8008740 <ip_reass_free_complete_datagram+0xdc>)
 8008732:	22d2      	movs	r2, #210	; 0xd2
 8008734:	4908      	ldr	r1, [pc, #32]	; (8008758 <ip_reass_free_complete_datagram+0xf4>)
 8008736:	4804      	ldr	r0, [pc, #16]	; (8008748 <ip_reass_free_complete_datagram+0xe4>)
 8008738:	f006 feb8 	bl	800f4ac <iprintf>
 800873c:	e7f1      	b.n	8008722 <ip_reass_free_complete_datagram+0xbe>
 800873e:	bf00      	nop
 8008740:	08011964 	.word	0x08011964
 8008744:	080119c8 	.word	0x080119c8
 8008748:	080109f4 	.word	0x080109f4
 800874c:	080119bc 	.word	0x080119bc
 8008750:	080119dc 	.word	0x080119dc
 8008754:	200033f0 	.word	0x200033f0
 8008758:	080119fc 	.word	0x080119fc

0800875c <ip_reass_remove_oldest_datagram>:
{
 800875c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008760:	4606      	mov	r6, r0
 8008762:	4688      	mov	r8, r1
  int pbufs_freed = 0, pbufs_freed_current;
 8008764:	2700      	movs	r7, #0
 8008766:	e02f      	b.n	80087c8 <ip_reass_remove_oldest_datagram+0x6c>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8008768:	699a      	ldr	r2, [r3, #24]
 800876a:	f8d6 c010 	ldr.w	ip, [r6, #16]
 800876e:	4562      	cmp	r2, ip
 8008770:	d111      	bne.n	8008796 <ip_reass_remove_oldest_datagram+0x3a>
 8008772:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
 8008776:	88b2      	ldrh	r2, [r6, #4]
 8008778:	4594      	cmp	ip, r2
 800877a:	d10c      	bne.n	8008796 <ip_reass_remove_oldest_datagram+0x3a>
 800877c:	e001      	b.n	8008782 <ip_reass_remove_oldest_datagram+0x26>
          oldest_prev = prev;
 800877e:	4629      	mov	r1, r5
          oldest = r;
 8008780:	4618      	mov	r0, r3
      if (r->next != NULL) {
 8008782:	681a      	ldr	r2, [r3, #0]
 8008784:	b192      	cbz	r2, 80087ac <ip_reass_remove_oldest_datagram+0x50>
 8008786:	461d      	mov	r5, r3
 8008788:	4613      	mov	r3, r2
    while (r != NULL) {
 800878a:	b18b      	cbz	r3, 80087b0 <ip_reass_remove_oldest_datagram+0x54>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 800878c:	695a      	ldr	r2, [r3, #20]
 800878e:	f8d6 c00c 	ldr.w	ip, [r6, #12]
 8008792:	4562      	cmp	r2, ip
 8008794:	d0e8      	beq.n	8008768 <ip_reass_remove_oldest_datagram+0xc>
        other_datagrams++;
 8008796:	3401      	adds	r4, #1
        if (oldest == NULL) {
 8008798:	2800      	cmp	r0, #0
 800879a:	d0f0      	beq.n	800877e <ip_reass_remove_oldest_datagram+0x22>
        } else if (r->timer <= oldest->timer) {
 800879c:	f893 c01f 	ldrb.w	ip, [r3, #31]
 80087a0:	7fc2      	ldrb	r2, [r0, #31]
 80087a2:	4594      	cmp	ip, r2
 80087a4:	d8ed      	bhi.n	8008782 <ip_reass_remove_oldest_datagram+0x26>
          oldest_prev = prev;
 80087a6:	4629      	mov	r1, r5
          oldest = r;
 80087a8:	4618      	mov	r0, r3
 80087aa:	e7ea      	b.n	8008782 <ip_reass_remove_oldest_datagram+0x26>
      if (r->next != NULL) {
 80087ac:	462b      	mov	r3, r5
 80087ae:	e7ea      	b.n	8008786 <ip_reass_remove_oldest_datagram+0x2a>
    if (oldest != NULL) {
 80087b0:	b110      	cbz	r0, 80087b8 <ip_reass_remove_oldest_datagram+0x5c>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 80087b2:	f7ff ff57 	bl	8008664 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 80087b6:	4407      	add	r7, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 80087b8:	4547      	cmp	r7, r8
 80087ba:	bfac      	ite	ge
 80087bc:	2300      	movge	r3, #0
 80087be:	2301      	movlt	r3, #1
 80087c0:	2c01      	cmp	r4, #1
 80087c2:	bfd8      	it	le
 80087c4:	2300      	movle	r3, #0
 80087c6:	b133      	cbz	r3, 80087d6 <ip_reass_remove_oldest_datagram+0x7a>
    r = reassdatagrams;
 80087c8:	4b04      	ldr	r3, [pc, #16]	; (80087dc <ip_reass_remove_oldest_datagram+0x80>)
 80087ca:	681b      	ldr	r3, [r3, #0]
    other_datagrams = 0;
 80087cc:	2400      	movs	r4, #0
    oldest_prev = NULL;
 80087ce:	4621      	mov	r1, r4
    prev = NULL;
 80087d0:	4625      	mov	r5, r4
    oldest = NULL;
 80087d2:	4620      	mov	r0, r4
    while (r != NULL) {
 80087d4:	e7d9      	b.n	800878a <ip_reass_remove_oldest_datagram+0x2e>
}
 80087d6:	4638      	mov	r0, r7
 80087d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80087dc:	200033f0 	.word	0x200033f0

080087e0 <ip_frag_free_pbuf_custom_ref>:
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 80087e0:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
 80087e2:	4604      	mov	r4, r0
 80087e4:	b120      	cbz	r0, 80087f0 <ip_frag_free_pbuf_custom_ref+0x10>
  memp_free(MEMP_FRAG_PBUF, p);
 80087e6:	4621      	mov	r1, r4
 80087e8:	2002      	movs	r0, #2
 80087ea:	f7fd fca1 	bl	8006130 <memp_free>
}
 80087ee:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("p != NULL", p != NULL);
 80087f0:	4b03      	ldr	r3, [pc, #12]	; (8008800 <ip_frag_free_pbuf_custom_ref+0x20>)
 80087f2:	f240 22ae 	movw	r2, #686	; 0x2ae
 80087f6:	4903      	ldr	r1, [pc, #12]	; (8008804 <ip_frag_free_pbuf_custom_ref+0x24>)
 80087f8:	4803      	ldr	r0, [pc, #12]	; (8008808 <ip_frag_free_pbuf_custom_ref+0x28>)
 80087fa:	f006 fe57 	bl	800f4ac <iprintf>
 80087fe:	e7f2      	b.n	80087e6 <ip_frag_free_pbuf_custom_ref+0x6>
 8008800:	08011964 	.word	0x08011964
 8008804:	08010db4 	.word	0x08010db4
 8008808:	080109f4 	.word	0x080109f4

0800880c <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 800880c:	b510      	push	{r4, lr}
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 800880e:	4604      	mov	r4, r0
 8008810:	b138      	cbz	r0, 8008822 <ipfrag_free_pbuf_custom+0x16>
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 8008812:	6960      	ldr	r0, [r4, #20]
 8008814:	b108      	cbz	r0, 800881a <ipfrag_free_pbuf_custom+0xe>
    pbuf_free(pcr->original);
 8008816:	f7fd fe41 	bl	800649c <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 800881a:	4620      	mov	r0, r4
 800881c:	f7ff ffe0 	bl	80087e0 <ip_frag_free_pbuf_custom_ref>
}
 8008820:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 8008822:	4b04      	ldr	r3, [pc, #16]	; (8008834 <ipfrag_free_pbuf_custom+0x28>)
 8008824:	f44f 722e 	mov.w	r2, #696	; 0x2b8
 8008828:	4903      	ldr	r1, [pc, #12]	; (8008838 <ipfrag_free_pbuf_custom+0x2c>)
 800882a:	4804      	ldr	r0, [pc, #16]	; (800883c <ipfrag_free_pbuf_custom+0x30>)
 800882c:	f006 fe3e 	bl	800f4ac <iprintf>
 8008830:	e7ef      	b.n	8008812 <ipfrag_free_pbuf_custom+0x6>
 8008832:	bf00      	nop
 8008834:	08011964 	.word	0x08011964
 8008838:	08011a18 	.word	0x08011a18
 800883c:	080109f4 	.word	0x080109f4

08008840 <ip_reass_chain_frag_into_datagram_and_validate>:
{
 8008840:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008844:	4680      	mov	r8, r0
 8008846:	460f      	mov	r7, r1
 8008848:	4691      	mov	r9, r2
  fraghdr = (struct ip_hdr*)new_p->payload;
 800884a:	684c      	ldr	r4, [r1, #4]
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800884c:	8860      	ldrh	r0, [r4, #2]
 800884e:	f7fd f96d 	bl	8005b2c <lwip_htons>
 8008852:	7826      	ldrb	r6, [r4, #0]
 8008854:	f006 060f 	and.w	r6, r6, #15
 8008858:	eba0 0686 	sub.w	r6, r0, r6, lsl #2
 800885c:	b2b6      	uxth	r6, r6
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800885e:	88e0      	ldrh	r0, [r4, #6]
 8008860:	f7fd f964 	bl	8005b2c <lwip_htons>
 8008864:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8008868:	00c2      	lsls	r2, r0, #3
  iprh = (struct ip_reass_helper*)new_p->payload;
 800886a:	687d      	ldr	r5, [r7, #4]
  iprh->next_pbuf = NULL;
 800886c:	2400      	movs	r4, #0
 800886e:	702c      	strb	r4, [r5, #0]
 8008870:	706c      	strb	r4, [r5, #1]
 8008872:	70ac      	strb	r4, [r5, #2]
 8008874:	70ec      	strb	r4, [r5, #3]
  iprh->start = offset;
 8008876:	80aa      	strh	r2, [r5, #4]
  iprh->end = offset + len;
 8008878:	eb06 0c02 	add.w	ip, r6, r2
 800887c:	fa1f fc8c 	uxth.w	ip, ip
 8008880:	f8a5 c006 	strh.w	ip, [r5, #6]
  for (q = ipr->p; q != NULL;) {
 8008884:	f8d8 0004 	ldr.w	r0, [r8, #4]
  int valid = 1;
 8008888:	2601      	movs	r6, #1
  for (q = ipr->p; q != NULL;) {
 800888a:	e033      	b.n	80088f4 <ip_reass_chain_frag_into_datagram_and_validate+0xb4>
      iprh->next_pbuf = q;
 800888c:	6028      	str	r0, [r5, #0]
      if (iprh_prev != NULL) {
 800888e:	b34c      	cbz	r4, 80088e4 <ip_reass_chain_frag_into_datagram_and_validate+0xa4>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8008890:	88e1      	ldrh	r1, [r4, #6]
 8008892:	4291      	cmp	r1, r2
 8008894:	d87d      	bhi.n	8008992 <ip_reass_chain_frag_into_datagram_and_validate+0x152>
 8008896:	889b      	ldrh	r3, [r3, #4]
 8008898:	459c      	cmp	ip, r3
 800889a:	d87a      	bhi.n	8008992 <ip_reass_chain_frag_into_datagram_and_validate+0x152>
        iprh_prev->next_pbuf = new_p;
 800889c:	6027      	str	r7, [r4, #0]
        if (iprh_prev->end != iprh->start) {
 800889e:	88ab      	ldrh	r3, [r5, #4]
 80088a0:	4299      	cmp	r1, r3
 80088a2:	d000      	beq.n	80088a6 <ip_reass_chain_frag_into_datagram_and_validate+0x66>
          valid = 0;
 80088a4:	2600      	movs	r6, #0
  if (q == NULL) {
 80088a6:	2800      	cmp	r0, #0
 80088a8:	d036      	beq.n	8008918 <ip_reass_chain_frag_into_datagram_and_validate+0xd8>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 80088aa:	f1b9 0f00 	cmp.w	r9, #0
 80088ae:	d104      	bne.n	80088ba <ip_reass_chain_frag_into_datagram_and_validate+0x7a>
 80088b0:	f898 301e 	ldrb.w	r3, [r8, #30]
 80088b4:	f013 0f01 	tst.w	r3, #1
 80088b8:	d079      	beq.n	80089ae <ip_reass_chain_frag_into_datagram_and_validate+0x16e>
    if (valid) {
 80088ba:	2e00      	cmp	r6, #0
 80088bc:	d067      	beq.n	800898e <ip_reass_chain_frag_into_datagram_and_validate+0x14e>
      if ((ipr->p == NULL) || (((struct ip_reass_helper*)ipr->p->payload)->start != 0)) {
 80088be:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80088c2:	2b00      	cmp	r3, #0
 80088c4:	d060      	beq.n	8008988 <ip_reass_chain_frag_into_datagram_and_validate+0x148>
 80088c6:	6858      	ldr	r0, [r3, #4]
 80088c8:	8883      	ldrh	r3, [r0, #4]
 80088ca:	2b00      	cmp	r3, #0
 80088cc:	d15e      	bne.n	800898c <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
        q = iprh->next_pbuf;
 80088ce:	682a      	ldr	r2, [r5, #0]
        while (q != NULL) {
 80088d0:	2a00      	cmp	r2, #0
 80088d2:	d044      	beq.n	800895e <ip_reass_chain_frag_into_datagram_and_validate+0x11e>
          iprh = (struct ip_reass_helper*)q->payload;
 80088d4:	6853      	ldr	r3, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 80088d6:	88e9      	ldrh	r1, [r5, #6]
 80088d8:	889a      	ldrh	r2, [r3, #4]
 80088da:	4291      	cmp	r1, r2
 80088dc:	d13d      	bne.n	800895a <ip_reass_chain_frag_into_datagram_and_validate+0x11a>
          q = iprh->next_pbuf;
 80088de:	681a      	ldr	r2, [r3, #0]
          iprh = (struct ip_reass_helper*)q->payload;
 80088e0:	461d      	mov	r5, r3
 80088e2:	e7f5      	b.n	80088d0 <ip_reass_chain_frag_into_datagram_and_validate+0x90>
        if (iprh->end > iprh_tmp->start) {
 80088e4:	889b      	ldrh	r3, [r3, #4]
 80088e6:	459c      	cmp	ip, r3
 80088e8:	d853      	bhi.n	8008992 <ip_reass_chain_frag_into_datagram_and_validate+0x152>
        ipr->p = new_p;
 80088ea:	f8c8 7004 	str.w	r7, [r8, #4]
 80088ee:	e7da      	b.n	80088a6 <ip_reass_chain_frag_into_datagram_and_validate+0x66>
    q = iprh_tmp->next_pbuf;
 80088f0:	6818      	ldr	r0, [r3, #0]
    iprh_prev = iprh_tmp;
 80088f2:	461c      	mov	r4, r3
  for (q = ipr->p; q != NULL;) {
 80088f4:	2800      	cmp	r0, #0
 80088f6:	d0d6      	beq.n	80088a6 <ip_reass_chain_frag_into_datagram_and_validate+0x66>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 80088f8:	6843      	ldr	r3, [r0, #4]
    if (iprh->start < iprh_tmp->start) {
 80088fa:	8899      	ldrh	r1, [r3, #4]
 80088fc:	4291      	cmp	r1, r2
 80088fe:	d8c5      	bhi.n	800888c <ip_reass_chain_frag_into_datagram_and_validate+0x4c>
    } else if (iprh->start == iprh_tmp->start) {
 8008900:	4291      	cmp	r1, r2
 8008902:	d046      	beq.n	8008992 <ip_reass_chain_frag_into_datagram_and_validate+0x152>
    } else if (iprh->start < iprh_tmp->end) {
 8008904:	88d8      	ldrh	r0, [r3, #6]
 8008906:	4290      	cmp	r0, r2
 8008908:	d843      	bhi.n	8008992 <ip_reass_chain_frag_into_datagram_and_validate+0x152>
      if (iprh_prev != NULL) {
 800890a:	2c00      	cmp	r4, #0
 800890c:	d0f0      	beq.n	80088f0 <ip_reass_chain_frag_into_datagram_and_validate+0xb0>
        if (iprh_prev->end != iprh_tmp->start) {
 800890e:	88e0      	ldrh	r0, [r4, #6]
 8008910:	4281      	cmp	r1, r0
 8008912:	d0ed      	beq.n	80088f0 <ip_reass_chain_frag_into_datagram_and_validate+0xb0>
          valid = 0;
 8008914:	2600      	movs	r6, #0
 8008916:	e7eb      	b.n	80088f0 <ip_reass_chain_frag_into_datagram_and_validate+0xb0>
    if (iprh_prev != NULL) {
 8008918:	b194      	cbz	r4, 8008940 <ip_reass_chain_frag_into_datagram_and_validate+0x100>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800891a:	88e2      	ldrh	r2, [r4, #6]
 800891c:	88ab      	ldrh	r3, [r5, #4]
 800891e:	429a      	cmp	r2, r3
 8008920:	d806      	bhi.n	8008930 <ip_reass_chain_frag_into_datagram_and_validate+0xf0>
      iprh_prev->next_pbuf = new_p;
 8008922:	6027      	str	r7, [r4, #0]
      if (iprh_prev->end != iprh->start) {
 8008924:	88e2      	ldrh	r2, [r4, #6]
 8008926:	88ab      	ldrh	r3, [r5, #4]
 8008928:	429a      	cmp	r2, r3
 800892a:	d0be      	beq.n	80088aa <ip_reass_chain_frag_into_datagram_and_validate+0x6a>
        valid = 0;
 800892c:	2600      	movs	r6, #0
 800892e:	e7bc      	b.n	80088aa <ip_reass_chain_frag_into_datagram_and_validate+0x6a>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 8008930:	4b20      	ldr	r3, [pc, #128]	; (80089b4 <ip_reass_chain_frag_into_datagram_and_validate+0x174>)
 8008932:	f240 12ab 	movw	r2, #427	; 0x1ab
 8008936:	4920      	ldr	r1, [pc, #128]	; (80089b8 <ip_reass_chain_frag_into_datagram_and_validate+0x178>)
 8008938:	4820      	ldr	r0, [pc, #128]	; (80089bc <ip_reass_chain_frag_into_datagram_and_validate+0x17c>)
 800893a:	f006 fdb7 	bl	800f4ac <iprintf>
 800893e:	e7f0      	b.n	8008922 <ip_reass_chain_frag_into_datagram_and_validate+0xe2>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
 8008940:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8008944:	b133      	cbz	r3, 8008954 <ip_reass_chain_frag_into_datagram_and_validate+0x114>
 8008946:	4b1b      	ldr	r3, [pc, #108]	; (80089b4 <ip_reass_chain_frag_into_datagram_and_validate+0x174>)
 8008948:	f44f 72da 	mov.w	r2, #436	; 0x1b4
 800894c:	491c      	ldr	r1, [pc, #112]	; (80089c0 <ip_reass_chain_frag_into_datagram_and_validate+0x180>)
 800894e:	481b      	ldr	r0, [pc, #108]	; (80089bc <ip_reass_chain_frag_into_datagram_and_validate+0x17c>)
 8008950:	f006 fdac 	bl	800f4ac <iprintf>
      ipr->p = new_p;
 8008954:	f8c8 7004 	str.w	r7, [r8, #4]
 8008958:	e7a7      	b.n	80088aa <ip_reass_chain_frag_into_datagram_and_validate+0x6a>
          iprh = (struct ip_reass_helper*)q->payload;
 800895a:	461d      	mov	r5, r3
            valid = 0;
 800895c:	2600      	movs	r6, #0
        if (valid) {
 800895e:	b1b6      	cbz	r6, 800898e <ip_reass_chain_frag_into_datagram_and_validate+0x14e>
          LWIP_ASSERT("sanity check",
 8008960:	42a8      	cmp	r0, r5
 8008962:	d009      	beq.n	8008978 <ip_reass_chain_frag_into_datagram_and_validate+0x138>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 8008964:	682b      	ldr	r3, [r5, #0]
 8008966:	b193      	cbz	r3, 800898e <ip_reass_chain_frag_into_datagram_and_validate+0x14e>
 8008968:	4b12      	ldr	r3, [pc, #72]	; (80089b4 <ip_reass_chain_frag_into_datagram_and_validate+0x174>)
 800896a:	f44f 72ec 	mov.w	r2, #472	; 0x1d8
 800896e:	4915      	ldr	r1, [pc, #84]	; (80089c4 <ip_reass_chain_frag_into_datagram_and_validate+0x184>)
 8008970:	4812      	ldr	r0, [pc, #72]	; (80089bc <ip_reass_chain_frag_into_datagram_and_validate+0x17c>)
 8008972:	f006 fd9b 	bl	800f4ac <iprintf>
 8008976:	e00a      	b.n	800898e <ip_reass_chain_frag_into_datagram_and_validate+0x14e>
          LWIP_ASSERT("sanity check",
 8008978:	4b0e      	ldr	r3, [pc, #56]	; (80089b4 <ip_reass_chain_frag_into_datagram_and_validate+0x174>)
 800897a:	f44f 72eb 	mov.w	r2, #470	; 0x1d6
 800897e:	4912      	ldr	r1, [pc, #72]	; (80089c8 <ip_reass_chain_frag_into_datagram_and_validate+0x188>)
 8008980:	480e      	ldr	r0, [pc, #56]	; (80089bc <ip_reass_chain_frag_into_datagram_and_validate+0x17c>)
 8008982:	f006 fd93 	bl	800f4ac <iprintf>
 8008986:	e7ed      	b.n	8008964 <ip_reass_chain_frag_into_datagram_and_validate+0x124>
        valid = 0;
 8008988:	2600      	movs	r6, #0
 800898a:	e000      	b.n	800898e <ip_reass_chain_frag_into_datagram_and_validate+0x14e>
 800898c:	2600      	movs	r6, #0
    return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
 800898e:	4630      	mov	r0, r6
 8008990:	e00b      	b.n	80089aa <ip_reass_chain_frag_into_datagram_and_validate+0x16a>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 8008992:	4638      	mov	r0, r7
 8008994:	f7fd ff4a 	bl	800682c <pbuf_clen>
 8008998:	4a0c      	ldr	r2, [pc, #48]	; (80089cc <ip_reass_chain_frag_into_datagram_and_validate+0x18c>)
 800899a:	8893      	ldrh	r3, [r2, #4]
 800899c:	1a18      	subs	r0, r3, r0
 800899e:	8090      	strh	r0, [r2, #4]
  pbuf_free(new_p);
 80089a0:	4638      	mov	r0, r7
 80089a2:	f7fd fd7b 	bl	800649c <pbuf_free>
  return IP_REASS_VALIDATE_PBUF_DROPPED;
 80089a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80089aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 80089ae:	4648      	mov	r0, r9
 80089b0:	e7fb      	b.n	80089aa <ip_reass_chain_frag_into_datagram_and_validate+0x16a>
 80089b2:	bf00      	nop
 80089b4:	08011964 	.word	0x08011964
 80089b8:	08011a24 	.word	0x08011a24
 80089bc:	080109f4 	.word	0x080109f4
 80089c0:	08011a44 	.word	0x08011a44
 80089c4:	08011a8c 	.word	0x08011a8c
 80089c8:	08011a7c 	.word	0x08011a7c
 80089cc:	200033f0 	.word	0x200033f0

080089d0 <ip_frag_alloc_pbuf_custom_ref>:
{
 80089d0:	b508      	push	{r3, lr}
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 80089d2:	2002      	movs	r0, #2
 80089d4:	f7fd fb92 	bl	80060fc <memp_malloc>
}
 80089d8:	bd08      	pop	{r3, pc}
	...

080089dc <ip_reass_enqueue_new_datagram>:
{
 80089dc:	b570      	push	{r4, r5, r6, lr}
 80089de:	4605      	mov	r5, r0
 80089e0:	460e      	mov	r6, r1
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 80089e2:	2001      	movs	r0, #1
 80089e4:	f7fd fb8a 	bl	80060fc <memp_malloc>
  if (ipr == NULL) {
 80089e8:	4604      	mov	r4, r0
 80089ea:	b1c8      	cbz	r0, 8008a20 <ip_reass_enqueue_new_datagram+0x44>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 80089ec:	2200      	movs	r2, #0
 80089ee:	6062      	str	r2, [r4, #4]
 80089f0:	60a2      	str	r2, [r4, #8]
 80089f2:	60e2      	str	r2, [r4, #12]
 80089f4:	6122      	str	r2, [r4, #16]
 80089f6:	6162      	str	r2, [r4, #20]
 80089f8:	61a2      	str	r2, [r4, #24]
 80089fa:	61e2      	str	r2, [r4, #28]
  ipr->timer = IP_REASS_MAXAGE;
 80089fc:	2303      	movs	r3, #3
 80089fe:	77e3      	strb	r3, [r4, #31]
  ipr->next = reassdatagrams;
 8008a00:	4b0e      	ldr	r3, [pc, #56]	; (8008a3c <ip_reass_enqueue_new_datagram+0x60>)
 8008a02:	681a      	ldr	r2, [r3, #0]
 8008a04:	6022      	str	r2, [r4, #0]
  reassdatagrams = ipr;
 8008a06:	601c      	str	r4, [r3, #0]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8008a08:	682a      	ldr	r2, [r5, #0]
 8008a0a:	686e      	ldr	r6, [r5, #4]
 8008a0c:	68a8      	ldr	r0, [r5, #8]
 8008a0e:	68e9      	ldr	r1, [r5, #12]
 8008a10:	60a2      	str	r2, [r4, #8]
 8008a12:	60e6      	str	r6, [r4, #12]
 8008a14:	6120      	str	r0, [r4, #16]
 8008a16:	6161      	str	r1, [r4, #20]
 8008a18:	692a      	ldr	r2, [r5, #16]
 8008a1a:	61a2      	str	r2, [r4, #24]
}
 8008a1c:	4620      	mov	r0, r4
 8008a1e:	bd70      	pop	{r4, r5, r6, pc}
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8008a20:	4631      	mov	r1, r6
 8008a22:	4628      	mov	r0, r5
 8008a24:	f7ff fe9a 	bl	800875c <ip_reass_remove_oldest_datagram>
 8008a28:	42b0      	cmp	r0, r6
 8008a2a:	da02      	bge.n	8008a32 <ip_reass_enqueue_new_datagram+0x56>
    if (ipr == NULL)
 8008a2c:	2c00      	cmp	r4, #0
 8008a2e:	d1dd      	bne.n	80089ec <ip_reass_enqueue_new_datagram+0x10>
 8008a30:	e7f4      	b.n	8008a1c <ip_reass_enqueue_new_datagram+0x40>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8008a32:	2001      	movs	r0, #1
 8008a34:	f7fd fb62 	bl	80060fc <memp_malloc>
 8008a38:	4604      	mov	r4, r0
 8008a3a:	e7f7      	b.n	8008a2c <ip_reass_enqueue_new_datagram+0x50>
 8008a3c:	200033f0 	.word	0x200033f0

08008a40 <ip_reass_tmr>:
{
 8008a40:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 8008a42:	4b09      	ldr	r3, [pc, #36]	; (8008a68 <ip_reass_tmr+0x28>)
 8008a44:	6818      	ldr	r0, [r3, #0]
  struct ip_reassdata *r, *prev = NULL;
 8008a46:	2400      	movs	r4, #0
  while (r != NULL) {
 8008a48:	e004      	b.n	8008a54 <ip_reass_tmr+0x14>
      r = r->next;
 8008a4a:	6805      	ldr	r5, [r0, #0]
      ip_reass_free_complete_datagram(tmp, prev);
 8008a4c:	4621      	mov	r1, r4
 8008a4e:	f7ff fe09 	bl	8008664 <ip_reass_free_complete_datagram>
      r = r->next;
 8008a52:	4628      	mov	r0, r5
  while (r != NULL) {
 8008a54:	b138      	cbz	r0, 8008a66 <ip_reass_tmr+0x26>
    if (r->timer > 0) {
 8008a56:	7fc3      	ldrb	r3, [r0, #31]
 8008a58:	2b00      	cmp	r3, #0
 8008a5a:	d0f6      	beq.n	8008a4a <ip_reass_tmr+0xa>
      r->timer--;
 8008a5c:	3b01      	subs	r3, #1
 8008a5e:	77c3      	strb	r3, [r0, #31]
      prev = r;
 8008a60:	4604      	mov	r4, r0
      r = r->next;
 8008a62:	6800      	ldr	r0, [r0, #0]
 8008a64:	e7f6      	b.n	8008a54 <ip_reass_tmr+0x14>
}
 8008a66:	bd38      	pop	{r3, r4, r5, pc}
 8008a68:	200033f0 	.word	0x200033f0

08008a6c <ip4_reass>:
{
 8008a6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008a70:	4681      	mov	r9, r0
  fraghdr = (struct ip_hdr*)p->payload;
 8008a72:	6845      	ldr	r5, [r0, #4]
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 8008a74:	782b      	ldrb	r3, [r5, #0]
 8008a76:	f003 030f 	and.w	r3, r3, #15
 8008a7a:	2b05      	cmp	r3, #5
 8008a7c:	d124      	bne.n	8008ac8 <ip4_reass+0x5c>
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8008a7e:	88e8      	ldrh	r0, [r5, #6]
 8008a80:	f7fd f854 	bl	8005b2c <lwip_htons>
 8008a84:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8008a88:	00c7      	lsls	r7, r0, #3
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8008a8a:	8868      	ldrh	r0, [r5, #2]
 8008a8c:	f7fd f84e 	bl	8005b2c <lwip_htons>
 8008a90:	782e      	ldrb	r6, [r5, #0]
 8008a92:	f006 060f 	and.w	r6, r6, #15
 8008a96:	eba0 0686 	sub.w	r6, r0, r6, lsl #2
 8008a9a:	b2b6      	uxth	r6, r6
  clen = pbuf_clen(p);
 8008a9c:	4648      	mov	r0, r9
 8008a9e:	f7fd fec5 	bl	800682c <pbuf_clen>
 8008aa2:	4680      	mov	r8, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 8008aa4:	4b59      	ldr	r3, [pc, #356]	; (8008c0c <ip4_reass+0x1a0>)
 8008aa6:	889b      	ldrh	r3, [r3, #4]
 8008aa8:	4403      	add	r3, r0
 8008aaa:	2b0a      	cmp	r3, #10
 8008aac:	dc02      	bgt.n	8008ab4 <ip4_reass+0x48>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8008aae:	4b57      	ldr	r3, [pc, #348]	; (8008c0c <ip4_reass+0x1a0>)
 8008ab0:	681c      	ldr	r4, [r3, #0]
 8008ab2:	e00f      	b.n	8008ad4 <ip4_reass+0x68>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8008ab4:	4601      	mov	r1, r0
 8008ab6:	4628      	mov	r0, r5
 8008ab8:	f7ff fe50 	bl	800875c <ip_reass_remove_oldest_datagram>
 8008abc:	b120      	cbz	r0, 8008ac8 <ip4_reass+0x5c>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 8008abe:	4b53      	ldr	r3, [pc, #332]	; (8008c0c <ip4_reass+0x1a0>)
 8008ac0:	889b      	ldrh	r3, [r3, #4]
 8008ac2:	4443      	add	r3, r8
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8008ac4:	2b0a      	cmp	r3, #10
 8008ac6:	ddf2      	ble.n	8008aae <ip4_reass+0x42>
  pbuf_free(p);
 8008ac8:	4648      	mov	r0, r9
 8008aca:	f7fd fce7 	bl	800649c <pbuf_free>
  return NULL;
 8008ace:	2700      	movs	r7, #0
 8008ad0:	e096      	b.n	8008c00 <ip4_reass+0x194>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8008ad2:	6824      	ldr	r4, [r4, #0]
 8008ad4:	b15c      	cbz	r4, 8008aee <ip4_reass+0x82>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8008ad6:	6962      	ldr	r2, [r4, #20]
 8008ad8:	68eb      	ldr	r3, [r5, #12]
 8008ada:	429a      	cmp	r2, r3
 8008adc:	d1f9      	bne.n	8008ad2 <ip4_reass+0x66>
 8008ade:	69a2      	ldr	r2, [r4, #24]
 8008ae0:	692b      	ldr	r3, [r5, #16]
 8008ae2:	429a      	cmp	r2, r3
 8008ae4:	d1f5      	bne.n	8008ad2 <ip4_reass+0x66>
 8008ae6:	89a2      	ldrh	r2, [r4, #12]
 8008ae8:	88ab      	ldrh	r3, [r5, #4]
 8008aea:	429a      	cmp	r2, r3
 8008aec:	d1f1      	bne.n	8008ad2 <ip4_reass+0x66>
  if (ipr == NULL) {
 8008aee:	2c00      	cmp	r4, #0
 8008af0:	d048      	beq.n	8008b84 <ip4_reass+0x118>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 8008af2:	88e8      	ldrh	r0, [r5, #6]
 8008af4:	f7fd f81a 	bl	8005b2c <lwip_htons>
 8008af8:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8008afc:	2800      	cmp	r0, #0
 8008afe:	d049      	beq.n	8008b94 <ip4_reass+0x128>
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 8008b00:	88ed      	ldrh	r5, [r5, #6]
 8008b02:	f005 0520 	and.w	r5, r5, #32
 8008b06:	2d00      	cmp	r5, #0
 8008b08:	bf0c      	ite	eq
 8008b0a:	2201      	moveq	r2, #1
 8008b0c:	2200      	movne	r2, #0
  if (is_last) {
 8008b0e:	d107      	bne.n	8008b20 <ip4_reass+0xb4>
    u16_t datagram_len = (u16_t)(offset + len);
 8008b10:	19bb      	adds	r3, r7, r6
 8008b12:	b29b      	uxth	r3, r3
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 8008b14:	f64f 71eb 	movw	r1, #65515	; 0xffeb
 8008b18:	428b      	cmp	r3, r1
 8008b1a:	bf98      	it	ls
 8008b1c:	429f      	cmpls	r7, r3
 8008b1e:	d8d3      	bhi.n	8008ac8 <ip4_reass+0x5c>
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
 8008b20:	4649      	mov	r1, r9
 8008b22:	4620      	mov	r0, r4
 8008b24:	f7ff fe8c 	bl	8008840 <ip_reass_chain_frag_into_datagram_and_validate>
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 8008b28:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8008b2c:	d0cc      	beq.n	8008ac8 <ip4_reass+0x5c>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 8008b2e:	4b37      	ldr	r3, [pc, #220]	; (8008c0c <ip4_reass+0x1a0>)
 8008b30:	889a      	ldrh	r2, [r3, #4]
 8008b32:	4490      	add	r8, r2
 8008b34:	f8a3 8004 	strh.w	r8, [r3, #4]
  if (is_last) {
 8008b38:	b92d      	cbnz	r5, 8008b46 <ip4_reass+0xda>
    u16_t datagram_len = (u16_t)(offset + len);
 8008b3a:	443e      	add	r6, r7
    ipr->datagram_len = datagram_len;
 8008b3c:	83a6      	strh	r6, [r4, #28]
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8008b3e:	7fa3      	ldrb	r3, [r4, #30]
 8008b40:	f043 0301 	orr.w	r3, r3, #1
 8008b44:	77a3      	strb	r3, [r4, #30]
  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 8008b46:	2801      	cmp	r0, #1
 8008b48:	d15d      	bne.n	8008c06 <ip4_reass+0x19a>
    ipr->datagram_len += IP_HLEN;
 8008b4a:	8ba3      	ldrh	r3, [r4, #28]
 8008b4c:	3314      	adds	r3, #20
 8008b4e:	83a3      	strh	r3, [r4, #28]
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 8008b50:	6863      	ldr	r3, [r4, #4]
 8008b52:	685e      	ldr	r6, [r3, #4]
 8008b54:	6835      	ldr	r5, [r6, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8008b56:	4623      	mov	r3, r4
 8008b58:	f853 2f08 	ldr.w	r2, [r3, #8]!
 8008b5c:	685f      	ldr	r7, [r3, #4]
 8008b5e:	6898      	ldr	r0, [r3, #8]
 8008b60:	68d9      	ldr	r1, [r3, #12]
 8008b62:	6032      	str	r2, [r6, #0]
 8008b64:	6077      	str	r7, [r6, #4]
 8008b66:	60b0      	str	r0, [r6, #8]
 8008b68:	60f1      	str	r1, [r6, #12]
 8008b6a:	691a      	ldr	r2, [r3, #16]
 8008b6c:	6132      	str	r2, [r6, #16]
    IPH_LEN_SET(fraghdr, lwip_htons(ipr->datagram_len));
 8008b6e:	8ba0      	ldrh	r0, [r4, #28]
 8008b70:	f7fc ffdc 	bl	8005b2c <lwip_htons>
 8008b74:	8070      	strh	r0, [r6, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 8008b76:	2300      	movs	r3, #0
 8008b78:	71b3      	strb	r3, [r6, #6]
 8008b7a:	71f3      	strb	r3, [r6, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8008b7c:	72b3      	strb	r3, [r6, #10]
 8008b7e:	72f3      	strb	r3, [r6, #11]
    p = ipr->p;
 8008b80:	6867      	ldr	r7, [r4, #4]
    while (r != NULL) {
 8008b82:	e026      	b.n	8008bd2 <ip4_reass+0x166>
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 8008b84:	4641      	mov	r1, r8
 8008b86:	4628      	mov	r0, r5
 8008b88:	f7ff ff28 	bl	80089dc <ip_reass_enqueue_new_datagram>
    if (ipr == NULL) {
 8008b8c:	4604      	mov	r4, r0
 8008b8e:	2800      	cmp	r0, #0
 8008b90:	d1b6      	bne.n	8008b00 <ip4_reass+0x94>
 8008b92:	e799      	b.n	8008ac8 <ip4_reass+0x5c>
      ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 8008b94:	89e0      	ldrh	r0, [r4, #14]
 8008b96:	f7fc ffc9 	bl	8005b2c <lwip_htons>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 8008b9a:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8008b9e:	2800      	cmp	r0, #0
 8008ba0:	d0ae      	beq.n	8008b00 <ip4_reass+0x94>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 8008ba2:	682a      	ldr	r2, [r5, #0]
 8008ba4:	f8d5 c004 	ldr.w	ip, [r5, #4]
 8008ba8:	68a8      	ldr	r0, [r5, #8]
 8008baa:	68e9      	ldr	r1, [r5, #12]
 8008bac:	60a2      	str	r2, [r4, #8]
 8008bae:	f8c4 c00c 	str.w	ip, [r4, #12]
 8008bb2:	6120      	str	r0, [r4, #16]
 8008bb4:	6161      	str	r1, [r4, #20]
 8008bb6:	692a      	ldr	r2, [r5, #16]
 8008bb8:	61a2      	str	r2, [r4, #24]
 8008bba:	e7a1      	b.n	8008b00 <ip4_reass+0x94>
      iprh = (struct ip_reass_helper*)r->payload;
 8008bbc:	686e      	ldr	r6, [r5, #4]
      pbuf_header(r, -IP_HLEN);
 8008bbe:	f06f 0113 	mvn.w	r1, #19
 8008bc2:	4628      	mov	r0, r5
 8008bc4:	f7fd fc60 	bl	8006488 <pbuf_header>
      pbuf_cat(p, r);
 8008bc8:	4629      	mov	r1, r5
 8008bca:	4638      	mov	r0, r7
 8008bcc:	f7fd fe54 	bl	8006878 <pbuf_cat>
      r = iprh->next_pbuf;
 8008bd0:	6835      	ldr	r5, [r6, #0]
    while (r != NULL) {
 8008bd2:	2d00      	cmp	r5, #0
 8008bd4:	d1f2      	bne.n	8008bbc <ip4_reass+0x150>
    if (ipr == reassdatagrams) {
 8008bd6:	4b0d      	ldr	r3, [pc, #52]	; (8008c0c <ip4_reass+0x1a0>)
 8008bd8:	6819      	ldr	r1, [r3, #0]
 8008bda:	42a1      	cmp	r1, r4
 8008bdc:	d005      	beq.n	8008bea <ip4_reass+0x17e>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 8008bde:	b129      	cbz	r1, 8008bec <ip4_reass+0x180>
        if (ipr_prev->next == ipr) {
 8008be0:	680b      	ldr	r3, [r1, #0]
 8008be2:	42a3      	cmp	r3, r4
 8008be4:	d002      	beq.n	8008bec <ip4_reass+0x180>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 8008be6:	4619      	mov	r1, r3
 8008be8:	e7f9      	b.n	8008bde <ip4_reass+0x172>
      ipr_prev = NULL;
 8008bea:	2100      	movs	r1, #0
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 8008bec:	4620      	mov	r0, r4
 8008bee:	f7ff fd15 	bl	800861c <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
 8008bf2:	4638      	mov	r0, r7
 8008bf4:	f7fd fe1a 	bl	800682c <pbuf_clen>
 8008bf8:	4a04      	ldr	r2, [pc, #16]	; (8008c0c <ip4_reass+0x1a0>)
 8008bfa:	8893      	ldrh	r3, [r2, #4]
 8008bfc:	1a18      	subs	r0, r3, r0
 8008bfe:	8090      	strh	r0, [r2, #4]
}
 8008c00:	4638      	mov	r0, r7
 8008c02:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return NULL;
 8008c06:	2700      	movs	r7, #0
 8008c08:	e7fa      	b.n	8008c00 <ip4_reass+0x194>
 8008c0a:	bf00      	nop
 8008c0c:	200033f0 	.word	0x200033f0

08008c10 <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 8008c10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008c14:	b08d      	sub	sp, #52	; 0x34
 8008c16:	4606      	mov	r6, r0
 8008c18:	9108      	str	r1, [sp, #32]
 8008c1a:	920b      	str	r2, [sp, #44]	; 0x2c
  u16_t newpbuflen = 0;
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 8008c1c:	8ccb      	ldrh	r3, [r1, #38]	; 0x26
 8008c1e:	3b14      	subs	r3, #20
 8008c20:	d44d      	bmi.n	8008cbe <ip4_frag+0xae>
 8008c22:	10db      	asrs	r3, r3, #3
 8008c24:	9307      	str	r3, [sp, #28]
 8008c26:	b29b      	uxth	r3, r3
 8008c28:	930a      	str	r3, [sp, #40]	; 0x28
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
  u16_t tmp;

  original_iphdr = (struct ip_hdr *)p->payload;
 8008c2a:	f8d6 a004 	ldr.w	sl, [r6, #4]
  iphdr = original_iphdr;
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 8008c2e:	f89a 3000 	ldrb.w	r3, [sl]
 8008c32:	f003 030f 	and.w	r3, r3, #15
 8008c36:	2b05      	cmp	r3, #5
 8008c38:	d143      	bne.n	8008cc2 <ip4_frag+0xb2>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 8008c3a:	f8ba 0006 	ldrh.w	r0, [sl, #6]
 8008c3e:	f7fc ff75 	bl	8005b2c <lwip_htons>
  ofo = tmp & IP_OFFMASK;
 8008c42:	f3c0 030c 	ubfx	r3, r0, #0, #13
 8008c46:	9306      	str	r3, [sp, #24]
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 8008c48:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 8008c4c:	d143      	bne.n	8008cd6 <ip4_frag+0xc6>

  left = p->tot_len - IP_HLEN;
 8008c4e:	f8b6 8008 	ldrh.w	r8, [r6, #8]
 8008c52:	f1a8 0814 	sub.w	r8, r8, #20
 8008c56:	fa1f fb88 	uxth.w	fp, r8
  u16_t poff = IP_HLEN;
 8008c5a:	f04f 0914 	mov.w	r9, #20
  u16_t newpbuflen = 0;
 8008c5e:	2400      	movs	r4, #0

  while (left) {
 8008c60:	f1bb 0f00 	cmp.w	fp, #0
 8008c64:	f000 80b9 	beq.w	8008dda <ip4_frag+0x1ca>
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, nfb * 8);
 8008c68:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8008c6c:	00db      	lsls	r3, r3, #3
 8008c6e:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 8008c72:	455b      	cmp	r3, fp
 8008c74:	bfa8      	it	ge
 8008c76:	465b      	movge	r3, fp
 8008c78:	b29b      	uxth	r3, r3
 8008c7a:	9305      	str	r3, [sp, #20]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8008c7c:	2200      	movs	r2, #0
 8008c7e:	2114      	movs	r1, #20
 8008c80:	2002      	movs	r0, #2
 8008c82:	f7fd fc75 	bl	8006570 <pbuf_alloc>
    if (rambuf == NULL) {
 8008c86:	9004      	str	r0, [sp, #16]
 8008c88:	2800      	cmp	r0, #0
 8008c8a:	f000 80a8 	beq.w	8008dde <ip4_frag+0x1ce>
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
 8008c8e:	8973      	ldrh	r3, [r6, #10]
 8008c90:	2b13      	cmp	r3, #19
 8008c92:	d92a      	bls.n	8008cea <ip4_frag+0xda>
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 8008c94:	9f04      	ldr	r7, [sp, #16]
 8008c96:	687b      	ldr	r3, [r7, #4]
 8008c98:	f8da 2000 	ldr.w	r2, [sl]
 8008c9c:	f8da 5004 	ldr.w	r5, [sl, #4]
 8008ca0:	f8da 0008 	ldr.w	r0, [sl, #8]
 8008ca4:	f8da 100c 	ldr.w	r1, [sl, #12]
 8008ca8:	601a      	str	r2, [r3, #0]
 8008caa:	605d      	str	r5, [r3, #4]
 8008cac:	6098      	str	r0, [r3, #8]
 8008cae:	60d9      	str	r1, [r3, #12]
 8008cb0:	f8da 2010 	ldr.w	r2, [sl, #16]
 8008cb4:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;
 8008cb6:	f8d7 8004 	ldr.w	r8, [r7, #4]

    left_to_copy = fragsize;
 8008cba:	9d05      	ldr	r5, [sp, #20]
    while (left_to_copy) {
 8008cbc:	e03d      	b.n	8008d3a <ip4_frag+0x12a>
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 8008cbe:	3307      	adds	r3, #7
 8008cc0:	e7af      	b.n	8008c22 <ip4_frag+0x12>
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 8008cc2:	4b48      	ldr	r3, [pc, #288]	; (8008de4 <ip4_frag+0x1d4>)
 8008cc4:	f240 22e1 	movw	r2, #737	; 0x2e1
 8008cc8:	4947      	ldr	r1, [pc, #284]	; (8008de8 <ip4_frag+0x1d8>)
 8008cca:	4848      	ldr	r0, [pc, #288]	; (8008dec <ip4_frag+0x1dc>)
 8008ccc:	f006 fbee 	bl	800f4ac <iprintf>
 8008cd0:	f06f 0005 	mvn.w	r0, #5
 8008cd4:	e043      	b.n	8008d5e <ip4_frag+0x14e>
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 8008cd6:	4b43      	ldr	r3, [pc, #268]	; (8008de4 <ip4_frag+0x1d4>)
 8008cd8:	f240 22e6 	movw	r2, #742	; 0x2e6
 8008cdc:	4944      	ldr	r1, [pc, #272]	; (8008df0 <ip4_frag+0x1e0>)
 8008cde:	4843      	ldr	r0, [pc, #268]	; (8008dec <ip4_frag+0x1dc>)
 8008ce0:	f006 fbe4 	bl	800f4ac <iprintf>
 8008ce4:	f06f 0005 	mvn.w	r0, #5
 8008ce8:	e039      	b.n	8008d5e <ip4_frag+0x14e>
    LWIP_ASSERT("this needs a pbuf in one piece!",
 8008cea:	4b3e      	ldr	r3, [pc, #248]	; (8008de4 <ip4_frag+0x1d4>)
 8008cec:	f240 3209 	movw	r2, #777	; 0x309
 8008cf0:	4940      	ldr	r1, [pc, #256]	; (8008df4 <ip4_frag+0x1e4>)
 8008cf2:	483e      	ldr	r0, [pc, #248]	; (8008dec <ip4_frag+0x1dc>)
 8008cf4:	f006 fbda 	bl	800f4ac <iprintf>
 8008cf8:	e7cc      	b.n	8008c94 <ip4_frag+0x84>
      if (!newpbuflen) {
        poff = 0;
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 8008cfa:	f7ff fe69 	bl	80089d0 <ip_frag_alloc_pbuf_custom_ref>
      if (pcr == NULL) {
 8008cfe:	4607      	mov	r7, r0
 8008d00:	b340      	cbz	r0, 8008d54 <ip4_frag+0x144>
        pbuf_free(rambuf);
        goto memerr;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
        (u8_t*)p->payload + poff, newpbuflen);
 8008d02:	6873      	ldr	r3, [r6, #4]
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 8008d04:	444b      	add	r3, r9
 8008d06:	9401      	str	r4, [sp, #4]
 8008d08:	9300      	str	r3, [sp, #0]
 8008d0a:	4603      	mov	r3, r0
 8008d0c:	2202      	movs	r2, #2
 8008d0e:	4621      	mov	r1, r4
 8008d10:	2004      	movs	r0, #4
 8008d12:	f7fd fb7d 	bl	8006410 <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 8008d16:	9003      	str	r0, [sp, #12]
 8008d18:	b320      	cbz	r0, 8008d64 <ip4_frag+0x154>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        goto memerr;
      }
      pbuf_ref(p);
 8008d1a:	4630      	mov	r0, r6
 8008d1c:	f7fd fd90 	bl	8006840 <pbuf_ref>
      pcr->original = p;
 8008d20:	617e      	str	r6, [r7, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 8008d22:	4b35      	ldr	r3, [pc, #212]	; (8008df8 <ip4_frag+0x1e8>)
 8008d24:	613b      	str	r3, [r7, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 8008d26:	9903      	ldr	r1, [sp, #12]
 8008d28:	9804      	ldr	r0, [sp, #16]
 8008d2a:	f7fd fda5 	bl	8006878 <pbuf_cat>
      left_to_copy -= newpbuflen;
 8008d2e:	1b2d      	subs	r5, r5, r4
 8008d30:	b2ad      	uxth	r5, r5
      if (left_to_copy) {
 8008d32:	b115      	cbz	r5, 8008d3a <ip4_frag+0x12a>
        poff = 0;
        p = p->next;
 8008d34:	6836      	ldr	r6, [r6, #0]
        poff = 0;
 8008d36:	f04f 0900 	mov.w	r9, #0
    while (left_to_copy) {
 8008d3a:	b1e5      	cbz	r5, 8008d76 <ip4_frag+0x166>
      u16_t plen = p->len - poff;
 8008d3c:	8974      	ldrh	r4, [r6, #10]
 8008d3e:	eba4 0409 	sub.w	r4, r4, r9
 8008d42:	b2a4      	uxth	r4, r4
      newpbuflen = LWIP_MIN(left_to_copy, plen);
 8008d44:	42ac      	cmp	r4, r5
 8008d46:	bf28      	it	cs
 8008d48:	462c      	movcs	r4, r5
      if (!newpbuflen) {
 8008d4a:	2c00      	cmp	r4, #0
 8008d4c:	d1d5      	bne.n	8008cfa <ip4_frag+0xea>
        p = p->next;
 8008d4e:	6836      	ldr	r6, [r6, #0]
        poff = 0;
 8008d50:	46a1      	mov	r9, r4
        continue;
 8008d52:	e7f2      	b.n	8008d3a <ip4_frag+0x12a>
        pbuf_free(rambuf);
 8008d54:	9804      	ldr	r0, [sp, #16]
 8008d56:	f7fd fba1 	bl	800649c <pbuf_free>
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
 8008d5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8008d5e:	b00d      	add	sp, #52	; 0x34
 8008d60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ip_frag_free_pbuf_custom_ref(pcr);
 8008d64:	4638      	mov	r0, r7
 8008d66:	f7ff fd3b 	bl	80087e0 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 8008d6a:	9804      	ldr	r0, [sp, #16]
 8008d6c:	f7fd fb96 	bl	800649c <pbuf_free>
  return ERR_MEM;
 8008d70:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        goto memerr;
 8008d74:	e7f3      	b.n	8008d5e <ip4_frag+0x14e>
    poff += newpbuflen;
 8008d76:	44a1      	add	r9, r4
 8008d78:	fa1f f989 	uxth.w	r9, r9
    last = (left <= netif->mtu - IP_HLEN);
 8008d7c:	9b08      	ldr	r3, [sp, #32]
 8008d7e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8008d80:	3b14      	subs	r3, #20
    tmp = (IP_OFFMASK & (ofo));
 8008d82:	9a06      	ldr	r2, [sp, #24]
 8008d84:	f3c2 000c 	ubfx	r0, r2, #0, #13
    if (!last) {
 8008d88:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008d8a:	429a      	cmp	r2, r3
 8008d8c:	dd01      	ble.n	8008d92 <ip4_frag+0x182>
      tmp = tmp | IP_MF;
 8008d8e:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 8008d92:	f7fc fecb 	bl	8005b2c <lwip_htons>
 8008d96:	f8a8 0006 	strh.w	r0, [r8, #6]
    IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));
 8008d9a:	9d05      	ldr	r5, [sp, #20]
 8008d9c:	f105 0014 	add.w	r0, r5, #20
 8008da0:	b280      	uxth	r0, r0
 8008da2:	f7fc fec3 	bl	8005b2c <lwip_htons>
 8008da6:	f8a8 0002 	strh.w	r0, [r8, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 8008daa:	2300      	movs	r3, #0
 8008dac:	f888 300a 	strb.w	r3, [r8, #10]
 8008db0:	f888 300b 	strb.w	r3, [r8, #11]
    netif->output(netif, rambuf, dest);
 8008db4:	9808      	ldr	r0, [sp, #32]
 8008db6:	6943      	ldr	r3, [r0, #20]
 8008db8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008dba:	9f04      	ldr	r7, [sp, #16]
 8008dbc:	4639      	mov	r1, r7
 8008dbe:	4798      	blx	r3
    pbuf_free(rambuf);
 8008dc0:	4638      	mov	r0, r7
 8008dc2:	f7fd fb6b 	bl	800649c <pbuf_free>
    left -= fragsize;
 8008dc6:	ebab 0b05 	sub.w	fp, fp, r5
 8008dca:	fa1f fb8b 	uxth.w	fp, fp
    ofo += nfb;
 8008dce:	9b06      	ldr	r3, [sp, #24]
 8008dd0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008dd2:	4413      	add	r3, r2
 8008dd4:	b29b      	uxth	r3, r3
 8008dd6:	9306      	str	r3, [sp, #24]
 8008dd8:	e742      	b.n	8008c60 <ip4_frag+0x50>
  return ERR_OK;
 8008dda:	2000      	movs	r0, #0
 8008ddc:	e7bf      	b.n	8008d5e <ip4_frag+0x14e>
  return ERR_MEM;
 8008dde:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008de2:	e7bc      	b.n	8008d5e <ip4_frag+0x14e>
 8008de4:	08011964 	.word	0x08011964
 8008de8:	08011ab0 	.word	0x08011ab0
 8008dec:	080109f4 	.word	0x080109f4
 8008df0:	08011ad8 	.word	0x08011ad8
 8008df4:	08011af4 	.word	0x08011af4
 8008df8:	0800880d 	.word	0x0800880d

08008dfc <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008dfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008dfe:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8008e00:	8945      	ldrh	r5, [r0, #10]
 8008e02:	2d0e      	cmp	r5, #14
 8008e04:	d916      	bls.n	8008e34 <ethernet_input+0x38>
 8008e06:	460f      	mov	r7, r1
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 8008e08:	6840      	ldr	r0, [r0, #4]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0],  (unsigned)ethhdr->src.addr[1],  (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3],  (unsigned)ethhdr->src.addr[4],  (unsigned)ethhdr->src.addr[5],
     lwip_htons(ethhdr->type)));

  type = ethhdr->type;
 8008e0a:	8986      	ldrh	r6, [r0, #12]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 8008e0c:	7803      	ldrb	r3, [r0, #0]
 8008e0e:	f013 0f01 	tst.w	r3, #1
 8008e12:	d00a      	beq.n	8008e2a <ethernet_input+0x2e>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
 8008e14:	2b01      	cmp	r3, #1
 8008e16:	d012      	beq.n	8008e3e <ethernet_input+0x42>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8008e18:	2206      	movs	r2, #6
 8008e1a:	4921      	ldr	r1, [pc, #132]	; (8008ea0 <ethernet_input+0xa4>)
 8008e1c:	f006 fb24 	bl	800f468 <memcmp>
 8008e20:	b918      	cbnz	r0, 8008e2a <ethernet_input+0x2e>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 8008e22:	7b63      	ldrb	r3, [r4, #13]
 8008e24:	f043 0308 	orr.w	r3, r3, #8
 8008e28:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 8008e2a:	2e08      	cmp	r6, #8
 8008e2c:	d012      	beq.n	8008e54 <ethernet_input+0x58>
 8008e2e:	f5b6 6fc1 	cmp.w	r6, #1544	; 0x608
 8008e32:	d022      	beq.n	8008e7a <ethernet_input+0x7e>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 8008e34:	4620      	mov	r0, r4
 8008e36:	f7fd fb31 	bl	800649c <pbuf_free>
  return ERR_OK;
}
 8008e3a:	2000      	movs	r0, #0
 8008e3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 8008e3e:	7843      	ldrb	r3, [r0, #1]
 8008e40:	2b00      	cmp	r3, #0
 8008e42:	d1f2      	bne.n	8008e2a <ethernet_input+0x2e>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
 8008e44:	7883      	ldrb	r3, [r0, #2]
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 8008e46:	2b5e      	cmp	r3, #94	; 0x5e
 8008e48:	d1ef      	bne.n	8008e2a <ethernet_input+0x2e>
        p->flags |= PBUF_FLAG_LLMCAST;
 8008e4a:	7b63      	ldrb	r3, [r4, #13]
 8008e4c:	f043 0310 	orr.w	r3, r3, #16
 8008e50:	7363      	strb	r3, [r4, #13]
 8008e52:	e7ea      	b.n	8008e2a <ethernet_input+0x2e>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008e54:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8008e58:	f013 0f08 	tst.w	r3, #8
 8008e5c:	d0ea      	beq.n	8008e34 <ethernet_input+0x38>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 8008e5e:	2d0d      	cmp	r5, #13
 8008e60:	d9e8      	bls.n	8008e34 <ethernet_input+0x38>
 8008e62:	f06f 010d 	mvn.w	r1, #13
 8008e66:	4620      	mov	r0, r4
 8008e68:	f7fd fb0e 	bl	8006488 <pbuf_header>
 8008e6c:	2800      	cmp	r0, #0
 8008e6e:	d1e1      	bne.n	8008e34 <ethernet_input+0x38>
        ip4_input(p, netif);
 8008e70:	4639      	mov	r1, r7
 8008e72:	4620      	mov	r0, r4
 8008e74:	f7ff f9e8 	bl	8008248 <ip4_input>
      break;
 8008e78:	e7df      	b.n	8008e3a <ethernet_input+0x3e>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008e7a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8008e7e:	f013 0f08 	tst.w	r3, #8
 8008e82:	d0d7      	beq.n	8008e34 <ethernet_input+0x38>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 8008e84:	2d0d      	cmp	r5, #13
 8008e86:	d9d5      	bls.n	8008e34 <ethernet_input+0x38>
 8008e88:	f06f 010d 	mvn.w	r1, #13
 8008e8c:	4620      	mov	r0, r4
 8008e8e:	f7fd fafb 	bl	8006488 <pbuf_header>
 8008e92:	2800      	cmp	r0, #0
 8008e94:	d1ce      	bne.n	8008e34 <ethernet_input+0x38>
        etharp_input(p, netif);
 8008e96:	4639      	mov	r1, r7
 8008e98:	4620      	mov	r0, r4
 8008e9a:	f7fe fba7 	bl	80075ec <etharp_input>
      break;
 8008e9e:	e7cc      	b.n	8008e3a <ethernet_input+0x3e>
 8008ea0:	080108d0 	.word	0x080108d0

08008ea4 <ethernet_output>:
 */
err_t
ethernet_output(struct netif* netif, struct pbuf* p,
                const struct eth_addr* src, const struct eth_addr* dst,
                u16_t eth_type)
{
 8008ea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008ea8:	4605      	mov	r5, r0
 8008eaa:	460c      	mov	r4, r1
 8008eac:	4616      	mov	r6, r2
 8008eae:	461f      	mov	r7, r3
  struct eth_hdr* ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
 8008eb0:	f8bd 0018 	ldrh.w	r0, [sp, #24]
 8008eb4:	f7fc fe3a 	bl	8005b2c <lwip_htons>
 8008eb8:	4680      	mov	r8, r0

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_header(p, SIZEOF_ETH_HDR) != 0) {
 8008eba:	210e      	movs	r1, #14
 8008ebc:	4620      	mov	r0, r4
 8008ebe:	f7fd fae3 	bl	8006488 <pbuf_header>
 8008ec2:	b9e8      	cbnz	r0, 8008f00 <ethernet_output+0x5c>
      goto pbuf_header_failed;
    }
  }

  ethhdr = (struct eth_hdr*)p->payload;
 8008ec4:	6863      	ldr	r3, [r4, #4]
  ethhdr->type = eth_type_be;
 8008ec6:	f8a3 800c 	strh.w	r8, [r3, #12]
  ETHADDR32_COPY(&ethhdr->dest, dst);
 8008eca:	683a      	ldr	r2, [r7, #0]
 8008ecc:	601a      	str	r2, [r3, #0]
 8008ece:	88ba      	ldrh	r2, [r7, #4]
 8008ed0:	809a      	strh	r2, [r3, #4]
  ETHADDR16_COPY(&ethhdr->src,  src);
 8008ed2:	6832      	ldr	r2, [r6, #0]
 8008ed4:	f8c3 2006 	str.w	r2, [r3, #6]
 8008ed8:	88b2      	ldrh	r2, [r6, #4]
 8008eda:	815a      	strh	r2, [r3, #10]

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 8008edc:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8008ee0:	2b06      	cmp	r3, #6
 8008ee2:	d105      	bne.n	8008ef0 <ethernet_output+0x4c>
    (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
    ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
 8008ee4:	69ab      	ldr	r3, [r5, #24]
 8008ee6:	4621      	mov	r1, r4
 8008ee8:	4628      	mov	r0, r5
 8008eea:	4798      	blx	r3
pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  return ERR_BUF;
}
 8008eec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 8008ef0:	4b05      	ldr	r3, [pc, #20]	; (8008f08 <ethernet_output+0x64>)
 8008ef2:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8008ef6:	4905      	ldr	r1, [pc, #20]	; (8008f0c <ethernet_output+0x68>)
 8008ef8:	4805      	ldr	r0, [pc, #20]	; (8008f10 <ethernet_output+0x6c>)
 8008efa:	f006 fad7 	bl	800f4ac <iprintf>
 8008efe:	e7f1      	b.n	8008ee4 <ethernet_output+0x40>
  return ERR_BUF;
 8008f00:	f06f 0001 	mvn.w	r0, #1
 8008f04:	e7f2      	b.n	8008eec <ethernet_output+0x48>
 8008f06:	bf00      	nop
 8008f08:	08011b14 	.word	0x08011b14
 8008f0c:	08011b4c 	.word	0x08011b4c
 8008f10:	080109f4 	.word	0x080109f4

08008f14 <sys_mbox_new>:
#endif

/*-----------------------------------------------------------------------------------*/
//  Creates an empty mailbox.
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
 8008f14:	b510      	push	{r4, lr}
 8008f16:	b082      	sub	sp, #8
 8008f18:	4604      	mov	r4, r0
#if (osCMSIS < 0x20000U)
  osMessageQDef(QUEUE, size, void *);
 8008f1a:	9100      	str	r1, [sp, #0]
 8008f1c:	2304      	movs	r3, #4
 8008f1e:	9301      	str	r3, [sp, #4]
  *mbox = osMessageCreate(osMessageQ(QUEUE), NULL);
 8008f20:	2100      	movs	r1, #0
 8008f22:	4668      	mov	r0, sp
 8008f24:	f7fa ff52 	bl	8003dcc <osMessageCreate>
 8008f28:	6020      	str	r0, [r4, #0]
  if(lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used)
  {
    lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
  }
#endif /* SYS_STATS */
  if(*mbox == NULL)
 8008f2a:	b110      	cbz	r0, 8008f32 <sys_mbox_new+0x1e>
    return ERR_MEM;

  return ERR_OK;
 8008f2c:	2000      	movs	r0, #0
}
 8008f2e:	b002      	add	sp, #8
 8008f30:	bd10      	pop	{r4, pc}
    return ERR_MEM;
 8008f32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008f36:	e7fa      	b.n	8008f2e <sys_mbox_new+0x1a>

08008f38 <sys_mbox_trypost>:


/*-----------------------------------------------------------------------------------*/
//   Try to post the "msg" to the mailbox.
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
 8008f38:	b508      	push	{r3, lr}
  err_t result;
#if (osCMSIS < 0x20000U)
  if(osMessagePut(*mbox, (uint32_t)msg, 0) == osOK)
 8008f3a:	2200      	movs	r2, #0
 8008f3c:	6800      	ldr	r0, [r0, #0]
 8008f3e:	f7fa ff4d 	bl	8003ddc <osMessagePut>
 8008f42:	b900      	cbnz	r0, 8008f46 <sys_mbox_trypost+0xe>
    lwip_stats.sys.mbox.err++;
#endif /* SYS_STATS */
  }

  return result;
}
 8008f44:	bd08      	pop	{r3, pc}
    result = ERR_MEM;
 8008f46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008f4a:	e7fb      	b.n	8008f44 <sys_mbox_trypost+0xc>

08008f4c <sys_arch_mbox_fetch>:

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP.
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
 8008f4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008f4e:	b089      	sub	sp, #36	; 0x24
 8008f50:	4606      	mov	r6, r0
 8008f52:	460f      	mov	r7, r1
 8008f54:	4615      	mov	r5, r2
#if (osCMSIS < 0x20000U)
  osEvent event;
  uint32_t starttime = osKernelSysTick();
 8008f56:	f7fa fe18 	bl	8003b8a <osKernelSysTick>
 8008f5a:	4604      	mov	r4, r0
#else
  osStatus_t status;
  uint32_t starttime = osKernelGetTickCount();
#endif
  if(timeout != 0)
 8008f5c:	b185      	cbz	r5, 8008f80 <sys_arch_mbox_fetch+0x34>
  {
#if (osCMSIS < 0x20000U)
    event = osMessageGet (*mbox, timeout);
 8008f5e:	462a      	mov	r2, r5
 8008f60:	6831      	ldr	r1, [r6, #0]
 8008f62:	a805      	add	r0, sp, #20
 8008f64:	f7fa ff6e 	bl	8003e44 <osMessageGet>

    if(event.status == osEventMessage)
 8008f68:	9b05      	ldr	r3, [sp, #20]
 8008f6a:	2b10      	cmp	r3, #16
 8008f6c:	d002      	beq.n	8008f74 <sys_arch_mbox_fetch+0x28>
      return (osKernelGetTickCount() - starttime);
    }
#endif
    else
    {
      return SYS_ARCH_TIMEOUT;
 8008f6e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008f72:	e016      	b.n	8008fa2 <sys_arch_mbox_fetch+0x56>
      *msg = (void *)event.value.v;
 8008f74:	9b06      	ldr	r3, [sp, #24]
 8008f76:	603b      	str	r3, [r7, #0]
      return (osKernelSysTick() - starttime);
 8008f78:	f7fa fe07 	bl	8003b8a <osKernelSysTick>
 8008f7c:	1b00      	subs	r0, r0, r4
 8008f7e:	e010      	b.n	8008fa2 <sys_arch_mbox_fetch+0x56>
    }
  }
  else
  {
#if (osCMSIS < 0x20000U)
    event = osMessageGet (*mbox, osWaitForever);
 8008f80:	466d      	mov	r5, sp
 8008f82:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008f86:	6831      	ldr	r1, [r6, #0]
 8008f88:	4628      	mov	r0, r5
 8008f8a:	f7fa ff5b 	bl	8003e44 <osMessageGet>
 8008f8e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8008f92:	ab08      	add	r3, sp, #32
 8008f94:	e903 0007 	stmdb	r3, {r0, r1, r2}
    *msg = (void *)event.value.v;
 8008f98:	9b06      	ldr	r3, [sp, #24]
 8008f9a:	603b      	str	r3, [r7, #0]
    return (osKernelSysTick() - starttime);
 8008f9c:	f7fa fdf5 	bl	8003b8a <osKernelSysTick>
 8008fa0:	1b00      	subs	r0, r0, r4
#else
    osMessageQueueGet(*mbox, msg, 0, osWaitForever );
    return (osKernelGetTickCount() - starttime);
#endif
  }
}
 8008fa2:	b009      	add	sp, #36	; 0x24
 8008fa4:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008fa6 <sys_mbox_valid>:
  }
}
/*----------------------------------------------------------------------------------*/
int sys_mbox_valid(sys_mbox_t *mbox)
{
  if (*mbox == SYS_MBOX_NULL)
 8008fa6:	6803      	ldr	r3, [r0, #0]
 8008fa8:	b10b      	cbz	r3, 8008fae <sys_mbox_valid+0x8>
    return 0;
  else
    return 1;
 8008faa:	2001      	movs	r0, #1
}
 8008fac:	4770      	bx	lr
    return 0;
 8008fae:	2000      	movs	r0, #0
 8008fb0:	4770      	bx	lr

08008fb2 <sys_sem_new>:

/*-----------------------------------------------------------------------------------*/
//  Creates a new semaphore. The "count" argument specifies
//  the initial state of the semaphore.
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
 8008fb2:	b530      	push	{r4, r5, lr}
 8008fb4:	b083      	sub	sp, #12
 8008fb6:	4604      	mov	r4, r0
 8008fb8:	460d      	mov	r5, r1
#if (osCMSIS < 0x20000U)
  osSemaphoreDef(SEM);
 8008fba:	a802      	add	r0, sp, #8
 8008fbc:	2300      	movs	r3, #0
 8008fbe:	f840 3d04 	str.w	r3, [r0, #-4]!
  *sem = osSemaphoreCreate (osSemaphore(SEM), 1);
 8008fc2:	2101      	movs	r1, #1
 8008fc4:	f7fa fe7c 	bl	8003cc0 <osSemaphoreCreate>
 8008fc8:	6020      	str	r0, [r4, #0]
#else
  *sem = osSemaphoreNew(UINT16_MAX, count, NULL);
#endif

  if(*sem == NULL)
 8008fca:	b140      	cbz	r0, 8008fde <sys_sem_new+0x2c>
    ++lwip_stats.sys.sem.err;
#endif /* SYS_STATS */
    return ERR_MEM;
  }

  if(count == 0)	// Means it can't be taken
 8008fcc:	b115      	cbz	r5, 8008fd4 <sys_sem_new+0x22>
  if (lwip_stats.sys.sem.max < lwip_stats.sys.sem.used) {
    lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
  }
#endif /* SYS_STATS */

  return ERR_OK;
 8008fce:	2000      	movs	r0, #0
}
 8008fd0:	b003      	add	sp, #12
 8008fd2:	bd30      	pop	{r4, r5, pc}
    osSemaphoreWait(*sem, 0);
 8008fd4:	2100      	movs	r1, #0
 8008fd6:	f7fa fe87 	bl	8003ce8 <osSemaphoreWait>
  return ERR_OK;
 8008fda:	2000      	movs	r0, #0
 8008fdc:	e7f8      	b.n	8008fd0 <sys_sem_new+0x1e>
    return ERR_MEM;
 8008fde:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008fe2:	e7f5      	b.n	8008fd0 <sys_sem_new+0x1e>

08008fe4 <sys_arch_sem_wait>:

  Notice that lwIP implements a function with a similar name,
  sys_sem_wait(), that uses the sys_arch_sem_wait() function.
*/
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
 8008fe4:	b570      	push	{r4, r5, r6, lr}
 8008fe6:	4604      	mov	r4, r0
 8008fe8:	460e      	mov	r6, r1
#if (osCMSIS < 0x20000U)
  uint32_t starttime = osKernelSysTick();
 8008fea:	f7fa fdce 	bl	8003b8a <osKernelSysTick>
 8008fee:	4605      	mov	r5, r0
#else
  uint32_t starttime = osKernelGetTickCount();
#endif
  if(timeout != 0)
 8008ff0:	b956      	cbnz	r6, 8009008 <sys_arch_sem_wait+0x24>
    }
  }
  else
  {
#if (osCMSIS < 0x20000U)
    while(osSemaphoreWait (*sem, osWaitForever) != osOK);
 8008ff2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008ff6:	6820      	ldr	r0, [r4, #0]
 8008ff8:	f7fa fe76 	bl	8003ce8 <osSemaphoreWait>
 8008ffc:	2800      	cmp	r0, #0
 8008ffe:	d1f8      	bne.n	8008ff2 <sys_arch_sem_wait+0xe>
    return (osKernelSysTick() - starttime);
 8009000:	f7fa fdc3 	bl	8003b8a <osKernelSysTick>
 8009004:	1b40      	subs	r0, r0, r5
#else
    while(osSemaphoreAcquire(*sem, osWaitForever) != osOK);
    return (osKernelGetTickCount() - starttime);
#endif
  }
}
 8009006:	bd70      	pop	{r4, r5, r6, pc}
    if(osSemaphoreWait (*sem, timeout) == osOK)
 8009008:	4631      	mov	r1, r6
 800900a:	6820      	ldr	r0, [r4, #0]
 800900c:	f7fa fe6c 	bl	8003ce8 <osSemaphoreWait>
 8009010:	b918      	cbnz	r0, 800901a <sys_arch_sem_wait+0x36>
      return (osKernelSysTick() - starttime);
 8009012:	f7fa fdba 	bl	8003b8a <osKernelSysTick>
 8009016:	1b40      	subs	r0, r0, r5
 8009018:	e7f5      	b.n	8009006 <sys_arch_sem_wait+0x22>
      return SYS_ARCH_TIMEOUT;
 800901a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800901e:	e7f2      	b.n	8009006 <sys_arch_sem_wait+0x22>

08009020 <sys_sem_signal>:

/*-----------------------------------------------------------------------------------*/
// Signals a semaphore
void sys_sem_signal(sys_sem_t *sem)
{
 8009020:	b508      	push	{r3, lr}
  osSemaphoreRelease(*sem);
 8009022:	6800      	ldr	r0, [r0, #0]
 8009024:	f7fa fe98 	bl	8003d58 <osSemaphoreRelease>
}
 8009028:	bd08      	pop	{r3, pc}

0800902a <sys_sem_free>:

/*-----------------------------------------------------------------------------------*/
// Deallocates a semaphore
void sys_sem_free(sys_sem_t *sem)
{
 800902a:	b508      	push	{r3, lr}
#if SYS_STATS
  --lwip_stats.sys.sem.used;
#endif /* SYS_STATS */

  osSemaphoreDelete(*sem);
 800902c:	6800      	ldr	r0, [r0, #0]
 800902e:	f7fa fec1 	bl	8003db4 <osSemaphoreDelete>
}
 8009032:	bd08      	pop	{r3, pc}

08009034 <sys_sem_valid>:
/*-----------------------------------------------------------------------------------*/
int sys_sem_valid(sys_sem_t *sem)
{
  if (*sem == SYS_SEM_NULL)
 8009034:	6803      	ldr	r3, [r0, #0]
 8009036:	b10b      	cbz	r3, 800903c <sys_sem_valid+0x8>
    return 0;
  else
    return 1;
 8009038:	2001      	movs	r0, #1
}
 800903a:	4770      	bx	lr
    return 0;
 800903c:	2000      	movs	r0, #0
 800903e:	4770      	bx	lr

08009040 <sys_init>:
#else
osMutexId_t lwip_sys_mutex;
#endif
// Initialize sys arch
void sys_init(void)
{
 8009040:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  lwip_sys_mutex = osMutexCreate(osMutex(lwip_sys_mutex));
 8009042:	4803      	ldr	r0, [pc, #12]	; (8009050 <sys_init+0x10>)
 8009044:	f7fa fdc5 	bl	8003bd2 <osMutexCreate>
 8009048:	4b02      	ldr	r3, [pc, #8]	; (8009054 <sys_init+0x14>)
 800904a:	6018      	str	r0, [r3, #0]
#else
  lwip_sys_mutex = osMutexNew(NULL);
#endif
}
 800904c:	bd08      	pop	{r3, pc}
 800904e:	bf00      	nop
 8009050:	080108e0 	.word	0x080108e0
 8009054:	2000861c 	.word	0x2000861c

08009058 <sys_mutex_new>:
                                      /* Mutexes*/
/*-----------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------*/
#if LWIP_COMPAT_MUTEX == 0
/* Create a new mutex*/
err_t sys_mutex_new(sys_mutex_t *mutex) {
 8009058:	b510      	push	{r4, lr}
 800905a:	b082      	sub	sp, #8
 800905c:	4604      	mov	r4, r0

#if (osCMSIS < 0x20000U)
  osMutexDef(MUTEX);
 800905e:	a802      	add	r0, sp, #8
 8009060:	2300      	movs	r3, #0
 8009062:	f840 3d04 	str.w	r3, [r0, #-4]!
  *mutex = osMutexCreate(osMutex(MUTEX));
 8009066:	f7fa fdb4 	bl	8003bd2 <osMutexCreate>
 800906a:	6020      	str	r0, [r4, #0]
#else
  *mutex = osMutexNew(NULL);
#endif

  if(*mutex == NULL)
 800906c:	b110      	cbz	r0, 8009074 <sys_mutex_new+0x1c>
  ++lwip_stats.sys.mutex.used;
  if (lwip_stats.sys.mutex.max < lwip_stats.sys.mutex.used) {
    lwip_stats.sys.mutex.max = lwip_stats.sys.mutex.used;
  }
#endif /* SYS_STATS */
  return ERR_OK;
 800906e:	2000      	movs	r0, #0
}
 8009070:	b002      	add	sp, #8
 8009072:	bd10      	pop	{r4, pc}
    return ERR_MEM;
 8009074:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8009078:	e7fa      	b.n	8009070 <sys_mutex_new+0x18>

0800907a <sys_mutex_free>:
/*-----------------------------------------------------------------------------------*/
/* Deallocate a mutex*/
void sys_mutex_free(sys_mutex_t *mutex)
{
 800907a:	b508      	push	{r3, lr}
#if SYS_STATS
      --lwip_stats.sys.mutex.used;
#endif /* SYS_STATS */

  osMutexDelete(*mutex);
 800907c:	6800      	ldr	r0, [r0, #0]
 800907e:	f7fa fe13 	bl	8003ca8 <osMutexDelete>
}
 8009082:	bd08      	pop	{r3, pc}

08009084 <sys_mutex_lock>:
/*-----------------------------------------------------------------------------------*/
/* Lock a mutex*/
void sys_mutex_lock(sys_mutex_t *mutex)
{
 8009084:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  osMutexWait(*mutex, osWaitForever);
 8009086:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800908a:	6800      	ldr	r0, [r0, #0]
 800908c:	f7fa fda6 	bl	8003bdc <osMutexWait>
#else
  osMutexAcquire(*mutex, osWaitForever);
#endif
}
 8009090:	bd08      	pop	{r3, pc}

08009092 <sys_mutex_unlock>:

/*-----------------------------------------------------------------------------------*/
/* Unlock a mutex*/
void sys_mutex_unlock(sys_mutex_t *mutex)
{
 8009092:	b508      	push	{r3, lr}
  osMutexRelease(*mutex);
 8009094:	6800      	ldr	r0, [r0, #0]
 8009096:	f7fa fdd9 	bl	8003c4c <osMutexRelease>
}
 800909a:	bd08      	pop	{r3, pc}

0800909c <sys_thread_new>:
  function "thread()". The "arg" argument will be passed as an argument to the
  thread() function. The id of the new thread is returned. Both the id and
  the priority are system dependent.
*/
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread , void *arg, int stacksize, int prio)
{
 800909c:	b500      	push	{lr}
 800909e:	b087      	sub	sp, #28
#if (osCMSIS < 0x20000U)
  const osThreadDef_t os_thread_def = { (char *)name, (os_pthread)thread, (osPriority)prio, 0, stacksize/4};
 80090a0:	9001      	str	r0, [sp, #4]
 80090a2:	9102      	str	r1, [sp, #8]
 80090a4:	f9bd 1020 	ldrsh.w	r1, [sp, #32]
 80090a8:	f8ad 100c 	strh.w	r1, [sp, #12]
 80090ac:	2100      	movs	r1, #0
 80090ae:	9104      	str	r1, [sp, #16]
 80090b0:	4619      	mov	r1, r3
 80090b2:	2b00      	cmp	r3, #0
 80090b4:	db08      	blt.n	80090c8 <sys_thread_new+0x2c>
 80090b6:	1089      	asrs	r1, r1, #2
 80090b8:	9105      	str	r1, [sp, #20]
  return osThreadCreate(&os_thread_def, arg);
 80090ba:	4611      	mov	r1, r2
 80090bc:	a801      	add	r0, sp, #4
 80090be:	f7fa fd6e 	bl	8003b9e <osThreadCreate>
                        .stack_size = stacksize,
                        .priority = (osPriority_t)prio,
                      };
  return osThreadNew(thread, arg, &attributes);
#endif
}
 80090c2:	b007      	add	sp, #28
 80090c4:	f85d fb04 	ldr.w	pc, [sp], #4
  const osThreadDef_t os_thread_def = { (char *)name, (os_pthread)thread, (osPriority)prio, 0, stacksize/4};
 80090c8:	1cd9      	adds	r1, r3, #3
 80090ca:	e7f4      	b.n	80090b6 <sys_thread_new+0x1a>

080090cc <sys_arch_protect>:

  Note: This function is based on FreeRTOS API, because no equivalent CMSIS-RTOS
        API is available
*/
sys_prot_t sys_arch_protect(void)
{
 80090cc:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  osMutexWait(lwip_sys_mutex, osWaitForever);
 80090ce:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80090d2:	4b03      	ldr	r3, [pc, #12]	; (80090e0 <sys_arch_protect+0x14>)
 80090d4:	6818      	ldr	r0, [r3, #0]
 80090d6:	f7fa fd81 	bl	8003bdc <osMutexWait>
#else
  osMutexAcquire(lwip_sys_mutex, osWaitForever);
#endif
  return (sys_prot_t)1;
}
 80090da:	2001      	movs	r0, #1
 80090dc:	bd08      	pop	{r3, pc}
 80090de:	bf00      	nop
 80090e0:	2000861c 	.word	0x2000861c

080090e4 <sys_arch_unprotect>:

  Note: This function is based on FreeRTOS API, because no equivalent CMSIS-RTOS
        API is available
*/
void sys_arch_unprotect(sys_prot_t pval)
{
 80090e4:	b508      	push	{r3, lr}
  ( void ) pval;
  osMutexRelease(lwip_sys_mutex);
 80090e6:	4b02      	ldr	r3, [pc, #8]	; (80090f0 <sys_arch_unprotect+0xc>)
 80090e8:	6818      	ldr	r0, [r3, #0]
 80090ea:	f7fa fdaf 	bl	8003c4c <osMutexRelease>
}
 80090ee:	bd08      	pop	{r3, pc}
 80090f0:	2000861c 	.word	0x2000861c

080090f4 <low_level_input>:
 * @param netif the lwip network interface structure for this ethernetif
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
   */
static struct pbuf * low_level_input(struct netif *netif)
{
 80090f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t byteslefttocopy = 0;
  uint32_t i=0;
  

  /* get received frame */
  if (HAL_ETH_GetReceivedFrame_IT(&heth) != HAL_OK)
 80090f8:	4833      	ldr	r0, [pc, #204]	; (80091c8 <low_level_input+0xd4>)
 80090fa:	f7f8 fc87 	bl	8001a0c <HAL_ETH_GetReceivedFrame_IT>
 80090fe:	2800      	cmp	r0, #0
 8009100:	d15e      	bne.n	80091c0 <low_level_input+0xcc>
    return NULL;
  
  /* Obtain the size of the packet and put it into the "len" variable. */
  len = heth.RxFrameInfos.length;
 8009102:	4b31      	ldr	r3, [pc, #196]	; (80091c8 <low_level_input+0xd4>)
 8009104:	8f99      	ldrh	r1, [r3, #60]	; 0x3c
  buffer = (uint8_t *)heth.RxFrameInfos.buffer;
 8009106:	f8d3 9040 	ldr.w	r9, [r3, #64]	; 0x40
  
  if (len > 0)
 800910a:	b929      	cbnz	r1, 8009118 <low_level_input+0x24>
  struct pbuf *p = NULL;
 800910c:	f04f 0800 	mov.w	r8, #0
    }
  }  
  
    /* Release descriptors to DMA */
    /* Point to first descriptor */
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 8009110:	4b2d      	ldr	r3, [pc, #180]	; (80091c8 <low_level_input+0xd4>)
 8009112:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 8009114:	2100      	movs	r1, #0
 8009116:	e03a      	b.n	800918e <low_level_input+0x9a>
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 8009118:	2203      	movs	r2, #3
 800911a:	2004      	movs	r0, #4
 800911c:	f7fd fa28 	bl	8006570 <pbuf_alloc>
  if (p != NULL)
 8009120:	4680      	mov	r8, r0
 8009122:	2800      	cmp	r0, #0
 8009124:	d0f4      	beq.n	8009110 <low_level_input+0x1c>
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 8009126:	4b28      	ldr	r3, [pc, #160]	; (80091c8 <low_level_input+0xd4>)
 8009128:	6b1f      	ldr	r7, [r3, #48]	; 0x30
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 800912a:	4682      	mov	sl, r0
    bufferoffset = 0;
 800912c:	2400      	movs	r4, #0
    for(q = p; q != NULL; q = q->next)
 800912e:	e021      	b.n	8009174 <low_level_input+0x80>
        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
 8009130:	f8da 0004 	ldr.w	r0, [sl, #4]
 8009134:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8009138:	1b12      	subs	r2, r2, r4
 800913a:	eb09 0104 	add.w	r1, r9, r4
 800913e:	4430      	add	r0, r6
 8009140:	f006 f9a1 	bl	800f486 <memcpy>
        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 8009144:	68ff      	ldr	r7, [r7, #12]
        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
 8009146:	f8d7 9008 	ldr.w	r9, [r7, #8]
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
 800914a:	f2a5 52f4 	subw	r2, r5, #1524	; 0x5f4
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
 800914e:	1b36      	subs	r6, r6, r4
 8009150:	f206 56f4 	addw	r6, r6, #1524	; 0x5f4
        bufferoffset = 0;
 8009154:	2400      	movs	r4, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 8009156:	18a5      	adds	r5, r4, r2
 8009158:	f240 53f4 	movw	r3, #1524	; 0x5f4
 800915c:	429d      	cmp	r5, r3
 800915e:	d8e7      	bhi.n	8009130 <low_level_input+0x3c>
      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
 8009160:	f8da 0004 	ldr.w	r0, [sl, #4]
 8009164:	eb09 0104 	add.w	r1, r9, r4
 8009168:	4430      	add	r0, r6
 800916a:	f006 f98c 	bl	800f486 <memcpy>
    for(q = p; q != NULL; q = q->next)
 800916e:	f8da a000 	ldr.w	sl, [sl]
      bufferoffset = bufferoffset + byteslefttocopy;
 8009172:	462c      	mov	r4, r5
    for(q = p; q != NULL; q = q->next)
 8009174:	f1ba 0f00 	cmp.w	sl, #0
 8009178:	d0ca      	beq.n	8009110 <low_level_input+0x1c>
      byteslefttocopy = q->len;
 800917a:	f8ba 200a 	ldrh.w	r2, [sl, #10]
      payloadoffset = 0;
 800917e:	2600      	movs	r6, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 8009180:	e7e9      	b.n	8009156 <low_level_input+0x62>
    {  
      dmarxdesc->Status |= ETH_DMARXDESC_OWN;
 8009182:	681a      	ldr	r2, [r3, #0]
 8009184:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8009188:	601a      	str	r2, [r3, #0]
      dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 800918a:	68db      	ldr	r3, [r3, #12]
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 800918c:	3101      	adds	r1, #1
 800918e:	4a0e      	ldr	r2, [pc, #56]	; (80091c8 <low_level_input+0xd4>)
 8009190:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8009192:	428a      	cmp	r2, r1
 8009194:	d8f5      	bhi.n	8009182 <low_level_input+0x8e>
    }
    
    /* Clear Segment_Count */
    heth.RxFrameInfos.SegCount =0;  
 8009196:	4b0c      	ldr	r3, [pc, #48]	; (80091c8 <low_level_input+0xd4>)
 8009198:	2200      	movs	r2, #0
 800919a:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
 800919c:	681b      	ldr	r3, [r3, #0]
 800919e:	f241 0214 	movw	r2, #4116	; 0x1014
 80091a2:	589a      	ldr	r2, [r3, r2]
 80091a4:	f012 0f80 	tst.w	r2, #128	; 0x80
 80091a8:	d007      	beq.n	80091ba <low_level_input+0xc6>
  {
    /* Clear RBUS ETHERNET DMA flag */
    heth.Instance->DMASR = ETH_DMASR_RBUS;
 80091aa:	f241 0214 	movw	r2, #4116	; 0x1014
 80091ae:	2180      	movs	r1, #128	; 0x80
 80091b0:	5099      	str	r1, [r3, r2]
    /* Resume DMA reception */
    heth.Instance->DMARPDR = 0;
 80091b2:	f241 0208 	movw	r2, #4104	; 0x1008
 80091b6:	2100      	movs	r1, #0
 80091b8:	5099      	str	r1, [r3, r2]
  }
  return p;
}
 80091ba:	4640      	mov	r0, r8
 80091bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return NULL;
 80091c0:	f04f 0800 	mov.w	r8, #0
 80091c4:	e7f9      	b.n	80091ba <low_level_input+0xc6>
 80091c6:	bf00      	nop
 80091c8:	20009ef0 	.word	0x20009ef0

080091cc <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void ethernetif_input( void const * argument ) 
{
 80091cc:	b538      	push	{r3, r4, r5, lr}
 80091ce:	4605      	mov	r5, r0
  struct pbuf *p;
  struct netif *netif = (struct netif *) argument;
  
  for( ;; )
  {
    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
 80091d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80091d4:	4b0b      	ldr	r3, [pc, #44]	; (8009204 <ethernetif_input+0x38>)
 80091d6:	6818      	ldr	r0, [r3, #0]
 80091d8:	f7fa fd86 	bl	8003ce8 <osSemaphoreWait>
 80091dc:	2800      	cmp	r0, #0
 80091de:	d1f7      	bne.n	80091d0 <ethernetif_input+0x4>
 80091e0:	e001      	b.n	80091e6 <ethernetif_input+0x1a>
          if (netif->input( p, netif) != ERR_OK )
          {
            pbuf_free(p);
          }
        }
      } while(p!=NULL);
 80091e2:	2c00      	cmp	r4, #0
 80091e4:	d0f4      	beq.n	80091d0 <ethernetif_input+0x4>
        p = low_level_input( netif );
 80091e6:	4628      	mov	r0, r5
 80091e8:	f7ff ff84 	bl	80090f4 <low_level_input>
        if   (p != NULL)
 80091ec:	4604      	mov	r4, r0
 80091ee:	2800      	cmp	r0, #0
 80091f0:	d0f7      	beq.n	80091e2 <ethernetif_input+0x16>
          if (netif->input( p, netif) != ERR_OK )
 80091f2:	692b      	ldr	r3, [r5, #16]
 80091f4:	4629      	mov	r1, r5
 80091f6:	4798      	blx	r3
 80091f8:	2800      	cmp	r0, #0
 80091fa:	d0f2      	beq.n	80091e2 <ethernetif_input+0x16>
            pbuf_free(p);
 80091fc:	4620      	mov	r0, r4
 80091fe:	f7fd f94d 	bl	800649c <pbuf_free>
 8009202:	e7ee      	b.n	80091e2 <ethernetif_input+0x16>
 8009204:	200033f8 	.word	0x200033f8

08009208 <low_level_output>:
{
 8009208:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800920c:	468b      	mov	fp, r1
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 800920e:	4b2c      	ldr	r3, [pc, #176]	; (80092c0 <low_level_output+0xb8>)
 8009210:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 8009212:	f8d6 a008 	ldr.w	sl, [r6, #8]
  bufferoffset = 0;
 8009216:	2400      	movs	r4, #0
  uint32_t framelength = 0;
 8009218:	4627      	mov	r7, r4
  for(q = p; q != NULL; q = q->next)
 800921a:	f1bb 0f00 	cmp.w	fp, #0
 800921e:	d032      	beq.n	8009286 <low_level_output+0x7e>
      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 8009220:	6833      	ldr	r3, [r6, #0]
 8009222:	2b00      	cmp	r3, #0
 8009224:	db35      	blt.n	8009292 <low_level_output+0x8a>
      byteslefttocopy = q->len;
 8009226:	f8bb 900a 	ldrh.w	r9, [fp, #10]
      payloadoffset = 0;
 800922a:	2500      	movs	r5, #0
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 800922c:	eb04 0809 	add.w	r8, r4, r9
 8009230:	f240 53f4 	movw	r3, #1524	; 0x5f4
 8009234:	4598      	cmp	r8, r3
 8009236:	d919      	bls.n	800926c <low_level_output+0x64>
        memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
 8009238:	f8db 1004 	ldr.w	r1, [fp, #4]
 800923c:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8009240:	1b12      	subs	r2, r2, r4
 8009242:	4429      	add	r1, r5
 8009244:	eb0a 0004 	add.w	r0, sl, r4
 8009248:	f006 f91d 	bl	800f486 <memcpy>
        DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
 800924c:	68f6      	ldr	r6, [r6, #12]
        if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 800924e:	6833      	ldr	r3, [r6, #0]
 8009250:	2b00      	cmp	r3, #0
 8009252:	db21      	blt.n	8009298 <low_level_output+0x90>
        buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
 8009254:	f8d6 a008 	ldr.w	sl, [r6, #8]
        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
 8009258:	f2a8 59f4 	subw	r9, r8, #1524	; 0x5f4
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
 800925c:	1b2d      	subs	r5, r5, r4
 800925e:	f205 55f4 	addw	r5, r5, #1524	; 0x5f4
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
 8009262:	1b3f      	subs	r7, r7, r4
 8009264:	f207 57f4 	addw	r7, r7, #1524	; 0x5f4
        bufferoffset = 0;
 8009268:	2400      	movs	r4, #0
 800926a:	e7df      	b.n	800922c <low_level_output+0x24>
      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
 800926c:	f8db 1004 	ldr.w	r1, [fp, #4]
 8009270:	464a      	mov	r2, r9
 8009272:	4429      	add	r1, r5
 8009274:	eb0a 0004 	add.w	r0, sl, r4
 8009278:	f006 f905 	bl	800f486 <memcpy>
      framelength = framelength + byteslefttocopy;
 800927c:	444f      	add	r7, r9
  for(q = p; q != NULL; q = q->next)
 800927e:	f8db b000 	ldr.w	fp, [fp]
      bufferoffset = bufferoffset + byteslefttocopy;
 8009282:	4644      	mov	r4, r8
 8009284:	e7c9      	b.n	800921a <low_level_output+0x12>
  HAL_ETH_TransmitFrame(&heth, framelength);
 8009286:	4639      	mov	r1, r7
 8009288:	480d      	ldr	r0, [pc, #52]	; (80092c0 <low_level_output+0xb8>)
 800928a:	f7f8 fb2f 	bl	80018ec <HAL_ETH_TransmitFrame>
  errval = ERR_OK;
 800928e:	2000      	movs	r0, #0
 8009290:	e004      	b.n	800929c <low_level_output+0x94>
        errval = ERR_USE;
 8009292:	f06f 0007 	mvn.w	r0, #7
 8009296:	e001      	b.n	800929c <low_level_output+0x94>
          errval = ERR_USE;
 8009298:	f06f 0007 	mvn.w	r0, #7
  if ((heth.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
 800929c:	4b08      	ldr	r3, [pc, #32]	; (80092c0 <low_level_output+0xb8>)
 800929e:	681b      	ldr	r3, [r3, #0]
 80092a0:	f241 0214 	movw	r2, #4116	; 0x1014
 80092a4:	589a      	ldr	r2, [r3, r2]
 80092a6:	f012 0f20 	tst.w	r2, #32
 80092aa:	d007      	beq.n	80092bc <low_level_output+0xb4>
    heth.Instance->DMASR = ETH_DMASR_TUS;
 80092ac:	f241 0214 	movw	r2, #4116	; 0x1014
 80092b0:	2120      	movs	r1, #32
 80092b2:	5099      	str	r1, [r3, r2]
    heth.Instance->DMATPDR = 0;
 80092b4:	f241 0204 	movw	r2, #4100	; 0x1004
 80092b8:	2100      	movs	r1, #0
 80092ba:	5099      	str	r1, [r3, r2]
}
 80092bc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80092c0:	20009ef0 	.word	0x20009ef0

080092c4 <low_level_init>:
{ 
 80092c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80092c6:	b08b      	sub	sp, #44	; 0x2c
 80092c8:	4604      	mov	r4, r0
  uint32_t regvalue = 0;
 80092ca:	2300      	movs	r3, #0
 80092cc:	9309      	str	r3, [sp, #36]	; 0x24
  heth.Instance = ETH;
 80092ce:	4840      	ldr	r0, [pc, #256]	; (80093d0 <low_level_init+0x10c>)
 80092d0:	4a40      	ldr	r2, [pc, #256]	; (80093d4 <low_level_init+0x110>)
 80092d2:	6002      	str	r2, [r0, #0]
  heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 80092d4:	2201      	movs	r2, #1
 80092d6:	6042      	str	r2, [r0, #4]
  heth.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
 80092d8:	8203      	strh	r3, [r0, #16]
  MACAddr[0] = 0x00;
 80092da:	f88d 301c 	strb.w	r3, [sp, #28]
  MACAddr[1] = 0x80;
 80092de:	2180      	movs	r1, #128	; 0x80
 80092e0:	f88d 101d 	strb.w	r1, [sp, #29]
  MACAddr[2] = 0xE1;
 80092e4:	21e1      	movs	r1, #225	; 0xe1
 80092e6:	f88d 101e 	strb.w	r1, [sp, #30]
  MACAddr[3] = 0x00;
 80092ea:	f88d 301f 	strb.w	r3, [sp, #31]
  MACAddr[4] = 0x00;
 80092ee:	f88d 3020 	strb.w	r3, [sp, #32]
  MACAddr[5] = 0x00;
 80092f2:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
  heth.Init.MACAddr = &MACAddr[0];
 80092f6:	a907      	add	r1, sp, #28
 80092f8:	6141      	str	r1, [r0, #20]
  heth.Init.RxMode = ETH_RXINTERRUPT_MODE;
 80092fa:	6182      	str	r2, [r0, #24]
  heth.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 80092fc:	61c3      	str	r3, [r0, #28]
  heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 80092fe:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 8009302:	6203      	str	r3, [r0, #32]
  hal_eth_init_status = HAL_ETH_Init(&heth);
 8009304:	f7f8 fc8c 	bl	8001c20 <HAL_ETH_Init>
  if (hal_eth_init_status == HAL_OK)
 8009308:	b928      	cbnz	r0, 8009316 <low_level_init+0x52>
    netif->flags |= NETIF_FLAG_LINK_UP;
 800930a:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 800930e:	f043 0304 	orr.w	r3, r3, #4
 8009312:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
  HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 8009316:	4d2e      	ldr	r5, [pc, #184]	; (80093d0 <low_level_init+0x10c>)
 8009318:	2304      	movs	r3, #4
 800931a:	4a2f      	ldr	r2, [pc, #188]	; (80093d8 <low_level_init+0x114>)
 800931c:	492f      	ldr	r1, [pc, #188]	; (80093dc <low_level_init+0x118>)
 800931e:	4628      	mov	r0, r5
 8009320:	f7f8 fa75 	bl	800180e <HAL_ETH_DMATxDescListInit>
  HAL_ETH_DMARxDescListInit(&heth, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 8009324:	2304      	movs	r3, #4
 8009326:	4a2e      	ldr	r2, [pc, #184]	; (80093e0 <low_level_init+0x11c>)
 8009328:	492e      	ldr	r1, [pc, #184]	; (80093e4 <low_level_init+0x120>)
 800932a:	4628      	mov	r0, r5
 800932c:	f7f8 faa8 	bl	8001880 <HAL_ETH_DMARxDescListInit>
  netif->hwaddr_len = ETH_HWADDR_LEN;
 8009330:	2306      	movs	r3, #6
 8009332:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
 8009336:	696b      	ldr	r3, [r5, #20]
 8009338:	781a      	ldrb	r2, [r3, #0]
 800933a:	f884 2029 	strb.w	r2, [r4, #41]	; 0x29
  netif->hwaddr[1] =  heth.Init.MACAddr[1];
 800933e:	785a      	ldrb	r2, [r3, #1]
 8009340:	f884 202a 	strb.w	r2, [r4, #42]	; 0x2a
  netif->hwaddr[2] =  heth.Init.MACAddr[2];
 8009344:	789a      	ldrb	r2, [r3, #2]
 8009346:	f884 202b 	strb.w	r2, [r4, #43]	; 0x2b
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
 800934a:	78da      	ldrb	r2, [r3, #3]
 800934c:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
  netif->hwaddr[4] =  heth.Init.MACAddr[4];
 8009350:	791a      	ldrb	r2, [r3, #4]
 8009352:	f884 202d 	strb.w	r2, [r4, #45]	; 0x2d
  netif->hwaddr[5] =  heth.Init.MACAddr[5];
 8009356:	795b      	ldrb	r3, [r3, #5]
 8009358:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
  netif->mtu = 1500;
 800935c:	f240 53dc 	movw	r3, #1500	; 0x5dc
 8009360:	84e3      	strh	r3, [r4, #38]	; 0x26
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 8009362:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8009366:	f043 030a 	orr.w	r3, r3, #10
 800936a:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
  osSemaphoreDef(SEM);
 800936e:	a80a      	add	r0, sp, #40	; 0x28
 8009370:	2300      	movs	r3, #0
 8009372:	f840 3d10 	str.w	r3, [r0, #-16]!
  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
 8009376:	2101      	movs	r1, #1
 8009378:	f7fa fca2 	bl	8003cc0 <osSemaphoreCreate>
 800937c:	4b1a      	ldr	r3, [pc, #104]	; (80093e8 <low_level_init+0x124>)
 800937e:	6018      	str	r0, [r3, #0]
  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
 8009380:	ae01      	add	r6, sp, #4
 8009382:	4f1a      	ldr	r7, [pc, #104]	; (80093ec <low_level_init+0x128>)
 8009384:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8009386:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8009388:	683b      	ldr	r3, [r7, #0]
 800938a:	6033      	str	r3, [r6, #0]
  osThreadCreate (osThread(EthIf), netif);
 800938c:	4621      	mov	r1, r4
 800938e:	a801      	add	r0, sp, #4
 8009390:	f7fa fc05 	bl	8003b9e <osThreadCreate>
  HAL_ETH_Start(&heth);
 8009394:	4628      	mov	r0, r5
 8009396:	f7f8 fd6d 	bl	8001e74 <HAL_ETH_Start>
  netif->flags |= NETIF_FLAG_IGMP;
 800939a:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 800939e:	f043 0320 	orr.w	r3, r3, #32
 80093a2:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR, &regvalue);
 80093a6:	aa09      	add	r2, sp, #36	; 0x24
 80093a8:	211d      	movs	r1, #29
 80093aa:	4628      	mov	r0, r5
 80093ac:	f7f8 fbc2 	bl	8001b34 <HAL_ETH_ReadPHYRegister>
  regvalue |= (PHY_ISFR_INT4);
 80093b0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80093b2:	f042 020b 	orr.w	r2, r2, #11
 80093b6:	9209      	str	r2, [sp, #36]	; 0x24
  HAL_ETH_WritePHYRegister(&heth, PHY_ISFR , regvalue );
 80093b8:	211d      	movs	r1, #29
 80093ba:	4628      	mov	r0, r5
 80093bc:	f7f8 fbf6 	bl	8001bac <HAL_ETH_WritePHYRegister>
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR , &regvalue);
 80093c0:	aa09      	add	r2, sp, #36	; 0x24
 80093c2:	211d      	movs	r1, #29
 80093c4:	4628      	mov	r0, r5
 80093c6:	f7f8 fbb5 	bl	8001b34 <HAL_ETH_ReadPHYRegister>
}
 80093ca:	b00b      	add	sp, #44	; 0x2c
 80093cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80093ce:	bf00      	nop
 80093d0:	20009ef0 	.word	0x20009ef0
 80093d4:	40028000 	.word	0x40028000
 80093d8:	20009f38 	.word	0x20009f38
 80093dc:	20008620 	.word	0x20008620
 80093e0:	200086a0 	.word	0x200086a0
 80093e4:	20009e70 	.word	0x20009e70
 80093e8:	200033f8 	.word	0x200033f8
 80093ec:	080108e4 	.word	0x080108e4

080093f0 <HAL_ETH_MspInit>:
  if(ethHandle->Instance==ETH)
 80093f0:	6802      	ldr	r2, [r0, #0]
 80093f2:	4b3f      	ldr	r3, [pc, #252]	; (80094f0 <HAL_ETH_MspInit+0x100>)
 80093f4:	429a      	cmp	r2, r3
 80093f6:	d000      	beq.n	80093fa <HAL_ETH_MspInit+0xa>
 80093f8:	4770      	bx	lr
{
 80093fa:	b5f0      	push	{r4, r5, r6, r7, lr}
 80093fc:	b08d      	sub	sp, #52	; 0x34
    __HAL_RCC_ETH_CLK_ENABLE();
 80093fe:	f5a3 4390 	sub.w	r3, r3, #18432	; 0x4800
 8009402:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009404:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8009408:	631a      	str	r2, [r3, #48]	; 0x30
 800940a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800940c:	f002 7200 	and.w	r2, r2, #33554432	; 0x2000000
 8009410:	9200      	str	r2, [sp, #0]
 8009412:	9a00      	ldr	r2, [sp, #0]
 8009414:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009416:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800941a:	631a      	str	r2, [r3, #48]	; 0x30
 800941c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800941e:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 8009422:	9201      	str	r2, [sp, #4]
 8009424:	9a01      	ldr	r2, [sp, #4]
 8009426:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009428:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800942c:	631a      	str	r2, [r3, #48]	; 0x30
 800942e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009430:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 8009434:	9202      	str	r2, [sp, #8]
 8009436:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8009438:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800943a:	f042 0204 	orr.w	r2, r2, #4
 800943e:	631a      	str	r2, [r3, #48]	; 0x30
 8009440:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009442:	f002 0204 	and.w	r2, r2, #4
 8009446:	9203      	str	r2, [sp, #12]
 8009448:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800944a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800944c:	f042 0201 	orr.w	r2, r2, #1
 8009450:	631a      	str	r2, [r3, #48]	; 0x30
 8009452:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009454:	f002 0201 	and.w	r2, r2, #1
 8009458:	9204      	str	r2, [sp, #16]
 800945a:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800945c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800945e:	f042 0202 	orr.w	r2, r2, #2
 8009462:	631a      	str	r2, [r3, #48]	; 0x30
 8009464:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009466:	f002 0202 	and.w	r2, r2, #2
 800946a:	9205      	str	r2, [sp, #20]
 800946c:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 800946e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009470:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009474:	631a      	str	r2, [r3, #48]	; 0x30
 8009476:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009478:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800947c:	9306      	str	r3, [sp, #24]
 800947e:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
 8009480:	2332      	movs	r3, #50	; 0x32
 8009482:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009484:	2702      	movs	r7, #2
 8009486:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009488:	2400      	movs	r4, #0
 800948a:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800948c:	2603      	movs	r6, #3
 800948e:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8009490:	250b      	movs	r5, #11
 8009492:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009494:	a907      	add	r1, sp, #28
 8009496:	4817      	ldr	r0, [pc, #92]	; (80094f4 <HAL_ETH_MspInit+0x104>)
 8009498:	f7f8 fd0e 	bl	8001eb8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
 800949c:	2386      	movs	r3, #134	; 0x86
 800949e:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80094a0:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80094a2:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80094a4:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80094a6:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80094a8:	a907      	add	r1, sp, #28
 80094aa:	4813      	ldr	r0, [pc, #76]	; (80094f8 <HAL_ETH_MspInit+0x108>)
 80094ac:	f7f8 fd04 	bl	8001eb8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_TXD1_Pin;
 80094b0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80094b4:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80094b6:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80094b8:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80094ba:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80094bc:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(RMII_TXD1_GPIO_Port, &GPIO_InitStruct);
 80094be:	a907      	add	r1, sp, #28
 80094c0:	480e      	ldr	r0, [pc, #56]	; (80094fc <HAL_ETH_MspInit+0x10c>)
 80094c2:	f7f8 fcf9 	bl	8001eb8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_TX_EN_Pin|RMII_TXD0_Pin;
 80094c6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80094ca:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80094cc:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80094ce:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80094d0:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80094d2:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80094d4:	a907      	add	r1, sp, #28
 80094d6:	480a      	ldr	r0, [pc, #40]	; (8009500 <HAL_ETH_MspInit+0x110>)
 80094d8:	f7f8 fcee 	bl	8001eb8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(ETH_IRQn, 5, 0);
 80094dc:	4622      	mov	r2, r4
 80094de:	2105      	movs	r1, #5
 80094e0:	203d      	movs	r0, #61	; 0x3d
 80094e2:	f7f8 f85f 	bl	80015a4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ETH_IRQn);
 80094e6:	203d      	movs	r0, #61	; 0x3d
 80094e8:	f7f8 f88e 	bl	8001608 <HAL_NVIC_EnableIRQ>
}
 80094ec:	b00d      	add	sp, #52	; 0x34
 80094ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80094f0:	40028000 	.word	0x40028000
 80094f4:	40020800 	.word	0x40020800
 80094f8:	40020000 	.word	0x40020000
 80094fc:	40020400 	.word	0x40020400
 8009500:	40021800 	.word	0x40021800

08009504 <HAL_ETH_RxCpltCallback>:
{
 8009504:	b508      	push	{r3, lr}
  osSemaphoreRelease(s_xSemaphore);
 8009506:	4b02      	ldr	r3, [pc, #8]	; (8009510 <HAL_ETH_RxCpltCallback+0xc>)
 8009508:	6818      	ldr	r0, [r3, #0]
 800950a:	f7fa fc25 	bl	8003d58 <osSemaphoreRelease>
}
 800950e:	bd08      	pop	{r3, pc}
 8009510:	200033f8 	.word	0x200033f8

08009514 <ethernetif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ethernetif_init(struct netif *netif)
{
 8009514:	b510      	push	{r4, lr}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 8009516:	4604      	mov	r4, r0
 8009518:	b170      	cbz	r0, 8009538 <ethernetif_init+0x24>
#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
 800951a:	2373      	movs	r3, #115	; 0x73
 800951c:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  netif->name[1] = IFNAME1;
 8009520:	2374      	movs	r3, #116	; 0x74
 8009522:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
   * is available...) */

#if LWIP_IPV4
#if LWIP_ARP || LWIP_ETHERNET
#if LWIP_ARP
  netif->output = etharp_output;
 8009526:	4b08      	ldr	r3, [pc, #32]	; (8009548 <ethernetif_init+0x34>)
 8009528:	6163      	str	r3, [r4, #20]
 
#if LWIP_IPV6
  netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */

  netif->linkoutput = low_level_output;
 800952a:	4b08      	ldr	r3, [pc, #32]	; (800954c <ethernetif_init+0x38>)
 800952c:	61a3      	str	r3, [r4, #24]

  /* initialize the hardware */
  low_level_init(netif);
 800952e:	4620      	mov	r0, r4
 8009530:	f7ff fec8 	bl	80092c4 <low_level_init>

  return ERR_OK;
}
 8009534:	2000      	movs	r0, #0
 8009536:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 8009538:	4b05      	ldr	r3, [pc, #20]	; (8009550 <ethernetif_init+0x3c>)
 800953a:	f240 222d 	movw	r2, #557	; 0x22d
 800953e:	4905      	ldr	r1, [pc, #20]	; (8009554 <ethernetif_init+0x40>)
 8009540:	4805      	ldr	r0, [pc, #20]	; (8009558 <ethernetif_init+0x44>)
 8009542:	f005 ffb3 	bl	800f4ac <iprintf>
 8009546:	e7e8      	b.n	800951a <ethernetif_init+0x6>
 8009548:	080079d1 	.word	0x080079d1
 800954c:	08009209 	.word	0x08009209
 8009550:	08011b80 	.word	0x08011b80
 8009554:	080113a8 	.word	0x080113a8
 8009558:	080109f4 	.word	0x080109f4

0800955c <sys_now>:
*         when LWIP_TIMERS == 1 and NO_SYS == 1
* @param  None
* @retval Time
*/
u32_t sys_now(void)
{
 800955c:	b508      	push	{r3, lr}
  return HAL_GetTick();
 800955e:	f7f7 fff5 	bl	800154c <HAL_GetTick>
}
 8009562:	bd08      	pop	{r3, pc}

08009564 <MX_LWIP_Init>:

/**
  * LwIP initialization function
  */
void MX_LWIP_Init(void)
{
 8009564:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009566:	b085      	sub	sp, #20
  /* IP addresses initialization */
  IP_ADDRESS[0] = 192;
 8009568:	4f3b      	ldr	r7, [pc, #236]	; (8009658 <MX_LWIP_Init+0xf4>)
 800956a:	21c0      	movs	r1, #192	; 0xc0
 800956c:	7039      	strb	r1, [r7, #0]
  IP_ADDRESS[1] = 168;
 800956e:	22a8      	movs	r2, #168	; 0xa8
 8009570:	707a      	strb	r2, [r7, #1]
  IP_ADDRESS[2] = 0;
 8009572:	2400      	movs	r4, #0
 8009574:	70bc      	strb	r4, [r7, #2]
  IP_ADDRESS[3] = 47;
 8009576:	232f      	movs	r3, #47	; 0x2f
 8009578:	70fb      	strb	r3, [r7, #3]
  NETMASK_ADDRESS[0] = 255;
 800957a:	4e38      	ldr	r6, [pc, #224]	; (800965c <MX_LWIP_Init+0xf8>)
 800957c:	23ff      	movs	r3, #255	; 0xff
 800957e:	7033      	strb	r3, [r6, #0]
  NETMASK_ADDRESS[1] = 255;
 8009580:	7073      	strb	r3, [r6, #1]
  NETMASK_ADDRESS[2] = 255;
 8009582:	70b3      	strb	r3, [r6, #2]
  NETMASK_ADDRESS[3] = 0;
 8009584:	70f4      	strb	r4, [r6, #3]
  GATEWAY_ADDRESS[0] = 192;
 8009586:	4d36      	ldr	r5, [pc, #216]	; (8009660 <MX_LWIP_Init+0xfc>)
 8009588:	7029      	strb	r1, [r5, #0]
  GATEWAY_ADDRESS[1] = 168;
 800958a:	706a      	strb	r2, [r5, #1]
  GATEWAY_ADDRESS[2] = 0;
 800958c:	70ac      	strb	r4, [r5, #2]
  GATEWAY_ADDRESS[3] = 1;
 800958e:	2301      	movs	r3, #1
 8009590:	70eb      	strb	r3, [r5, #3]
  
  /* Initilialize the LwIP stack with RTOS */
  tcpip_init( NULL, NULL );
 8009592:	4621      	mov	r1, r4
 8009594:	4620      	mov	r0, r4
 8009596:	f7fc fa8b 	bl	8005ab0 <tcpip_init>

  /* IP addresses initialization without DHCP (IPv4) */
  IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
 800959a:	783a      	ldrb	r2, [r7, #0]
 800959c:	787b      	ldrb	r3, [r7, #1]
 800959e:	041b      	lsls	r3, r3, #16
 80095a0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80095a4:	78ba      	ldrb	r2, [r7, #2]
 80095a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80095aa:	78fa      	ldrb	r2, [r7, #3]
 80095ac:	4313      	orrs	r3, r2
 80095ae:	021a      	lsls	r2, r3, #8
 80095b0:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 80095b4:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80095b8:	0a19      	lsrs	r1, r3, #8
 80095ba:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
 80095be:	430a      	orrs	r2, r1
 80095c0:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 80095c4:	4927      	ldr	r1, [pc, #156]	; (8009664 <MX_LWIP_Init+0x100>)
 80095c6:	600b      	str	r3, [r1, #0]
  IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
 80095c8:	7832      	ldrb	r2, [r6, #0]
 80095ca:	7873      	ldrb	r3, [r6, #1]
 80095cc:	041b      	lsls	r3, r3, #16
 80095ce:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80095d2:	78b2      	ldrb	r2, [r6, #2]
 80095d4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80095d8:	78f2      	ldrb	r2, [r6, #3]
 80095da:	4313      	orrs	r3, r2
 80095dc:	021a      	lsls	r2, r3, #8
 80095de:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 80095e2:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80095e6:	0a18      	lsrs	r0, r3, #8
 80095e8:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 80095ec:	4302      	orrs	r2, r0
 80095ee:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 80095f2:	4a1d      	ldr	r2, [pc, #116]	; (8009668 <MX_LWIP_Init+0x104>)
 80095f4:	6013      	str	r3, [r2, #0]
  IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
 80095f6:	7828      	ldrb	r0, [r5, #0]
 80095f8:	786b      	ldrb	r3, [r5, #1]
 80095fa:	041b      	lsls	r3, r3, #16
 80095fc:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8009600:	78a8      	ldrb	r0, [r5, #2]
 8009602:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8009606:	78e8      	ldrb	r0, [r5, #3]
 8009608:	4303      	orrs	r3, r0
 800960a:	0218      	lsls	r0, r3, #8
 800960c:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 8009610:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 8009614:	0a1d      	lsrs	r5, r3, #8
 8009616:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
 800961a:	4328      	orrs	r0, r5
 800961c:	ea40 6013 	orr.w	r0, r0, r3, lsr #24
 8009620:	4b12      	ldr	r3, [pc, #72]	; (800966c <MX_LWIP_Init+0x108>)
 8009622:	6018      	str	r0, [r3, #0]

  /* add the network interface (IPv4/IPv6) with RTOS */
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
 8009624:	4d12      	ldr	r5, [pc, #72]	; (8009670 <MX_LWIP_Init+0x10c>)
 8009626:	4813      	ldr	r0, [pc, #76]	; (8009674 <MX_LWIP_Init+0x110>)
 8009628:	9002      	str	r0, [sp, #8]
 800962a:	4813      	ldr	r0, [pc, #76]	; (8009678 <MX_LWIP_Init+0x114>)
 800962c:	9001      	str	r0, [sp, #4]
 800962e:	9400      	str	r4, [sp, #0]
 8009630:	4628      	mov	r0, r5
 8009632:	f7fc fe01 	bl	8006238 <netif_add>

  /* Registers the default network interface */
  netif_set_default(&gnetif);
 8009636:	4628      	mov	r0, r5
 8009638:	f7fc fe48 	bl	80062cc <netif_set_default>

  if (netif_is_link_up(&gnetif))
 800963c:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 8009640:	f013 0f04 	tst.w	r3, #4
 8009644:	d104      	bne.n	8009650 <MX_LWIP_Init+0xec>
    netif_set_up(&gnetif);
  }
  else
  {
    /* When the netif link is down this function must be called */
    netif_set_down(&gnetif);
 8009646:	480a      	ldr	r0, [pc, #40]	; (8009670 <MX_LWIP_Init+0x10c>)
 8009648:	f7fc fe58 	bl	80062fc <netif_set_down>
  }

/* USER CODE BEGIN 3 */

/* USER CODE END 3 */
}
 800964c:	b005      	add	sp, #20
 800964e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    netif_set_up(&gnetif);
 8009650:	4628      	mov	r0, r5
 8009652:	f7fc fe41 	bl	80062d8 <netif_set_up>
 8009656:	e7f9      	b.n	800964c <MX_LWIP_Init+0xe8>
 8009658:	2000b74c 	.word	0x2000b74c
 800965c:	2000b748 	.word	0x2000b748
 8009660:	2000b708 	.word	0x2000b708
 8009664:	2000b744 	.word	0x2000b744
 8009668:	2000b750 	.word	0x2000b750
 800966c:	2000b754 	.word	0x2000b754
 8009670:	2000b70c 	.word	0x2000b70c
 8009674:	08005a8d 	.word	0x08005a8d
 8009678:	08009515 	.word	0x08009515

0800967c <_Z7setTruePv>:
	// Receive done. Wake up thread an continue
	xTaskNotifyGive(defaultTaskHandle);
}

void setTrue(void* args){
	*static_cast<volatile bool*>(args) = true;
 800967c:	2301      	movs	r3, #1
 800967e:	7003      	strb	r3, [r0, #0]
}
 8009680:	4770      	bx	lr

08009682 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE16registerCallbackEPFvPvRKNS_17ReaderCacheChangeEES3_>:
    }
}

template <class NetworkDriver>
void StatefulReaderT<NetworkDriver>::registerCallback(ddsReaderCallback_fp cb, void* callee){
    if(cb != nullptr){
 8009682:	b119      	cbz	r1, 800968c <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE16registerCallbackEPFvPvRKNS_17ReaderCacheChangeEES3_+0xa>
        m_callback = cb;
 8009684:	f8c0 1120 	str.w	r1, [r0, #288]	; 0x120
        m_callee = callee; // It's okay if this is null
 8009688:	f8c0 2124 	str.w	r2, [r0, #292]	; 0x124
    }else{
#if SLR_VERBOSE
        printf("StatefulReader[%s]: Passed callback is nullptr\n", &m_attributes.topicName[0]);
#endif
    }
}
 800968c:	4770      	bx	lr

0800968e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE>:

    return true;
}

template <class NetworkDriver>
bool StatefulWriterT<NetworkDriver>::addNewMatchedReader(const ReaderProxy& newProxy){
 800968e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if SFW_VERBOSE
    log("StatefulWriter[%s]: New reader added with id: ", &this->m_attributes.topicName[0]);
    printGuid(newProxy.remoteReaderGuid);
    log("\n");
#endif
    return m_proxies.add(newProxy);
 8009690:	f500 75bc 	add.w	r5, r0, #376	; 0x178
        uint32_t getSize(){
            return SIZE;
        }

        bool isFull(){
            return m_numElements == SIZE;
 8009694:	686e      	ldr	r6, [r5, #4]
        uint32_t getNumElements(){
        	return m_numElements;
        }

        bool add(const TYPE& data){
            if(isFull()){
 8009696:	2e03      	cmp	r6, #3
 8009698:	d025      	beq.n	80096e6 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x58>
                return false;
            }
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 800969a:	2400      	movs	r4, #0
 800969c:	bb2c      	cbnz	r4, 80096ea <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x5c>
                if(bucket != 0xFF){
 800969e:	2cff      	cmp	r4, #255	; 0xff
 80096a0:	d01e      	beq.n	80096e0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x52>
                    uint8_t byte = m_bitMap[bucket];
 80096a2:	4620      	mov	r0, r4
 80096a4:	5d2f      	ldrb	r7, [r5, r4]
                    for(uint8_t bit=0; bit < 8; ++bit){
 80096a6:	4623      	mov	r3, r4
                    uint8_t byte = m_bitMap[bucket];
 80096a8:	463a      	mov	r2, r7
                    for(uint8_t bit=0; bit < 8; ++bit){
 80096aa:	2b07      	cmp	r3, #7
 80096ac:	d818      	bhi.n	80096e0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x52>
                        if(!(byte & 1)){
 80096ae:	f012 0f01 	tst.w	r2, #1
 80096b2:	d003      	beq.n	80096bc <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x2e>
                            m_bitMap[bucket] |= 1 << bit;
                            m_data[bucket*8+bit] = data;
                            ++m_numElements;
                            return true;
                        }
                        byte = byte>>1;
 80096b4:	0852      	lsrs	r2, r2, #1
                    for(uint8_t bit=0; bit < 8; ++bit){
 80096b6:	3301      	adds	r3, #1
 80096b8:	b2db      	uxtb	r3, r3
 80096ba:	e7f6      	b.n	80096aa <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x1c>
                            m_bitMap[bucket] |= 1 << bit;
 80096bc:	2401      	movs	r4, #1
 80096be:	fa04 f203 	lsl.w	r2, r4, r3
 80096c2:	4317      	orrs	r7, r2
 80096c4:	542f      	strb	r7, [r5, r0]
                            m_data[bucket*8+bit] = data;
 80096c6:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 80096ca:	2258      	movs	r2, #88	; 0x58
 80096cc:	fb02 5303 	mla	r3, r2, r3, r5
 80096d0:	f103 0008 	add.w	r0, r3, #8
 80096d4:	f005 fed7 	bl	800f486 <memcpy>
                            ++m_numElements;
 80096d8:	4426      	add	r6, r4
 80096da:	606e      	str	r6, [r5, #4]
                            return true;
 80096dc:	4620      	mov	r0, r4
 80096de:	e005      	b.n	80096ec <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x5e>
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 80096e0:	3401      	adds	r4, #1
 80096e2:	b2e4      	uxtb	r4, r4
 80096e4:	e7da      	b.n	800969c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0xe>
                return false;
 80096e6:	2000      	movs	r0, #0
 80096e8:	e000      	b.n	80096ec <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x5e>
                    }
                }
            }
            return false;
 80096ea:	2000      	movs	r0, #0
}
 80096ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080096ee <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE>:

template <class NetworkDriver>
bool StatefulReaderT<NetworkDriver>::addNewMatchedWriter(const WriterProxy& newProxy){
 80096ee:	b4f0      	push	{r4, r5, r6, r7}
#if SFR_VERBOSE
    printf("StatefulReader[%s]: New writer added with id: ", &this->m_attributes.topicName[0]);
    printGuid(newProxy.remoteWriterGuid);
    printf("\n");
#endif
    return m_proxies.add(newProxy);
 80096f0:	f100 0570 	add.w	r5, r0, #112	; 0x70
            return m_numElements == SIZE;
 80096f4:	686e      	ldr	r6, [r5, #4]
            if(isFull()){
 80096f6:	2e03      	cmp	r6, #3
 80096f8:	d02f      	beq.n	800975a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x6c>
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 80096fa:	2000      	movs	r0, #0
 80096fc:	bb78      	cbnz	r0, 800975e <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x70>
                if(bucket != 0xFF){
 80096fe:	28ff      	cmp	r0, #255	; 0xff
 8009700:	d028      	beq.n	8009754 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x66>
                    uint8_t byte = m_bitMap[bucket];
 8009702:	4607      	mov	r7, r0
 8009704:	5c2c      	ldrb	r4, [r5, r0]
                    for(uint8_t bit=0; bit < 8; ++bit){
 8009706:	4603      	mov	r3, r0
                    uint8_t byte = m_bitMap[bucket];
 8009708:	4622      	mov	r2, r4
                    for(uint8_t bit=0; bit < 8; ++bit){
 800970a:	2b07      	cmp	r3, #7
 800970c:	d822      	bhi.n	8009754 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x66>
                        if(!(byte & 1)){
 800970e:	f012 0f01 	tst.w	r2, #1
 8009712:	d003      	beq.n	800971c <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x2e>
                        byte = byte>>1;
 8009714:	0852      	lsrs	r2, r2, #1
                    for(uint8_t bit=0; bit < 8; ++bit){
 8009716:	3301      	adds	r3, #1
 8009718:	b2db      	uxtb	r3, r3
 800971a:	e7f6      	b.n	800970a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x1c>
                            m_bitMap[bucket] |= 1 << bit;
 800971c:	f04f 0c01 	mov.w	ip, #1
 8009720:	fa0c f203 	lsl.w	r2, ip, r3
 8009724:	4314      	orrs	r4, r2
 8009726:	55ec      	strb	r4, [r5, r7]
                            m_data[bucket*8+bit] = data;
 8009728:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 800972c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8009730:	00df      	lsls	r7, r3, #3
 8009732:	442f      	add	r7, r5
 8009734:	3708      	adds	r7, #8
 8009736:	460c      	mov	r4, r1
 8009738:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800973a:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 800973c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800973e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8009740:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8009742:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8009744:	e894 0003 	ldmia.w	r4, {r0, r1}
 8009748:	e887 0003 	stmia.w	r7, {r0, r1}
                            ++m_numElements;
 800974c:	4466      	add	r6, ip
 800974e:	606e      	str	r6, [r5, #4]
                            return true;
 8009750:	4660      	mov	r0, ip
 8009752:	e005      	b.n	8009760 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x72>
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 8009754:	3001      	adds	r0, #1
 8009756:	b2c0      	uxtb	r0, r0
 8009758:	e7d0      	b.n	80096fc <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0xe>
                return false;
 800975a:	2000      	movs	r0, #0
 800975c:	e000      	b.n	8009760 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE19addNewMatchedWriterERKNS_11WriterProxyE+0x72>
            return false;
 800975e:	2000      	movs	r0, #0
}
 8009760:	bcf0      	pop	{r4, r5, r6, r7}
 8009762:	4770      	bx	lr

08009764 <_ZL12MX_GPIO_Initv>:
{
 8009764:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009766:	b091      	sub	sp, #68	; 0x44
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009768:	2400      	movs	r4, #0
 800976a:	940b      	str	r4, [sp, #44]	; 0x2c
 800976c:	940c      	str	r4, [sp, #48]	; 0x30
 800976e:	940d      	str	r4, [sp, #52]	; 0x34
 8009770:	940e      	str	r4, [sp, #56]	; 0x38
 8009772:	940f      	str	r4, [sp, #60]	; 0x3c
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8009774:	4b3f      	ldr	r3, [pc, #252]	; (8009874 <_ZL12MX_GPIO_Initv+0x110>)
 8009776:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009778:	f042 0204 	orr.w	r2, r2, #4
 800977c:	631a      	str	r2, [r3, #48]	; 0x30
 800977e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009780:	f002 0204 	and.w	r2, r2, #4
 8009784:	9200      	str	r2, [sp, #0]
 8009786:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8009788:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800978a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800978e:	631a      	str	r2, [r3, #48]	; 0x30
 8009790:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009792:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8009796:	9201      	str	r2, [sp, #4]
 8009798:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800979a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800979c:	f042 0201 	orr.w	r2, r2, #1
 80097a0:	631a      	str	r2, [r3, #48]	; 0x30
 80097a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80097a4:	f002 0201 	and.w	r2, r2, #1
 80097a8:	9202      	str	r2, [sp, #8]
 80097aa:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80097ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80097ae:	f042 0202 	orr.w	r2, r2, #2
 80097b2:	631a      	str	r2, [r3, #48]	; 0x30
 80097b4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80097b6:	f002 0202 	and.w	r2, r2, #2
 80097ba:	9203      	str	r2, [sp, #12]
 80097bc:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80097be:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80097c0:	f042 0208 	orr.w	r2, r2, #8
 80097c4:	631a      	str	r2, [r3, #48]	; 0x30
 80097c6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80097c8:	f002 0208 	and.w	r2, r2, #8
 80097cc:	9204      	str	r2, [sp, #16]
 80097ce:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80097d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80097d2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80097d6:	631a      	str	r2, [r3, #48]	; 0x30
 80097d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80097da:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80097de:	9305      	str	r3, [sp, #20]
 80097e0:	9b05      	ldr	r3, [sp, #20]
  HAL_GPIO_WritePin(GPIOB, LD3_Pin|LD2_Pin, GPIO_PIN_RESET);
 80097e2:	4f25      	ldr	r7, [pc, #148]	; (8009878 <_ZL12MX_GPIO_Initv+0x114>)
 80097e4:	4622      	mov	r2, r4
 80097e6:	f44f 4181 	mov.w	r1, #16512	; 0x4080
 80097ea:	4638      	mov	r0, r7
 80097ec:	f7f8 fc54 	bl	8002098 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 80097f0:	4e22      	ldr	r6, [pc, #136]	; (800987c <_ZL12MX_GPIO_Initv+0x118>)
 80097f2:	4622      	mov	r2, r4
 80097f4:	2140      	movs	r1, #64	; 0x40
 80097f6:	4630      	mov	r0, r6
 80097f8:	f7f8 fc4e 	bl	8002098 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = USER_Btn_Pin;
 80097fc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8009800:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8009802:	4b1f      	ldr	r3, [pc, #124]	; (8009880 <_ZL12MX_GPIO_Initv+0x11c>)
 8009804:	930c      	str	r3, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009806:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_Init(USER_Btn_GPIO_Port, &GPIO_InitStruct);
 8009808:	a90b      	add	r1, sp, #44	; 0x2c
 800980a:	481e      	ldr	r0, [pc, #120]	; (8009884 <_ZL12MX_GPIO_Initv+0x120>)
 800980c:	f7f8 fb54 	bl	8001eb8 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LD3_Pin|LD2_Pin;
 8009810:	f44f 4381 	mov.w	r3, #16512	; 0x4080
 8009814:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009816:	2501      	movs	r5, #1
 8009818:	950c      	str	r5, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800981a:	940d      	str	r4, [sp, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800981c:	940e      	str	r4, [sp, #56]	; 0x38
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800981e:	a90b      	add	r1, sp, #44	; 0x2c
 8009820:	4638      	mov	r0, r7
 8009822:	f7f8 fb49 	bl	8001eb8 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;
 8009826:	2340      	movs	r3, #64	; 0x40
 8009828:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800982a:	950c      	str	r5, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800982c:	940d      	str	r4, [sp, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800982e:	940e      	str	r4, [sp, #56]	; 0x38
  HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 8009830:	a90b      	add	r1, sp, #44	; 0x2c
 8009832:	4630      	mov	r0, r6
 8009834:	f7f8 fb40 	bl	8001eb8 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
 8009838:	2380      	movs	r3, #128	; 0x80
 800983a:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800983c:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800983e:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 8009840:	a90b      	add	r1, sp, #44	; 0x2c
 8009842:	4630      	mov	r0, r6
 8009844:	f7f8 fb38 	bl	8001eb8 <HAL_GPIO_Init>
#include "stm32f7xx_hal.h"

namespace GPIO{
	inline void initGPIO(){
		/*Configure GPIO pin Output Level */
		HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_11 | GPIO_PIN_12, GPIO_PIN_RESET); // D4 Matched, D5 RTT
 8009848:	f5a6 6640 	sub.w	r6, r6, #3072	; 0xc00
 800984c:	4622      	mov	r2, r4
 800984e:	f641 01f0 	movw	r1, #6384	; 0x18f0
 8009852:	4630      	mov	r0, r6
 8009854:	f7f8 fc20 	bl	8002098 <HAL_GPIO_WritePin>

		GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009858:	9408      	str	r4, [sp, #32]
 800985a:	9409      	str	r4, [sp, #36]	; 0x24
 800985c:	940a      	str	r4, [sp, #40]	; 0x28

		GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800985e:	9507      	str	r5, [sp, #28]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
		GPIO_InitStruct.Pin = GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_11 | GPIO_PIN_12;
 8009860:	a910      	add	r1, sp, #64	; 0x40
 8009862:	f641 03f0 	movw	r3, #6384	; 0x18f0
 8009866:	f841 3d28 	str.w	r3, [r1, #-40]!
		HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800986a:	4630      	mov	r0, r6
 800986c:	f7f8 fb24 	bl	8001eb8 <HAL_GPIO_Init>
}
 8009870:	b011      	add	sp, #68	; 0x44
 8009872:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009874:	40023800 	.word	0x40023800
 8009878:	40020400 	.word	0x40020400
 800987c:	40021800 	.word	0x40021800
 8009880:	10110000 	.word	0x10110000
 8009884:	40020800 	.word	0x40020800

08009888 <_ZL19MX_USART3_UART_Initv>:
{
 8009888:	b508      	push	{r3, lr}
  huart3.Instance = USART3;
 800988a:	4809      	ldr	r0, [pc, #36]	; (80098b0 <_ZL19MX_USART3_UART_Initv+0x28>)
 800988c:	4b09      	ldr	r3, [pc, #36]	; (80098b4 <_ZL19MX_USART3_UART_Initv+0x2c>)
 800988e:	6003      	str	r3, [r0, #0]
  huart3.Init.BaudRate = 115200;
 8009890:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8009894:	6043      	str	r3, [r0, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 8009896:	2300      	movs	r3, #0
 8009898:	6083      	str	r3, [r0, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 800989a:	60c3      	str	r3, [r0, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 800989c:	6103      	str	r3, [r0, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
 800989e:	220c      	movs	r2, #12
 80098a0:	6142      	str	r2, [r0, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80098a2:	6183      	str	r3, [r0, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 80098a4:	61c3      	str	r3, [r0, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80098a6:	6203      	str	r3, [r0, #32]
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80098a8:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart3) != HAL_OK)
 80098aa:	f7f9 ff9e 	bl	80037ea <HAL_UART_Init>
}
 80098ae:	bd08      	pop	{r3, pc}
 80098b0:	200033fc 	.word	0x200033fc
 80098b4:	40004800 	.word	0x40004800

080098b8 <_ZL19MX_USART6_UART_Initv>:
{
 80098b8:	b508      	push	{r3, lr}
  huart6.Instance = USART6;
 80098ba:	480f      	ldr	r0, [pc, #60]	; (80098f8 <_ZL19MX_USART6_UART_Initv+0x40>)
 80098bc:	4b0f      	ldr	r3, [pc, #60]	; (80098fc <_ZL19MX_USART6_UART_Initv+0x44>)
 80098be:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  huart6.Init.BaudRate = 115200;
 80098c2:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 80098c6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
 80098ca:	2300      	movs	r3, #0
 80098cc:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  huart6.Init.StopBits = UART_STOPBITS_1;
 80098d0:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart6.Init.Parity = UART_PARITY_NONE;
 80098d4:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
  huart6.Init.Mode = UART_MODE_TX_RX;
 80098d8:	220c      	movs	r2, #12
 80098da:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80098de:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
 80098e2:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
  huart6.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80098e6:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
  huart6.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80098ea:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
  if (HAL_UART_Init(&huart6) != HAL_OK)
 80098ee:	3080      	adds	r0, #128	; 0x80
 80098f0:	f7f9 ff7b 	bl	80037ea <HAL_UART_Init>
}
 80098f4:	bd08      	pop	{r3, pc}
 80098f6:	bf00      	nop
 80098f8:	200033fc 	.word	0x200033fc
 80098fc:	40011400 	.word	0x40011400

08009900 <_ZL22MX_USB_OTG_FS_PCD_Initv>:
{
 8009900:	b508      	push	{r3, lr}
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8009902:	4810      	ldr	r0, [pc, #64]	; (8009944 <_ZL22MX_USB_OTG_FS_PCD_Initv+0x44>)
 8009904:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8009908:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 800990c:	2306      	movs	r3, #6
 800990e:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8009912:	2202      	movs	r2, #2
 8009914:	f8c0 210c 	str.w	r2, [r0, #268]	; 0x10c
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8009918:	2300      	movs	r3, #0
 800991a:	f8c0 3110 	str.w	r3, [r0, #272]	; 0x110
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 800991e:	f8c0 2118 	str.w	r2, [r0, #280]	; 0x118
  hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;
 8009922:	2201      	movs	r2, #1
 8009924:	f8c0 211c 	str.w	r2, [r0, #284]	; 0x11c
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8009928:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 800992c:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8009930:	f8c0 212c 	str.w	r2, [r0, #300]	; 0x12c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8009934:	f8c0 3130 	str.w	r3, [r0, #304]	; 0x130
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8009938:	f500 7080 	add.w	r0, r0, #256	; 0x100
 800993c:	f7f8 fbb2 	bl	80020a4 <HAL_PCD_Init>
}
 8009940:	bd08      	pop	{r3, pc}
 8009942:	bf00      	nop
 8009944:	200033fc 	.word	0x200033fc

08009948 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_>:
template <class NetworkDriver>
void StatefulWriterT<NetworkDriver>::removeReader(const Guid& guid){
    auto isElementToRemove=[&](const ReaderProxy& proxy){
        return proxy.remoteReaderGuid == guid;
    };
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 8009948:	b538      	push	{r3, r4, r5, lr}
 800994a:	460b      	mov	r3, r1
        return proxy.remoteReaderGuid == guid;
 800994c:	6804      	ldr	r4, [r0, #0]
      end() noexcept
      { return iterator(data() + _Nm); }

      _GLIBCXX17_CONSTEXPR const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }
 800994e:	f101 050c 	add.w	r5, r1, #12
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
	  if (const size_t __len = (__last1 - __first1))
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 8009952:	220c      	movs	r2, #12
 8009954:	4621      	mov	r1, r4
 8009956:	4618      	mov	r0, r3
 8009958:	f005 fd86 	bl	800f468 <memcmp>
 800995c:	fab0 f080 	clz	r0, r0
 8009960:	0940      	lsrs	r0, r0, #5
    struct Guid{
        GuidPrefix_t prefix;
        EntityId_t entityId;

        bool operator==(const Guid& other) const{
            return this->prefix == other.prefix &&
 8009962:	b150      	cbz	r0, 800997a <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x32>
                   this->entityId == other.entityId;
 8009964:	340c      	adds	r4, #12
 8009966:	2203      	movs	r2, #3
 8009968:	4621      	mov	r1, r4
 800996a:	4628      	mov	r0, r5
 800996c:	f005 fd7c 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 8009970:	b920      	cbnz	r0, 800997c <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x34>
                   this->entityKind == other.entityKind;
 8009972:	78ea      	ldrb	r2, [r5, #3]
 8009974:	78e3      	ldrb	r3, [r4, #3]
            return this->entityKey == other.entityKey &&
 8009976:	429a      	cmp	r2, r3
 8009978:	d002      	beq.n	8009980 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x38>
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800997a:	bd38      	pop	{r3, r4, r5, pc}
 800997c:	2000      	movs	r0, #0
 800997e:	e7fc      	b.n	800997a <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x32>
 8009980:	2001      	movs	r0, #1
 8009982:	e7fa      	b.n	800997a <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x32>

08009984 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev>:
StatefulWriterT<NetworkDriver>::~StatefulWriterT(){
 8009984:	b570      	push	{r4, r5, r6, lr}
 8009986:	4605      	mov	r5, r0
}
 8009988:	4b0f      	ldr	r3, [pc, #60]	; (80099c8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev+0x44>)
 800998a:	6003      	str	r3, [r0, #0]
    m_running = false;
 800998c:	2300      	movs	r3, #0
 800998e:	f880 3174 	strb.w	r3, [r0, #372]	; 0x174
    sys_msleep(10); // Required for tests/ Join currently not available
 8009992:	200a      	movs	r0, #10
 8009994:	f7fd f8ec 	bl	8006b70 <sys_msleep>
        sys_mutex_free(&m_mutex);
 8009998:	f105 0058 	add.w	r0, r5, #88	; 0x58
 800999c:	f7ff fb6d 	bl	800907a <sys_mutex_free>
    struct array
 80099a0:	f115 0684 	adds.w	r6, r5, #132	; 0x84
 80099a4:	d009      	beq.n	80099ba <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev+0x36>
 80099a6:	f505 74b0 	add.w	r4, r5, #352	; 0x160
 80099aa:	42a6      	cmp	r6, r4
 80099ac:	d005      	beq.n	80099ba <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev+0x36>
 80099ae:	3c14      	subs	r4, #20

#include "rtps/common/types.h"
#include "rtps/storages/PBufWrapper.h"

namespace rtps{
    struct CacheChange{
 80099b0:	f104 000c 	add.w	r0, r4, #12
 80099b4:	f004 fd15 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 80099b8:	e7f7      	b.n	80099aa <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev+0x26>
            this->destPort = other.destPort;
            this->destAddr = other.destAddr;
        }

        PacketInfo() = default;
        ~PacketInfo() = default;
 80099ba:	f105 006c 	add.w	r0, r5, #108	; 0x6c
 80099be:	f004 fd10 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
}
 80099c2:	4628      	mov	r0, r5
 80099c4:	bd70      	pop	{r4, r5, r6, pc}
 80099c6:	bf00      	nop
 80099c8:	08011bc8 	.word	0x08011bc8

080099cc <_ZN4rtps15StatefulReaderTINS_9UdpDriverEED1Ev>:
StatefulReaderT<NetworkDriver>::~StatefulReaderT(){
 80099cc:	b510      	push	{r4, lr}
 80099ce:	4604      	mov	r4, r0
}
 80099d0:	4b05      	ldr	r3, [pc, #20]	; (80099e8 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEED1Ev+0x1c>)
 80099d2:	6003      	str	r3, [r0, #0]
    sys_mutex_free(&m_mutex);
 80099d4:	f500 7094 	add.w	r0, r0, #296	; 0x128
 80099d8:	f7ff fb4f 	bl	800907a <sys_mutex_free>
 80099dc:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80099e0:	f004 fcff 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
}
 80099e4:	4620      	mov	r0, r4
 80099e6:	bd10      	pop	{r4, pc}
 80099e8:	08011ba4 	.word	0x08011ba4

080099ec <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE21setAllChangesToUnsentEv>:
    //return kind == ChangeKind_t::INVALID || (m_topicKind == TopicKind_t::NO_KEY && kind != ChangeKind_t::ALIVE);
    return kind != ChangeKind_t::ALIVE;
}

template <class NetworkDriver>
void StatefulWriterT<NetworkDriver>::setAllChangesToUnsent(){
 80099ec:	b538      	push	{r3, r4, r5, lr}
 80099ee:	4604      	mov	r4, r0
    Lock lock(m_mutex);
 80099f0:	f100 0558 	add.w	r5, r0, #88	; 0x58
namespace rtps{

    class Lock {
    public:
        explicit Lock(sys_mutex_t& passedMutex) : m_mutex(passedMutex) {
            sys_mutex_lock(&m_mutex);
 80099f4:	4628      	mov	r0, r5
 80099f6:	f7ff fb45 	bl	8009084 <sys_mutex_lock>

    m_nextSequenceNumberToSend = m_history.getSeqNumMin();
 80099fa:	f104 0084 	add.w	r0, r4, #132	; 0x84
 80099fe:	f004 fd61 	bl	800e4c4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv>
 8009a02:	f104 037c 	add.w	r3, r4, #124	; 0x7c
 8009a06:	c803      	ldmia	r0, {r0, r1}
 8009a08:	e883 0003 	stmia.w	r3, {r0, r1}

    if(mp_threadPool != nullptr){
 8009a0c:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8009a0e:	b110      	cbz	r0, 8009a16 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE21setAllChangesToUnsentEv+0x2a>
        mp_threadPool->addWorkload(this);
 8009a10:	4621      	mov	r1, r4
 8009a12:	f001 fb04 	bl	800b01e <_ZN4rtps10ThreadPool11addWorkloadEPNS_6WriterE>
        };

        ~Lock() {
            sys_mutex_unlock(&m_mutex);
 8009a16:	4628      	mov	r0, r5
 8009a18:	f7ff fb3b 	bl	8009092 <sys_mutex_unlock>
    }
}
 8009a1c:	bd38      	pop	{r3, r4, r5, pc}
 8009a1e:	4628      	mov	r0, r5
 8009a20:	f7ff fb37 	bl	8009092 <sys_mutex_unlock>
 8009a24:	f004 ffd9 	bl	800e9da <__cxa_end_cleanup>

08009a28 <__tcf_0>:

void startRTPStest(){
	bool pubMatched = false;
	bool subMatched = false;
	static rtps::Domain domain;
 8009a28:	b538      	push	{r3, r4, r5, lr}
 8009a2a:	4c24      	ldr	r4, [pc, #144]	; (8009abc <__tcf_0+0x94>)
 8009a2c:	4b24      	ldr	r3, [pc, #144]	; (8009ac0 <__tcf_0+0x98>)
 8009a2e:	429c      	cmp	r4, r3
 8009a30:	d005      	beq.n	8009a3e <__tcf_0+0x16>
 8009a32:	f5a4 7422 	sub.w	r4, r4, #648	; 0x288
 8009a36:	4620      	mov	r0, r4
 8009a38:	f7ff ffa4 	bl	8009984 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev>
 8009a3c:	e7f6      	b.n	8009a2c <__tcf_0+0x4>
 8009a3e:	4c21      	ldr	r4, [pc, #132]	; (8009ac4 <__tcf_0+0x9c>)
 8009a40:	4b21      	ldr	r3, [pc, #132]	; (8009ac8 <__tcf_0+0xa0>)
 8009a42:	429c      	cmp	r4, r3
 8009a44:	d005      	beq.n	8009a52 <__tcf_0+0x2a>
 8009a46:	f5a4 7496 	sub.w	r4, r4, #300	; 0x12c
 8009a4a:	4620      	mov	r0, r4
 8009a4c:	f7ff ffbe 	bl	80099cc <_ZN4rtps15StatefulReaderTINS_9UdpDriverEED1Ev>
 8009a50:	e7f6      	b.n	8009a40 <__tcf_0+0x18>
 8009a52:	4b1e      	ldr	r3, [pc, #120]	; (8009acc <__tcf_0+0xa4>)
 8009a54:	4a1e      	ldr	r2, [pc, #120]	; (8009ad0 <__tcf_0+0xa8>)
 8009a56:	4293      	cmp	r3, r2
 8009a58:	d001      	beq.n	8009a5e <__tcf_0+0x36>
 8009a5a:	3b60      	subs	r3, #96	; 0x60
 8009a5c:	e7fa      	b.n	8009a54 <__tcf_0+0x2c>
 8009a5e:	4c1d      	ldr	r4, [pc, #116]	; (8009ad4 <__tcf_0+0xac>)
 8009a60:	4b1d      	ldr	r3, [pc, #116]	; (8009ad8 <__tcf_0+0xb0>)
 8009a62:	429c      	cmp	r4, r3
 8009a64:	d006      	beq.n	8009a74 <__tcf_0+0x4c>
 8009a66:	f5a4 741f 	sub.w	r4, r4, #636	; 0x27c
 8009a6a:	6823      	ldr	r3, [r4, #0]
 8009a6c:	699b      	ldr	r3, [r3, #24]
 8009a6e:	4620      	mov	r0, r4
 8009a70:	4798      	blx	r3
 8009a72:	e7f5      	b.n	8009a60 <__tcf_0+0x38>
 8009a74:	4c19      	ldr	r4, [pc, #100]	; (8009adc <__tcf_0+0xb4>)
 8009a76:	4b1a      	ldr	r3, [pc, #104]	; (8009ae0 <__tcf_0+0xb8>)
 8009a78:	429c      	cmp	r4, r3
 8009a7a:	d006      	beq.n	8009a8a <__tcf_0+0x62>
 8009a7c:	f5a4 548a 	sub.w	r4, r4, #4416	; 0x1140
 8009a80:	3c08      	subs	r4, #8
 8009a82:	4620      	mov	r0, r4
 8009a84:	f004 f80e 	bl	800daa4 <_ZN4rtps11ParticipantD1Ev>
 8009a88:	e7f5      	b.n	8009a76 <__tcf_0+0x4e>
 8009a8a:	4c16      	ldr	r4, [pc, #88]	; (8009ae4 <__tcf_0+0xbc>)
 8009a8c:	4b16      	ldr	r3, [pc, #88]	; (8009ae8 <__tcf_0+0xc0>)
 8009a8e:	429c      	cmp	r4, r3
 8009a90:	d010      	beq.n	8009ab4 <__tcf_0+0x8c>
            other.pcb = nullptr;
            return *this;
        }

        ~UdpConnection() {
            if (pcb != nullptr) {
 8009a92:	f854 3d08 	ldr.w	r3, [r4, #-8]!
 8009a96:	2b00      	cmp	r3, #0
 8009a98:	d0f8      	beq.n	8009a8c <__tcf_0+0x64>

namespace rtps{
        class TcpipCoreLock{
            public:
            TcpipCoreLock(){
                LOCK_TCPIP_CORE();
 8009a9a:	4d14      	ldr	r5, [pc, #80]	; (8009aec <__tcf_0+0xc4>)
 8009a9c:	4628      	mov	r0, r5
 8009a9e:	f7ff faf1 	bl	8009084 <sys_mutex_lock>
                TcpipCoreLock lock;
                udp_remove(pcb);
 8009aa2:	6820      	ldr	r0, [r4, #0]
 8009aa4:	f7fd fb68 	bl	8007178 <udp_remove>
                pcb = nullptr;
 8009aa8:	2300      	movs	r3, #0
 8009aaa:	6023      	str	r3, [r4, #0]
            }
            ~TcpipCoreLock(){
                UNLOCK_TCPIP_CORE();
 8009aac:	4628      	mov	r0, r5
 8009aae:	f7ff faf0 	bl	8009092 <sys_mutex_unlock>
 8009ab2:	e7eb      	b.n	8009a8c <__tcf_0+0x64>
#include "rtps/entities/StatelessWriter.h"
#include "rtps/storages/PBufWrapper.h"
#include "rtps/ThreadPool.h"

namespace rtps{
    class Domain{
 8009ab4:	480e      	ldr	r0, [pc, #56]	; (8009af0 <__tcf_0+0xc8>)
 8009ab6:	f001 f9f8 	bl	800aeaa <_ZN4rtps10ThreadPoolD1Ev>
 8009aba:	bd38      	pop	{r3, r4, r5, pc}
 8009abc:	20005938 	.word	0x20005938
 8009ac0:	20005428 	.word	0x20005428
 8009ac4:	20005424 	.word	0x20005424
 8009ac8:	200051cc 	.word	0x200051cc
 8009acc:	200051c8 	.word	0x200051c8
 8009ad0:	20005108 	.word	0x20005108
 8009ad4:	20005104 	.word	0x20005104
 8009ad8:	20004c0c 	.word	0x20004c0c
 8009adc:	20004c08 	.word	0x20004c08
 8009ae0:	20003ac0 	.word	0x20003ac0
 8009ae4:	20003ab4 	.word	0x20003ab4
 8009ae8:	20003a64 	.word	0x20003a64
 8009aec:	20005a2c 	.word	0x20005a2c
 8009af0:	20003928 	.word	0x20003928

08009af4 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE>:

template <class NetworkDriver>
void StatefulReaderT<NetworkDriver>::removeWriter(const Guid& guid){
 8009af4:	b570      	push	{r4, r5, r6, lr}
 8009af6:	b084      	sub	sp, #16
    auto isElementToRemove=[&](const WriterProxy& proxy){
 8009af8:	9103      	str	r1, [sp, #12]
        return proxy.remoteWriterGuid == guid;
    };
    auto thunk=[](void* arg, const WriterProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};

    m_proxies.remove(thunk, &isElementToRemove);
 8009afa:	f100 0470 	add.w	r4, r0, #112	; 0x70
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 8009afe:	9401      	str	r4, [sp, #4]
 8009b00:	2300      	movs	r3, #0
 8009b02:	f88d 3009 	strb.w	r3, [sp, #9]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 8009b06:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 8009b0a:	f88d 3008 	strb.w	r3, [sp, #8]
            return nullptr;
        }

        MemPoolIter begin(){
            MemPoolIter it(*this);
            if(!(m_bitMap[0] & 1)){
 8009b0e:	f013 0f01 	tst.w	r3, #1
 8009b12:	d12a      	bne.n	8009b6a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x76>
                if(m_pool.m_numElements == 0){
 8009b14:	6863      	ldr	r3, [r4, #4]
 8009b16:	b19b      	cbz	r3, 8009b40 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x4c>
                    ++m_bit;
 8009b18:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8009b1c:	3301      	adds	r3, #1
 8009b1e:	b2db      	uxtb	r3, r3
 8009b20:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 8009b24:	aa04      	add	r2, sp, #16
 8009b26:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 8009b2a:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 8009b2e:	0852      	lsrs	r2, r2, #1
 8009b30:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 8009b34:	f012 0f01 	tst.w	r2, #1
 8009b38:	d117      	bne.n	8009b6a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x76>
 8009b3a:	2b02      	cmp	r3, #2
 8009b3c:	d9ec      	bls.n	8009b18 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x24>
 8009b3e:	e014      	b.n	8009b6a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x76>
                    m_bit = SIZE;
 8009b40:	2303      	movs	r3, #3
 8009b42:	f88d 3009 	strb.w	r3, [sp, #9]
 8009b46:	e010      	b.n	8009b6a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x76>
                    const uint8_t bucket = it.m_bit/uint8_t{8};
 8009b48:	08ea      	lsrs	r2, r5, #3
                    const uint8_t pos = it.m_bit & uint8_t{7}; // 7 sets all bits above and including the one for 8 to 0
 8009b4a:	f005 0507 	and.w	r5, r5, #7
                    m_bitMap[bucket] &= ~(static_cast<uint8_t>(1) << pos);
 8009b4e:	2301      	movs	r3, #1
 8009b50:	40ab      	lsls	r3, r5
 8009b52:	5ca5      	ldrb	r5, [r4, r2]
 8009b54:	ea25 0503 	bic.w	r5, r5, r3
 8009b58:	54a5      	strb	r5, [r4, r2]
                    --m_numElements;
 8009b5a:	6863      	ldr	r3, [r4, #4]
 8009b5c:	3b01      	subs	r3, #1
 8009b5e:	6063      	str	r3, [r4, #4]
}
 8009b60:	b004      	add	sp, #16
 8009b62:	bd70      	pop	{r4, r5, r6, pc}
                    m_bit = SIZE;
 8009b64:	2303      	movs	r3, #3
 8009b66:	f88d 3009 	strb.w	r3, [sp, #9]
                 return m_bit != other.m_bit;
 8009b6a:	f89d 5009 	ldrb.w	r5, [sp, #9]
            for(auto it=begin(); it!=end();++it){
 8009b6e:	2d03      	cmp	r5, #3
 8009b70:	d0f6      	beq.n	8009b60 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x6c>
                return m_pool.m_data[m_bit];
 8009b72:	9e01      	ldr	r6, [sp, #4]
 8009b74:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
 8009b78:	00d9      	lsls	r1, r3, #3
 8009b7a:	3108      	adds	r1, #8
                if(jumppad(isCorrectElement, *it)){
 8009b7c:	4431      	add	r1, r6
 8009b7e:	a803      	add	r0, sp, #12
 8009b80:	f000 f937 	bl	8009df2 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENUlPvRKNS_11WriterProxyEE0_4_FUNES6_S9_>
 8009b84:	2800      	cmp	r0, #0
 8009b86:	d1df      	bne.n	8009b48 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x54>
                if(m_pool.m_numElements == 0){
 8009b88:	6873      	ldr	r3, [r6, #4]
 8009b8a:	2b00      	cmp	r3, #0
 8009b8c:	d0ea      	beq.n	8009b64 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x70>
                    ++m_bit;
 8009b8e:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8009b92:	3301      	adds	r3, #1
 8009b94:	b2db      	uxtb	r3, r3
 8009b96:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 8009b9a:	aa04      	add	r2, sp, #16
 8009b9c:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 8009ba0:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 8009ba4:	0852      	lsrs	r2, r2, #1
 8009ba6:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 8009baa:	f012 0f01 	tst.w	r2, #1
 8009bae:	d1dc      	bne.n	8009b6a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x76>
 8009bb0:	2b02      	cmp	r3, #2
 8009bb2:	d9ec      	bls.n	8009b8e <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x9a>
 8009bb4:	e7d9      	b.n	8009b6a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidE+0x76>

08009bb6 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE>:
void StatefulWriterT<NetworkDriver>::removeReader(const Guid& guid){
 8009bb6:	b570      	push	{r4, r5, r6, lr}
 8009bb8:	b084      	sub	sp, #16
    auto isElementToRemove=[&](const ReaderProxy& proxy){
 8009bba:	9103      	str	r1, [sp, #12]
    m_proxies.remove(thunk, &isElementToRemove);
 8009bbc:	f500 74bc 	add.w	r4, r0, #376	; 0x178
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 8009bc0:	9401      	str	r4, [sp, #4]
 8009bc2:	2300      	movs	r3, #0
 8009bc4:	f88d 3009 	strb.w	r3, [sp, #9]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 8009bc8:	f890 3178 	ldrb.w	r3, [r0, #376]	; 0x178
 8009bcc:	f88d 3008 	strb.w	r3, [sp, #8]
            if(!(m_bitMap[0] & 1)){
 8009bd0:	f013 0f01 	tst.w	r3, #1
 8009bd4:	d12a      	bne.n	8009c2c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
                if(m_pool.m_numElements == 0){
 8009bd6:	6863      	ldr	r3, [r4, #4]
 8009bd8:	b19b      	cbz	r3, 8009c02 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x4c>
                    ++m_bit;
 8009bda:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8009bde:	3301      	adds	r3, #1
 8009be0:	b2db      	uxtb	r3, r3
 8009be2:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 8009be6:	aa04      	add	r2, sp, #16
 8009be8:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 8009bec:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 8009bf0:	0852      	lsrs	r2, r2, #1
 8009bf2:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 8009bf6:	f012 0f01 	tst.w	r2, #1
 8009bfa:	d117      	bne.n	8009c2c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
 8009bfc:	2b02      	cmp	r3, #2
 8009bfe:	d9ec      	bls.n	8009bda <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x24>
 8009c00:	e014      	b.n	8009c2c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
                    m_bit = SIZE;
 8009c02:	2303      	movs	r3, #3
 8009c04:	f88d 3009 	strb.w	r3, [sp, #9]
 8009c08:	e010      	b.n	8009c2c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
                    const uint8_t bucket = it.m_bit/uint8_t{8};
 8009c0a:	08ea      	lsrs	r2, r5, #3
                    const uint8_t pos = it.m_bit & uint8_t{7}; // 7 sets all bits above and including the one for 8 to 0
 8009c0c:	f005 0507 	and.w	r5, r5, #7
                    m_bitMap[bucket] &= ~(static_cast<uint8_t>(1) << pos);
 8009c10:	2301      	movs	r3, #1
 8009c12:	40ab      	lsls	r3, r5
 8009c14:	5ca5      	ldrb	r5, [r4, r2]
 8009c16:	ea25 0503 	bic.w	r5, r5, r3
 8009c1a:	54a5      	strb	r5, [r4, r2]
                    --m_numElements;
 8009c1c:	6863      	ldr	r3, [r4, #4]
 8009c1e:	3b01      	subs	r3, #1
 8009c20:	6063      	str	r3, [r4, #4]
}
 8009c22:	b004      	add	sp, #16
 8009c24:	bd70      	pop	{r4, r5, r6, pc}
                    m_bit = SIZE;
 8009c26:	2303      	movs	r3, #3
 8009c28:	f88d 3009 	strb.w	r3, [sp, #9]
                 return m_bit != other.m_bit;
 8009c2c:	f89d 5009 	ldrb.w	r5, [sp, #9]
            for(auto it=begin(); it!=end();++it){
 8009c30:	2d03      	cmp	r5, #3
 8009c32:	d0f6      	beq.n	8009c22 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x6c>
                return m_pool.m_data[m_bit];
 8009c34:	9e01      	ldr	r6, [sp, #4]
 8009c36:	2158      	movs	r1, #88	; 0x58
 8009c38:	fb01 f105 	mul.w	r1, r1, r5
 8009c3c:	3108      	adds	r1, #8
                if(jumppad(isCorrectElement, *it)){
 8009c3e:	4431      	add	r1, r6
 8009c40:	a803      	add	r0, sp, #12
 8009c42:	f7ff fe81 	bl	8009948 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_>
 8009c46:	2800      	cmp	r0, #0
 8009c48:	d1df      	bne.n	8009c0a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x54>
                if(m_pool.m_numElements == 0){
 8009c4a:	6873      	ldr	r3, [r6, #4]
 8009c4c:	2b00      	cmp	r3, #0
 8009c4e:	d0ea      	beq.n	8009c26 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x70>
                    ++m_bit;
 8009c50:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8009c54:	3301      	adds	r3, #1
 8009c56:	b2db      	uxtb	r3, r3
 8009c58:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 8009c5c:	aa04      	add	r2, sp, #16
 8009c5e:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 8009c62:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 8009c66:	0852      	lsrs	r2, r2, #1
 8009c68:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 8009c6c:	f012 0f01 	tst.w	r2, #1
 8009c70:	d1dc      	bne.n	8009c2c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
 8009c72:	2b02      	cmp	r3, #2
 8009c74:	d9ec      	bls.n	8009c50 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x9a>
 8009c76:	e7d9      	b.n	8009c2c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>

08009c78 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE>:
    if(m_callback == nullptr){
 8009c78:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
 8009c7c:	2b00      	cmp	r3, #0
 8009c7e:	f000 80b7 	beq.w	8009df0 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x178>
void StatefulReaderT<NetworkDriver>::newChange(const ReaderCacheChange& cacheChange){
 8009c82:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009c86:	b086      	sub	sp, #24
 8009c88:	460c      	mov	r4, r1
 8009c8a:	4605      	mov	r5, r0
    Lock lock{m_mutex};
 8009c8c:	f500 7094 	add.w	r0, r0, #296	; 0x128
        explicit Lock(sys_mutex_t& passedMutex) : m_mutex(passedMutex) {
 8009c90:	9005      	str	r0, [sp, #20]
            sys_mutex_lock(&m_mutex);
 8009c92:	f7ff f9f7 	bl	8009084 <sys_mutex_lock>
    for(auto& proxy : m_proxies){
 8009c96:	f105 0270 	add.w	r2, r5, #112	; 0x70
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 8009c9a:	9201      	str	r2, [sp, #4]
 8009c9c:	2300      	movs	r3, #0
 8009c9e:	f88d 3009 	strb.w	r3, [sp, #9]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 8009ca2:	f895 3070 	ldrb.w	r3, [r5, #112]	; 0x70
 8009ca6:	f88d 3008 	strb.w	r3, [sp, #8]
            if(!(m_bitMap[0] & 1)){
 8009caa:	f013 0f01 	tst.w	r3, #1
 8009cae:	d118      	bne.n	8009ce2 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x6a>
                if(m_pool.m_numElements == 0){
 8009cb0:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8009cb2:	b19b      	cbz	r3, 8009cdc <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x64>
                    ++m_bit;
 8009cb4:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8009cb8:	3301      	adds	r3, #1
 8009cba:	b2db      	uxtb	r3, r3
 8009cbc:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 8009cc0:	aa06      	add	r2, sp, #24
 8009cc2:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 8009cc6:	f811 2c10 	ldrb.w	r2, [r1, #-16]
 8009cca:	0852      	lsrs	r2, r2, #1
 8009ccc:	f801 2c10 	strb.w	r2, [r1, #-16]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 8009cd0:	f012 0f01 	tst.w	r2, #1
 8009cd4:	d105      	bne.n	8009ce2 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x6a>
 8009cd6:	2b02      	cmp	r3, #2
 8009cd8:	d9ec      	bls.n	8009cb4 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x3c>
 8009cda:	e002      	b.n	8009ce2 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x6a>
                    m_bit = SIZE;
 8009cdc:	2303      	movs	r3, #3
 8009cde:	f88d 3009 	strb.w	r3, [sp, #9]
            return it;
        }

        MemPoolIter end(){
            MemPoolIter endIt(*this);
            endIt.m_bit = SIZE;
 8009ce2:	2303      	movs	r3, #3
 8009ce4:	f88d 3011 	strb.w	r3, [sp, #17]
 8009ce8:	e022      	b.n	8009d30 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0xb8>
 8009cea:	2000      	movs	r0, #0
 8009cec:	e048      	b.n	8009d80 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x108>
 8009cee:	2001      	movs	r0, #1
 8009cf0:	e046      	b.n	8009d80 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x108>
        bool operator<=(const SequenceNumber_t& other) const{
            return *this == other || *this < other;
        }

        SequenceNumber_t& operator++(){
            ++low;
 8009cf2:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8009cf6:	eba2 0208 	sub.w	r2, r2, r8
 8009cfa:	00d3      	lsls	r3, r2, #3
 8009cfc:	443b      	add	r3, r7
 8009cfe:	69da      	ldr	r2, [r3, #28]
 8009d00:	3201      	adds	r2, #1
 8009d02:	61da      	str	r2, [r3, #28]
            if(low == 0){
 8009d04:	b952      	cbnz	r2, 8009d1c <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0xa4>
                ++high;
 8009d06:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 8009d0a:	eba3 0108 	sub.w	r1, r3, r8
 8009d0e:	00ca      	lsls	r2, r1, #3
 8009d10:	4611      	mov	r1, r2
 8009d12:	443a      	add	r2, r7
 8009d14:	6992      	ldr	r2, [r2, #24]
 8009d16:	440f      	add	r7, r1
 8009d18:	3201      	adds	r2, #1
 8009d1a:	61ba      	str	r2, [r7, #24]
            sys_mutex_unlock(&m_mutex);
 8009d1c:	9805      	ldr	r0, [sp, #20]
 8009d1e:	f7ff f9b8 	bl	8009092 <sys_mutex_unlock>
 8009d22:	e05d      	b.n	8009de0 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x168>
                if(m_pool.m_numElements == 0){
 8009d24:	687b      	ldr	r3, [r7, #4]
 8009d26:	2b00      	cmp	r3, #0
 8009d28:	d143      	bne.n	8009db2 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x13a>
                    m_bit = SIZE;
 8009d2a:	2303      	movs	r3, #3
 8009d2c:	f88d 3009 	strb.w	r3, [sp, #9]
                 return m_bit != other.m_bit;
 8009d30:	f89d 6009 	ldrb.w	r6, [sp, #9]
 8009d34:	f89d 3011 	ldrb.w	r3, [sp, #17]
 8009d38:	42b3      	cmp	r3, r6
 8009d3a:	d04e      	beq.n	8009dda <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x162>
                return m_pool.m_data[m_bit];
 8009d3c:	9f01      	ldr	r7, [sp, #4]
 8009d3e:	46b0      	mov	r8, r6
        if(proxy.remoteWriterGuid == cacheChange.writerGuid){
 8009d40:	ebc6 03c6 	rsb	r3, r6, r6, lsl #3
 8009d44:	00d8      	lsls	r0, r3, #3
 8009d46:	3008      	adds	r0, #8
 8009d48:	4438      	add	r0, r7
 8009d4a:	f104 0908 	add.w	r9, r4, #8
      { return const_iterator(data() + _Nm); }
 8009d4e:	f100 0a0c 	add.w	sl, r0, #12
 8009d52:	220c      	movs	r2, #12
 8009d54:	4649      	mov	r1, r9
 8009d56:	f005 fb87 	bl	800f468 <memcmp>
 8009d5a:	fab0 f080 	clz	r0, r0
 8009d5e:	0940      	lsrs	r0, r0, #5
            return this->prefix == other.prefix &&
 8009d60:	b170      	cbz	r0, 8009d80 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x108>
                   this->entityId == other.entityId;
 8009d62:	f104 0914 	add.w	r9, r4, #20
 8009d66:	2203      	movs	r2, #3
 8009d68:	4649      	mov	r1, r9
 8009d6a:	4650      	mov	r0, sl
 8009d6c:	f005 fb7c 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 8009d70:	2800      	cmp	r0, #0
 8009d72:	d1ba      	bne.n	8009cea <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x72>
                   this->entityKind == other.entityKind;
 8009d74:	f89a 2003 	ldrb.w	r2, [sl, #3]
 8009d78:	f899 3003 	ldrb.w	r3, [r9, #3]
            return this->entityKey == other.entityKey &&
 8009d7c:	429a      	cmp	r2, r3
 8009d7e:	d0b6      	beq.n	8009cee <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x76>
 8009d80:	2800      	cmp	r0, #0
 8009d82:	d0cf      	beq.n	8009d24 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0xac>
            return high == other.high && low == other.low;
 8009d84:	ebc6 02c6 	rsb	r2, r6, r6, lsl #3
 8009d88:	00d3      	lsls	r3, r2, #3
 8009d8a:	443b      	add	r3, r7
 8009d8c:	699a      	ldr	r2, [r3, #24]
 8009d8e:	69a3      	ldr	r3, [r4, #24]
 8009d90:	429a      	cmp	r2, r3
 8009d92:	d1c7      	bne.n	8009d24 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0xac>
 8009d94:	ebc6 06c6 	rsb	r6, r6, r6, lsl #3
 8009d98:	00f3      	lsls	r3, r6, #3
 8009d9a:	443b      	add	r3, r7
 8009d9c:	69da      	ldr	r2, [r3, #28]
 8009d9e:	69e3      	ldr	r3, [r4, #28]
 8009da0:	429a      	cmp	r2, r3
 8009da2:	d1bf      	bne.n	8009d24 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0xac>
                m_callback(m_callee, cacheChange);
 8009da4:	f8d5 3120 	ldr.w	r3, [r5, #288]	; 0x120
 8009da8:	4621      	mov	r1, r4
 8009daa:	f8d5 0124 	ldr.w	r0, [r5, #292]	; 0x124
 8009dae:	4798      	blx	r3
 8009db0:	e79f      	b.n	8009cf2 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x7a>
                    ++m_bit;
 8009db2:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8009db6:	3301      	adds	r3, #1
 8009db8:	b2db      	uxtb	r3, r3
 8009dba:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 8009dbe:	aa06      	add	r2, sp, #24
 8009dc0:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 8009dc4:	f811 2c10 	ldrb.w	r2, [r1, #-16]
 8009dc8:	0852      	lsrs	r2, r2, #1
 8009dca:	f801 2c10 	strb.w	r2, [r1, #-16]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 8009dce:	f012 0f01 	tst.w	r2, #1
 8009dd2:	d1ad      	bne.n	8009d30 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0xb8>
 8009dd4:	2b02      	cmp	r3, #2
 8009dd6:	d9ec      	bls.n	8009db2 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0x13a>
 8009dd8:	e7aa      	b.n	8009d30 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE9newChangeERKNS_17ReaderCacheChangeE+0xb8>
 8009dda:	9805      	ldr	r0, [sp, #20]
 8009ddc:	f7ff f959 	bl	8009092 <sys_mutex_unlock>
}
 8009de0:	b006      	add	sp, #24
 8009de2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009de6:	9805      	ldr	r0, [sp, #20]
 8009de8:	f7ff f953 	bl	8009092 <sys_mutex_unlock>
 8009dec:	f004 fdf5 	bl	800e9da <__cxa_end_cleanup>
 8009df0:	4770      	bx	lr

08009df2 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENUlPvRKNS_11WriterProxyEE0_4_FUNES6_S9_>:
    auto thunk=[](void* arg, const WriterProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 8009df2:	b538      	push	{r3, r4, r5, lr}
 8009df4:	460b      	mov	r3, r1
        return proxy.remoteWriterGuid == guid;
 8009df6:	6804      	ldr	r4, [r0, #0]
 8009df8:	f101 050c 	add.w	r5, r1, #12
 8009dfc:	220c      	movs	r2, #12
 8009dfe:	4621      	mov	r1, r4
 8009e00:	4618      	mov	r0, r3
 8009e02:	f005 fb31 	bl	800f468 <memcmp>
 8009e06:	fab0 f080 	clz	r0, r0
 8009e0a:	0940      	lsrs	r0, r0, #5
            return this->prefix == other.prefix &&
 8009e0c:	b150      	cbz	r0, 8009e24 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENUlPvRKNS_11WriterProxyEE0_4_FUNES6_S9_+0x32>
                   this->entityId == other.entityId;
 8009e0e:	340c      	adds	r4, #12
 8009e10:	2203      	movs	r2, #3
 8009e12:	4621      	mov	r1, r4
 8009e14:	4628      	mov	r0, r5
 8009e16:	f005 fb27 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 8009e1a:	b920      	cbnz	r0, 8009e26 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENUlPvRKNS_11WriterProxyEE0_4_FUNES6_S9_+0x34>
                   this->entityKind == other.entityKind;
 8009e1c:	78ea      	ldrb	r2, [r5, #3]
 8009e1e:	78e3      	ldrb	r3, [r4, #3]
            return this->entityKey == other.entityKey &&
 8009e20:	429a      	cmp	r2, r3
 8009e22:	d002      	beq.n	8009e2a <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENUlPvRKNS_11WriterProxyEE0_4_FUNES6_S9_+0x38>
    auto thunk=[](void* arg, const WriterProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 8009e24:	bd38      	pop	{r3, r4, r5, pc}
 8009e26:	2000      	movs	r0, #0
 8009e28:	e7fc      	b.n	8009e24 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENUlPvRKNS_11WriterProxyEE0_4_FUNES6_S9_+0x32>
 8009e2a:	2001      	movs	r0, #1
 8009e2c:	e7fa      	b.n	8009e24 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENUlPvRKNS_11WriterProxyEE0_4_FUNES6_S9_+0x32>
	...

08009e30 <__io_putchar>:
extern "C" int __io_putchar(int ch) {
 8009e30:	b500      	push	{lr}
 8009e32:	b083      	sub	sp, #12
 8009e34:	a902      	add	r1, sp, #8
 8009e36:	f841 0d04 	str.w	r0, [r1, #-4]!
  HAL_UART_Transmit(&huart6, (uint8_t *)&ch, 1, 1000);
 8009e3a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8009e3e:	2201      	movs	r2, #1
 8009e40:	4803      	ldr	r0, [pc, #12]	; (8009e50 <__io_putchar+0x20>)
 8009e42:	f7f9 fc42 	bl	80036ca <HAL_UART_Transmit>
}
 8009e46:	9801      	ldr	r0, [sp, #4]
 8009e48:	b003      	add	sp, #12
 8009e4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e4e:	bf00      	nop
 8009e50:	2000347c 	.word	0x2000347c

08009e54 <_Z10uart_printPc>:
void uart_print(char* str){
 8009e54:	b510      	push	{r4, lr}
 8009e56:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8009e58:	f7fb fb44 	bl	80054e4 <vPortEnterCritical>
	HAL_UART_Transmit(&huart6, (uint8_t*) str, strlen(str), 100);
 8009e5c:	4620      	mov	r0, r4
 8009e5e:	f7f6 f9f9 	bl	8000254 <strlen>
 8009e62:	2364      	movs	r3, #100	; 0x64
 8009e64:	b282      	uxth	r2, r0
 8009e66:	4621      	mov	r1, r4
 8009e68:	4802      	ldr	r0, [pc, #8]	; (8009e74 <_Z10uart_printPc+0x20>)
 8009e6a:	f7f9 fc2e 	bl	80036ca <HAL_UART_Transmit>
	taskEXIT_CRITICAL();
 8009e6e:	f7fb fb5f 	bl	8005530 <vPortExitCritical>
}
 8009e72:	bd10      	pop	{r4, pc}
 8009e74:	2000347c 	.word	0x2000347c

08009e78 <_ZdlPv>:
{
 8009e78:	b508      	push	{r3, lr}
	vPortFree ( ptr );
 8009e7a:	f7fb fd49 	bl	8005910 <vPortFree>
}
 8009e7e:	bd08      	pop	{r3, pc}

08009e80 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED0Ev>:
StatefulWriterT<NetworkDriver>::~StatefulWriterT(){
 8009e80:	b510      	push	{r4, lr}
 8009e82:	4604      	mov	r4, r0
}
 8009e84:	f7ff fd7e 	bl	8009984 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev>
 8009e88:	4620      	mov	r0, r4
 8009e8a:	f7ff fff5 	bl	8009e78 <_ZdlPv>
 8009e8e:	4620      	mov	r0, r4
 8009e90:	bd10      	pop	{r4, pc}

08009e92 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEED0Ev>:
StatefulReaderT<NetworkDriver>::~StatefulReaderT(){
 8009e92:	b510      	push	{r4, lr}
 8009e94:	4604      	mov	r4, r0
}
 8009e96:	f7ff fd99 	bl	80099cc <_ZN4rtps15StatefulReaderTINS_9UdpDriverEED1Ev>
 8009e9a:	4620      	mov	r0, r4
 8009e9c:	f7ff ffec 	bl	8009e78 <_ZdlPv>
 8009ea0:	4620      	mov	r0, r4
 8009ea2:	bd10      	pop	{r4, pc}

08009ea4 <vApplicationStackOverflowHook>:
extern "C" void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
 8009ea4:	b508      	push	{r3, lr}
	uart_print("Stackoverflow\n");
 8009ea6:	4802      	ldr	r0, [pc, #8]	; (8009eb0 <vApplicationStackOverflowHook+0xc>)
 8009ea8:	f7ff ffd4 	bl	8009e54 <_Z10uart_printPc>
 8009eac:	e7fe      	b.n	8009eac <vApplicationStackOverflowHook+0x8>
 8009eae:	bf00      	nop
 8009eb0:	08011bf4 	.word	0x08011bf4

08009eb4 <vApplicationMallocFailedHook>:
extern "C" void vApplicationMallocFailedHook( void ){
 8009eb4:	b508      	push	{r3, lr}
	uart_print("Malloc failed\n");
 8009eb6:	4802      	ldr	r0, [pc, #8]	; (8009ec0 <vApplicationMallocFailedHook+0xc>)
 8009eb8:	f7ff ffcc 	bl	8009e54 <_Z10uart_printPc>
 8009ebc:	e7fe      	b.n	8009ebc <vApplicationMallocFailedHook+0x8>
 8009ebe:	bf00      	nop
 8009ec0:	08011c04 	.word	0x08011c04

08009ec4 <_Z18SystemClock_Configv>:
{
 8009ec4:	b530      	push	{r4, r5, lr}
 8009ec6:	b0b9      	sub	sp, #228	; 0xe4
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8009ec8:	2234      	movs	r2, #52	; 0x34
 8009eca:	2100      	movs	r1, #0
 8009ecc:	a82b      	add	r0, sp, #172	; 0xac
 8009ece:	f005 fae5 	bl	800f49c <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8009ed2:	2400      	movs	r4, #0
 8009ed4:	9426      	str	r4, [sp, #152]	; 0x98
 8009ed6:	9427      	str	r4, [sp, #156]	; 0x9c
 8009ed8:	9428      	str	r4, [sp, #160]	; 0xa0
 8009eda:	9429      	str	r4, [sp, #164]	; 0xa4
 8009edc:	942a      	str	r4, [sp, #168]	; 0xa8
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8009ede:	2290      	movs	r2, #144	; 0x90
 8009ee0:	4621      	mov	r1, r4
 8009ee2:	a802      	add	r0, sp, #8
 8009ee4:	f005 fada 	bl	800f49c <memset>
  HAL_PWR_EnableBkUpAccess();
 8009ee8:	f7f8 f982 	bl	80021f0 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_PWR_CLK_ENABLE();
 8009eec:	4b20      	ldr	r3, [pc, #128]	; (8009f70 <_Z18SystemClock_Configv+0xac>)
 8009eee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009ef0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8009ef4:	641a      	str	r2, [r3, #64]	; 0x40
 8009ef6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009ef8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8009efc:	9300      	str	r3, [sp, #0]
 8009efe:	9b00      	ldr	r3, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 8009f00:	4a1c      	ldr	r2, [pc, #112]	; (8009f74 <_Z18SystemClock_Configv+0xb0>)
 8009f02:	6813      	ldr	r3, [r2, #0]
 8009f04:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8009f08:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009f0c:	6013      	str	r3, [r2, #0]
 8009f0e:	6813      	ldr	r3, [r2, #0]
 8009f10:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8009f14:	9301      	str	r3, [sp, #4]
 8009f16:	9b01      	ldr	r3, [sp, #4]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8009f18:	2301      	movs	r3, #1
 8009f1a:	932b      	str	r3, [sp, #172]	; 0xac
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8009f1c:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 8009f20:	932c      	str	r3, [sp, #176]	; 0xb0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8009f22:	2502      	movs	r5, #2
 8009f24:	9531      	str	r5, [sp, #196]	; 0xc4
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8009f26:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009f2a:	9332      	str	r3, [sp, #200]	; 0xc8
  RCC_OscInitStruct.PLL.PLLM = 4;
 8009f2c:	2304      	movs	r3, #4
 8009f2e:	9333      	str	r3, [sp, #204]	; 0xcc
  RCC_OscInitStruct.PLL.PLLN = 96;
 8009f30:	2260      	movs	r2, #96	; 0x60
 8009f32:	9234      	str	r2, [sp, #208]	; 0xd0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8009f34:	9535      	str	r5, [sp, #212]	; 0xd4
  RCC_OscInitStruct.PLL.PLLQ = 4;
 8009f36:	9336      	str	r3, [sp, #216]	; 0xd8
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8009f38:	a82b      	add	r0, sp, #172	; 0xac
 8009f3a:	f7f8 f99f 	bl	800227c <HAL_RCC_OscConfig>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 8009f3e:	f7f8 f95f 	bl	8002200 <HAL_PWREx_EnableOverDrive>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8009f42:	230f      	movs	r3, #15
 8009f44:	9326      	str	r3, [sp, #152]	; 0x98
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8009f46:	9527      	str	r5, [sp, #156]	; 0x9c
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8009f48:	9428      	str	r4, [sp, #160]	; 0xa0
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8009f4a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8009f4e:	9329      	str	r3, [sp, #164]	; 0xa4
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8009f50:	942a      	str	r4, [sp, #168]	; 0xa8
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 8009f52:	2103      	movs	r1, #3
 8009f54:	a826      	add	r0, sp, #152	; 0x98
 8009f56:	f7f8 fbe7 	bl	8002728 <HAL_RCC_ClockConfig>
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_USART6
 8009f5a:	4b07      	ldr	r3, [pc, #28]	; (8009f78 <_Z18SystemClock_Configv+0xb4>)
 8009f5c:	9302      	str	r3, [sp, #8]
  PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 8009f5e:	9415      	str	r4, [sp, #84]	; 0x54
  PeriphClkInitStruct.Usart6ClockSelection = RCC_USART6CLKSOURCE_PCLK2;
 8009f60:	9418      	str	r4, [sp, #96]	; 0x60
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL;
 8009f62:	9421      	str	r4, [sp, #132]	; 0x84
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8009f64:	a802      	add	r0, sp, #8
 8009f66:	f7f8 fcd5 	bl	8002914 <HAL_RCCEx_PeriphCLKConfig>
}
 8009f6a:	b039      	add	sp, #228	; 0xe4
 8009f6c:	bd30      	pop	{r4, r5, pc}
 8009f6e:	bf00      	nop
 8009f70:	40023800 	.word	0x40023800
 8009f74:	40007000 	.word	0x40007000
 8009f78:	00200900 	.word	0x00200900

08009f7c <main>:
{
 8009f7c:	b530      	push	{r4, r5, lr}
 8009f7e:	b087      	sub	sp, #28
  HAL_Init();
 8009f80:	f7f7 facc 	bl	800151c <HAL_Init>
  SystemClock_Config();
 8009f84:	f7ff ff9e 	bl	8009ec4 <_Z18SystemClock_Configv>
  MX_GPIO_Init();
 8009f88:	f7ff fbec 	bl	8009764 <_ZL12MX_GPIO_Initv>
  MX_USART3_UART_Init();
 8009f8c:	f7ff fc7c 	bl	8009888 <_ZL19MX_USART3_UART_Initv>
  MX_USB_OTG_FS_PCD_Init();
 8009f90:	f7ff fcb6 	bl	8009900 <_ZL22MX_USB_OTG_FS_PCD_Initv>
  MX_USART6_UART_Init();
 8009f94:	f7ff fc90 	bl	80098b8 <_ZL19MX_USART6_UART_Initv>
  osThreadDef(defaultTask, StartDefaultTask, osPriorityRealtime, 0, 250);
 8009f98:	ac01      	add	r4, sp, #4
 8009f9a:	4d09      	ldr	r5, [pc, #36]	; (8009fc0 <main+0x44>)
 8009f9c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8009f9e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8009fa0:	682b      	ldr	r3, [r5, #0]
 8009fa2:	6023      	str	r3, [r4, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8009fa4:	2100      	movs	r1, #0
 8009fa6:	a801      	add	r0, sp, #4
 8009fa8:	f7f9 fdf9 	bl	8003b9e <osThreadCreate>
 8009fac:	4b05      	ldr	r3, [pc, #20]	; (8009fc4 <main+0x48>)
 8009fae:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
  volatile int heap_size = rtps::Config::OVERALL_HEAP_SIZE;
 8009fb2:	f241 6312 	movw	r3, #5650	; 0x1612
 8009fb6:	9300      	str	r3, [sp, #0]
  osKernelStart();
 8009fb8:	f7f9 fde2 	bl	8003b80 <osKernelStart>
 8009fbc:	e7fe      	b.n	8009fbc <main+0x40>
 8009fbe:	bf00      	nop
 8009fc0:	080108f8 	.word	0x080108f8
 8009fc4:	200033fc 	.word	0x200033fc

08009fc8 <_Z13startRTPStestv>:
void startRTPStest(){
 8009fc8:	b570      	push	{r4, r5, r6, lr}
 8009fca:	b084      	sub	sp, #16
	bool pubMatched = false;
 8009fcc:	2300      	movs	r3, #0
 8009fce:	f88d 300f 	strb.w	r3, [sp, #15]
	static rtps::Domain domain;
 8009fd2:	4b29      	ldr	r3, [pc, #164]	; (800a078 <_Z13startRTPStestv+0xb0>)
 8009fd4:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
 8009fd8:	f013 0f01 	tst.w	r3, #1
 8009fdc:	d03f      	beq.n	800a05e <_Z13startRTPStestv+0x96>
	domain.completeInit();
 8009fde:	4c27      	ldr	r4, [pc, #156]	; (800a07c <_Z13startRTPStestv+0xb4>)
 8009fe0:	4620      	mov	r0, r4
 8009fe2:	f002 fdff 	bl	800cbe4 <_ZN4rtps6Domain12completeInitEv>

	rtps::Participant* part = domain.createParticipant();
 8009fe6:	4620      	mov	r0, r4
 8009fe8:	f003 f88a 	bl	800d100 <_ZN4rtps6Domain17createParticipantEv>
	if(part == nullptr){
 8009fec:	4604      	mov	r4, r0
 8009fee:	2800      	cmp	r0, #0
 8009ff0:	d040      	beq.n	800a074 <_Z13startRTPStestv+0xac>
		return;
	}

	part->registerOnNewPublisherMatchedCallback(setTrue, &pubMatched);
 8009ff2:	4d23      	ldr	r5, [pc, #140]	; (800a080 <_Z13startRTPStestv+0xb8>)
 8009ff4:	f10d 020f 	add.w	r2, sp, #15
 8009ff8:	4629      	mov	r1, r5
 8009ffa:	f003 fd96 	bl	800db2a <_ZN4rtps11Participant37registerOnNewPublisherMatchedCallbackEPFvPvES1_>
	part->registerOnNewSubscriberMatchedCallback(setTrue, &pubMatched);
 8009ffe:	f10d 020f 	add.w	r2, sp, #15
 800a002:	4629      	mov	r1, r5
 800a004:	4620      	mov	r0, r4
 800a006:	f003 fd9b 	bl	800db40 <_ZN4rtps11Participant38registerOnNewSubscriberMatchedCallbackEPFvPvES1_>

	rtps::Writer* writer = domain.createWriter(*part, "TEST", "TEST", false);
 800a00a:	4a1e      	ldr	r2, [pc, #120]	; (800a084 <_Z13startRTPStestv+0xbc>)
 800a00c:	2300      	movs	r3, #0
 800a00e:	9300      	str	r3, [sp, #0]
 800a010:	4613      	mov	r3, r2
 800a012:	4621      	mov	r1, r4
 800a014:	4819      	ldr	r0, [pc, #100]	; (800a07c <_Z13startRTPStestv+0xb4>)
 800a016:	f003 f8a7 	bl	800d168 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b>
	//rtps::Reader* reader = domain.createReader(*part, "LatencyTest_SUB2PUB", "LatencyType", false);
	if(writer == nullptr ){//|| reader == nullptr){
 800a01a:	4605      	mov	r5, r0
 800a01c:	b350      	cbz	r0, 800a074 <_Z13startRTPStestv+0xac>
		return;
	}

	while(!pubMatched){
 800a01e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800a022:	2b00      	cmp	r3, #0
 800a024:	d0fb      	beq.n	800a01e <_Z13startRTPStestv+0x56>
	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
 800a026:	4914      	ldr	r1, [pc, #80]	; (800a078 <_Z13startRTPStestv+0xb0>)
 800a028:	f04f 3305 	mov.w	r3, #84215045	; 0x5050505
 800a02c:	f8c1 351c 	str.w	r3, [r1, #1308]	; 0x51c
 800a030:	f8c1 3520 	str.w	r3, [r1, #1312]	; 0x520
 800a034:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
 800a038:	f8c1 3528 	str.w	r3, [r1, #1320]	; 0x528

	static std::array<uint8_t, DATA_SIZE> data{};
	data.fill(5);
	const size_t numSamples = NUM_SAMPLES;

	uart_print("matched\n");
 800a03c:	4812      	ldr	r0, [pc, #72]	; (800a088 <_Z13startRTPStestv+0xc0>)
 800a03e:	f7ff ff09 	bl	8009e54 <_Z10uart_printPc>
	/* Infinite loop */
	for(size_t i=0; i<numSamples; ++i){
 800a042:	2400      	movs	r4, #0
 800a044:	f242 7341 	movw	r3, #10049	; 0x2741
 800a048:	429c      	cmp	r4, r3
 800a04a:	d813      	bhi.n	800a074 <_Z13startRTPStestv+0xac>
		auto* change = writer->newChange(rtps::ChangeKind_t::ALIVE, data.data(), data.size());
 800a04c:	682b      	ldr	r3, [r5, #0]
 800a04e:	68de      	ldr	r6, [r3, #12]
 800a050:	2310      	movs	r3, #16
 800a052:	4a0e      	ldr	r2, [pc, #56]	; (800a08c <_Z13startRTPStestv+0xc4>)
 800a054:	2101      	movs	r1, #1
 800a056:	4628      	mov	r0, r5
 800a058:	47b0      	blx	r6
	for(size_t i=0; i<numSamples; ++i){
 800a05a:	3401      	adds	r4, #1
 800a05c:	e7f2      	b.n	800a044 <_Z13startRTPStestv+0x7c>
	static rtps::Domain domain;
 800a05e:	4807      	ldr	r0, [pc, #28]	; (800a07c <_Z13startRTPStestv+0xb4>)
 800a060:	f002 fab2 	bl	800c5c8 <_ZN4rtps6DomainC1Ev>
 800a064:	4b04      	ldr	r3, [pc, #16]	; (800a078 <_Z13startRTPStestv+0xb0>)
 800a066:	2201      	movs	r2, #1
 800a068:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
 800a06c:	4808      	ldr	r0, [pc, #32]	; (800a090 <_Z13startRTPStestv+0xc8>)
 800a06e:	f005 f9cb 	bl	800f408 <atexit>
 800a072:	e7b4      	b.n	8009fde <_Z13startRTPStestv+0x16>
	}
}
 800a074:	b004      	add	sp, #16
 800a076:	bd70      	pop	{r4, r5, r6, pc}
 800a078:	200033fc 	.word	0x200033fc
 800a07c:	20003928 	.word	0x20003928
 800a080:	0800967d 	.word	0x0800967d
 800a084:	08011c14 	.word	0x08011c14
 800a088:	08011c1c 	.word	0x08011c1c
 800a08c:	20003918 	.word	0x20003918
 800a090:	08009a29 	.word	0x08009a29

0800a094 <_Z16StartDefaultTaskPKv>:
  */
/* USER CODE END Header_StartDefaultTask */


void StartDefaultTask(void const * argument)
{
 800a094:	b500      	push	{lr}
 800a096:	b083      	sub	sp, #12

	/* init code for LWIP */
	MX_LWIP_Init();
 800a098:	f7ff fa64 	bl	8009564 <MX_LWIP_Init>


    /* USER CODE BEGIN 5 */
	startRTPStest();
 800a09c:	f7ff ff94 	bl	8009fc8 <_Z13startRTPStestv>

	volatile auto size = uxTaskGetStackHighWaterMark(nullptr);
 800a0a0:	2000      	movs	r0, #0
 800a0a2:	f7fb f85d 	bl	8005160 <uxTaskGetStackHighWaterMark>
 800a0a6:	9001      	str	r0, [sp, #4]
 800a0a8:	e7fe      	b.n	800a0a8 <_Z16StartDefaultTaskPKv+0x14>
	...

0800a0ac <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800a0ac:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 800a0ae:	6802      	ldr	r2, [r0, #0]
 800a0b0:	4b03      	ldr	r3, [pc, #12]	; (800a0c0 <HAL_TIM_PeriodElapsedCallback+0x14>)
 800a0b2:	429a      	cmp	r2, r3
 800a0b4:	d000      	beq.n	800a0b8 <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 800a0b6:	bd08      	pop	{r3, pc}
    HAL_IncTick();
 800a0b8:	f7f7 fa3c 	bl	8001534 <HAL_IncTick>
}
 800a0bc:	e7fb      	b.n	800a0b6 <HAL_TIM_PeriodElapsedCallback+0xa>
 800a0be:	bf00      	nop
 800a0c0:	40010000 	.word	0x40010000

0800a0c4 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_>:
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800a0c4:	b538      	push	{r3, r4, r5, lr}
 800a0c6:	4610      	mov	r0, r2
        return proxy.remoteReaderGuid == guid;
 800a0c8:	680c      	ldr	r4, [r1, #0]
 800a0ca:	f102 050c 	add.w	r5, r2, #12
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800a0ce:	220c      	movs	r2, #12
 800a0d0:	4621      	mov	r1, r4
 800a0d2:	f005 f9c9 	bl	800f468 <memcmp>
 800a0d6:	fab0 f080 	clz	r0, r0
 800a0da:	0940      	lsrs	r0, r0, #5
            return this->prefix == other.prefix &&
 800a0dc:	b150      	cbz	r0, 800a0f4 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x30>
                   this->entityId == other.entityId;
 800a0de:	340c      	adds	r4, #12
 800a0e0:	2203      	movs	r2, #3
 800a0e2:	4621      	mov	r1, r4
 800a0e4:	4628      	mov	r0, r5
 800a0e6:	f005 f9bf 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 800a0ea:	b920      	cbnz	r0, 800a0f6 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x32>
                   this->entityKind == other.entityKind;
 800a0ec:	78ea      	ldrb	r2, [r5, #3]
 800a0ee:	78e3      	ldrb	r3, [r4, #3]
            return this->entityKey == other.entityKey &&
 800a0f0:	429a      	cmp	r2, r3
 800a0f2:	d002      	beq.n	800a0fa <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x36>
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800a0f4:	bd38      	pop	{r3, r4, r5, pc}
 800a0f6:	2000      	movs	r0, #0
 800a0f8:	e7fc      	b.n	800a0f4 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x30>
 800a0fa:	2001      	movs	r0, #1
 800a0fc:	e7fa      	b.n	800a0f4 <_ZZN4rtps15StatefulWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x30>

0800a0fe <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENKUlPvRKNS_11WriterProxyEE0_clES6_S9_>:
    auto thunk=[](void* arg, const WriterProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800a0fe:	b538      	push	{r3, r4, r5, lr}
 800a100:	4610      	mov	r0, r2
        return proxy.remoteWriterGuid == guid;
 800a102:	680c      	ldr	r4, [r1, #0]
 800a104:	f102 050c 	add.w	r5, r2, #12
 800a108:	220c      	movs	r2, #12
 800a10a:	4621      	mov	r1, r4
 800a10c:	f005 f9ac 	bl	800f468 <memcmp>
 800a110:	fab0 f080 	clz	r0, r0
 800a114:	0940      	lsrs	r0, r0, #5
            return this->prefix == other.prefix &&
 800a116:	b150      	cbz	r0, 800a12e <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENKUlPvRKNS_11WriterProxyEE0_clES6_S9_+0x30>
                   this->entityId == other.entityId;
 800a118:	340c      	adds	r4, #12
 800a11a:	2203      	movs	r2, #3
 800a11c:	4621      	mov	r1, r4
 800a11e:	4628      	mov	r0, r5
 800a120:	f005 f9a2 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 800a124:	b920      	cbnz	r0, 800a130 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENKUlPvRKNS_11WriterProxyEE0_clES6_S9_+0x32>
                   this->entityKind == other.entityKind;
 800a126:	78ea      	ldrb	r2, [r5, #3]
 800a128:	78e3      	ldrb	r3, [r4, #3]
            return this->entityKey == other.entityKey &&
 800a12a:	429a      	cmp	r2, r3
 800a12c:	d002      	beq.n	800a134 <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENKUlPvRKNS_11WriterProxyEE0_clES6_S9_+0x36>
    auto thunk=[](void* arg, const WriterProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800a12e:	bd38      	pop	{r3, r4, r5, pc}
 800a130:	2000      	movs	r0, #0
 800a132:	e7fc      	b.n	800a12e <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENKUlPvRKNS_11WriterProxyEE0_clES6_S9_+0x30>
 800a134:	2001      	movs	r0, #1
 800a136:	e7fa      	b.n	800a12e <_ZZN4rtps15StatefulReaderTINS_9UdpDriverEE12removeWriterERKNS_4GuidEENKUlPvRKNS_11WriterProxyEE0_clES6_S9_+0x30>

0800a138 <_ZNK4rtps15StatefulWriterTINS_9UdpDriverEE12isIrrelevantENS_12ChangeKind_tE>:
}
 800a138:	f111 30ff 	adds.w	r0, r1, #4294967295	; 0xffffffff
 800a13c:	bf18      	it	ne
 800a13e:	2001      	movne	r0, #1
 800a140:	4770      	bx	lr

0800a142 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht>:
const rtps::CacheChange* StatefulWriterT<NetworkDriver>::newChange(ChangeKind_t kind, const uint8_t* data, DataSize_t size) {
 800a142:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a146:	b084      	sub	sp, #16
 800a148:	4604      	mov	r4, r0
 800a14a:	4617      	mov	r7, r2
 800a14c:	4698      	mov	r8, r3
    if (isIrrelevant(kind)) {
 800a14e:	f7ff fff3 	bl	800a138 <_ZNK4rtps15StatefulWriterTINS_9UdpDriverEE12isIrrelevantENS_12ChangeKind_tE>
 800a152:	2800      	cmp	r0, #0
 800a154:	d13f      	bne.n	800a1d6 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x94>
    Lock lock{m_mutex};
 800a156:	f104 0658 	add.w	r6, r4, #88	; 0x58
            sys_mutex_lock(&m_mutex);
 800a15a:	4630      	mov	r0, r6
 800a15c:	f7fe ff92 	bl	8009084 <sys_mutex_lock>
    if(m_history.isFull()){
 800a160:	f104 0584 	add.w	r5, r4, #132	; 0x84
 800a164:	4628      	mov	r0, r5
 800a166:	f004 f99f 	bl	800e4a8 <_ZNK4rtps18SimpleHistoryCache6isFullEv>
 800a16a:	b310      	cbz	r0, 800a1b2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x70>
        SequenceNumber_t newMin = ++SequenceNumber_t(m_history.getSeqNumMin());
 800a16c:	4628      	mov	r0, r5
 800a16e:	f004 f9a9 	bl	800e4c4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv>
 800a172:	c803      	ldmia	r0, {r0, r1}
 800a174:	ab04      	add	r3, sp, #16
 800a176:	e903 0003 	stmdb	r3, {r0, r1}
            ++low;
 800a17a:	9b03      	ldr	r3, [sp, #12]
 800a17c:	3301      	adds	r3, #1
 800a17e:	9303      	str	r3, [sp, #12]
            if(low == 0){
 800a180:	b913      	cbnz	r3, 800a188 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x46>
                ++high;
 800a182:	9a02      	ldr	r2, [sp, #8]
 800a184:	3201      	adds	r2, #1
 800a186:	9202      	str	r2, [sp, #8]
 800a188:	466a      	mov	r2, sp
 800a18a:	a904      	add	r1, sp, #16
 800a18c:	e911 0003 	ldmdb	r1, {r0, r1}
 800a190:	e882 0003 	stmia.w	r2, {r0, r1}
            return high < other.high || (high == other.high && low < other.low);
 800a194:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800a196:	4290      	cmp	r0, r2
 800a198:	dc04      	bgt.n	800a1a4 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x62>
 800a19a:	d10a      	bne.n	800a1b2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x70>
 800a19c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800a1a0:	429a      	cmp	r2, r3
 800a1a2:	d206      	bcs.n	800a1b2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x70>
            m_nextSequenceNumberToSend = newMin; // Make sure we have the correct sn to send
 800a1a4:	f104 037c 	add.w	r3, r4, #124	; 0x7c
 800a1a8:	466a      	mov	r2, sp
 800a1aa:	e892 0003 	ldmia.w	r2, {r0, r1}
 800a1ae:	e883 0003 	stmia.w	r3, {r0, r1}
    auto* result = m_history.addChange(data, size);
 800a1b2:	4642      	mov	r2, r8
 800a1b4:	4639      	mov	r1, r7
 800a1b6:	4628      	mov	r0, r5
 800a1b8:	f004 f9a0 	bl	800e4fc <_ZN4rtps18SimpleHistoryCache9addChangeEPKht>
 800a1bc:	4605      	mov	r5, r0
    if(mp_threadPool != nullptr){
 800a1be:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800a1c0:	b110      	cbz	r0, 800a1c8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x86>
        mp_threadPool->addWorkload(this);
 800a1c2:	4621      	mov	r1, r4
 800a1c4:	f000 ff2b 	bl	800b01e <_ZN4rtps10ThreadPool11addWorkloadEPNS_6WriterE>
            sys_mutex_unlock(&m_mutex);
 800a1c8:	4630      	mov	r0, r6
 800a1ca:	f7fe ff62 	bl	8009092 <sys_mutex_unlock>
}
 800a1ce:	4628      	mov	r0, r5
 800a1d0:	b004      	add	sp, #16
 800a1d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return nullptr;
 800a1d6:	2500      	movs	r5, #0
 800a1d8:	e7f9      	b.n	800a1ce <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x8c>
 800a1da:	4630      	mov	r0, r6
 800a1dc:	f7fe ff59 	bl	8009092 <sys_mutex_unlock>
 800a1e0:	f004 fbfb 	bl	800e9da <__cxa_end_cleanup>

0800a1e4 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_6HeaderE>:
        }

    };

	template<typename Buffer>
	bool serializeMessage(Buffer& buffer, Header& header){
 800a1e4:	b570      	push	{r4, r5, r6, lr}
 800a1e6:	4604      	mov	r4, r0
 800a1e8:	460d      	mov	r5, r1
	    if(!buffer.reserve(Header::getRawSize())){
 800a1ea:	2114      	movs	r1, #20
 800a1ec:	f004 f951 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>
 800a1f0:	4606      	mov	r6, r0
 800a1f2:	b908      	cbnz	r0, 800a1f8 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_6HeaderE+0x14>
		buffer.append(header.protocolName.data(), sizeof(std::array<uint8_t, 4>));
		buffer.append(reinterpret_cast<uint8_t*>(&header.protocolVersion), sizeof(ProtocolVersion_t));
		buffer.append(header.vendorId.vendorId.data(), sizeof(VendorId_t));
		buffer.append(header.guidPrefix.id.data(), sizeof(GuidPrefix_t));
		return true;
	}
 800a1f4:	4630      	mov	r0, r6
 800a1f6:	bd70      	pop	{r4, r5, r6, pc}
		buffer.append(header.protocolName.data(), sizeof(std::array<uint8_t, 4>));
 800a1f8:	2204      	movs	r2, #4
 800a1fa:	4629      	mov	r1, r5
 800a1fc:	4620      	mov	r0, r4
 800a1fe:	f004 f906 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&header.protocolVersion), sizeof(ProtocolVersion_t));
 800a202:	2202      	movs	r2, #2
 800a204:	1d29      	adds	r1, r5, #4
 800a206:	4620      	mov	r0, r4
 800a208:	f004 f901 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(header.vendorId.vendorId.data(), sizeof(VendorId_t));
 800a20c:	2202      	movs	r2, #2
 800a20e:	1da9      	adds	r1, r5, #6
 800a210:	4620      	mov	r0, r4
 800a212:	f004 f8fc 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(header.guidPrefix.id.data(), sizeof(GuidPrefix_t));
 800a216:	220c      	movs	r2, #12
 800a218:	f105 0108 	add.w	r1, r5, #8
 800a21c:	4620      	mov	r0, r4
 800a21e:	f004 f8f6 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		return true;
 800a222:	e7e7      	b.n	800a1f4 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_6HeaderE+0x10>

0800a224 <_ZN4rtps14MessageFactory9addHeaderINS_11PBufWrapperEEEvRT_RKNS_12GuidPrefix_tE>:
    namespace MessageFactory{
        const std::array<uint8_t, 4> PROTOCOL_TYPE{'R', 'T', 'P', 'S'};
        const uint8_t numBytesUntilEndOfLength = 4; // The first bytes incl. submessagelength don't count

        template <class Buffer>
        void addHeader(Buffer& buffer, const GuidPrefix_t& guidPrefix){
 800a224:	b510      	push	{r4, lr}
 800a226:	b086      	sub	sp, #24
 800a228:	4604      	mov	r4, r0
 800a22a:	460a      	mov	r2, r1

            Header header;
            header.protocolName = PROTOCOL_TYPE;
 800a22c:	4b09      	ldr	r3, [pc, #36]	; (800a254 <_ZN4rtps14MessageFactory9addHeaderINS_11PBufWrapperEEEvRT_RKNS_12GuidPrefix_tE+0x30>)
 800a22e:	6959      	ldr	r1, [r3, #20]
 800a230:	9101      	str	r1, [sp, #4]
            header.protocolVersion = PROTOCOLVERSION;
 800a232:	8b19      	ldrh	r1, [r3, #24]
 800a234:	f8ad 1008 	strh.w	r1, [sp, #8]
            header.vendorId = Config::VENDOR_ID;
 800a238:	8b9b      	ldrh	r3, [r3, #28]
 800a23a:	f8ad 300a 	strh.w	r3, [sp, #10]
            header.guidPrefix = guidPrefix;
 800a23e:	ab03      	add	r3, sp, #12
 800a240:	6810      	ldr	r0, [r2, #0]
 800a242:	6851      	ldr	r1, [r2, #4]
 800a244:	6892      	ldr	r2, [r2, #8]
 800a246:	c307      	stmia	r3!, {r0, r1, r2}

            serializeMessage(buffer, header);
 800a248:	a901      	add	r1, sp, #4
 800a24a:	4620      	mov	r0, r4
 800a24c:	f7ff ffca 	bl	800a1e4 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_6HeaderE>
        }
 800a250:	b006      	add	sp, #24
 800a252:	bd10      	pop	{r4, pc}
 800a254:	080108f8 	.word	0x080108f8

0800a258 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_16SubmessageHeaderE>:

	template<typename Buffer>
    bool serializeMessage(Buffer& buffer, SubmessageHeader& header){
 800a258:	b570      	push	{r4, r5, r6, lr}
 800a25a:	4604      	mov	r4, r0
 800a25c:	460d      	mov	r5, r1
        if(!buffer.reserve(Header::getRawSize())){
 800a25e:	2114      	movs	r1, #20
 800a260:	f004 f917 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>
 800a264:	4606      	mov	r6, r0
 800a266:	b908      	cbnz	r0, 800a26c <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_16SubmessageHeaderE+0x14>

		buffer.append(reinterpret_cast<uint8_t*>(&header.submessageId), sizeof(SubmessageKind));
		buffer.append(&header.flags, sizeof(uint8_t));
		buffer.append(reinterpret_cast<uint8_t*>(&header.submessageLength), sizeof(uint16_t));
        return true;
	}
 800a268:	4630      	mov	r0, r6
 800a26a:	bd70      	pop	{r4, r5, r6, pc}
		buffer.reserve(SubmessageHeader::getRawSize());
 800a26c:	2104      	movs	r1, #4
 800a26e:	4620      	mov	r0, r4
 800a270:	f004 f90f 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>
		buffer.append(reinterpret_cast<uint8_t*>(&header.submessageId), sizeof(SubmessageKind));
 800a274:	2201      	movs	r2, #1
 800a276:	4629      	mov	r1, r5
 800a278:	4620      	mov	r0, r4
 800a27a:	f004 f8c8 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(&header.flags, sizeof(uint8_t));
 800a27e:	2201      	movs	r2, #1
 800a280:	18a9      	adds	r1, r5, r2
 800a282:	4620      	mov	r0, r4
 800a284:	f004 f8c3 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&header.submessageLength), sizeof(uint16_t));
 800a288:	2202      	movs	r2, #2
 800a28a:	18a9      	adds	r1, r5, r2
 800a28c:	4620      	mov	r0, r4
 800a28e:	f004 f8be 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
        return true;
 800a292:	e7e9      	b.n	800a268 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_16SubmessageHeaderE+0x10>

0800a294 <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b>:

        template <class Buffer>
        void addSubMessageTimeStamp(Buffer& buffer, bool setInvalid=false){
 800a294:	b530      	push	{r4, r5, lr}
 800a296:	b085      	sub	sp, #20
 800a298:	4604      	mov	r4, r0
            SubmessageHeader header;
            header.submessageId = SubmessageKind::INFO_TS;
 800a29a:	2309      	movs	r3, #9
 800a29c:	f88d 300c 	strb.w	r3, [sp, #12]

#if IS_LITTLE_ENDIAN
            header.flags = FLAG_LITTLE_ENDIAN;
 800a2a0:	2301      	movs	r3, #1
 800a2a2:	f88d 300d 	strb.w	r3, [sp, #13]
#else
            header.flags = FLAG_BIG_ENDIAN;
#endif

            if(setInvalid){
 800a2a6:	460d      	mov	r5, r1
 800a2a8:	b161      	cbz	r1, 800a2c4 <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b+0x30>
                header.flags |= FLAG_INVALIDATE;
 800a2aa:	2303      	movs	r3, #3
 800a2ac:	f88d 300d 	strb.w	r3, [sp, #13]
                header.submessageLength = 0;
 800a2b0:	2300      	movs	r3, #0
 800a2b2:	f8ad 300e 	strh.w	r3, [sp, #14]
            }else{
                header.submessageLength = sizeof(Time_t);
            }

            serializeMessage(buffer, header);
 800a2b6:	a903      	add	r1, sp, #12
 800a2b8:	4620      	mov	r0, r4
 800a2ba:	f7ff ffcd 	bl	800a258 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_16SubmessageHeaderE>

            if(!setInvalid){
 800a2be:	b12d      	cbz	r5, 800a2cc <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b+0x38>
                Time_t now = getCurrentTimeStamp();
                buffer.append(reinterpret_cast<uint8_t*>(&now.seconds), sizeof(Time_t::seconds));
                buffer.append(reinterpret_cast<uint8_t*>(&now.fraction), sizeof(Time_t::fraction));
            }

        }
 800a2c0:	b005      	add	sp, #20
 800a2c2:	bd30      	pop	{r4, r5, pc}
                header.submessageLength = sizeof(Time_t);
 800a2c4:	2308      	movs	r3, #8
 800a2c6:	f8ad 300e 	strh.w	r3, [sp, #14]
 800a2ca:	e7f4      	b.n	800a2b6 <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b+0x22>
                buffer.reserve(header.submessageLength);
 800a2cc:	f8bd 100e 	ldrh.w	r1, [sp, #14]
 800a2d0:	4620      	mov	r0, r4
 800a2d2:	f004 f8de 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>

namespace rtps{
    inline Time_t getCurrentTimeStamp(){
        Time_t now;
        // TODO FIX
        uint32_t nowMs = sys_now();
 800a2d6:	f7ff f941 	bl	800955c <sys_now>
        now.seconds = (int32_t) nowMs / 1000;
 800a2da:	4a0f      	ldr	r2, [pc, #60]	; (800a318 <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b+0x84>)
 800a2dc:	fb82 3100 	smull	r3, r1, r2, r0
 800a2e0:	17c3      	asrs	r3, r0, #31
 800a2e2:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
 800a2e6:	9301      	str	r3, [sp, #4]
        now.fraction = ((nowMs % 1000)/1000);
 800a2e8:	fba2 1300 	umull	r1, r3, r2, r0
 800a2ec:	099b      	lsrs	r3, r3, #6
 800a2ee:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800a2f2:	fb01 0313 	mls	r3, r1, r3, r0
 800a2f6:	fba2 2303 	umull	r2, r3, r2, r3
 800a2fa:	099b      	lsrs	r3, r3, #6
 800a2fc:	9302      	str	r3, [sp, #8]
                buffer.append(reinterpret_cast<uint8_t*>(&now.seconds), sizeof(Time_t::seconds));
 800a2fe:	2204      	movs	r2, #4
 800a300:	eb0d 0102 	add.w	r1, sp, r2
 800a304:	4620      	mov	r0, r4
 800a306:	f004 f882 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
                buffer.append(reinterpret_cast<uint8_t*>(&now.fraction), sizeof(Time_t::fraction));
 800a30a:	2204      	movs	r2, #4
 800a30c:	a902      	add	r1, sp, #8
 800a30e:	4620      	mov	r0, r4
 800a310:	f004 f87d 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
        }
 800a314:	e7d4      	b.n	800a2c0 <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b+0x2c>
 800a316:	bf00      	nop
 800a318:	10624dd3 	.word	0x10624dd3

0800a31c <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE>:
		buffer.append(reinterpret_cast<uint8_t*>(&msg.count.value), sizeof(msg.count.value));
        return true;
	}

	template<typename Buffer>
    bool serializeMessage(Buffer& buffer, SubmessageAckNack& msg){
 800a31c:	b570      	push	{r4, r5, r6, lr}
 800a31e:	4605      	mov	r5, r0
 800a320:	460c      	mov	r4, r1
			if(set.numBits != 0){
 800a322:	6949      	ldr	r1, [r1, #20]
 800a324:	b161      	cbz	r1, 800a340 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE+0x24>
				bitMapSize = 4*((set.numBits/32) + 1);
 800a326:	0949      	lsrs	r1, r1, #5
 800a328:	3101      	adds	r1, #1
 800a32a:	0089      	lsls	r1, r1, #2
 800a32c:	b289      	uxth	r1, r1
				   + sizeof(SequenceNumber_t) + sizeof(uint32_t) + bitMapSize; // SequenceNumberSet
 800a32e:	311c      	adds	r1, #28
 800a330:	b289      	uxth	r1, r1
        if(!buffer.reserve(SubmessageAckNack::getRawSize(msg.readerSNState))){
 800a332:	4628      	mov	r0, r5
 800a334:	f004 f8ad 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>
 800a338:	4606      	mov	r6, r0
 800a33a:	b918      	cbnz	r0, 800a344 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE+0x28>
		if(msg.readerSNState.numBits != 0){
			buffer.append(reinterpret_cast<uint8_t*>(msg.readerSNState.bitMap.data()), 4*((msg.readerSNState.numBits / 32) + 1));
		}
		buffer.append(reinterpret_cast<uint8_t*>(&msg.count.value), sizeof(msg.count.value));
        return true;
	}
 800a33c:	4630      	mov	r0, r6
 800a33e:	bd70      	pop	{r4, r5, r6, pc}
            uint16_t bitMapSize = 0;
 800a340:	2100      	movs	r1, #0
 800a342:	e7f4      	b.n	800a32e <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE+0x12>
		serializeMessage(buffer, msg.header);
 800a344:	4621      	mov	r1, r4
 800a346:	4628      	mov	r0, r5
 800a348:	f7ff ff86 	bl	800a258 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_16SubmessageHeaderE>
		buffer.append(msg.readerId.entityKey.data(), msg.readerId.entityKey.size());
 800a34c:	2203      	movs	r2, #3
 800a34e:	1d21      	adds	r1, r4, #4
 800a350:	4628      	mov	r0, r5
 800a352:	f004 f85c 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.readerId.entityKind), sizeof(EntityKind_t));
 800a356:	2201      	movs	r2, #1
 800a358:	1de1      	adds	r1, r4, #7
 800a35a:	4628      	mov	r0, r5
 800a35c:	f004 f857 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(msg.writerId.entityKey.data(), msg.writerId.entityKey.size());
 800a360:	2203      	movs	r2, #3
 800a362:	f104 0108 	add.w	r1, r4, #8
 800a366:	4628      	mov	r0, r5
 800a368:	f004 f851 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.writerId.entityKind), sizeof(EntityKind_t));
 800a36c:	2201      	movs	r2, #1
 800a36e:	f104 010b 	add.w	r1, r4, #11
 800a372:	4628      	mov	r0, r5
 800a374:	f004 f84b 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.readerSNState.base.high), sizeof(msg.readerSNState.base.high));
 800a378:	2204      	movs	r2, #4
 800a37a:	f104 010c 	add.w	r1, r4, #12
 800a37e:	4628      	mov	r0, r5
 800a380:	f004 f845 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.readerSNState.base.low), sizeof(msg.readerSNState.base.low));
 800a384:	2204      	movs	r2, #4
 800a386:	f104 0110 	add.w	r1, r4, #16
 800a38a:	4628      	mov	r0, r5
 800a38c:	f004 f83f 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.readerSNState.numBits), sizeof(uint32_t));
 800a390:	2204      	movs	r2, #4
 800a392:	f104 0114 	add.w	r1, r4, #20
 800a396:	4628      	mov	r0, r5
 800a398:	f004 f839 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		if(msg.readerSNState.numBits != 0){
 800a39c:	6962      	ldr	r2, [r4, #20]
 800a39e:	b932      	cbnz	r2, 800a3ae <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE+0x92>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.count.value), sizeof(msg.count.value));
 800a3a0:	2204      	movs	r2, #4
 800a3a2:	f104 0138 	add.w	r1, r4, #56	; 0x38
 800a3a6:	4628      	mov	r0, r5
 800a3a8:	f004 f831 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
        return true;
 800a3ac:	e7c6      	b.n	800a33c <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE+0x20>
			buffer.append(reinterpret_cast<uint8_t*>(msg.readerSNState.bitMap.data()), 4*((msg.readerSNState.numBits / 32) + 1));
 800a3ae:	0952      	lsrs	r2, r2, #5
 800a3b0:	3201      	adds	r2, #1
 800a3b2:	0092      	lsls	r2, r2, #2
 800a3b4:	b292      	uxth	r2, r2
 800a3b6:	f104 0118 	add.w	r1, r4, #24
 800a3ba:	4628      	mov	r0, r5
 800a3bc:	f004 f827 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
 800a3c0:	e7ee      	b.n	800a3a0 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE+0x84>

0800a3c2 <_ZN4rtps14MessageFactory10addAckNackINS_11PBufWrapperEEEvRT_NS_10EntityId_tES5_NS_17SequenceNumberSetENS_7Count_tE>:

            serializeMessage(buffer, subMsg);
        }

        template <class Buffer>
        void addAckNack(Buffer& buffer, EntityId_t writerId, EntityId_t readerId, SequenceNumberSet readerSNState,
 800a3c2:	b082      	sub	sp, #8
 800a3c4:	b570      	push	{r4, r5, r6, lr}
 800a3c6:	b092      	sub	sp, #72	; 0x48
 800a3c8:	4606      	mov	r6, r0
 800a3ca:	9101      	str	r1, [sp, #4]
 800a3cc:	9200      	str	r2, [sp, #0]
 800a3ce:	9317      	str	r3, [sp, #92]	; 0x5c
                        Count_t count){
            SubmessageAckNack subMsg;
            subMsg.header.submessageId = SubmessageKind::ACKNACK;
 800a3d0:	2306      	movs	r3, #6
 800a3d2:	f88d 300c 	strb.w	r3, [sp, #12]
#if IS_LITTLE_ENDIAN
            subMsg.header.flags = FLAG_LITTLE_ENDIAN;
#else
            subMsg.header.flags = FLAG_BIG_ENDIAN;
#endif
            subMsg.header.flags |= FLAG_FINAL; // For now, we don't want any response
 800a3d6:	2303      	movs	r3, #3
 800a3d8:	f88d 300d 	strb.w	r3, [sp, #13]
			if(set.numBits != 0){
 800a3dc:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800a3de:	b1fb      	cbz	r3, 800a420 <_ZN4rtps14MessageFactory10addAckNackINS_11PBufWrapperEEEvRT_NS_10EntityId_tES5_NS_17SequenceNumberSetENS_7Count_tE+0x5e>
				bitMapSize = 4*((set.numBits/32) + 1);
 800a3e0:	095b      	lsrs	r3, r3, #5
 800a3e2:	3301      	adds	r3, #1
 800a3e4:	009b      	lsls	r3, r3, #2
 800a3e6:	b29b      	uxth	r3, r3
            subMsg.header.submessageLength = SubmessageAckNack::getRawSize(readerSNState) - numBytesUntilEndOfLength;
 800a3e8:	3318      	adds	r3, #24
 800a3ea:	f8ad 300e 	strh.w	r3, [sp, #14]

            subMsg.writerId = writerId;
 800a3ee:	9b01      	ldr	r3, [sp, #4]
 800a3f0:	9305      	str	r3, [sp, #20]
            subMsg.readerId = readerId;
 800a3f2:	9b00      	ldr	r3, [sp, #0]
 800a3f4:	9304      	str	r3, [sp, #16]
            subMsg.readerSNState = readerSNState;
 800a3f6:	ac06      	add	r4, sp, #24
 800a3f8:	ad17      	add	r5, sp, #92	; 0x5c
 800a3fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800a3fc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800a3fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800a400:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800a402:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800a406:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            subMsg.count = count;
 800a40a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800a40c:	9311      	str	r3, [sp, #68]	; 0x44

            serializeMessage(buffer, subMsg);
 800a40e:	a903      	add	r1, sp, #12
 800a410:	4630      	mov	r0, r6
 800a412:	f7ff ff83 	bl	800a31c <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_17SubmessageAckNackE>
        }
 800a416:	b012      	add	sp, #72	; 0x48
 800a418:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800a41c:	b002      	add	sp, #8
 800a41e:	4770      	bx	lr
            uint16_t bitMapSize = 0;
 800a420:	2300      	movs	r3, #0
 800a422:	e7e1      	b.n	800a3e8 <_ZN4rtps14MessageFactory10addAckNackINS_11PBufWrapperEEEvRT_NS_10EntityId_tES5_NS_17SequenceNumberSetENS_7Count_tE+0x26>

0800a424 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE>:

template <class NetworkDriver>
bool StatefulReaderT<NetworkDriver>::onNewHeartbeat(const SubmessageHeartbeat& msg, const GuidPrefix_t& sourceGuidPrefix){
 800a424:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800a428:	b0a0      	sub	sp, #128	; 0x80
 800a42a:	4606      	mov	r6, r0
 800a42c:	460c      	mov	r4, r1
 800a42e:	4690      	mov	r8, r2
    Lock lock(m_mutex);
 800a430:	f500 7094 	add.w	r0, r0, #296	; 0x128
        explicit Lock(sys_mutex_t& passedMutex) : m_mutex(passedMutex) {
 800a434:	901f      	str	r0, [sp, #124]	; 0x7c
            sys_mutex_lock(&m_mutex);
 800a436:	f7fe fe25 	bl	8009084 <sys_mutex_lock>

    struct PBufWrapper {

        pbuf* firstElement = nullptr;

        PBufWrapper() = default;
 800a43a:	2300      	movs	r3, #0
 800a43c:	931d      	str	r3, [sp, #116]	; 0x74
 800a43e:	f8ad 3078 	strh.w	r3, [sp, #120]	; 0x78
    PacketInfo info;
    info.srcPort = m_packetInfo.srcPort;
 800a442:	f8b6 2058 	ldrh.w	r2, [r6, #88]	; 0x58
 800a446:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
    WriterProxy* writer = nullptr;
    // Search for writer
    for(WriterProxy& proxy : m_proxies){
 800a44a:	f106 0270 	add.w	r2, r6, #112	; 0x70
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 800a44e:	920d      	str	r2, [sp, #52]	; 0x34
 800a450:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 800a454:	f896 3070 	ldrb.w	r3, [r6, #112]	; 0x70
 800a458:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
            if(!(m_bitMap[0] & 1)){
 800a45c:	f013 0f01 	tst.w	r3, #1
 800a460:	d118      	bne.n	800a494 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x70>
                if(m_pool.m_numElements == 0){
 800a462:	6f73      	ldr	r3, [r6, #116]	; 0x74
 800a464:	b19b      	cbz	r3, 800a48e <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x6a>
                    ++m_bit;
 800a466:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
 800a46a:	3301      	adds	r3, #1
 800a46c:	b2db      	uxtb	r3, r3
 800a46e:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800a472:	aa20      	add	r2, sp, #128	; 0x80
 800a474:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800a478:	f811 2c48 	ldrb.w	r2, [r1, #-72]
 800a47c:	0852      	lsrs	r2, r2, #1
 800a47e:	f801 2c48 	strb.w	r2, [r1, #-72]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800a482:	f012 0f01 	tst.w	r2, #1
 800a486:	d105      	bne.n	800a494 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x70>
 800a488:	2b02      	cmp	r3, #2
 800a48a:	d9ec      	bls.n	800a466 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x42>
 800a48c:	e002      	b.n	800a494 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x70>
                    m_bit = SIZE;
 800a48e:	2303      	movs	r3, #3
 800a490:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
            endIt.m_bit = SIZE;
 800a494:	2303      	movs	r3, #3
 800a496:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
 800a49a:	e00d      	b.n	800a4b8 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x94>
                   this->entityKind == other.entityKind;
 800a49c:	f899 2003 	ldrb.w	r2, [r9, #3]
 800a4a0:	f89a 3003 	ldrb.w	r3, [sl, #3]
            return this->entityKey == other.entityKey &&
 800a4a4:	429a      	cmp	r2, r3
 800a4a6:	d032      	beq.n	800a50e <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0xea>
 800a4a8:	2300      	movs	r3, #0
        if(proxy.remoteWriterGuid.prefix == sourceGuidPrefix && proxy.remoteWriterGuid.entityId == msg.writerId){
 800a4aa:	2b00      	cmp	r3, #0
 800a4ac:	d146      	bne.n	800a53c <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x118>
                if(m_pool.m_numElements == 0){
 800a4ae:	686b      	ldr	r3, [r5, #4]
 800a4b0:	bb7b      	cbnz	r3, 800a512 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0xee>
                    m_bit = SIZE;
 800a4b2:	2303      	movs	r3, #3
 800a4b4:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                 return m_bit != other.m_bit;
 800a4b8:	f89d 9039 	ldrb.w	r9, [sp, #57]	; 0x39
 800a4bc:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
    for(WriterProxy& proxy : m_proxies){
 800a4c0:	454b      	cmp	r3, r9
 800a4c2:	d03a      	beq.n	800a53a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x116>
                return m_pool.m_data[m_bit];
 800a4c4:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800a4c6:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 800a4ca:	eba3 0309 	sub.w	r3, r3, r9
 800a4ce:	00df      	lsls	r7, r3, #3
 800a4d0:	3708      	adds	r7, #8
 800a4d2:	442f      	add	r7, r5
 800a4d4:	220c      	movs	r2, #12
 800a4d6:	4641      	mov	r1, r8
 800a4d8:	4638      	mov	r0, r7
 800a4da:	f004 ffc5 	bl	800f468 <memcmp>
        if(proxy.remoteWriterGuid.prefix == sourceGuidPrefix && proxy.remoteWriterGuid.entityId == msg.writerId){
 800a4de:	2800      	cmp	r0, #0
 800a4e0:	d1e5      	bne.n	800a4ae <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x8a>
 800a4e2:	ebc9 09c9 	rsb	r9, r9, r9, lsl #3
 800a4e6:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 800a4ea:	3210      	adds	r2, #16
 800a4ec:	442a      	add	r2, r5
 800a4ee:	f102 0904 	add.w	r9, r2, #4
 800a4f2:	f104 0a08 	add.w	sl, r4, #8
 800a4f6:	3207      	adds	r2, #7
	  if (const size_t __len = (__last1 - __first1))
 800a4f8:	ebb2 0209 	subs.w	r2, r2, r9
 800a4fc:	d0ce      	beq.n	800a49c <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x78>
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800a4fe:	4651      	mov	r1, sl
 800a500:	4648      	mov	r0, r9
 800a502:	f004 ffb1 	bl	800f468 <memcmp>
 800a506:	2800      	cmp	r0, #0
 800a508:	d0c8      	beq.n	800a49c <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x78>
 800a50a:	2300      	movs	r3, #0
 800a50c:	e7cd      	b.n	800a4aa <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x86>
 800a50e:	2301      	movs	r3, #1
 800a510:	e7cb      	b.n	800a4aa <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x86>
                    ++m_bit;
 800a512:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
 800a516:	3301      	adds	r3, #1
 800a518:	b2db      	uxtb	r3, r3
 800a51a:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800a51e:	aa20      	add	r2, sp, #128	; 0x80
 800a520:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800a524:	f811 2c48 	ldrb.w	r2, [r1, #-72]
 800a528:	0852      	lsrs	r2, r2, #1
 800a52a:	f801 2c48 	strb.w	r2, [r1, #-72]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800a52e:	f012 0f01 	tst.w	r2, #1
 800a532:	d1c1      	bne.n	800a4b8 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x94>
 800a534:	2b02      	cmp	r3, #2
 800a536:	d9ec      	bls.n	800a512 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0xee>
 800a538:	e7be      	b.n	800a4b8 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x94>
    WriterProxy* writer = nullptr;
 800a53a:	2700      	movs	r7, #0
        }
    }



    if(writer == nullptr){
 800a53c:	2f00      	cmp	r7, #0
 800a53e:	d065      	beq.n	800a60c <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x1e8>
      printf("\n");
#endif
        return false;
    }

    if(msg.count.value <= writer->hbCount.value){
 800a540:	69e3      	ldr	r3, [r4, #28]
 800a542:	69fa      	ldr	r2, [r7, #28]
 800a544:	4293      	cmp	r3, r2
 800a546:	dc0a      	bgt.n	800a55e <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x13a>
#if SFR_VERBOSE
        printf("StatefulReader[%s]: Ignore heartbeat. Count too low.\n", &this->m_attributes.topicName[0]);
#endif
        return false;
 800a548:	2400      	movs	r4, #0
 800a54a:	a81d      	add	r0, sp, #116	; 0x74
 800a54c:	f003 ff49 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
            sys_mutex_unlock(&m_mutex);
 800a550:	981f      	ldr	r0, [sp, #124]	; 0x7c
 800a552:	f7fe fd9e 	bl	8009092 <sys_mutex_unlock>
#if SFR_VERBOSE
    printf("StatefulReader[%s]: Sending acknack.\n", &this->m_attributes.topicName[0]);
#endif
    m_transport->sendPacket(info);
    return true;
}
 800a556:	4620      	mov	r0, r4
 800a558:	b020      	add	sp, #128	; 0x80
 800a55a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    writer->hbCount.value = msg.count.value;
 800a55e:	61fb      	str	r3, [r7, #28]
                ucdr_serialize_array_uint8_t(&buffer, reinterpret_cast<uint8_t*>(this), sizeof(Locator));
            }
        }

        ip4_addr_t getIp4Address() const{
            return transformIP4ToU32(address[12], address[13], address[14], address[15]);
 800a560:	f897 2034 	ldrb.w	r2, [r7, #52]	; 0x34
 800a564:	f897 1035 	ldrb.w	r1, [r7, #53]	; 0x35
 800a568:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 800a56c:	f897 0037 	ldrb.w	r0, [r7, #55]	; 0x37
    }


    constexpr ip4_addr transformIP4ToU32(uint8_t MSB, uint8_t p2, uint8_t p1, uint8_t LSB) {
        return {((uint32_t) (LSB << 24)) |
                ((uint32_t) (p1 << 16)) |
 800a570:	041b      	lsls	r3, r3, #16
        return {((uint32_t) (LSB << 24)) |
 800a572:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
                ((uint32_t) (p1 << 16)) |
 800a576:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                ((uint32_t) (p2 << 8)) |
 800a57a:	4313      	orrs	r3, r2
    info.destAddr = writer->remoteLocator.getIp4Address();
 800a57c:	931b      	str	r3, [sp, #108]	; 0x6c
    info.destPort = writer->remoteLocator.port;
 800a57e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a580:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
    rtps::MessageFactory::addHeader(info.buffer, m_attributes.endpointGuid.prefix);
 800a584:	1d31      	adds	r1, r6, #4
 800a586:	a81d      	add	r0, sp, #116	; 0x74
 800a588:	f7ff fe4c 	bl	800a224 <_ZN4rtps14MessageFactory9addHeaderINS_11PBufWrapperEEEvRT_RKNS_12GuidPrefix_tE>
                hbCount{0}, remoteLocator(loc){
        }

        // For now, we don't store any packets, so we just request all starting from the next expected
        SequenceNumberSet getMissing(const SequenceNumber_t& /*firstAvail*/, const SequenceNumber_t& lastAvail){
            SequenceNumberSet set;
 800a58c:	222c      	movs	r2, #44	; 0x2c
 800a58e:	2100      	movs	r1, #0
 800a590:	a80f      	add	r0, sp, #60	; 0x3c
 800a592:	f004 ff83 	bl	800f49c <memset>
 800a596:	2320      	movs	r3, #32
 800a598:	9311      	str	r3, [sp, #68]	; 0x44
            return high < other.high || (high == other.high && low < other.low);
 800a59a:	6962      	ldr	r2, [r4, #20]
 800a59c:	693b      	ldr	r3, [r7, #16]
 800a59e:	429a      	cmp	r2, r3
 800a5a0:	db11      	blt.n	800a5c6 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x1a2>
 800a5a2:	d00c      	beq.n	800a5be <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x19a>
            if(lastAvail < expectedSN){
				set.base = expectedSN;
            	set.numBits = 0;
            }else{
            	set.numBits = 1;
 800a5a4:	2301      	movs	r3, #1
 800a5a6:	9311      	str	r3, [sp, #68]	; 0x44
				set.base = expectedSN;
 800a5a8:	ab0f      	add	r3, sp, #60	; 0x3c
 800a5aa:	f107 0210 	add.w	r2, r7, #16
 800a5ae:	e892 0003 	ldmia.w	r2, {r0, r1}
 800a5b2:	e883 0003 	stmia.w	r3, {r0, r1}
				set.bitMap[0] = uint32_t{1} << 31;
 800a5b6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800a5ba:	9312      	str	r3, [sp, #72]	; 0x48
 800a5bc:	e00c      	b.n	800a5d8 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x1b4>
 800a5be:	69a2      	ldr	r2, [r4, #24]
 800a5c0:	697b      	ldr	r3, [r7, #20]
 800a5c2:	429a      	cmp	r2, r3
 800a5c4:	d2ee      	bcs.n	800a5a4 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x180>
				set.base = expectedSN;
 800a5c6:	ab0f      	add	r3, sp, #60	; 0x3c
 800a5c8:	f107 0210 	add.w	r2, r7, #16
 800a5cc:	e892 0003 	ldmia.w	r2, {r0, r1}
 800a5d0:	e883 0003 	stmia.w	r3, {r0, r1}
            	set.numBits = 0;
 800a5d4:	2300      	movs	r3, #0
 800a5d6:	9311      	str	r3, [sp, #68]	; 0x44

            return set;
        }

        Count_t getNextAckNackCount(){
            const Count_t tmp = ackNackCount;
 800a5d8:	69bb      	ldr	r3, [r7, #24]
            ++ackNackCount.value;
 800a5da:	1c5a      	adds	r2, r3, #1
 800a5dc:	61ba      	str	r2, [r7, #24]
    rtps::MessageFactory::addAckNack(info.buffer, msg.writerId, msg.readerId, writer->getMissing(msg.firstSN,
 800a5de:	930a      	str	r3, [sp, #40]	; 0x28
 800a5e0:	466d      	mov	r5, sp
 800a5e2:	af10      	add	r7, sp, #64	; 0x40
 800a5e4:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800a5e6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800a5e8:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800a5ea:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800a5ec:	e897 0003 	ldmia.w	r7, {r0, r1}
 800a5f0:	e885 0003 	stmia.w	r5, {r0, r1}
 800a5f4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800a5f6:	6862      	ldr	r2, [r4, #4]
 800a5f8:	68a1      	ldr	r1, [r4, #8]
 800a5fa:	a81d      	add	r0, sp, #116	; 0x74
 800a5fc:	f7ff fee1 	bl	800a3c2 <_ZN4rtps14MessageFactory10addAckNackINS_11PBufWrapperEEEvRT_NS_10EntityId_tES5_NS_17SequenceNumberSetENS_7Count_tE>
    m_transport->sendPacket(info);
 800a600:	a91a      	add	r1, sp, #104	; 0x68
 800a602:	6ef0      	ldr	r0, [r6, #108]	; 0x6c
 800a604:	f000 ff2a 	bl	800b45c <_ZN4rtps9UdpDriver10sendPacketERNS_10PacketInfoE>
    return true;
 800a608:	2401      	movs	r4, #1
 800a60a:	e79e      	b.n	800a54a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x126>
        return false;
 800a60c:	2400      	movs	r4, #0
 800a60e:	e79c      	b.n	800a54a <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE+0x126>
 800a610:	a81d      	add	r0, sp, #116	; 0x74
 800a612:	f003 fee6 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800a616:	981f      	ldr	r0, [sp, #124]	; 0x7c
 800a618:	f7fe fd3b 	bl	8009092 <sys_mutex_unlock>
 800a61c:	f004 f9dd 	bl	800e9da <__cxa_end_cleanup>

0800a620 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_14SubmessageDataE>:
    bool serializeMessage(Buffer& buffer, SubmessageData& msg){
 800a620:	b570      	push	{r4, r5, r6, lr}
 800a622:	4604      	mov	r4, r0
 800a624:	460d      	mov	r5, r1
        if(!buffer.reserve(SubmessageData::getRawSize())){
 800a626:	2118      	movs	r1, #24
 800a628:	f003 ff33 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>
 800a62c:	4606      	mov	r6, r0
 800a62e:	b908      	cbnz	r0, 800a634 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_14SubmessageDataE+0x14>
	}
 800a630:	4630      	mov	r0, r6
 800a632:	bd70      	pop	{r4, r5, r6, pc}
		serializeMessage(buffer, msg.header);
 800a634:	4629      	mov	r1, r5
 800a636:	4620      	mov	r0, r4
 800a638:	f7ff fe0e 	bl	800a258 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_16SubmessageHeaderE>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.extraFlags), sizeof(uint16_t));
 800a63c:	2202      	movs	r2, #2
 800a63e:	1d29      	adds	r1, r5, #4
 800a640:	4620      	mov	r0, r4
 800a642:	f003 fee4 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.octetsToInlineQos), sizeof(uint16_t));
 800a646:	2202      	movs	r2, #2
 800a648:	1da9      	adds	r1, r5, #6
 800a64a:	4620      	mov	r0, r4
 800a64c:	f003 fedf 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(msg.readerId.entityKey.data(), msg.readerId.entityKey.size());
 800a650:	2203      	movs	r2, #3
 800a652:	f105 0108 	add.w	r1, r5, #8
 800a656:	4620      	mov	r0, r4
 800a658:	f003 fed9 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.readerId.entityKind), sizeof(EntityKind_t));
 800a65c:	2201      	movs	r2, #1
 800a65e:	f105 010b 	add.w	r1, r5, #11
 800a662:	4620      	mov	r0, r4
 800a664:	f003 fed3 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(msg.writerId.entityKey.data(), msg.writerId.entityKey.size());
 800a668:	2203      	movs	r2, #3
 800a66a:	f105 010c 	add.w	r1, r5, #12
 800a66e:	4620      	mov	r0, r4
 800a670:	f003 fecd 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.writerId.entityKind), sizeof(EntityKind_t));
 800a674:	2201      	movs	r2, #1
 800a676:	f105 010f 	add.w	r1, r5, #15
 800a67a:	4620      	mov	r0, r4
 800a67c:	f003 fec7 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.writerSN.high), sizeof(msg.writerSN.high));
 800a680:	2204      	movs	r2, #4
 800a682:	f105 0110 	add.w	r1, r5, #16
 800a686:	4620      	mov	r0, r4
 800a688:	f003 fec1 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.writerSN.low), sizeof(msg.writerSN.low));
 800a68c:	2204      	movs	r2, #4
 800a68e:	f105 0114 	add.w	r1, r5, #20
 800a692:	4620      	mov	r0, r4
 800a694:	f003 febb 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
        return true;
 800a698:	e7ca      	b.n	800a630 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_14SubmessageDataE+0x10>

0800a69a <_ZN4rtps14MessageFactory17addSubMessageDataINS_11PBufWrapperEEEvRT_RKS3_bRKNS_16SequenceNumber_tERKNS_10EntityId_tESC_>:
        void addSubMessageData(Buffer& buffer, const Buffer& filledPayload, bool containsInlineQos, const SequenceNumber_t& SN, const EntityId_t& writerID, const EntityId_t& readerID){
 800a69a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a69c:	b089      	sub	sp, #36	; 0x24
 800a69e:	4606      	mov	r6, r0
 800a6a0:	460c      	mov	r4, r1
 800a6a2:	4617      	mov	r7, r2
 800a6a4:	461d      	mov	r5, r3
            msg.header.submessageId = SubmessageKind::DATA;
 800a6a6:	2315      	movs	r3, #21
 800a6a8:	f88d 3008 	strb.w	r3, [sp, #8]
            msg.header.flags = FLAG_LITTLE_ENDIAN;
 800a6ac:	2301      	movs	r3, #1
 800a6ae:	f88d 3009 	strb.w	r3, [sp, #9]
            msg.header.submessageLength = SubmessageData::getRawSize() + filledPayload.spaceUsed() - numBytesUntilEndOfLength;
 800a6b2:	4608      	mov	r0, r1
 800a6b4:	f003 fea2 	bl	800e3fc <_ZNK4rtps11PBufWrapper9spaceUsedEv>
 800a6b8:	3014      	adds	r0, #20
 800a6ba:	f8ad 000a 	strh.w	r0, [sp, #10]
            if(containsInlineQos){
 800a6be:	b12f      	cbz	r7, 800a6cc <_ZN4rtps14MessageFactory17addSubMessageDataINS_11PBufWrapperEEEvRT_RKS3_bRKNS_16SequenceNumber_tERKNS_10EntityId_tESC_+0x32>
                msg.header.flags |= FLAG_INLINE_QOS;
 800a6c0:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800a6c4:	f043 0302 	orr.w	r3, r3, #2
 800a6c8:	f88d 3009 	strb.w	r3, [sp, #9]
            if(filledPayload.isValid()){
 800a6cc:	4620      	mov	r0, r4
 800a6ce:	f003 fe90 	bl	800e3f2 <_ZNK4rtps11PBufWrapper7isValidEv>
 800a6d2:	b128      	cbz	r0, 800a6e0 <_ZN4rtps14MessageFactory17addSubMessageDataINS_11PBufWrapperEEEvRT_RKS3_bRKNS_16SequenceNumber_tERKNS_10EntityId_tESC_+0x46>
                msg.header.flags |= FLAG_DATA_PAYLOAD;
 800a6d4:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800a6d8:	f043 0304 	orr.w	r3, r3, #4
 800a6dc:	f88d 3009 	strb.w	r3, [sp, #9]
            msg.writerSN = SN;
 800a6e0:	e895 0003 	ldmia.w	r5, {r0, r1}
 800a6e4:	ab08      	add	r3, sp, #32
 800a6e6:	e903 0003 	stmdb	r3, {r0, r1}
            msg.extraFlags = 0;
 800a6ea:	2300      	movs	r3, #0
 800a6ec:	f8ad 300c 	strh.w	r3, [sp, #12]
            msg.readerId = readerID;
 800a6f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800a6f2:	6818      	ldr	r0, [r3, #0]
 800a6f4:	9004      	str	r0, [sp, #16]
            msg.writerId = writerID;
 800a6f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a6f8:	6818      	ldr	r0, [r3, #0]
 800a6fa:	9005      	str	r0, [sp, #20]
            msg.octetsToInlineQos = octetsToInlineQoS;
 800a6fc:	2310      	movs	r3, #16
 800a6fe:	f8ad 300e 	strh.w	r3, [sp, #14]
            serializeMessage(buffer, msg);
 800a702:	a902      	add	r1, sp, #8
 800a704:	4630      	mov	r0, r6
 800a706:	f7ff ff8b 	bl	800a620 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_14SubmessageDataE>
            if(filledPayload.isValid()){
 800a70a:	4620      	mov	r0, r4
 800a70c:	f003 fe71 	bl	800e3f2 <_ZNK4rtps11PBufWrapper7isValidEv>
 800a710:	b908      	cbnz	r0, 800a716 <_ZN4rtps14MessageFactory17addSubMessageDataINS_11PBufWrapperEEEvRT_RKS3_bRKNS_16SequenceNumber_tERKNS_10EntityId_tESC_+0x7c>
        }
 800a712:	b009      	add	sp, #36	; 0x24
 800a714:	bdf0      	pop	{r4, r5, r6, r7, pc}
                Buffer shallowCopy = filledPayload;
 800a716:	4621      	mov	r1, r4
 800a718:	4668      	mov	r0, sp
 800a71a:	f003 fe4d 	bl	800e3b8 <_ZN4rtps11PBufWrapperC1ERKS0_>
                buffer.append(std::move(shallowCopy));
 800a71e:	4669      	mov	r1, sp
 800a720:	4630      	mov	r0, r6
 800a722:	f003 fe8c 	bl	800e43e <_ZN4rtps11PBufWrapper6appendEOS0_>
                Buffer shallowCopy = filledPayload;
 800a726:	4668      	mov	r0, sp
 800a728:	f003 fe5b 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
        }
 800a72c:	e7f1      	b.n	800a712 <_ZN4rtps14MessageFactory17addSubMessageDataINS_11PBufWrapperEEEvRT_RKS3_bRKNS_16SequenceNumber_tERKNS_10EntityId_tESC_+0x78>
                Buffer shallowCopy = filledPayload;
 800a72e:	4668      	mov	r0, sp
 800a730:	f003 fe57 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800a734:	f004 f951 	bl	800e9da <__cxa_end_cleanup>

0800a738 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE>:
        ++nextSN;
    }
}

template <class NetworkDriver>
bool StatefulWriterT<NetworkDriver>::sendData(const ReaderProxy &reader, const SequenceNumber_t& snMissing){
 800a738:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a73a:	b089      	sub	sp, #36	; 0x24
 800a73c:	4605      	mov	r5, r0
 800a73e:	460c      	mov	r4, r1
 800a740:	4616      	mov	r6, r2
 800a742:	2300      	movs	r3, #0
 800a744:	9306      	str	r3, [sp, #24]
 800a746:	f8ad 301c 	strh.w	r3, [sp, #28]

    // TODO smarter packaging e.g. by creating MessageStruct and serialize after adjusting values
    // Reusing the pbuf is not possible. See https://www.nongnu.org/lwip/2_0_x/raw_api.html (Zero-Copy MACs)

    PacketInfo info;
    info.srcPort = m_packetInfo.srcPort;
 800a74a:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
 800a74e:	f8ad 300c 	strh.w	r3, [sp, #12]

    MessageFactory::addHeader(info.buffer, m_attributes.endpointGuid.prefix);
 800a752:	1d01      	adds	r1, r0, #4
 800a754:	a806      	add	r0, sp, #24
 800a756:	f7ff fd65 	bl	800a224 <_ZN4rtps14MessageFactory9addHeaderINS_11PBufWrapperEEEvRT_RKNS_12GuidPrefix_tE>
    MessageFactory::addSubMessageTimeStamp(info.buffer);
 800a75a:	2100      	movs	r1, #0
 800a75c:	a806      	add	r0, sp, #24
 800a75e:	f7ff fd99 	bl	800a294 <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b>
 800a762:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
 800a766:	f894 1025 	ldrb.w	r1, [r4, #37]	; 0x25
 800a76a:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 800a76e:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
                ((uint32_t) (p1 << 16)) |
 800a772:	041b      	lsls	r3, r3, #16
        return {((uint32_t) (LSB << 24)) |
 800a774:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
                ((uint32_t) (p1 << 16)) |
 800a778:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                ((uint32_t) (p2 << 8)) |
 800a77c:	4313      	orrs	r3, r2

    // Just usable for IPv4
    const Locator& locator = reader.remoteLocator;

    info.destAddr = locator.getIp4Address();
 800a77e:	9304      	str	r3, [sp, #16]
    info.destPort = (Ip4Port_t) locator.port;
 800a780:	6963      	ldr	r3, [r4, #20]
 800a782:	f8ad 3014 	strh.w	r3, [sp, #20]

    {
        Lock lock(m_mutex);
 800a786:	f105 0758 	add.w	r7, r5, #88	; 0x58
            sys_mutex_lock(&m_mutex);
 800a78a:	4638      	mov	r0, r7
 800a78c:	f7fe fc7a 	bl	8009084 <sys_mutex_lock>
        const CacheChange* next = m_history.getChangeBySN(snMissing);
 800a790:	e896 0006 	ldmia.w	r6, {r1, r2}
 800a794:	f105 0084 	add.w	r0, r5, #132	; 0x84
 800a798:	f003 ff19 	bl	800e5ce <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE>
        if(next == nullptr){
 800a79c:	4601      	mov	r1, r0
 800a79e:	b158      	cbz	r0, 800a7b8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE+0x80>
            log("StatefulWriter[%s]: Couldn't get a CacheChange with SN (%i,%u)\n", &this->m_attributes.topicName[0],
                                                                                       snMissing.high, snMissing.low);
#endif
            return false;
        }
        MessageFactory::addSubMessageData(info.buffer, next->data, false, next->sequenceNumber, m_attributes.endpointGuid.entityId,
 800a7a0:	340c      	adds	r4, #12
 800a7a2:	9401      	str	r4, [sp, #4]
 800a7a4:	f105 0310 	add.w	r3, r5, #16
 800a7a8:	9300      	str	r3, [sp, #0]
 800a7aa:	1d03      	adds	r3, r0, #4
 800a7ac:	2200      	movs	r2, #0
 800a7ae:	310c      	adds	r1, #12
 800a7b0:	a806      	add	r0, sp, #24
 800a7b2:	f7ff ff72 	bl	800a69a <_ZN4rtps14MessageFactory17addSubMessageDataINS_11PBufWrapperEEEvRT_RKS3_bRKNS_16SequenceNumber_tERKNS_10EntityId_tESC_>
 800a7b6:	e004      	b.n	800a7c2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE+0x8a>
            sys_mutex_unlock(&m_mutex);
 800a7b8:	4638      	mov	r0, r7
 800a7ba:	f7fe fc6a 	bl	8009092 <sys_mutex_unlock>
            return false;
 800a7be:	2400      	movs	r4, #0
 800a7c0:	e007      	b.n	800a7d2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE+0x9a>
 800a7c2:	4638      	mov	r0, r7
 800a7c4:	f7fe fc65 	bl	8009092 <sys_mutex_unlock>
                                          reader.remoteReaderGuid.entityId);
    }

    m_transport->sendPacket(info);
 800a7c8:	a903      	add	r1, sp, #12
 800a7ca:	6f68      	ldr	r0, [r5, #116]	; 0x74
 800a7cc:	f000 fe46 	bl	800b45c <_ZN4rtps9UdpDriver10sendPacketERNS_10PacketInfoE>
    return true;
 800a7d0:	2401      	movs	r4, #1
 800a7d2:	a806      	add	r0, sp, #24
 800a7d4:	f003 fe05 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
}
 800a7d8:	4620      	mov	r0, r4
 800a7da:	b009      	add	sp, #36	; 0x24
 800a7dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a7de:	4638      	mov	r0, r7
 800a7e0:	f7fe fc57 	bl	8009092 <sys_mutex_unlock>
 800a7e4:	a806      	add	r0, sp, #24
 800a7e6:	f003 fdfc 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800a7ea:	f004 f8f6 	bl	800e9da <__cxa_end_cleanup>
 800a7ee:	e7f9      	b.n	800a7e4 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE+0xac>

0800a7f0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE>:
void StatefulWriterT<NetworkDriver>::onNewAckNack(const SubmessageAckNack& msg, const GuidPrefix_t& sourceGuidPrefix){
 800a7f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800a7f4:	b090      	sub	sp, #64	; 0x40
 800a7f6:	4606      	mov	r6, r0
 800a7f8:	460d      	mov	r5, r1
 800a7fa:	4690      	mov	r8, r2
    for(auto& proxy : m_proxies){
 800a7fc:	f500 73bc 	add.w	r3, r0, #376	; 0x178
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 800a800:	9303      	str	r3, [sp, #12]
 800a802:	2200      	movs	r2, #0
 800a804:	f88d 2011 	strb.w	r2, [sp, #17]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 800a808:	f890 2178 	ldrb.w	r2, [r0, #376]	; 0x178
 800a80c:	f88d 2010 	strb.w	r2, [sp, #16]
            if(!(m_bitMap[0] & 1)){
 800a810:	f012 0f01 	tst.w	r2, #1
 800a814:	d105      	bne.n	800a822 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x32>
                if(m_pool.m_numElements == 0){
 800a816:	f8d0 317c 	ldr.w	r3, [r0, #380]	; 0x17c
 800a81a:	b933      	cbnz	r3, 800a82a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x3a>
                    m_bit = SIZE;
 800a81c:	2303      	movs	r3, #3
 800a81e:	f88d 3011 	strb.w	r3, [sp, #17]
            endIt.m_bit = SIZE;
 800a822:	2303      	movs	r3, #3
 800a824:	f88d 3019 	strb.w	r3, [sp, #25]
 800a828:	e021      	b.n	800a86e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x7e>
                    ++m_bit;
 800a82a:	f89d 3011 	ldrb.w	r3, [sp, #17]
 800a82e:	3301      	adds	r3, #1
 800a830:	b2db      	uxtb	r3, r3
 800a832:	f88d 3011 	strb.w	r3, [sp, #17]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800a836:	aa10      	add	r2, sp, #64	; 0x40
 800a838:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800a83c:	f811 2c30 	ldrb.w	r2, [r1, #-48]
 800a840:	0852      	lsrs	r2, r2, #1
 800a842:	f801 2c30 	strb.w	r2, [r1, #-48]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800a846:	f012 0f01 	tst.w	r2, #1
 800a84a:	d1ea      	bne.n	800a822 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x32>
 800a84c:	2b02      	cmp	r3, #2
 800a84e:	d9ec      	bls.n	800a82a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x3a>
 800a850:	e7e7      	b.n	800a822 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x32>
                   this->entityKind == other.entityKind;
 800a852:	f899 2003 	ldrb.w	r2, [r9, #3]
 800a856:	f89a 3003 	ldrb.w	r3, [sl, #3]
            return this->entityKey == other.entityKey &&
 800a85a:	429a      	cmp	r2, r3
 800a85c:	d02f      	beq.n	800a8be <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0xce>
 800a85e:	2300      	movs	r3, #0
        if(proxy.remoteReaderGuid.prefix == sourceGuidPrefix && proxy.remoteReaderGuid.entityId == msg.readerId){
 800a860:	2b00      	cmp	r3, #0
 800a862:	d143      	bne.n	800a8ec <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0xfc>
                if(m_pool.m_numElements == 0){
 800a864:	687b      	ldr	r3, [r7, #4]
 800a866:	bb63      	cbnz	r3, 800a8c2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0xd2>
                    m_bit = SIZE;
 800a868:	2303      	movs	r3, #3
 800a86a:	f88d 3011 	strb.w	r3, [sp, #17]
                 return m_bit != other.m_bit;
 800a86e:	f89d 9011 	ldrb.w	r9, [sp, #17]
 800a872:	f89d 3019 	ldrb.w	r3, [sp, #25]
    for(auto& proxy : m_proxies){
 800a876:	454b      	cmp	r3, r9
 800a878:	d037      	beq.n	800a8ea <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0xfa>
                return m_pool.m_data[m_bit];
 800a87a:	9f03      	ldr	r7, [sp, #12]
 800a87c:	2458      	movs	r4, #88	; 0x58
 800a87e:	fb04 f409 	mul.w	r4, r4, r9
 800a882:	3408      	adds	r4, #8
 800a884:	443c      	add	r4, r7
 800a886:	220c      	movs	r2, #12
 800a888:	4641      	mov	r1, r8
 800a88a:	4620      	mov	r0, r4
 800a88c:	f004 fdec 	bl	800f468 <memcmp>
        if(proxy.remoteReaderGuid.prefix == sourceGuidPrefix && proxy.remoteReaderGuid.entityId == msg.readerId){
 800a890:	2800      	cmp	r0, #0
 800a892:	d1e7      	bne.n	800a864 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x74>
 800a894:	2358      	movs	r3, #88	; 0x58
 800a896:	fb03 f309 	mul.w	r3, r3, r9
 800a89a:	3310      	adds	r3, #16
 800a89c:	443b      	add	r3, r7
 800a89e:	f103 0904 	add.w	r9, r3, #4
 800a8a2:	f105 0a04 	add.w	sl, r5, #4
 800a8a6:	3307      	adds	r3, #7
	  if (const size_t __len = (__last1 - __first1))
 800a8a8:	ebb3 0209 	subs.w	r2, r3, r9
 800a8ac:	d0d1      	beq.n	800a852 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x62>
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800a8ae:	4651      	mov	r1, sl
 800a8b0:	4648      	mov	r0, r9
 800a8b2:	f004 fdd9 	bl	800f468 <memcmp>
 800a8b6:	2800      	cmp	r0, #0
 800a8b8:	d0cb      	beq.n	800a852 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x62>
 800a8ba:	2300      	movs	r3, #0
 800a8bc:	e7d0      	b.n	800a860 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x70>
 800a8be:	2301      	movs	r3, #1
 800a8c0:	e7ce      	b.n	800a860 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x70>
                    ++m_bit;
 800a8c2:	f89d 3011 	ldrb.w	r3, [sp, #17]
 800a8c6:	3301      	adds	r3, #1
 800a8c8:	b2db      	uxtb	r3, r3
 800a8ca:	f88d 3011 	strb.w	r3, [sp, #17]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800a8ce:	aa10      	add	r2, sp, #64	; 0x40
 800a8d0:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800a8d4:	f811 2c30 	ldrb.w	r2, [r1, #-48]
 800a8d8:	0852      	lsrs	r2, r2, #1
 800a8da:	f801 2c30 	strb.w	r2, [r1, #-48]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800a8de:	f012 0f01 	tst.w	r2, #1
 800a8e2:	d1c4      	bne.n	800a86e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x7e>
 800a8e4:	2b02      	cmp	r3, #2
 800a8e6:	d9ec      	bls.n	800a8c2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0xd2>
 800a8e8:	e7c1      	b.n	800a86e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x7e>
    ReaderProxy* reader = nullptr;
 800a8ea:	2400      	movs	r4, #0
    if(reader == nullptr){
 800a8ec:	2c00      	cmp	r4, #0
 800a8ee:	d066      	beq.n	800a9be <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1ce>
    for(int i = 0; i < sourceGuidPrefix.id.size(); i++){
 800a8f0:	2300      	movs	r3, #0
 800a8f2:	2b0b      	cmp	r3, #11
 800a8f4:	d801      	bhi.n	800a8fa <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x10a>
 800a8f6:	3301      	adds	r3, #1
 800a8f8:	e7fb      	b.n	800a8f2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x102>
    size_t size = snprintf(bfr, sizeof(bfr), "%u <= %u", msg.count.value, reader->ackNackCount.value);
 800a8fa:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800a8fc:	9300      	str	r3, [sp, #0]
 800a8fe:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800a900:	4a35      	ldr	r2, [pc, #212]	; (800a9d8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1e8>)
 800a902:	2114      	movs	r1, #20
 800a904:	a80b      	add	r0, sp, #44	; 0x2c
 800a906:	f004 fe61 	bl	800f5cc <sniprintf>
    if(!(size < sizeof(bfr))){
 800a90a:	2813      	cmp	r0, #19
 800a90c:	d900      	bls.n	800a910 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x120>
 800a90e:	e7fe      	b.n	800a90e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x11e>
    if(msg.count.value <= reader->ackNackCount.value){
 800a910:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800a912:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800a914:	429a      	cmp	r2, r3
 800a916:	dd52      	ble.n	800a9be <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1ce>
    reader->ackNackCount = msg.count;
 800a918:	6562      	str	r2, [r4, #84]	; 0x54
    SequenceNumber_t nextSN = msg.readerSNState.base;
 800a91a:	ab09      	add	r3, sp, #36	; 0x24
 800a91c:	f105 020c 	add.w	r2, r5, #12
 800a920:	e892 0003 	ldmia.w	r2, {r0, r1}
 800a924:	e883 0003 	stmia.w	r3, {r0, r1}
    for(uint32_t i=0; i < msg.readerSNState.numBits; ++i, ++nextSN){
 800a928:	2700      	movs	r7, #0
 800a92a:	696b      	ldr	r3, [r5, #20]
 800a92c:	42bb      	cmp	r3, r7
 800a92e:	d91d      	bls.n	800a96c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x17c>
        uint32_t numBits = SNS_NUM_BITS;
        std::array<uint32_t, 8> bitMap{};

        // We only need 1 byte because atm we don't store packets.
        bool isSet(uint32_t bit) const{
            if(bit >= SNS_NUM_BITS){
 800a930:	2f1f      	cmp	r7, #31
 800a932:	d80c      	bhi.n	800a94e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x15e>
                return true;
            }
            const auto bucket = static_cast<uint8_t>(bit / 32);
            const auto pos = static_cast<uint8_t>(bit % 32);
 800a934:	f007 031f 	and.w	r3, r7, #31
            return (bitMap[bucket] & (1 << (31 - pos))) != 0;
 800a938:	f1c3 021f 	rsb	r2, r3, #31
 800a93c:	2301      	movs	r3, #1
 800a93e:	4093      	lsls	r3, r2
 800a940:	f3c7 1247 	ubfx	r2, r7, #5, #8
 800a944:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 800a948:	6992      	ldr	r2, [r2, #24]
        if(msg.readerSNState.isSet(i)){
 800a94a:	4213      	tst	r3, r2
 800a94c:	d004      	beq.n	800a958 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x168>
            sendData(*reader, nextSN);
 800a94e:	aa09      	add	r2, sp, #36	; 0x24
 800a950:	4621      	mov	r1, r4
 800a952:	4630      	mov	r0, r6
 800a954:	f7ff fef0 	bl	800a738 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE>
    for(uint32_t i=0; i < msg.readerSNState.numBits; ++i, ++nextSN){
 800a958:	3701      	adds	r7, #1
            ++low;
 800a95a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a95c:	3301      	adds	r3, #1
 800a95e:	930a      	str	r3, [sp, #40]	; 0x28
            if(low == 0){
 800a960:	2b00      	cmp	r3, #0
 800a962:	d1e2      	bne.n	800a92a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x13a>
                ++high;
 800a964:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a966:	3301      	adds	r3, #1
 800a968:	9309      	str	r3, [sp, #36]	; 0x24
 800a96a:	e7de      	b.n	800a92a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x13a>
        Lock lock(m_mutex);
 800a96c:	f106 0558 	add.w	r5, r6, #88	; 0x58
            sys_mutex_lock(&m_mutex);
 800a970:	4628      	mov	r0, r5
 800a972:	f7fe fb87 	bl	8009084 <sys_mutex_lock>
        maxSN = m_history.getSeqNumMax();
 800a976:	f106 0084 	add.w	r0, r6, #132	; 0x84
 800a97a:	f003 fdb3 	bl	800e4e4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMaxEv>
 800a97e:	ab07      	add	r3, sp, #28
 800a980:	c803      	ldmia	r0, {r0, r1}
 800a982:	e883 0003 	stmia.w	r3, {r0, r1}
            sys_mutex_unlock(&m_mutex);
 800a986:	4628      	mov	r0, r5
 800a988:	f7fe fb83 	bl	8009092 <sys_mutex_unlock>
 800a98c:	e00c      	b.n	800a9a8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1b8>
            return high == other.high && low == other.low;
 800a98e:	980a      	ldr	r0, [sp, #40]	; 0x28
 800a990:	9908      	ldr	r1, [sp, #32]
 800a992:	4288      	cmp	r0, r1
 800a994:	d10c      	bne.n	800a9b0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1c0>
        sendData(*reader, nextSN);
 800a996:	aa09      	add	r2, sp, #36	; 0x24
 800a998:	4621      	mov	r1, r4
 800a99a:	4630      	mov	r0, r6
 800a99c:	f7ff fecc 	bl	800a738 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE>
            ++low;
 800a9a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a9a2:	3301      	adds	r3, #1
 800a9a4:	930a      	str	r3, [sp, #40]	; 0x28
            if(low == 0){
 800a9a6:	b16b      	cbz	r3, 800a9c4 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1d4>
            return high == other.high && low == other.low;
 800a9a8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800a9aa:	9b07      	ldr	r3, [sp, #28]
 800a9ac:	429a      	cmp	r2, r3
 800a9ae:	d0ee      	beq.n	800a98e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x19e>
            return high < other.high || (high == other.high && low < other.low);
 800a9b0:	429a      	cmp	r2, r3
 800a9b2:	dbf0      	blt.n	800a996 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1a6>
 800a9b4:	d103      	bne.n	800a9be <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1ce>
 800a9b6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a9b8:	9b08      	ldr	r3, [sp, #32]
 800a9ba:	429a      	cmp	r2, r3
 800a9bc:	d3eb      	bcc.n	800a996 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1a6>
}
 800a9be:	b010      	add	sp, #64	; 0x40
 800a9c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                ++high;
 800a9c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a9c6:	3301      	adds	r3, #1
 800a9c8:	9309      	str	r3, [sp, #36]	; 0x24
 800a9ca:	e7ed      	b.n	800a9a8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE+0x1b8>
 800a9cc:	4628      	mov	r0, r5
 800a9ce:	f7fe fb60 	bl	8009092 <sys_mutex_unlock>
 800a9d2:	f004 f802 	bl	800e9da <__cxa_end_cleanup>
 800a9d6:	bf00      	nop
 800a9d8:	08011be8 	.word	0x08011be8

0800a9dc <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv>:
void StatefulWriterT<NetworkDriver>::progress(){
 800a9dc:	b530      	push	{r4, r5, lr}
 800a9de:	b085      	sub	sp, #20
 800a9e0:	4604      	mov	r4, r0
    for(const auto& proxy : m_proxies) {
 800a9e2:	f500 72bc 	add.w	r2, r0, #376	; 0x178
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 800a9e6:	9200      	str	r2, [sp, #0]
 800a9e8:	2300      	movs	r3, #0
 800a9ea:	f88d 3005 	strb.w	r3, [sp, #5]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 800a9ee:	f890 3178 	ldrb.w	r3, [r0, #376]	; 0x178
 800a9f2:	f88d 3004 	strb.w	r3, [sp, #4]
            if(!(m_bitMap[0] & 1)){
 800a9f6:	f013 0f01 	tst.w	r3, #1
 800a9fa:	d119      	bne.n	800aa30 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x54>
                if(m_pool.m_numElements == 0){
 800a9fc:	f8d0 317c 	ldr.w	r3, [r0, #380]	; 0x17c
 800aa00:	b19b      	cbz	r3, 800aa2a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x4e>
                    ++m_bit;
 800aa02:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800aa06:	3301      	adds	r3, #1
 800aa08:	b2db      	uxtb	r3, r3
 800aa0a:	f88d 3005 	strb.w	r3, [sp, #5]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800aa0e:	aa04      	add	r2, sp, #16
 800aa10:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800aa14:	f811 2c0c 	ldrb.w	r2, [r1, #-12]
 800aa18:	0852      	lsrs	r2, r2, #1
 800aa1a:	f801 2c0c 	strb.w	r2, [r1, #-12]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800aa1e:	f012 0f01 	tst.w	r2, #1
 800aa22:	d105      	bne.n	800aa30 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x54>
 800aa24:	2b02      	cmp	r3, #2
 800aa26:	d9ec      	bls.n	800aa02 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x26>
 800aa28:	e002      	b.n	800aa30 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x54>
                    m_bit = SIZE;
 800aa2a:	2303      	movs	r3, #3
 800aa2c:	f88d 3005 	strb.w	r3, [sp, #5]
            endIt.m_bit = SIZE;
 800aa30:	2303      	movs	r3, #3
 800aa32:	f88d 300d 	strb.w	r3, [sp, #13]
 800aa36:	e002      	b.n	800aa3e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x62>
                    m_bit = SIZE;
 800aa38:	2303      	movs	r3, #3
 800aa3a:	f88d 3005 	strb.w	r3, [sp, #5]
                 return m_bit != other.m_bit;
 800aa3e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800aa42:	f89d 200d 	ldrb.w	r2, [sp, #13]
 800aa46:	4293      	cmp	r3, r2
 800aa48:	d021      	beq.n	800aa8e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0xb2>
                return m_pool.m_data[m_bit];
 800aa4a:	9d00      	ldr	r5, [sp, #0]
 800aa4c:	2158      	movs	r1, #88	; 0x58
 800aa4e:	fb01 f103 	mul.w	r1, r1, r3
 800aa52:	3108      	adds	r1, #8
        if(!sendData(proxy, m_nextSequenceNumberToSend)){
 800aa54:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 800aa58:	4429      	add	r1, r5
 800aa5a:	4620      	mov	r0, r4
 800aa5c:	f7ff fe6c 	bl	800a738 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8sendDataERKNS_11ReaderProxyERKNS_16SequenceNumber_tE>
                if(m_pool.m_numElements == 0){
 800aa60:	686b      	ldr	r3, [r5, #4]
 800aa62:	2b00      	cmp	r3, #0
 800aa64:	d0e8      	beq.n	800aa38 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x5c>
                    ++m_bit;
 800aa66:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800aa6a:	3301      	adds	r3, #1
 800aa6c:	b2db      	uxtb	r3, r3
 800aa6e:	f88d 3005 	strb.w	r3, [sp, #5]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800aa72:	aa04      	add	r2, sp, #16
 800aa74:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800aa78:	f811 2c0c 	ldrb.w	r2, [r1, #-12]
 800aa7c:	0852      	lsrs	r2, r2, #1
 800aa7e:	f801 2c0c 	strb.w	r2, [r1, #-12]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800aa82:	f012 0f01 	tst.w	r2, #1
 800aa86:	d1da      	bne.n	800aa3e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x62>
 800aa88:	2b02      	cmp	r3, #2
 800aa8a:	d9ec      	bls.n	800aa66 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x8a>
 800aa8c:	e7d7      	b.n	800aa3e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0x62>
            ++low;
 800aa8e:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800aa92:	3301      	adds	r3, #1
 800aa94:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
            if(low == 0){
 800aa98:	b913      	cbnz	r3, 800aaa0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE8progressEv+0xc4>
                ++high;
 800aa9a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 800aa9c:	3301      	adds	r3, #1
 800aa9e:	67e3      	str	r3, [r4, #124]	; 0x7c
}
 800aaa0:	b005      	add	sp, #20
 800aaa2:	bd30      	pop	{r4, r5, pc}

0800aaa4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800aaa4:	b500      	push	{lr}
 800aaa6:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 800aaa8:	4b0d      	ldr	r3, [pc, #52]	; (800aae0 <HAL_MspInit+0x3c>)
 800aaaa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800aaac:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800aab0:	641a      	str	r2, [r3, #64]	; 0x40
 800aab2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800aab4:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 800aab8:	9200      	str	r2, [sp, #0]
 800aaba:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800aabc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800aabe:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800aac2:	645a      	str	r2, [r3, #68]	; 0x44
 800aac4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aac6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800aaca:	9301      	str	r3, [sp, #4]
 800aacc:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 800aace:	2200      	movs	r2, #0
 800aad0:	210f      	movs	r1, #15
 800aad2:	f06f 0001 	mvn.w	r0, #1
 800aad6:	f7f6 fd65 	bl	80015a4 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800aada:	b003      	add	sp, #12
 800aadc:	f85d fb04 	ldr.w	pc, [sp], #4
 800aae0:	40023800 	.word	0x40023800

0800aae4 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 800aae4:	b500      	push	{lr}
 800aae6:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800aae8:	2300      	movs	r3, #0
 800aaea:	9305      	str	r3, [sp, #20]
 800aaec:	9306      	str	r3, [sp, #24]
 800aaee:	9307      	str	r3, [sp, #28]
 800aaf0:	9308      	str	r3, [sp, #32]
 800aaf2:	9309      	str	r3, [sp, #36]	; 0x24
  if(huart->Instance==USART3)
 800aaf4:	6803      	ldr	r3, [r0, #0]
 800aaf6:	4a25      	ldr	r2, [pc, #148]	; (800ab8c <HAL_UART_MspInit+0xa8>)
 800aaf8:	4293      	cmp	r3, r2
 800aafa:	d005      	beq.n	800ab08 <HAL_UART_MspInit+0x24>

  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }
  else if(huart->Instance==USART6)
 800aafc:	4a24      	ldr	r2, [pc, #144]	; (800ab90 <HAL_UART_MspInit+0xac>)
 800aafe:	4293      	cmp	r3, r2
 800ab00:	d023      	beq.n	800ab4a <HAL_UART_MspInit+0x66>
  /* USER CODE BEGIN USART6_MspInit 1 */

  /* USER CODE END USART6_MspInit 1 */
  }

}
 800ab02:	b00b      	add	sp, #44	; 0x2c
 800ab04:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_USART3_CLK_ENABLE();
 800ab08:	4b22      	ldr	r3, [pc, #136]	; (800ab94 <HAL_UART_MspInit+0xb0>)
 800ab0a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800ab0c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800ab10:	641a      	str	r2, [r3, #64]	; 0x40
 800ab12:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800ab14:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 800ab18:	9201      	str	r2, [sp, #4]
 800ab1a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800ab1c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ab1e:	f042 0208 	orr.w	r2, r2, #8
 800ab22:	631a      	str	r2, [r3, #48]	; 0x30
 800ab24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ab26:	f003 0308 	and.w	r3, r3, #8
 800ab2a:	9302      	str	r3, [sp, #8]
 800ab2c:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = STLK_RX_Pin|STLK_TX_Pin;
 800ab2e:	f44f 7340 	mov.w	r3, #768	; 0x300
 800ab32:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ab34:	2302      	movs	r3, #2
 800ab36:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ab38:	2303      	movs	r3, #3
 800ab3a:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 800ab3c:	2307      	movs	r3, #7
 800ab3e:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800ab40:	a905      	add	r1, sp, #20
 800ab42:	4815      	ldr	r0, [pc, #84]	; (800ab98 <HAL_UART_MspInit+0xb4>)
 800ab44:	f7f7 f9b8 	bl	8001eb8 <HAL_GPIO_Init>
 800ab48:	e7db      	b.n	800ab02 <HAL_UART_MspInit+0x1e>
    __HAL_RCC_USART6_CLK_ENABLE();
 800ab4a:	4b12      	ldr	r3, [pc, #72]	; (800ab94 <HAL_UART_MspInit+0xb0>)
 800ab4c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800ab4e:	f042 0220 	orr.w	r2, r2, #32
 800ab52:	645a      	str	r2, [r3, #68]	; 0x44
 800ab54:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800ab56:	f002 0220 	and.w	r2, r2, #32
 800ab5a:	9203      	str	r2, [sp, #12]
 800ab5c:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800ab5e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ab60:	f042 0204 	orr.w	r2, r2, #4
 800ab64:	631a      	str	r2, [r3, #48]	; 0x30
 800ab66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ab68:	f003 0304 	and.w	r3, r3, #4
 800ab6c:	9304      	str	r3, [sp, #16]
 800ab6e:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 800ab70:	23c0      	movs	r3, #192	; 0xc0
 800ab72:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ab74:	2302      	movs	r3, #2
 800ab76:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ab78:	2303      	movs	r3, #3
 800ab7a:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 800ab7c:	2308      	movs	r3, #8
 800ab7e:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800ab80:	a905      	add	r1, sp, #20
 800ab82:	4806      	ldr	r0, [pc, #24]	; (800ab9c <HAL_UART_MspInit+0xb8>)
 800ab84:	f7f7 f998 	bl	8001eb8 <HAL_GPIO_Init>
}
 800ab88:	e7bb      	b.n	800ab02 <HAL_UART_MspInit+0x1e>
 800ab8a:	bf00      	nop
 800ab8c:	40004800 	.word	0x40004800
 800ab90:	40011400 	.word	0x40011400
 800ab94:	40023800 	.word	0x40023800
 800ab98:	40020c00 	.word	0x40020c00
 800ab9c:	40020800 	.word	0x40020800

0800aba0 <HAL_PCD_MspInit>:
* This function configures the hardware resources used in this example
* @param hpcd: PCD handle pointer
* @retval None
*/
void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
 800aba0:	b530      	push	{r4, r5, lr}
 800aba2:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800aba4:	2300      	movs	r3, #0
 800aba6:	9303      	str	r3, [sp, #12]
 800aba8:	9304      	str	r3, [sp, #16]
 800abaa:	9305      	str	r3, [sp, #20]
 800abac:	9306      	str	r3, [sp, #24]
 800abae:	9307      	str	r3, [sp, #28]
  if(hpcd->Instance==USB_OTG_FS)
 800abb0:	6803      	ldr	r3, [r0, #0]
 800abb2:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800abb6:	d001      	beq.n	800abbc <HAL_PCD_MspInit+0x1c>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }

}
 800abb8:	b009      	add	sp, #36	; 0x24
 800abba:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800abbc:	4c1a      	ldr	r4, [pc, #104]	; (800ac28 <HAL_PCD_MspInit+0x88>)
 800abbe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800abc0:	f043 0301 	orr.w	r3, r3, #1
 800abc4:	6323      	str	r3, [r4, #48]	; 0x30
 800abc6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800abc8:	f003 0301 	and.w	r3, r3, #1
 800abcc:	9300      	str	r3, [sp, #0]
 800abce:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = USB_SOF_Pin|USB_ID_Pin|USB_DM_Pin|USB_DP_Pin;
 800abd0:	f44f 53e8 	mov.w	r3, #7424	; 0x1d00
 800abd4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800abd6:	2302      	movs	r3, #2
 800abd8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800abda:	2303      	movs	r3, #3
 800abdc:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 800abde:	230a      	movs	r3, #10
 800abe0:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800abe2:	4d12      	ldr	r5, [pc, #72]	; (800ac2c <HAL_PCD_MspInit+0x8c>)
 800abe4:	a903      	add	r1, sp, #12
 800abe6:	4628      	mov	r0, r5
 800abe8:	f7f7 f966 	bl	8001eb8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = USB_VBUS_Pin;
 800abec:	f44f 7300 	mov.w	r3, #512	; 0x200
 800abf0:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800abf2:	2300      	movs	r3, #0
 800abf4:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800abf6:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(USB_VBUS_GPIO_Port, &GPIO_InitStruct);
 800abf8:	a903      	add	r1, sp, #12
 800abfa:	4628      	mov	r0, r5
 800abfc:	f7f7 f95c 	bl	8001eb8 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800ac00:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800ac02:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ac06:	6363      	str	r3, [r4, #52]	; 0x34
 800ac08:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800ac0a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ac0e:	9301      	str	r3, [sp, #4]
 800ac10:	9b01      	ldr	r3, [sp, #4]
 800ac12:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800ac14:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800ac18:	6463      	str	r3, [r4, #68]	; 0x44
 800ac1a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800ac1c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800ac20:	9302      	str	r3, [sp, #8]
 800ac22:	9b02      	ldr	r3, [sp, #8]
}
 800ac24:	e7c8      	b.n	800abb8 <HAL_PCD_MspInit+0x18>
 800ac26:	bf00      	nop
 800ac28:	40023800 	.word	0x40023800
 800ac2c:	40020000 	.word	0x40020000

0800ac30 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800ac30:	b500      	push	{lr}
 800ac32:	b089      	sub	sp, #36	; 0x24
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority ,0); 
 800ac34:	2200      	movs	r2, #0
 800ac36:	4601      	mov	r1, r0
 800ac38:	2019      	movs	r0, #25
 800ac3a:	f7f6 fcb3 	bl	80015a4 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn); 
 800ac3e:	2019      	movs	r0, #25
 800ac40:	f7f6 fce2 	bl	8001608 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 800ac44:	4b14      	ldr	r3, [pc, #80]	; (800ac98 <HAL_InitTick+0x68>)
 800ac46:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800ac48:	f042 0201 	orr.w	r2, r2, #1
 800ac4c:	645a      	str	r2, [r3, #68]	; 0x44
 800ac4e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac50:	f003 0301 	and.w	r3, r3, #1
 800ac54:	9301      	str	r3, [sp, #4]
 800ac56:	9b01      	ldr	r3, [sp, #4]
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800ac58:	a902      	add	r1, sp, #8
 800ac5a:	a803      	add	r0, sp, #12
 800ac5c:	f7f7 fe3c 	bl	80028d8 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM1 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 800ac60:	f7f7 fe2a 	bl	80028b8 <HAL_RCC_GetPCLK2Freq>
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800ac64:	4b0d      	ldr	r3, [pc, #52]	; (800ac9c <HAL_InitTick+0x6c>)
 800ac66:	fba3 2300 	umull	r2, r3, r3, r0
 800ac6a:	0c9b      	lsrs	r3, r3, #18
 800ac6c:	3b01      	subs	r3, #1
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 800ac6e:	480c      	ldr	r0, [pc, #48]	; (800aca0 <HAL_InitTick+0x70>)
 800ac70:	4a0c      	ldr	r2, [pc, #48]	; (800aca4 <HAL_InitTick+0x74>)
 800ac72:	6002      	str	r2, [r0, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
 800ac74:	f240 32e7 	movw	r2, #999	; 0x3e7
 800ac78:	60c2      	str	r2, [r0, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 800ac7a:	6043      	str	r3, [r0, #4]
  htim1.Init.ClockDivision = 0;
 800ac7c:	2300      	movs	r3, #0
 800ac7e:	6103      	str	r3, [r0, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 800ac80:	6083      	str	r3, [r0, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 800ac82:	f7f8 fab9 	bl	80031f8 <HAL_TIM_Base_Init>
 800ac86:	b118      	cbz	r0, 800ac90 <HAL_InitTick+0x60>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
  }
  
  /* Return function status */
  return HAL_ERROR;
 800ac88:	2001      	movs	r0, #1
}
 800ac8a:	b009      	add	sp, #36	; 0x24
 800ac8c:	f85d fb04 	ldr.w	pc, [sp], #4
    return HAL_TIM_Base_Start_IT(&htim1);
 800ac90:	4803      	ldr	r0, [pc, #12]	; (800aca0 <HAL_InitTick+0x70>)
 800ac92:	f7f8 f943 	bl	8002f1c <HAL_TIM_Base_Start_IT>
 800ac96:	e7f8      	b.n	800ac8a <HAL_InitTick+0x5a>
 800ac98:	40023800 	.word	0x40023800
 800ac9c:	431bde83 	.word	0x431bde83
 800aca0:	2000b758 	.word	0x2000b758
 800aca4:	40010000 	.word	0x40010000

0800aca8 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 800aca8:	4770      	bx	lr

0800acaa <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800acaa:	e7fe      	b.n	800acaa <MemManage_Handler>

0800acac <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800acac:	e7fe      	b.n	800acac <BusFault_Handler>

0800acae <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800acae:	e7fe      	b.n	800acae <UsageFault_Handler>

0800acb0 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800acb0:	4770      	bx	lr
	...

0800acb4 <TIM1_UP_TIM10_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt and TIM10 global interrupt.
  */
void TIM1_UP_TIM10_IRQHandler(void)
{
 800acb4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 800acb6:	4802      	ldr	r0, [pc, #8]	; (800acc0 <TIM1_UP_TIM10_IRQHandler+0xc>)
 800acb8:	f7f8 f94a 	bl	8002f50 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 1 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 1 */
}
 800acbc:	bd08      	pop	{r3, pc}
 800acbe:	bf00      	nop
 800acc0:	2000b758 	.word	0x2000b758

0800acc4 <ETH_IRQHandler>:

/**
  * @brief This function handles Ethernet global interrupt.
  */
void ETH_IRQHandler(void)
{
 800acc4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN ETH_IRQn 0 */

  /* USER CODE END ETH_IRQn 0 */
  HAL_ETH_IRQHandler(&heth);
 800acc6:	4802      	ldr	r0, [pc, #8]	; (800acd0 <ETH_IRQHandler+0xc>)
 800acc8:	f7f6 feee 	bl	8001aa8 <HAL_ETH_IRQHandler>
  /* USER CODE BEGIN ETH_IRQn 1 */

  /* USER CODE END ETH_IRQn 1 */
}
 800accc:	bd08      	pop	{r3, pc}
 800acce:	bf00      	nop
 800acd0:	20009ef0 	.word	0x20009ef0

0800acd4 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 800acd4:	2001      	movs	r0, #1
 800acd6:	4770      	bx	lr

0800acd8 <_kill>:

int _kill(int pid, int sig)
{
 800acd8:	b508      	push	{r3, lr}
	errno = EINVAL;
 800acda:	f004 fb9b 	bl	800f414 <__errno>
 800acde:	2316      	movs	r3, #22
 800ace0:	6003      	str	r3, [r0, #0]
	return -1;
}
 800ace2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800ace6:	bd08      	pop	{r3, pc}

0800ace8 <_exit>:

void _exit (int status)
{
 800ace8:	b508      	push	{r3, lr}
	_kill(status, -1);
 800acea:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800acee:	f7ff fff3 	bl	800acd8 <_kill>
 800acf2:	e7fe      	b.n	800acf2 <_exit+0xa>

0800acf4 <_read>:
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800acf4:	b570      	push	{r4, r5, r6, lr}
 800acf6:	460d      	mov	r5, r1
 800acf8:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800acfa:	2400      	movs	r4, #0
 800acfc:	e004      	b.n	800ad08 <_read+0x14>
	{
		*ptr++ = __io_getchar();
 800acfe:	f3af 8000 	nop.w
 800ad02:	7028      	strb	r0, [r5, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800ad04:	3401      	adds	r4, #1
		*ptr++ = __io_getchar();
 800ad06:	3501      	adds	r5, #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800ad08:	42b4      	cmp	r4, r6
 800ad0a:	dbf8      	blt.n	800acfe <_read+0xa>
	}

return len;
}
 800ad0c:	4630      	mov	r0, r6
 800ad0e:	bd70      	pop	{r4, r5, r6, pc}

0800ad10 <_write>:

int _write(int file, char *ptr, int len)
{
 800ad10:	b570      	push	{r4, r5, r6, lr}
 800ad12:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800ad14:	2400      	movs	r4, #0
 800ad16:	e005      	b.n	800ad24 <_write+0x14>
	{
		__io_putchar(*ptr++);
 800ad18:	1c4d      	adds	r5, r1, #1
 800ad1a:	7808      	ldrb	r0, [r1, #0]
 800ad1c:	f7ff f888 	bl	8009e30 <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800ad20:	3401      	adds	r4, #1
		__io_putchar(*ptr++);
 800ad22:	4629      	mov	r1, r5
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800ad24:	42b4      	cmp	r4, r6
 800ad26:	dbf7      	blt.n	800ad18 <_write+0x8>
	}
	return len;
}
 800ad28:	4630      	mov	r0, r6
 800ad2a:	bd70      	pop	{r4, r5, r6, pc}

0800ad2c <_sbrk>:

caddr_t _sbrk(int incr)
{
 800ad2c:	b508      	push	{r3, lr}
 800ad2e:	4603      	mov	r3, r0
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 800ad30:	4a0b      	ldr	r2, [pc, #44]	; (800ad60 <_sbrk+0x34>)
 800ad32:	6812      	ldr	r2, [r2, #0]
 800ad34:	b142      	cbz	r2, 800ad48 <_sbrk+0x1c>
		heap_end = &end;

	prev_heap_end = heap_end;
 800ad36:	4a0a      	ldr	r2, [pc, #40]	; (800ad60 <_sbrk+0x34>)
 800ad38:	6810      	ldr	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 800ad3a:	4403      	add	r3, r0
 800ad3c:	466a      	mov	r2, sp
 800ad3e:	4293      	cmp	r3, r2
 800ad40:	d806      	bhi.n	800ad50 <_sbrk+0x24>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 800ad42:	4a07      	ldr	r2, [pc, #28]	; (800ad60 <_sbrk+0x34>)
 800ad44:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 800ad46:	bd08      	pop	{r3, pc}
		heap_end = &end;
 800ad48:	4a05      	ldr	r2, [pc, #20]	; (800ad60 <_sbrk+0x34>)
 800ad4a:	4906      	ldr	r1, [pc, #24]	; (800ad64 <_sbrk+0x38>)
 800ad4c:	6011      	str	r1, [r2, #0]
 800ad4e:	e7f2      	b.n	800ad36 <_sbrk+0xa>
		errno = ENOMEM;
 800ad50:	f004 fb60 	bl	800f414 <__errno>
 800ad54:	230c      	movs	r3, #12
 800ad56:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 800ad58:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800ad5c:	e7f3      	b.n	800ad46 <_sbrk+0x1a>
 800ad5e:	bf00      	nop
 800ad60:	2000593c 	.word	0x2000593c
 800ad64:	2000b7a0 	.word	0x2000b7a0

0800ad68 <_close>:

int _close(int file)
{
	return -1;
}
 800ad68:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800ad6c:	4770      	bx	lr

0800ad6e <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 800ad6e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800ad72:	604b      	str	r3, [r1, #4]
	return 0;
}
 800ad74:	2000      	movs	r0, #0
 800ad76:	4770      	bx	lr

0800ad78 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 800ad78:	2001      	movs	r0, #1
 800ad7a:	4770      	bx	lr

0800ad7c <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 800ad7c:	2000      	movs	r0, #0
 800ad7e:	4770      	bx	lr

0800ad80 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800ad80:	b410      	push	{r4}
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800ad82:	4a0f      	ldr	r2, [pc, #60]	; (800adc0 <SystemInit+0x40>)
 800ad84:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800ad88:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800ad8c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800ad90:	4b0c      	ldr	r3, [pc, #48]	; (800adc4 <SystemInit+0x44>)
 800ad92:	6819      	ldr	r1, [r3, #0]
 800ad94:	f041 0101 	orr.w	r1, r1, #1
 800ad98:	6019      	str	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800ad9a:	2000      	movs	r0, #0
 800ad9c:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800ad9e:	681c      	ldr	r4, [r3, #0]
 800ada0:	4909      	ldr	r1, [pc, #36]	; (800adc8 <SystemInit+0x48>)
 800ada2:	4021      	ands	r1, r4
 800ada4:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800ada6:	4909      	ldr	r1, [pc, #36]	; (800adcc <SystemInit+0x4c>)
 800ada8:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800adaa:	6819      	ldr	r1, [r3, #0]
 800adac:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 800adb0:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800adb2:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800adb4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800adb8:	6093      	str	r3, [r2, #8]
#endif
}
 800adba:	f85d 4b04 	ldr.w	r4, [sp], #4
 800adbe:	4770      	bx	lr
 800adc0:	e000ed00 	.word	0xe000ed00
 800adc4:	40023800 	.word	0x40023800
 800adc8:	fef6ffff 	.word	0xfef6ffff
 800adcc:	24003010 	.word	0x24003010

0800add0 <_ZN4rtps10ThreadPool12startThreadsEv>:
    if(sys_sem_valid(&m_writerNotificationSem)){
        sys_sem_free(&m_writerNotificationSem);
    }
}

bool ThreadPool::startThreads(){
 800add0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800add2:	b083      	sub	sp, #12
    if(m_running){
 800add4:	7a04      	ldrb	r4, [r0, #8]
 800add6:	b114      	cbz	r4, 800adde <_ZN4rtps10ThreadPool12startThreadsEv+0xe>
    for(auto &thread : m_readers){
        // TODO ID, err check, waitOnStop
        thread = sys_thread_new("ReaderThread", readerThreadFunction, this, Config::THREAD_POOL_READER_STACKSIZE, Config::THREAD_POOL_READER_PRIO);
    }
    return true;
}
 800add8:	4620      	mov	r0, r4
 800adda:	b003      	add	sp, #12
 800addc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800adde:	4605      	mov	r5, r0
    if(!sys_sem_valid(&m_readerNotificationSem) || !sys_sem_valid(&m_writerNotificationSem)){
 800ade0:	f100 0614 	add.w	r6, r0, #20
 800ade4:	4630      	mov	r0, r6
 800ade6:	f7fe f925 	bl	8009034 <sys_sem_valid>
 800adea:	2800      	cmp	r0, #0
 800adec:	d0f4      	beq.n	800add8 <_ZN4rtps10ThreadPool12startThreadsEv+0x8>
 800adee:	f105 0018 	add.w	r0, r5, #24
 800adf2:	f7fe f91f 	bl	8009034 <sys_sem_valid>
 800adf6:	2800      	cmp	r0, #0
 800adf8:	d0ee      	beq.n	800add8 <_ZN4rtps10ThreadPool12startThreadsEv+0x8>
    m_running = true;
 800adfa:	2301      	movs	r3, #1
 800adfc:	722b      	strb	r3, [r5, #8]
 	           : _AT_Type::_S_ref(_M_elems, 0);
      }

      _GLIBCXX17_CONSTEXPR pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
 800adfe:	f105 040c 	add.w	r4, r5, #12
      { return iterator(data() + _Nm); }
 800ae02:	f105 0710 	add.w	r7, r5, #16
    for(auto &thread : m_writers){
 800ae06:	42bc      	cmp	r4, r7
 800ae08:	d00b      	beq.n	800ae22 <_ZN4rtps10ThreadPool12startThreadsEv+0x52>
        thread = sys_thread_new("WriterThread", writerThreadFunction, this, Config::THREAD_POOL_WRITER_STACKSIZE, Config::THREAD_POOL_WRITER_PRIO);
 800ae0a:	2303      	movs	r3, #3
 800ae0c:	9300      	str	r3, [sp, #0]
 800ae0e:	f240 434c 	movw	r3, #1100	; 0x44c
 800ae12:	462a      	mov	r2, r5
 800ae14:	490c      	ldr	r1, [pc, #48]	; (800ae48 <_ZN4rtps10ThreadPool12startThreadsEv+0x78>)
 800ae16:	480d      	ldr	r0, [pc, #52]	; (800ae4c <_ZN4rtps10ThreadPool12startThreadsEv+0x7c>)
 800ae18:	f7fe f940 	bl	800909c <sys_thread_new>
 800ae1c:	f844 0b04 	str.w	r0, [r4], #4
    for(auto &thread : m_writers){
 800ae20:	e7f1      	b.n	800ae06 <_ZN4rtps10ThreadPool12startThreadsEv+0x36>
      { return _AT_Type::_S_ptr(_M_elems); }
 800ae22:	f105 0410 	add.w	r4, r5, #16
    for(auto &thread : m_readers){
 800ae26:	42a6      	cmp	r6, r4
 800ae28:	d00b      	beq.n	800ae42 <_ZN4rtps10ThreadPool12startThreadsEv+0x72>
        thread = sys_thread_new("ReaderThread", readerThreadFunction, this, Config::THREAD_POOL_READER_STACKSIZE, Config::THREAD_POOL_READER_PRIO);
 800ae2a:	2303      	movs	r3, #3
 800ae2c:	9300      	str	r3, [sp, #0]
 800ae2e:	f44f 63c8 	mov.w	r3, #1600	; 0x640
 800ae32:	462a      	mov	r2, r5
 800ae34:	4906      	ldr	r1, [pc, #24]	; (800ae50 <_ZN4rtps10ThreadPool12startThreadsEv+0x80>)
 800ae36:	4807      	ldr	r0, [pc, #28]	; (800ae54 <_ZN4rtps10ThreadPool12startThreadsEv+0x84>)
 800ae38:	f7fe f930 	bl	800909c <sys_thread_new>
 800ae3c:	f844 0b04 	str.w	r0, [r4], #4
    for(auto &thread : m_readers){
 800ae40:	e7f1      	b.n	800ae26 <_ZN4rtps10ThreadPool12startThreadsEv+0x56>
    return true;
 800ae42:	2401      	movs	r4, #1
 800ae44:	e7c8      	b.n	800add8 <_ZN4rtps10ThreadPool12startThreadsEv+0x8>
 800ae46:	bf00      	nop
 800ae48:	0800b1bf 	.word	0x0800b1bf
 800ae4c:	08011c34 	.word	0x08011c34
 800ae50:	0800b289 	.word	0x0800b289
 800ae54:	08011c44 	.word	0x08011c44

0800ae58 <_ZN4rtps10ThreadPool11stopThreadsEv>:

void ThreadPool::stopThreads() {
 800ae58:	b508      	push	{r3, lr}
    m_running = false;
 800ae5a:	2300      	movs	r3, #0
 800ae5c:	7203      	strb	r3, [r0, #8]
    // TODO make sure they have finished. Seems to be sufficient for tests.
    // Not sufficient if threads shall actually be stopped during runtime.
    sys_msleep(10);
 800ae5e:	200a      	movs	r0, #10
 800ae60:	f7fb fe86 	bl	8006b70 <sys_msleep>
}
 800ae64:	bd08      	pop	{r3, pc}

0800ae66 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EED1Ev>:
            return true;
        }
    }

    template<typename T, uint16_t SIZE>
    ThreadSafeCircularBuffer<T, SIZE>::~ThreadSafeCircularBuffer(){
 800ae66:	b510      	push	{r4, lr}
 800ae68:	4604      	mov	r4, r0
        if (m_initialized) {
 800ae6a:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 800ae6e:	b90b      	cbnz	r3, 800ae74 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EED1Ev+0xe>
            sys_mutex_free(&m_mutex);
        }
    }
 800ae70:	4620      	mov	r0, r4
 800ae72:	bd10      	pop	{r4, pc}
            sys_mutex_free(&m_mutex);
 800ae74:	3030      	adds	r0, #48	; 0x30
 800ae76:	f7fe f900 	bl	800907a <sys_mutex_free>
 800ae7a:	e7f9      	b.n	800ae70 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EED1Ev+0xa>

0800ae7c <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev>:
    ThreadSafeCircularBuffer<T, SIZE>::~ThreadSafeCircularBuffer(){
 800ae7c:	b570      	push	{r4, r5, r6, lr}
 800ae7e:	4605      	mov	r5, r0
        if (m_initialized) {
 800ae80:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
 800ae84:	b95b      	cbnz	r3, 800ae9e <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev+0x22>
    struct array
 800ae86:	462e      	mov	r6, r5
 800ae88:	b16d      	cbz	r5, 800aea6 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev+0x2a>
 800ae8a:	f105 04dc 	add.w	r4, r5, #220	; 0xdc
 800ae8e:	42a6      	cmp	r6, r4
 800ae90:	d009      	beq.n	800aea6 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev+0x2a>
 800ae92:	3c14      	subs	r4, #20
 800ae94:	f104 000c 	add.w	r0, r4, #12
 800ae98:	f003 faa3 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800ae9c:	e7f7      	b.n	800ae8e <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev+0x12>
            sys_mutex_free(&m_mutex);
 800ae9e:	30e0      	adds	r0, #224	; 0xe0
 800aea0:	f7fe f8eb 	bl	800907a <sys_mutex_free>
 800aea4:	e7ef      	b.n	800ae86 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev+0xa>
    }
 800aea6:	4628      	mov	r0, r5
 800aea8:	bd70      	pop	{r4, r5, r6, pc}

0800aeaa <_ZN4rtps10ThreadPoolD1Ev>:
ThreadPool::~ThreadPool(){
 800aeaa:	b538      	push	{r3, r4, r5, lr}
 800aeac:	4604      	mov	r4, r0
    if(m_running){
 800aeae:	7a03      	ldrb	r3, [r0, #8]
 800aeb0:	b9ab      	cbnz	r3, 800aede <_ZN4rtps10ThreadPoolD1Ev+0x34>
    if(sys_sem_valid(&m_readerNotificationSem)){
 800aeb2:	f104 0514 	add.w	r5, r4, #20
 800aeb6:	4628      	mov	r0, r5
 800aeb8:	f7fe f8bc 	bl	8009034 <sys_sem_valid>
 800aebc:	b9b0      	cbnz	r0, 800aeec <_ZN4rtps10ThreadPoolD1Ev+0x42>
    if(sys_sem_valid(&m_writerNotificationSem)){
 800aebe:	f104 0518 	add.w	r5, r4, #24
 800aec2:	4628      	mov	r0, r5
 800aec4:	f7fe f8b6 	bl	8009034 <sys_sem_valid>
 800aec8:	b9a0      	cbnz	r0, 800aef4 <_ZN4rtps10ThreadPoolD1Ev+0x4a>
ThreadPool::~ThreadPool(){
 800aeca:	f104 0054 	add.w	r0, r4, #84	; 0x54
 800aece:	f7ff ffd5 	bl	800ae7c <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev>
 800aed2:	f104 001c 	add.w	r0, r4, #28
 800aed6:	f7ff ffc6 	bl	800ae66 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EED1Ev>
}
 800aeda:	4620      	mov	r0, r4
 800aedc:	bd38      	pop	{r3, r4, r5, pc}
        stopThreads();
 800aede:	f7ff ffbb 	bl	800ae58 <_ZN4rtps10ThreadPool11stopThreadsEv>
        sys_msleep(500);
 800aee2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800aee6:	f7fb fe43 	bl	8006b70 <sys_msleep>
 800aeea:	e7e2      	b.n	800aeb2 <_ZN4rtps10ThreadPoolD1Ev+0x8>
        sys_sem_free(&m_readerNotificationSem);
 800aeec:	4628      	mov	r0, r5
 800aeee:	f7fe f89c 	bl	800902a <sys_sem_free>
 800aef2:	e7e4      	b.n	800aebe <_ZN4rtps10ThreadPoolD1Ev+0x14>
        sys_sem_free(&m_writerNotificationSem);
 800aef4:	4628      	mov	r0, r5
 800aef6:	f7fe f898 	bl	800902a <sys_sem_free>
 800aefa:	e7e6      	b.n	800aeca <_ZN4rtps10ThreadPoolD1Ev+0x20>

0800aefc <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE4initEv>:
    bool ThreadSafeCircularBuffer<T, SIZE>::init(){
 800aefc:	b538      	push	{r3, r4, r5, lr}
        if (m_initialized) {
 800aefe:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 800af02:	b10c      	cbz	r4, 800af08 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE4initEv+0xc>
    }
 800af04:	4620      	mov	r0, r4
 800af06:	bd38      	pop	{r3, r4, r5, pc}
 800af08:	4605      	mov	r5, r0
        if (sys_mutex_new(&m_mutex) != ERR_OK) {
 800af0a:	3030      	adds	r0, #48	; 0x30
 800af0c:	f7fe f8a4 	bl	8009058 <sys_mutex_new>
 800af10:	2800      	cmp	r0, #0
 800af12:	d1f7      	bne.n	800af04 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE4initEv+0x8>
            m_initialized = true;
 800af14:	2401      	movs	r4, #1
 800af16:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
            return true;
 800af1a:	e7f3      	b.n	800af04 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE4initEv+0x8>

0800af1c <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE4initEv>:
    bool ThreadSafeCircularBuffer<T, SIZE>::init(){
 800af1c:	b538      	push	{r3, r4, r5, lr}
        if (m_initialized) {
 800af1e:	f890 40e4 	ldrb.w	r4, [r0, #228]	; 0xe4
 800af22:	b10c      	cbz	r4, 800af28 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE4initEv+0xc>
    }
 800af24:	4620      	mov	r0, r4
 800af26:	bd38      	pop	{r3, r4, r5, pc}
 800af28:	4605      	mov	r5, r0
        if (sys_mutex_new(&m_mutex) != ERR_OK) {
 800af2a:	30e0      	adds	r0, #224	; 0xe0
 800af2c:	f7fe f894 	bl	8009058 <sys_mutex_new>
 800af30:	2800      	cmp	r0, #0
 800af32:	d1f7      	bne.n	800af24 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE4initEv+0x8>
            m_initialized = true;
 800af34:	2401      	movs	r4, #1
 800af36:	f885 40e4 	strb.w	r4, [r5, #228]	; 0xe4
            return true;
 800af3a:	e7f3      	b.n	800af24 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE4initEv+0x8>

0800af3c <_ZN4rtps10ThreadPoolC1EPFvPvRKNS_10PacketInfoEES1_>:
ThreadPool::ThreadPool(receiveJumppad_fp receiveCallback, void* callee)
 800af3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800af3e:	4604      	mov	r4, r0
    : m_receiveJumppad(receiveCallback), m_callee(callee){
 800af40:	6001      	str	r1, [r0, #0]
 800af42:	6042      	str	r2, [r0, #4]
 800af44:	2500      	movs	r5, #0
 800af46:	7205      	strb	r5, [r0, #8]
 800af48:	f100 061c 	add.w	r6, r0, #28
#include <limits>

namespace rtps {

    template<typename T, uint16_t SIZE>
    class ThreadSafeCircularBuffer {
 800af4c:	222c      	movs	r2, #44	; 0x2c
 800af4e:	4629      	mov	r1, r5
 800af50:	4630      	mov	r0, r6
 800af52:	f004 faa3 	bl	800f49c <memset>
 800af56:	f8a4 5048 	strh.w	r5, [r4, #72]	; 0x48
 800af5a:	f8a4 504a 	strh.w	r5, [r4, #74]	; 0x4a
 800af5e:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
 800af62:	f104 0754 	add.w	r7, r4, #84	; 0x54
 800af66:	22dc      	movs	r2, #220	; 0xdc
 800af68:	4629      	mov	r1, r5
 800af6a:	4638      	mov	r0, r7
 800af6c:	f004 fa96 	bl	800f49c <memset>
 800af70:	f8a4 5130 	strh.w	r5, [r4, #304]	; 0x130
 800af74:	f8a4 5132 	strh.w	r5, [r4, #306]	; 0x132
 800af78:	f884 5138 	strb.w	r5, [r4, #312]	; 0x138
    if(!m_queueOutgoing.init() || !m_queueIncoming.init()){
 800af7c:	4630      	mov	r0, r6
 800af7e:	f7ff ffbd 	bl	800aefc <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE4initEv>
 800af82:	b908      	cbnz	r0, 800af88 <_ZN4rtps10ThreadPoolC1EPFvPvRKNS_10PacketInfoEES1_+0x4c>
}
 800af84:	4620      	mov	r0, r4
 800af86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(!m_queueOutgoing.init() || !m_queueIncoming.init()){
 800af88:	4638      	mov	r0, r7
 800af8a:	f7ff ffc7 	bl	800af1c <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE4initEv>
 800af8e:	2800      	cmp	r0, #0
 800af90:	d0f8      	beq.n	800af84 <_ZN4rtps10ThreadPoolC1EPFvPvRKNS_10PacketInfoEES1_+0x48>
    err_t inputErr = sys_sem_new(&m_readerNotificationSem, 0);
 800af92:	4629      	mov	r1, r5
 800af94:	f104 0014 	add.w	r0, r4, #20
 800af98:	f7fe f80b 	bl	8008fb2 <sys_sem_new>
    err_t outputErr = sys_sem_new(&m_writerNotificationSem, 0);
 800af9c:	4629      	mov	r1, r5
 800af9e:	f104 0018 	add.w	r0, r4, #24
 800afa2:	f7fe f806 	bl	8008fb2 <sys_sem_new>
 800afa6:	e7ed      	b.n	800af84 <_ZN4rtps10ThreadPoolC1EPFvPvRKNS_10PacketInfoEES1_+0x48>
    : m_receiveJumppad(receiveCallback), m_callee(callee){
 800afa8:	4638      	mov	r0, r7
 800afaa:	f7ff ff67 	bl	800ae7c <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EED1Ev>
 800afae:	4630      	mov	r0, r6
 800afb0:	f7ff ff59 	bl	800ae66 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EED1Ev>
 800afb4:	f003 fd11 	bl	800e9da <__cxa_end_cleanup>

0800afb8 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_>:


    template<typename T, uint16_t SIZE>
    bool ThreadSafeCircularBuffer<T, SIZE>::moveElementIntoBuffer(T&& elem) {
 800afb8:	b570      	push	{r4, r5, r6, lr}
 800afba:	4604      	mov	r4, r0
 800afbc:	460e      	mov	r6, r1
        Lock lock(m_mutex);
 800afbe:	f100 0530 	add.w	r5, r0, #48	; 0x30
            sys_mutex_lock(&m_mutex);
 800afc2:	4628      	mov	r0, r5
 800afc4:	f7fe f85e 	bl	8009084 <sys_mutex_lock>
        m_head = m_tail;
    }

    template<typename T, uint16_t SIZE>
    bool ThreadSafeCircularBuffer<T,SIZE>::isFull(){
        auto it = m_head;
 800afc8:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
        return it == m_tail;
    }

    template<typename T, uint16_t SIZE>
    inline void ThreadSafeCircularBuffer<T,SIZE>::incrementIterator(uint16_t& iterator) {
        ++iterator;
 800afca:	1c53      	adds	r3, r2, #1
 800afcc:	b29b      	uxth	r3, r3
        if (iterator >= m_buffer.size()) {
 800afce:	2b0a      	cmp	r3, #10
 800afd0:	d900      	bls.n	800afd4 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x1c>
            iterator = 0;
 800afd2:	2300      	movs	r3, #0
        return it == m_tail;
 800afd4:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
        if (!isFull()){
 800afd6:	4299      	cmp	r1, r3
 800afd8:	d01d      	beq.n	800b016 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x5e>
            m_buffer[m_head] = std::move(elem);
 800afda:	6833      	ldr	r3, [r6, #0]
 800afdc:	f844 3022 	str.w	r3, [r4, r2, lsl #2]
        ++iterator;
 800afe0:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800afe2:	3301      	adds	r3, #1
 800afe4:	b29b      	uxth	r3, r3
 800afe6:	85a3      	strh	r3, [r4, #44]	; 0x2c
        if (iterator >= m_buffer.size()) {
 800afe8:	2b0a      	cmp	r3, #10
 800afea:	d901      	bls.n	800aff0 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x38>
            iterator = 0;
 800afec:	2300      	movs	r3, #0
 800afee:	85a3      	strh	r3, [r4, #44]	; 0x2c
    }

    template<typename T, uint16_t SIZE>
    inline void ThreadSafeCircularBuffer<T,SIZE>::incrementHead() {
        incrementIterator(m_head);
        if (m_head == m_tail) {
 800aff0:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800aff2:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800aff4:	429a      	cmp	r2, r3
 800aff6:	d005      	beq.n	800b004 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x4c>
            return true;
 800aff8:	2401      	movs	r4, #1
            sys_mutex_unlock(&m_mutex);
 800affa:	4628      	mov	r0, r5
 800affc:	f7fe f849 	bl	8009092 <sys_mutex_unlock>
    }
 800b000:	4620      	mov	r0, r4
 800b002:	bd70      	pop	{r4, r5, r6, pc}
        ++iterator;
 800b004:	3301      	adds	r3, #1
 800b006:	b29b      	uxth	r3, r3
 800b008:	85e3      	strh	r3, [r4, #46]	; 0x2e
        if (iterator >= m_buffer.size()) {
 800b00a:	2b0a      	cmp	r3, #10
 800b00c:	d905      	bls.n	800b01a <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x62>
            iterator = 0;
 800b00e:	2300      	movs	r3, #0
 800b010:	85e3      	strh	r3, [r4, #46]	; 0x2e
            return true;
 800b012:	2401      	movs	r4, #1
 800b014:	e7f1      	b.n	800affa <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x42>
            return false;
 800b016:	2400      	movs	r4, #0
 800b018:	e7ef      	b.n	800affa <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x42>
            return true;
 800b01a:	2401      	movs	r4, #1
 800b01c:	e7ed      	b.n	800affa <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_+0x42>

0800b01e <_ZN4rtps10ThreadPool11addWorkloadEPNS_6WriterE>:
void ThreadPool::clearQueues(){
    m_queueOutgoing.clear();
    m_queueIncoming.clear();
}

bool ThreadPool::addWorkload(Writer* workload){
 800b01e:	b530      	push	{r4, r5, lr}
 800b020:	b083      	sub	sp, #12
 800b022:	4604      	mov	r4, r0
 800b024:	ab02      	add	r3, sp, #8
 800b026:	f843 1d04 	str.w	r1, [r3, #-4]!
    bool res = m_queueOutgoing.moveElementIntoBuffer(std::move(workload));
 800b02a:	4619      	mov	r1, r3
 800b02c:	301c      	adds	r0, #28
 800b02e:	f7ff ffc3 	bl	800afb8 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE21moveElementIntoBufferEOS2_>
    if(res) {
 800b032:	4605      	mov	r5, r0
 800b034:	b910      	cbnz	r0, 800b03c <_ZN4rtps10ThreadPool11addWorkloadEPNS_6WriterE+0x1e>
        sys_sem_signal(&m_writerNotificationSem);
    }

    return res;
}
 800b036:	4628      	mov	r0, r5
 800b038:	b003      	add	sp, #12
 800b03a:	bd30      	pop	{r4, r5, pc}
        sys_sem_signal(&m_writerNotificationSem);
 800b03c:	f104 0018 	add.w	r0, r4, #24
 800b040:	f7fd ffee 	bl	8009020 <sys_sem_signal>
 800b044:	e7f7      	b.n	800b036 <_ZN4rtps10ThreadPool11addWorkloadEPNS_6WriterE+0x18>

0800b046 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_>:
    bool ThreadSafeCircularBuffer<T, SIZE>::moveElementIntoBuffer(T&& elem) {
 800b046:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b048:	4604      	mov	r4, r0
 800b04a:	460e      	mov	r6, r1
        Lock lock(m_mutex);
 800b04c:	f100 05e0 	add.w	r5, r0, #224	; 0xe0
            sys_mutex_lock(&m_mutex);
 800b050:	4628      	mov	r0, r5
 800b052:	f7fe f817 	bl	8009084 <sys_mutex_lock>
        auto it = m_head;
 800b056:	f8b4 20dc 	ldrh.w	r2, [r4, #220]	; 0xdc
        ++iterator;
 800b05a:	1c53      	adds	r3, r2, #1
 800b05c:	b29b      	uxth	r3, r3
        if (iterator >= m_buffer.size()) {
 800b05e:	2b0a      	cmp	r3, #10
 800b060:	d900      	bls.n	800b064 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x1e>
            iterator = 0;
 800b062:	2300      	movs	r3, #0
        return it == m_tail;
 800b064:	f8b4 10de 	ldrh.w	r1, [r4, #222]	; 0xde
        if (!isFull()){
 800b068:	4299      	cmp	r1, r3
 800b06a:	d030      	beq.n	800b0ce <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x88>
            this->srcPort = other.srcPort;
 800b06c:	8837      	ldrh	r7, [r6, #0]
 800b06e:	0093      	lsls	r3, r2, #2
 800b070:	1898      	adds	r0, r3, r2
 800b072:	0081      	lsls	r1, r0, #2
 800b074:	1860      	adds	r0, r4, r1
 800b076:	5267      	strh	r7, [r4, r1]
            this->destPort = other.destPort;
 800b078:	8931      	ldrh	r1, [r6, #8]
 800b07a:	8101      	strh	r1, [r0, #8]
            this->destAddr = other.destAddr;
 800b07c:	6871      	ldr	r1, [r6, #4]
 800b07e:	6041      	str	r1, [r0, #4]
            return *this;
        }

        PacketInfo& operator=(PacketInfo&& other) noexcept{
            copyTriviallyCopyable(other);
            this->buffer = std::move(other.buffer);
 800b080:	441a      	add	r2, r3
 800b082:	0090      	lsls	r0, r2, #2
 800b084:	3008      	adds	r0, #8
 800b086:	4420      	add	r0, r4
 800b088:	f106 010c 	add.w	r1, r6, #12
 800b08c:	3004      	adds	r0, #4
 800b08e:	f003 f99c 	bl	800e3ca <_ZN4rtps11PBufWrapperaSEOS0_>
        ++iterator;
 800b092:	f8b4 30dc 	ldrh.w	r3, [r4, #220]	; 0xdc
 800b096:	3301      	adds	r3, #1
 800b098:	b29b      	uxth	r3, r3
 800b09a:	f8a4 30dc 	strh.w	r3, [r4, #220]	; 0xdc
        if (iterator >= m_buffer.size()) {
 800b09e:	2b0a      	cmp	r3, #10
 800b0a0:	d902      	bls.n	800b0a8 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x62>
            iterator = 0;
 800b0a2:	2300      	movs	r3, #0
 800b0a4:	f8a4 30dc 	strh.w	r3, [r4, #220]	; 0xdc
        if (m_head == m_tail) {
 800b0a8:	f8b4 20dc 	ldrh.w	r2, [r4, #220]	; 0xdc
 800b0ac:	f8b4 30de 	ldrh.w	r3, [r4, #222]	; 0xde
 800b0b0:	429a      	cmp	r2, r3
 800b0b2:	d001      	beq.n	800b0b8 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x72>
            return true;
 800b0b4:	2401      	movs	r4, #1
 800b0b6:	e00b      	b.n	800b0d0 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x8a>
        ++iterator;
 800b0b8:	3301      	adds	r3, #1
 800b0ba:	b29b      	uxth	r3, r3
 800b0bc:	f8a4 30de 	strh.w	r3, [r4, #222]	; 0xde
        if (iterator >= m_buffer.size()) {
 800b0c0:	2b0a      	cmp	r3, #10
 800b0c2:	d90a      	bls.n	800b0da <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x94>
            iterator = 0;
 800b0c4:	2300      	movs	r3, #0
 800b0c6:	f8a4 30de 	strh.w	r3, [r4, #222]	; 0xde
            return true;
 800b0ca:	2401      	movs	r4, #1
 800b0cc:	e000      	b.n	800b0d0 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x8a>
            return false;
 800b0ce:	2400      	movs	r4, #0
            sys_mutex_unlock(&m_mutex);
 800b0d0:	4628      	mov	r0, r5
 800b0d2:	f7fd ffde 	bl	8009092 <sys_mutex_unlock>
    }
 800b0d6:	4620      	mov	r0, r4
 800b0d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return true;
 800b0da:	2401      	movs	r4, #1
 800b0dc:	e7f8      	b.n	800b0d0 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_+0x8a>

0800b0de <_ZN4rtps10ThreadPool12addNewPacketEONS_10PacketInfoE>:

bool ThreadPool::addNewPacket(PacketInfo&& packet){
 800b0de:	b538      	push	{r3, r4, r5, lr}
 800b0e0:	4604      	mov	r4, r0
    bool res = m_queueIncoming.moveElementIntoBuffer(std::move(packet));
 800b0e2:	3054      	adds	r0, #84	; 0x54
 800b0e4:	f7ff ffaf 	bl	800b046 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE21moveElementIntoBufferEOS1_>
    if(res){
 800b0e8:	4605      	mov	r5, r0
 800b0ea:	b908      	cbnz	r0, 800b0f0 <_ZN4rtps10ThreadPool12addNewPacketEONS_10PacketInfoE+0x12>
        sys_sem_signal(&m_readerNotificationSem);
    }
    return res;
}
 800b0ec:	4628      	mov	r0, r5
 800b0ee:	bd38      	pop	{r3, r4, r5, pc}
        sys_sem_signal(&m_readerNotificationSem);
 800b0f0:	f104 0014 	add.w	r0, r4, #20
 800b0f4:	f7fd ff94 	bl	8009020 <sys_sem_signal>
 800b0f8:	e7f8      	b.n	800b0ec <_ZN4rtps10ThreadPool12addNewPacketEONS_10PacketInfoE+0xe>

0800b0fa <_ZN4rtps10ThreadPool12readCallbackEPvP7udp_pcbP4pbufPK8ip4_addrt>:

        workload->progress();
    }
}

void ThreadPool::readCallback(void* args, udp_pcb* target, pbuf* pbuf, const ip_addr_t* /*addr*/, Ip4Port_t port) {
 800b0fa:	b510      	push	{r4, lr}
 800b0fc:	b088      	sub	sp, #32
 800b0fe:	4604      	mov	r4, r0
 800b100:	2300      	movs	r3, #0
 800b102:	9304      	str	r3, [sp, #16]
 800b104:	f8ad 3014 	strh.w	r3, [sp, #20]
    auto& pool = *static_cast<ThreadPool*>(args);

    PacketInfo packet;
    packet.destAddr = {0}; // not relevant
 800b108:	9302      	str	r3, [sp, #8]
    packet.destPort = target->local_port;
 800b10a:	8a4b      	ldrh	r3, [r1, #18]
 800b10c:	f8ad 300c 	strh.w	r3, [sp, #12]
    packet.srcPort = port;
 800b110:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
 800b114:	f8ad 3004 	strh.w	r3, [sp, #4]
    packet.buffer = PBufWrapper{pbuf};
 800b118:	4611      	mov	r1, r2
 800b11a:	a806      	add	r0, sp, #24
 800b11c:	f003 f92e 	bl	800e37c <_ZN4rtps11PBufWrapperC1EP4pbuf>
 800b120:	a906      	add	r1, sp, #24
 800b122:	a804      	add	r0, sp, #16
 800b124:	f003 f951 	bl	800e3ca <_ZN4rtps11PBufWrapperaSEOS0_>
 800b128:	a806      	add	r0, sp, #24
 800b12a:	f003 f95a 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
    if(!pool.addNewPacket(std::move(packet))){
 800b12e:	a901      	add	r1, sp, #4
 800b130:	4620      	mov	r0, r4
 800b132:	f7ff ffd4 	bl	800b0de <_ZN4rtps10ThreadPool12addNewPacketEONS_10PacketInfoE>
        ~PacketInfo() = default;
 800b136:	a804      	add	r0, sp, #16
 800b138:	f003 f953 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
#if THREAD_POOL_VERBOSE
        printf("ThreadPool: dropped packet\n");
#endif
    }
}
 800b13c:	b008      	add	sp, #32
 800b13e:	bd10      	pop	{r4, pc}
 800b140:	a804      	add	r0, sp, #16
 800b142:	f003 f94e 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800b146:	f003 fc48 	bl	800e9da <__cxa_end_cleanup>

0800b14a <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE13moveFirstIntoERS2_>:
    bool ThreadSafeCircularBuffer<T, SIZE>::moveFirstInto(T& hull) {
 800b14a:	b570      	push	{r4, r5, r6, lr}
 800b14c:	4604      	mov	r4, r0
 800b14e:	460e      	mov	r6, r1
        Lock lock(m_mutex);
 800b150:	f100 0530 	add.w	r5, r0, #48	; 0x30
            sys_mutex_lock(&m_mutex);
 800b154:	4628      	mov	r0, r5
 800b156:	f7fd ff95 	bl	8009084 <sys_mutex_lock>
        if (m_head != m_tail) {
 800b15a:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800b15c:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800b15e:	429a      	cmp	r2, r3
 800b160:	d010      	beq.n	800b184 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE13moveFirstIntoERS2_+0x3a>
            hull = std::move(m_buffer[m_tail]);
 800b162:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 800b166:	6033      	str	r3, [r6, #0]
        ++iterator;
 800b168:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800b16a:	3301      	adds	r3, #1
 800b16c:	b29b      	uxth	r3, r3
 800b16e:	85e3      	strh	r3, [r4, #46]	; 0x2e
        if (iterator >= m_buffer.size()) {
 800b170:	2b0a      	cmp	r3, #10
 800b172:	d909      	bls.n	800b188 <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE13moveFirstIntoERS2_+0x3e>
            iterator = 0;
 800b174:	2300      	movs	r3, #0
 800b176:	85e3      	strh	r3, [r4, #46]	; 0x2e
            return true;
 800b178:	2401      	movs	r4, #1
            sys_mutex_unlock(&m_mutex);
 800b17a:	4628      	mov	r0, r5
 800b17c:	f7fd ff89 	bl	8009092 <sys_mutex_unlock>
    }
 800b180:	4620      	mov	r0, r4
 800b182:	bd70      	pop	{r4, r5, r6, pc}
            return false;
 800b184:	2400      	movs	r4, #0
 800b186:	e7f8      	b.n	800b17a <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE13moveFirstIntoERS2_+0x30>
            return true;
 800b188:	2401      	movs	r4, #1
 800b18a:	e7f6      	b.n	800b17a <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE13moveFirstIntoERS2_+0x30>

0800b18c <_ZN4rtps10ThreadPool12doWriterWorkEv>:
void ThreadPool::doWriterWork(){
 800b18c:	b510      	push	{r4, lr}
 800b18e:	b082      	sub	sp, #8
 800b190:	4604      	mov	r4, r0
 800b192:	e004      	b.n	800b19e <_ZN4rtps10ThreadPool12doWriterWorkEv+0x12>
            sys_sem_wait(&m_writerNotificationSem);
 800b194:	2100      	movs	r1, #0
 800b196:	f104 0018 	add.w	r0, r4, #24
 800b19a:	f7fd ff23 	bl	8008fe4 <sys_arch_sem_wait>
    while(m_running){
 800b19e:	7a23      	ldrb	r3, [r4, #8]
 800b1a0:	b15b      	cbz	r3, 800b1ba <_ZN4rtps10ThreadPool12doWriterWorkEv+0x2e>
        auto isWorkToDo = m_queueOutgoing.moveFirstInto(workload);
 800b1a2:	a901      	add	r1, sp, #4
 800b1a4:	f104 001c 	add.w	r0, r4, #28
 800b1a8:	f7ff ffcf 	bl	800b14a <_ZN4rtps24ThreadSafeCircularBufferIPNS_6WriterELt10EE13moveFirstIntoERS2_>
        if(!isWorkToDo){
 800b1ac:	2800      	cmp	r0, #0
 800b1ae:	d0f1      	beq.n	800b194 <_ZN4rtps10ThreadPool12doWriterWorkEv+0x8>
        workload->progress();
 800b1b0:	9801      	ldr	r0, [sp, #4]
 800b1b2:	6803      	ldr	r3, [r0, #0]
 800b1b4:	689b      	ldr	r3, [r3, #8]
 800b1b6:	4798      	blx	r3
 800b1b8:	e7f1      	b.n	800b19e <_ZN4rtps10ThreadPool12doWriterWorkEv+0x12>
}
 800b1ba:	b002      	add	sp, #8
 800b1bc:	bd10      	pop	{r4, pc}

0800b1be <_ZN4rtps10ThreadPool20writerThreadFunctionEPv>:
    if(pool == nullptr){
 800b1be:	b118      	cbz	r0, 800b1c8 <_ZN4rtps10ThreadPool20writerThreadFunctionEPv+0xa>
void ThreadPool::writerThreadFunction(void* arg){
 800b1c0:	b508      	push	{r3, lr}
    pool->doWriterWork();
 800b1c2:	f7ff ffe3 	bl	800b18c <_ZN4rtps10ThreadPool12doWriterWorkEv>
}
 800b1c6:	bd08      	pop	{r3, pc}
 800b1c8:	4770      	bx	lr

0800b1ca <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE13moveFirstIntoERS1_>:
    bool ThreadSafeCircularBuffer<T, SIZE>::moveFirstInto(T& hull) {
 800b1ca:	b570      	push	{r4, r5, r6, lr}
 800b1cc:	4604      	mov	r4, r0
 800b1ce:	460e      	mov	r6, r1
        Lock lock(m_mutex);
 800b1d0:	f100 05e0 	add.w	r5, r0, #224	; 0xe0
            sys_mutex_lock(&m_mutex);
 800b1d4:	4628      	mov	r0, r5
 800b1d6:	f7fd ff55 	bl	8009084 <sys_mutex_lock>
        if (m_head != m_tail) {
 800b1da:	f8b4 20dc 	ldrh.w	r2, [r4, #220]	; 0xdc
 800b1de:	f8b4 30de 	ldrh.w	r3, [r4, #222]	; 0xde
 800b1e2:	429a      	cmp	r2, r3
 800b1e4:	d01f      	beq.n	800b226 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE13moveFirstIntoERS1_+0x5c>
            this->srcPort = other.srcPort;
 800b1e6:	009a      	lsls	r2, r3, #2
 800b1e8:	18d0      	adds	r0, r2, r3
 800b1ea:	0081      	lsls	r1, r0, #2
 800b1ec:	1860      	adds	r0, r4, r1
 800b1ee:	5a61      	ldrh	r1, [r4, r1]
 800b1f0:	8031      	strh	r1, [r6, #0]
            this->destPort = other.destPort;
 800b1f2:	8901      	ldrh	r1, [r0, #8]
 800b1f4:	8131      	strh	r1, [r6, #8]
            this->destAddr = other.destAddr;
 800b1f6:	6841      	ldr	r1, [r0, #4]
 800b1f8:	6071      	str	r1, [r6, #4]
            this->buffer = std::move(other.buffer);
 800b1fa:	4413      	add	r3, r2
 800b1fc:	0099      	lsls	r1, r3, #2
 800b1fe:	3108      	adds	r1, #8
 800b200:	4421      	add	r1, r4
 800b202:	3104      	adds	r1, #4
 800b204:	f106 000c 	add.w	r0, r6, #12
 800b208:	f003 f8df 	bl	800e3ca <_ZN4rtps11PBufWrapperaSEOS0_>
        ++iterator;
 800b20c:	f8b4 30de 	ldrh.w	r3, [r4, #222]	; 0xde
 800b210:	3301      	adds	r3, #1
 800b212:	b29b      	uxth	r3, r3
 800b214:	f8a4 30de 	strh.w	r3, [r4, #222]	; 0xde
        if (iterator >= m_buffer.size()) {
 800b218:	2b0a      	cmp	r3, #10
 800b21a:	d90a      	bls.n	800b232 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE13moveFirstIntoERS1_+0x68>
            iterator = 0;
 800b21c:	2300      	movs	r3, #0
 800b21e:	f8a4 30de 	strh.w	r3, [r4, #222]	; 0xde
            return true;
 800b222:	2401      	movs	r4, #1
 800b224:	e000      	b.n	800b228 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE13moveFirstIntoERS1_+0x5e>
            return false;
 800b226:	2400      	movs	r4, #0
            sys_mutex_unlock(&m_mutex);
 800b228:	4628      	mov	r0, r5
 800b22a:	f7fd ff32 	bl	8009092 <sys_mutex_unlock>
    }
 800b22e:	4620      	mov	r0, r4
 800b230:	bd70      	pop	{r4, r5, r6, pc}
            return true;
 800b232:	2401      	movs	r4, #1
 800b234:	e7f8      	b.n	800b228 <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE13moveFirstIntoERS1_+0x5e>

0800b236 <_ZN4rtps10ThreadPool12doReaderWorkEv>:
        return;
    }
        pool->doReaderWork();
}

void ThreadPool::doReaderWork(){
 800b236:	b510      	push	{r4, lr}
 800b238:	b086      	sub	sp, #24
 800b23a:	4604      	mov	r4, r0
 800b23c:	e011      	b.n	800b262 <_ZN4rtps10ThreadPool12doReaderWorkEv+0x2c>

    while(m_running){
        PacketInfo packet;
        auto isWorkToDo = m_queueIncoming.moveFirstInto(packet);
        if(!isWorkToDo) {
 800b23e:	b120      	cbz	r0, 800b24a <_ZN4rtps10ThreadPool12doReaderWorkEv+0x14>
            sys_sem_wait(&m_readerNotificationSem);
            continue;
        }

        m_receiveJumppad(m_callee, const_cast<const PacketInfo&>(packet));
 800b240:	6823      	ldr	r3, [r4, #0]
 800b242:	a901      	add	r1, sp, #4
 800b244:	6860      	ldr	r0, [r4, #4]
 800b246:	4798      	blx	r3
 800b248:	e008      	b.n	800b25c <_ZN4rtps10ThreadPool12doReaderWorkEv+0x26>
            sys_sem_wait(&m_readerNotificationSem);
 800b24a:	2100      	movs	r1, #0
 800b24c:	f104 0014 	add.w	r0, r4, #20
 800b250:	f7fd fec8 	bl	8008fe4 <sys_arch_sem_wait>
        ~PacketInfo() = default;
 800b254:	a804      	add	r0, sp, #16
 800b256:	f003 f8c4 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800b25a:	e002      	b.n	800b262 <_ZN4rtps10ThreadPool12doReaderWorkEv+0x2c>
 800b25c:	a804      	add	r0, sp, #16
 800b25e:	f003 f8c0 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
    while(m_running){
 800b262:	7a23      	ldrb	r3, [r4, #8]
 800b264:	b173      	cbz	r3, 800b284 <_ZN4rtps10ThreadPool12doReaderWorkEv+0x4e>
 800b266:	2300      	movs	r3, #0
 800b268:	9304      	str	r3, [sp, #16]
 800b26a:	f8ad 3014 	strh.w	r3, [sp, #20]
        auto isWorkToDo = m_queueIncoming.moveFirstInto(packet);
 800b26e:	a901      	add	r1, sp, #4
 800b270:	f104 0054 	add.w	r0, r4, #84	; 0x54
 800b274:	f7ff ffa9 	bl	800b1ca <_ZN4rtps24ThreadSafeCircularBufferINS_10PacketInfoELt10EE13moveFirstIntoERS1_>
 800b278:	e7e1      	b.n	800b23e <_ZN4rtps10ThreadPool12doReaderWorkEv+0x8>
 800b27a:	a804      	add	r0, sp, #16
 800b27c:	f003 f8b1 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800b280:	f003 fbab 	bl	800e9da <__cxa_end_cleanup>
    }
}
 800b284:	b006      	add	sp, #24
 800b286:	bd10      	pop	{r4, pc}

0800b288 <_ZN4rtps10ThreadPool20readerThreadFunctionEPv>:
    if(pool == nullptr){
 800b288:	b118      	cbz	r0, 800b292 <_ZN4rtps10ThreadPool20readerThreadFunctionEPv+0xa>
void ThreadPool::readerThreadFunction(void* arg){
 800b28a:	b508      	push	{r3, lr}
        pool->doReaderWork();
 800b28c:	f7ff ffd3 	bl	800b236 <_ZN4rtps10ThreadPool12doReaderWorkEv>
}
 800b290:	bd08      	pop	{r3, pc}
 800b292:	4770      	bx	lr

0800b294 <_ZN4rtps9UdpDriverC1EPFvPvP7udp_pcbP4pbufPK8ip4_addrtES1_>:

using rtps::UdpDriver;

#define UDP_DRIVER_VERBOSE 0

UdpDriver::UdpDriver(rtps::UdpDriver::udpRxFunc_fp callback, void *args)
 800b294:	b570      	push	{r4, r5, r6, lr}
 800b296:	4604      	mov	r4, r0
 800b298:	460e      	mov	r6, r1
 800b29a:	4615      	mov	r5, r2
 800b29c:	2250      	movs	r2, #80	; 0x50
 800b29e:	2100      	movs	r1, #0
 800b2a0:	f004 f8fc 	bl	800f49c <memset>
    : m_rxCallback(callback), m_callbackArgs(args){
 800b2a4:	2300      	movs	r3, #0
 800b2a6:	6523      	str	r3, [r4, #80]	; 0x50
 800b2a8:	6566      	str	r6, [r4, #84]	; 0x54
 800b2aa:	65a5      	str	r5, [r4, #88]	; 0x58

}
 800b2ac:	4620      	mov	r0, r4
 800b2ae:	bd70      	pop	{r4, r5, r6, pc}

0800b2b0 <_ZN4rtps9UdpDriver19createUdpConnectionEt>:

const rtps::UdpConnection* UdpDriver::createUdpConnection(Ip4Port_t receivePort) {
 800b2b0:	b570      	push	{r4, r5, r6, lr}
 800b2b2:	b082      	sub	sp, #8
    for(uint8_t i=0; i < m_numConns; ++i){
 800b2b4:	2300      	movs	r3, #0
 800b2b6:	6d05      	ldr	r5, [r0, #80]	; 0x50
 800b2b8:	42ab      	cmp	r3, r5
 800b2ba:	d20c      	bcs.n	800b2d6 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x26>
        if(m_conns[i].port == receivePort){
 800b2bc:	eb00 05c3 	add.w	r5, r0, r3, lsl #3
 800b2c0:	88ad      	ldrh	r5, [r5, #4]
 800b2c2:	428d      	cmp	r5, r1
 800b2c4:	d002      	beq.n	800b2cc <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x1c>
    for(uint8_t i=0; i < m_numConns; ++i){
 800b2c6:	3301      	adds	r3, #1
 800b2c8:	b2db      	uxtb	r3, r3
 800b2ca:	e7f4      	b.n	800b2b6 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x6>
      { return const_cast<_Tp&>(__t[__n]); }
 800b2cc:	eb00 04c3 	add.w	r4, r0, r3, lsl #3
    m_numConns++;
#if UDP_DRIVER_VERBOSE
    printf("Successfully created UDP connection on port %u \n", receivePort);
#endif
    return &m_conns[m_numConns-1];
}
 800b2d0:	4620      	mov	r0, r4
 800b2d2:	b002      	add	sp, #8
 800b2d4:	bd70      	pop	{r4, r5, r6, pc}
    if(m_numConns == m_conns.size()){
 800b2d6:	2d0a      	cmp	r5, #10
 800b2d8:	d05d      	beq.n	800b396 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0xe6>
 800b2da:	460d      	mov	r5, r1
 800b2dc:	4604      	mov	r4, r0
        explicit UdpConnection(uint16_t port): port(port) {
 800b2de:	f8ad 1004 	strh.w	r1, [sp, #4]
                LOCK_TCPIP_CORE();
 800b2e2:	4837      	ldr	r0, [pc, #220]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b2e4:	f7fd fece 	bl	8009084 <sys_mutex_lock>
            pcb =  udp_new();
 800b2e8:	f7fb ff62 	bl	80071b0 <udp_new>
 800b2ec:	9000      	str	r0, [sp, #0]
                UNLOCK_TCPIP_CORE();
 800b2ee:	4e34      	ldr	r6, [pc, #208]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b2f0:	4630      	mov	r0, r6
 800b2f2:	f7fd fece 	bl	8009092 <sys_mutex_unlock>
                LOCK_TCPIP_CORE();
 800b2f6:	4630      	mov	r0, r6
 800b2f8:	f7fd fec4 	bl	8009084 <sys_mutex_lock>
 800b2fc:	e004      	b.n	800b308 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x58>
                UNLOCK_TCPIP_CORE();
 800b2fe:	4830      	ldr	r0, [pc, #192]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b300:	f7fd fec7 	bl	8009092 <sys_mutex_unlock>
 800b304:	f003 fb69 	bl	800e9da <__cxa_end_cleanup>
        err_t err = udp_bind(udp_conn.pcb, IP_ADDR_ANY, receivePort); //to receive multicast
 800b308:	462a      	mov	r2, r5
 800b30a:	492e      	ldr	r1, [pc, #184]	; (800b3c4 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x114>)
 800b30c:	9800      	ldr	r0, [sp, #0]
 800b30e:	f7fb fe09 	bl	8006f24 <udp_bind>
        if(err != ERR_OK && err != ERR_USE){
 800b312:	f110 0308 	adds.w	r3, r0, #8
 800b316:	bf18      	it	ne
 800b318:	2301      	movne	r3, #1
 800b31a:	2800      	cmp	r0, #0
 800b31c:	bf14      	ite	ne
 800b31e:	4618      	movne	r0, r3
 800b320:	2000      	moveq	r0, #0
 800b322:	b188      	cbz	r0, 800b348 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x98>
 800b324:	4826      	ldr	r0, [pc, #152]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b326:	f7fd feb4 	bl	8009092 <sys_mutex_unlock>
            return nullptr;
 800b32a:	2400      	movs	r4, #0
            if (pcb != nullptr) {
 800b32c:	9b00      	ldr	r3, [sp, #0]
 800b32e:	2b00      	cmp	r3, #0
 800b330:	d0ce      	beq.n	800b2d0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x20>
                LOCK_TCPIP_CORE();
 800b332:	4d23      	ldr	r5, [pc, #140]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b334:	4628      	mov	r0, r5
 800b336:	f7fd fea5 	bl	8009084 <sys_mutex_lock>
                udp_remove(pcb);
 800b33a:	9800      	ldr	r0, [sp, #0]
 800b33c:	f7fb ff1c 	bl	8007178 <udp_remove>
                UNLOCK_TCPIP_CORE();
 800b340:	4628      	mov	r0, r5
 800b342:	f7fd fea6 	bl	8009092 <sys_mutex_unlock>
 800b346:	e7c3      	b.n	800b2d0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x20>
        udp_recv(udp_conn.pcb, m_rxCallback, m_callbackArgs);
 800b348:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800b34a:	6d61      	ldr	r1, [r4, #84]	; 0x54
 800b34c:	9800      	ldr	r0, [sp, #0]
 800b34e:	f7fb ff0f 	bl	8007170 <udp_recv>
 800b352:	481b      	ldr	r0, [pc, #108]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b354:	f7fd fe9d 	bl	8009092 <sys_mutex_unlock>
    m_conns[m_numConns] = std::move(udp_conn);
 800b358:	6d25      	ldr	r5, [r4, #80]	; 0x50
 800b35a:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
            port = other.port;
 800b35e:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 800b362:	809a      	strh	r2, [r3, #4]
            if (pcb != nullptr) {
 800b364:	f854 3035 	ldr.w	r3, [r4, r5, lsl #3]
 800b368:	b153      	cbz	r3, 800b380 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0xd0>
                LOCK_TCPIP_CORE();
 800b36a:	4e15      	ldr	r6, [pc, #84]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b36c:	4630      	mov	r0, r6
 800b36e:	f7fd fe89 	bl	8009084 <sys_mutex_lock>
                udp_remove(pcb);
 800b372:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
 800b376:	f7fb feff 	bl	8007178 <udp_remove>
                UNLOCK_TCPIP_CORE();
 800b37a:	4630      	mov	r0, r6
 800b37c:	f7fd fe89 	bl	8009092 <sys_mutex_unlock>
            pcb = other.pcb;
 800b380:	9b00      	ldr	r3, [sp, #0]
 800b382:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
            other.pcb = nullptr;
 800b386:	2300      	movs	r3, #0
 800b388:	9300      	str	r3, [sp, #0]
    m_numConns++;
 800b38a:	6d20      	ldr	r0, [r4, #80]	; 0x50
 800b38c:	1c43      	adds	r3, r0, #1
 800b38e:	6523      	str	r3, [r4, #80]	; 0x50
 800b390:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
    return &m_conns[m_numConns-1];
 800b394:	e7ca      	b.n	800b32c <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x7c>
        return nullptr;
 800b396:	2400      	movs	r4, #0
 800b398:	e79a      	b.n	800b2d0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x20>
 800b39a:	4809      	ldr	r0, [pc, #36]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b39c:	f7fd fe79 	bl	8009092 <sys_mutex_unlock>
            if (pcb != nullptr) {
 800b3a0:	9b00      	ldr	r3, [sp, #0]
 800b3a2:	b14b      	cbz	r3, 800b3b8 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x108>
                LOCK_TCPIP_CORE();
 800b3a4:	4c06      	ldr	r4, [pc, #24]	; (800b3c0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0x110>)
 800b3a6:	4620      	mov	r0, r4
 800b3a8:	f7fd fe6c 	bl	8009084 <sys_mutex_lock>
                udp_remove(pcb);
 800b3ac:	9800      	ldr	r0, [sp, #0]
 800b3ae:	f7fb fee3 	bl	8007178 <udp_remove>
                UNLOCK_TCPIP_CORE();
 800b3b2:	4620      	mov	r0, r4
 800b3b4:	f7fd fe6d 	bl	8009092 <sys_mutex_unlock>
 800b3b8:	f003 fb0f 	bl	800e9da <__cxa_end_cleanup>
 800b3bc:	e7f0      	b.n	800b3a0 <_ZN4rtps9UdpDriver19createUdpConnectionEt+0xf0>
 800b3be:	bf00      	nop
 800b3c0:	20005a2c 	.word	0x20005a2c
 800b3c4:	080108cc 	.word	0x080108cc

0800b3c8 <_ZN4rtps9UdpDriver12isSameSubnetE8ip4_addr>:

bool UdpDriver::isSameSubnet(ip4_addr_t addr) {
	return (ip4_addr_netcmp(&addr, &(netif_default->ip_addr), &(netif_default->netmask)) != 0);
 800b3c8:	4b04      	ldr	r3, [pc, #16]	; (800b3dc <_ZN4rtps9UdpDriver12isSameSubnetE8ip4_addr+0x14>)
 800b3ca:	681a      	ldr	r2, [r3, #0]
 800b3cc:	6853      	ldr	r3, [r2, #4]
 800b3ce:	6892      	ldr	r2, [r2, #8]
 800b3d0:	4058      	eors	r0, r3
 800b3d2:	4210      	tst	r0, r2
}
 800b3d4:	bf0c      	ite	eq
 800b3d6:	2001      	moveq	r0, #1
 800b3d8:	2000      	movne	r0, #0
 800b3da:	4770      	bx	lr
 800b3dc:	20008614 	.word	0x20008614

0800b3e0 <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr>:

bool UdpDriver::joinMultiCastGroup(ip4_addr_t addr) const {
 800b3e0:	b510      	push	{r4, lr}
 800b3e2:	b082      	sub	sp, #8
 800b3e4:	ac02      	add	r4, sp, #8
 800b3e6:	f844 1d04 	str.w	r1, [r4, #-4]!
                LOCK_TCPIP_CORE();
 800b3ea:	480b      	ldr	r0, [pc, #44]	; (800b418 <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr+0x38>)
 800b3ec:	f7fd fe4a 	bl	8009084 <sys_mutex_lock>
    err_t iret;

    {
        TcpipCoreLock lock;
        iret = igmp_joingroup(IP_ADDR_ANY, (&addr));
 800b3f0:	4621      	mov	r1, r4
 800b3f2:	480a      	ldr	r0, [pc, #40]	; (800b41c <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr+0x3c>)
 800b3f4:	f7fc fe84 	bl	8008100 <igmp_joingroup>
 800b3f8:	4604      	mov	r4, r0
                UNLOCK_TCPIP_CORE();
 800b3fa:	4807      	ldr	r0, [pc, #28]	; (800b418 <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr+0x38>)
 800b3fc:	f7fd fe49 	bl	8009092 <sys_mutex_unlock>
    }

    if(iret != ERR_OK){
 800b400:	b914      	cbnz	r4, 800b408 <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr+0x28>
    }else{
#if UDP_DRIVER_VERBOSE
        printf("Succesfully joined  IGMP multicast group %s\n", ipaddr_ntoa(&addr));
#endif
    }
    return true;
 800b402:	2001      	movs	r0, #1
}
 800b404:	b002      	add	sp, #8
 800b406:	bd10      	pop	{r4, pc}
        return false;
 800b408:	2000      	movs	r0, #0
 800b40a:	e7fb      	b.n	800b404 <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr+0x24>
 800b40c:	4802      	ldr	r0, [pc, #8]	; (800b418 <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr+0x38>)
 800b40e:	f7fd fe40 	bl	8009092 <sys_mutex_unlock>
 800b412:	f003 fae2 	bl	800e9da <__cxa_end_cleanup>
 800b416:	bf00      	nop
 800b418:	20005a2c 	.word	0x20005a2c
 800b41c:	080108cc 	.word	0x080108cc

0800b420 <_ZN4rtps9UdpDriver10sendPacketERKNS_13UdpConnectionER8ip4_addrtR4pbuf>:

bool UdpDriver::sendPacket(const UdpConnection& conn, ip4_addr_t& destAddr, Ip4Port_t destPort, pbuf& buffer){
 800b420:	b570      	push	{r4, r5, r6, lr}
 800b422:	460c      	mov	r4, r1
 800b424:	4615      	mov	r5, r2
 800b426:	461e      	mov	r6, r3
                LOCK_TCPIP_CORE();
 800b428:	480b      	ldr	r0, [pc, #44]	; (800b458 <_ZN4rtps9UdpDriver10sendPacketERKNS_13UdpConnectionER8ip4_addrtR4pbuf+0x38>)
 800b42a:	f7fd fe2b 	bl	8009084 <sys_mutex_lock>
    err_t err;
    {
        TcpipCoreLock lock;
        err = udp_sendto(conn.pcb, &buffer, &destAddr, destPort);
 800b42e:	4633      	mov	r3, r6
 800b430:	462a      	mov	r2, r5
 800b432:	9904      	ldr	r1, [sp, #16]
 800b434:	6820      	ldr	r0, [r4, #0]
 800b436:	f7fb fe67 	bl	8007108 <udp_sendto>
 800b43a:	4604      	mov	r4, r0
                UNLOCK_TCPIP_CORE();
 800b43c:	4806      	ldr	r0, [pc, #24]	; (800b458 <_ZN4rtps9UdpDriver10sendPacketERKNS_13UdpConnectionER8ip4_addrtR4pbuf+0x38>)
 800b43e:	f7fd fe28 	bl	8009092 <sys_mutex_unlock>
    }

    if(err != ERR_OK){;
 800b442:	b90c      	cbnz	r4, 800b448 <_ZN4rtps9UdpDriver10sendPacketERKNS_13UdpConnectionER8ip4_addrtR4pbuf+0x28>
#if UDP_DRIVER_VERBOSE
        printf("UDP TRANSMIT NOT SUCCESSFUL %s:%u size: %u err: %i\n", ipaddr_ntoa(&destAddr), destPort, buffer.tot_len, err);
#endif
        return false;
    }
    return true;
 800b444:	2001      	movs	r0, #1
}
 800b446:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 800b448:	2000      	movs	r0, #0
 800b44a:	e7fc      	b.n	800b446 <_ZN4rtps9UdpDriver10sendPacketERKNS_13UdpConnectionER8ip4_addrtR4pbuf+0x26>
 800b44c:	4802      	ldr	r0, [pc, #8]	; (800b458 <_ZN4rtps9UdpDriver10sendPacketERKNS_13UdpConnectionER8ip4_addrtR4pbuf+0x38>)
 800b44e:	f7fd fe20 	bl	8009092 <sys_mutex_unlock>
 800b452:	f003 fac2 	bl	800e9da <__cxa_end_cleanup>
 800b456:	bf00      	nop
 800b458:	20005a2c 	.word	0x20005a2c

0800b45c <_ZN4rtps9UdpDriver10sendPacketERNS_10PacketInfoE>:

void UdpDriver::sendPacket(PacketInfo &packet){
 800b45c:	b530      	push	{r4, r5, lr}
 800b45e:	b083      	sub	sp, #12
 800b460:	4605      	mov	r5, r0
 800b462:	460c      	mov	r4, r1
    auto p_conn = createUdpConnection(packet.srcPort);
 800b464:	8809      	ldrh	r1, [r1, #0]
 800b466:	f7ff ff23 	bl	800b2b0 <_ZN4rtps9UdpDriver19createUdpConnectionEt>
    if(p_conn == nullptr){;
 800b46a:	b138      	cbz	r0, 800b47c <_ZN4rtps9UdpDriver10sendPacketERNS_10PacketInfoE+0x20>
 800b46c:	4601      	mov	r1, r0
        printf("Failed to create connection on port %u \n", packet.srcPort);
#endif
        return;
    }

    sendPacket(*p_conn, packet.destAddr, packet.destPort, *packet.buffer.firstElement);
 800b46e:	68e2      	ldr	r2, [r4, #12]
 800b470:	8923      	ldrh	r3, [r4, #8]
 800b472:	9200      	str	r2, [sp, #0]
 800b474:	1d22      	adds	r2, r4, #4
 800b476:	4628      	mov	r0, r5
 800b478:	f7ff ffd2 	bl	800b420 <_ZN4rtps9UdpDriver10sendPacketERKNS_13UdpConnectionER8ip4_addrtR4pbuf>
}
 800b47c:	b003      	add	sp, #12
 800b47e:	bd30      	pop	{r4, r5, pc}

0800b480 <_ZN4rtps20ParticipantProxyData5resetEv>:
ParticipantProxyData::ParticipantProxyData(Guid guid) : m_guid(guid){

}

void ParticipantProxyData::reset(){
    m_guid = Guid{GUIDPREFIX_UNKNOWN, ENTITYID_UNKNOWN};
 800b480:	2100      	movs	r1, #0
 800b482:	f8c0 1002 	str.w	r1, [r0, #2]
 800b486:	f8c0 1006 	str.w	r1, [r0, #6]
 800b48a:	f8c0 100a 	str.w	r1, [r0, #10]
 800b48e:	f8c0 100e 	str.w	r1, [r0, #14]
    m_manualLivelinessCount = Count_t{1};
 800b492:	2301      	movs	r3, #1
 800b494:	f8c0 31fc 	str.w	r3, [r0, #508]	; 0x1fc
    m_expectsInlineQos = false;
 800b498:	7501      	strb	r1, [r0, #20]
    for(int i = 0; i < Config::SPDP_MAX_NUM_LOCATORS; ++i){
 800b49a:	2904      	cmp	r1, #4
 800b49c:	dc2a      	bgt.n	800b4f4 <_ZN4rtps20ParticipantProxyData5resetEv+0x74>
void ParticipantProxyData::reset(){
 800b49e:	b430      	push	{r4, r5}
            kind = LocatorKind_t::LOCATOR_KIND_INVALID;
 800b4a0:	004c      	lsls	r4, r1, #1
 800b4a2:	1863      	adds	r3, r4, r1
 800b4a4:	00da      	lsls	r2, r3, #3
 800b4a6:	4402      	add	r2, r0
 800b4a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b4ac:	7713      	strb	r3, [r2, #28]
 800b4ae:	7753      	strb	r3, [r2, #29]
 800b4b0:	7793      	strb	r3, [r2, #30]
 800b4b2:	77d3      	strb	r3, [r2, #31]
 800b4b4:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 800b4b8:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 800b4bc:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 800b4c0:	f882 3097 	strb.w	r3, [r2, #151]	; 0x97
 800b4c4:	f882 310c 	strb.w	r3, [r2, #268]	; 0x10c
 800b4c8:	f882 310d 	strb.w	r3, [r2, #269]	; 0x10d
 800b4cc:	f882 310e 	strb.w	r3, [r2, #270]	; 0x10e
 800b4d0:	f882 310f 	strb.w	r3, [r2, #271]	; 0x10f
 800b4d4:	440c      	add	r4, r1
 800b4d6:	00e2      	lsls	r2, r4, #3
 800b4d8:	4402      	add	r2, r0
 800b4da:	f882 3184 	strb.w	r3, [r2, #388]	; 0x184
 800b4de:	f882 3185 	strb.w	r3, [r2, #389]	; 0x185
 800b4e2:	f882 3186 	strb.w	r3, [r2, #390]	; 0x186
 800b4e6:	f882 3187 	strb.w	r3, [r2, #391]	; 0x187
    for(int i = 0; i < Config::SPDP_MAX_NUM_LOCATORS; ++i){
 800b4ea:	3101      	adds	r1, #1
 800b4ec:	2904      	cmp	r1, #4
 800b4ee:	ddd7      	ble.n	800b4a0 <_ZN4rtps20ParticipantProxyData5resetEv+0x20>
        m_metatrafficUnicastLocatorList[i].setInvalid();
        m_metatrafficMulticastLocatorList[i].setInvalid();
        m_defaultUnicastLocatorList[i].setInvalid();
        m_defaultMulticastLocatorList[i].setInvalid();
    }
}
 800b4f0:	bc30      	pop	{r4, r5}
 800b4f2:	4770      	bx	lr
 800b4f4:	4770      	bx	lr

0800b4f6 <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE>:
        buffer.last_data_size = 4;
    }
    return true;
}

bool ParticipantProxyData::readLocatorIntoList(ucdrBuffer& buffer, std::array<Locator, Config::SPDP_MAX_NUM_LOCATORS>& list){
 800b4f6:	b538      	push	{r3, r4, r5, lr}
 800b4f8:	460d      	mov	r5, r1
 800b4fa:	4614      	mov	r4, r2
      { return iterator(data() + _Nm); }
 800b4fc:	3278      	adds	r2, #120	; 0x78
    for(auto& loc : list){
 800b4fe:	4294      	cmp	r4, r2
 800b500:	d012      	beq.n	800b528 <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE+0x32>
            return kind != LocatorKind_t::LOCATOR_KIND_INVALID;
 800b502:	6823      	ldr	r3, [r4, #0]
        if(!loc.isValid()){
 800b504:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b508:	d001      	beq.n	800b50e <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE+0x18>
    for(auto& loc : list){
 800b50a:	3418      	adds	r4, #24
 800b50c:	e7f7      	b.n	800b4fe <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE+0x8>
            if(ucdr_buffer_remaining(&buffer) < sizeof(Locator)){
 800b50e:	4628      	mov	r0, r5
 800b510:	f003 f8df 	bl	800e6d2 <ucdr_buffer_remaining>
 800b514:	2817      	cmp	r0, #23
 800b516:	d801      	bhi.n	800b51c <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE+0x26>
            loc.readFromUcdrBuffer(buffer);
            return true;
 800b518:	2001      	movs	r0, #1
 800b51a:	e006      	b.n	800b52a <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE+0x34>
                ucdr_deserialize_array_uint8_t(&buffer, reinterpret_cast<uint8_t*>(this), sizeof(Locator));
 800b51c:	2218      	movs	r2, #24
 800b51e:	4621      	mov	r1, r4
 800b520:	4628      	mov	r0, r5
 800b522:	f003 f914 	bl	800e74e <ucdr_deserialize_array_uint8_t>
 800b526:	e7f7      	b.n	800b518 <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE+0x22>
        }
    }
    // TODO printf("SPDP: m_metatrafficMulticastLocatorList full.");
    return false;
 800b528:	2000      	movs	r0, #0
}
 800b52a:	bd38      	pop	{r3, r4, r5, pc}

0800b52c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer>:
bool ParticipantProxyData::readFromUcdrBuffer(ucdrBuffer& buffer){
 800b52c:	b530      	push	{r4, r5, lr}
 800b52e:	b083      	sub	sp, #12
 800b530:	4605      	mov	r5, r0
 800b532:	460c      	mov	r4, r1
    reset();
 800b534:	f7ff ffa4 	bl	800b480 <_ZN4rtps20ParticipantProxyData5resetEv>
 800b538:	e01f      	b.n	800b57a <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x4e>
                return true;
 800b53a:	2301      	movs	r3, #1
}
 800b53c:	4618      	mov	r0, r3
 800b53e:	b003      	add	sp, #12
 800b540:	bd30      	pop	{r4, r5, pc}
                ucdr_deserialize_uint8_t(&buffer, &m_protocolVersion.major);
 800b542:	4629      	mov	r1, r5
 800b544:	4620      	mov	r0, r4
 800b546:	f003 fa09 	bl	800e95c <ucdr_deserialize_uint8_t>
                if(m_protocolVersion.major < PROTOCOLVERSION.major){
 800b54a:	782b      	ldrb	r3, [r5, #0]
 800b54c:	2b01      	cmp	r3, #1
 800b54e:	f240 8187 	bls.w	800b860 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x334>
                    ucdr_deserialize_uint8_t(&buffer, &m_protocolVersion.minor);
 800b552:	1c69      	adds	r1, r5, #1
 800b554:	4620      	mov	r0, r4
 800b556:	f003 fa01 	bl	800e95c <ucdr_deserialize_uint8_t>
 800b55a:	e005      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                ucdr_deserialize_array_uint8_t(&buffer, m_vendorId.vendorId.data(), m_vendorId.vendorId.size());
 800b55c:	2202      	movs	r2, #2
 800b55e:	f105 0112 	add.w	r1, r5, #18
 800b562:	4620      	mov	r0, r4
 800b564:	f003 f8f3 	bl	800e74e <ucdr_deserialize_array_uint8_t>
        uint32_t alignment = ucdr_buffer_alignment(&buffer, 4);
 800b568:	2104      	movs	r1, #4
 800b56a:	4620      	mov	r0, r4
 800b56c:	f003 f88f 	bl	800e68e <ucdr_buffer_alignment>
        buffer.iterator += alignment;
 800b570:	68a3      	ldr	r3, [r4, #8]
 800b572:	4418      	add	r0, r3
 800b574:	60a0      	str	r0, [r4, #8]
        buffer.last_data_size = 4;
 800b576:	2304      	movs	r3, #4
 800b578:	6123      	str	r3, [r4, #16]
    while(ucdr_buffer_remaining(&buffer) >= 4){
 800b57a:	4620      	mov	r0, r4
 800b57c:	f003 f8a9 	bl	800e6d2 <ucdr_buffer_remaining>
 800b580:	2803      	cmp	r0, #3
 800b582:	f240 8167 	bls.w	800b854 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x328>
        ucdr_deserialize_uint16_t(&buffer, reinterpret_cast<uint16_t*>(&pid));
 800b586:	f10d 0106 	add.w	r1, sp, #6
 800b58a:	4620      	mov	r0, r4
 800b58c:	f003 f9ea 	bl	800e964 <ucdr_deserialize_uint16_t>
        ucdr_deserialize_uint16_t(&buffer, &length);
 800b590:	a901      	add	r1, sp, #4
 800b592:	4620      	mov	r0, r4
 800b594:	f003 f9e6 	bl	800e964 <ucdr_deserialize_uint16_t>
        if(ucdr_buffer_remaining(&buffer) < length){
 800b598:	4620      	mov	r0, r4
 800b59a:	f003 f89a 	bl	800e6d2 <ucdr_buffer_remaining>
 800b59e:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 800b5a2:	4282      	cmp	r2, r0
 800b5a4:	f200 8158 	bhi.w	800b858 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x32c>
        switch(pid){
 800b5a8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800b5ac:	2b70      	cmp	r3, #112	; 0x70
 800b5ae:	f200 8155 	bhi.w	800b85c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x330>
 800b5b2:	a101      	add	r1, pc, #4	; (adr r1, 800b5b8 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x8c>)
 800b5b4:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800b5b8:	0800b849 	.word	0x0800b849
 800b5bc:	0800b53b 	.word	0x0800b53b
 800b5c0:	0800b803 	.word	0x0800b803
 800b5c4:	0800b85d 	.word	0x0800b85d
 800b5c8:	0800b85d 	.word	0x0800b85d
 800b5cc:	0800b85d 	.word	0x0800b85d
 800b5d0:	0800b85d 	.word	0x0800b85d
 800b5d4:	0800b85d 	.word	0x0800b85d
 800b5d8:	0800b85d 	.word	0x0800b85d
 800b5dc:	0800b85d 	.word	0x0800b85d
 800b5e0:	0800b85d 	.word	0x0800b85d
 800b5e4:	0800b85d 	.word	0x0800b85d
 800b5e8:	0800b85d 	.word	0x0800b85d
 800b5ec:	0800b85d 	.word	0x0800b85d
 800b5f0:	0800b85d 	.word	0x0800b85d
 800b5f4:	0800b85d 	.word	0x0800b85d
 800b5f8:	0800b85d 	.word	0x0800b85d
 800b5fc:	0800b85d 	.word	0x0800b85d
 800b600:	0800b85d 	.word	0x0800b85d
 800b604:	0800b85d 	.word	0x0800b85d
 800b608:	0800b85d 	.word	0x0800b85d
 800b60c:	0800b543 	.word	0x0800b543
 800b610:	0800b55d 	.word	0x0800b55d
 800b614:	0800b85d 	.word	0x0800b85d
 800b618:	0800b85d 	.word	0x0800b85d
 800b61c:	0800b85d 	.word	0x0800b85d
 800b620:	0800b85d 	.word	0x0800b85d
 800b624:	0800b85d 	.word	0x0800b85d
 800b628:	0800b85d 	.word	0x0800b85d
 800b62c:	0800b85d 	.word	0x0800b85d
 800b630:	0800b85d 	.word	0x0800b85d
 800b634:	0800b85d 	.word	0x0800b85d
 800b638:	0800b85d 	.word	0x0800b85d
 800b63c:	0800b85d 	.word	0x0800b85d
 800b640:	0800b85d 	.word	0x0800b85d
 800b644:	0800b85d 	.word	0x0800b85d
 800b648:	0800b85d 	.word	0x0800b85d
 800b64c:	0800b85d 	.word	0x0800b85d
 800b650:	0800b85d 	.word	0x0800b85d
 800b654:	0800b85d 	.word	0x0800b85d
 800b658:	0800b85d 	.word	0x0800b85d
 800b65c:	0800b85d 	.word	0x0800b85d
 800b660:	0800b85d 	.word	0x0800b85d
 800b664:	0800b85d 	.word	0x0800b85d
 800b668:	0800b83d 	.word	0x0800b83d
 800b66c:	0800b85d 	.word	0x0800b85d
 800b670:	0800b85d 	.word	0x0800b85d
 800b674:	0800b85d 	.word	0x0800b85d
 800b678:	0800b85d 	.word	0x0800b85d
 800b67c:	0800b7d7 	.word	0x0800b7d7
 800b680:	0800b7c1 	.word	0x0800b7c1
 800b684:	0800b7ab 	.word	0x0800b7ab
 800b688:	0800b85d 	.word	0x0800b85d
 800b68c:	0800b85d 	.word	0x0800b85d
 800b690:	0800b85d 	.word	0x0800b85d
 800b694:	0800b85d 	.word	0x0800b85d
 800b698:	0800b85d 	.word	0x0800b85d
 800b69c:	0800b85d 	.word	0x0800b85d
 800b6a0:	0800b85d 	.word	0x0800b85d
 800b6a4:	0800b85d 	.word	0x0800b85d
 800b6a8:	0800b85d 	.word	0x0800b85d
 800b6ac:	0800b85d 	.word	0x0800b85d
 800b6b0:	0800b85d 	.word	0x0800b85d
 800b6b4:	0800b85d 	.word	0x0800b85d
 800b6b8:	0800b85d 	.word	0x0800b85d
 800b6bc:	0800b85d 	.word	0x0800b85d
 800b6c0:	0800b85d 	.word	0x0800b85d
 800b6c4:	0800b77d 	.word	0x0800b77d
 800b6c8:	0800b85d 	.word	0x0800b85d
 800b6cc:	0800b85d 	.word	0x0800b85d
 800b6d0:	0800b85d 	.word	0x0800b85d
 800b6d4:	0800b85d 	.word	0x0800b85d
 800b6d8:	0800b7ed 	.word	0x0800b7ed
 800b6dc:	0800b85d 	.word	0x0800b85d
 800b6e0:	0800b85d 	.word	0x0800b85d
 800b6e4:	0800b85d 	.word	0x0800b85d
 800b6e8:	0800b85d 	.word	0x0800b85d
 800b6ec:	0800b85d 	.word	0x0800b85d
 800b6f0:	0800b85d 	.word	0x0800b85d
 800b6f4:	0800b85d 	.word	0x0800b85d
 800b6f8:	0800b789 	.word	0x0800b789
 800b6fc:	0800b85d 	.word	0x0800b85d
 800b700:	0800b85d 	.word	0x0800b85d
 800b704:	0800b85d 	.word	0x0800b85d
 800b708:	0800b85d 	.word	0x0800b85d
 800b70c:	0800b85d 	.word	0x0800b85d
 800b710:	0800b85d 	.word	0x0800b85d
 800b714:	0800b85d 	.word	0x0800b85d
 800b718:	0800b819 	.word	0x0800b819
 800b71c:	0800b831 	.word	0x0800b831
 800b720:	0800b85d 	.word	0x0800b85d
 800b724:	0800b85d 	.word	0x0800b85d
 800b728:	0800b85d 	.word	0x0800b85d
 800b72c:	0800b85d 	.word	0x0800b85d
 800b730:	0800b85d 	.word	0x0800b85d
 800b734:	0800b85d 	.word	0x0800b85d
 800b738:	0800b85d 	.word	0x0800b85d
 800b73c:	0800b85d 	.word	0x0800b85d
 800b740:	0800b825 	.word	0x0800b825
 800b744:	0800b85d 	.word	0x0800b85d
 800b748:	0800b85d 	.word	0x0800b85d
 800b74c:	0800b85d 	.word	0x0800b85d
 800b750:	0800b85d 	.word	0x0800b85d
 800b754:	0800b85d 	.word	0x0800b85d
 800b758:	0800b85d 	.word	0x0800b85d
 800b75c:	0800b85d 	.word	0x0800b85d
 800b760:	0800b85d 	.word	0x0800b85d
 800b764:	0800b85d 	.word	0x0800b85d
 800b768:	0800b85d 	.word	0x0800b85d
 800b76c:	0800b85d 	.word	0x0800b85d
 800b770:	0800b85d 	.word	0x0800b85d
 800b774:	0800b85d 	.word	0x0800b85d
 800b778:	0800b569 	.word	0x0800b569
                ucdr_deserialize_bool(&buffer, &m_expectsInlineQos);
 800b77c:	f105 0114 	add.w	r1, r5, #20
 800b780:	4620      	mov	r0, r4
 800b782:	f003 f8e7 	bl	800e954 <ucdr_deserialize_bool>
 800b786:	e6ef      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                ucdr_deserialize_array_uint8_t(&buffer, m_guid.prefix.id.data(), m_guid.prefix.id.size());
 800b788:	220c      	movs	r2, #12
 800b78a:	1ca9      	adds	r1, r5, #2
 800b78c:	4620      	mov	r0, r4
 800b78e:	f002 ffde 	bl	800e74e <ucdr_deserialize_array_uint8_t>
                ucdr_deserialize_array_uint8_t(&buffer, m_guid.entityId.entityKey.data(), m_guid.entityId.entityKey.size());
 800b792:	2203      	movs	r2, #3
 800b794:	f105 010e 	add.w	r1, r5, #14
 800b798:	4620      	mov	r0, r4
 800b79a:	f002 ffd8 	bl	800e74e <ucdr_deserialize_array_uint8_t>
                ucdr_deserialize_uint8_t(&buffer, reinterpret_cast<uint8_t*>(&m_guid.entityId.entityKind));
 800b79e:	f105 0111 	add.w	r1, r5, #17
 800b7a2:	4620      	mov	r0, r4
 800b7a4:	f003 f8da 	bl	800e95c <ucdr_deserialize_uint8_t>
 800b7a8:	e6de      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                if(!readLocatorIntoList(buffer, m_metatrafficMulticastLocatorList)) {
 800b7aa:	f105 0294 	add.w	r2, r5, #148	; 0x94
 800b7ae:	4621      	mov	r1, r4
 800b7b0:	4628      	mov	r0, r5
 800b7b2:	f7ff fea0 	bl	800b4f6 <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE>
 800b7b6:	4603      	mov	r3, r0
 800b7b8:	2800      	cmp	r0, #0
 800b7ba:	f47f aed5 	bne.w	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
 800b7be:	e6bd      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>
                if(!readLocatorIntoList(buffer, m_metatrafficUnicastLocatorList)) {
 800b7c0:	f105 021c 	add.w	r2, r5, #28
 800b7c4:	4621      	mov	r1, r4
 800b7c6:	4628      	mov	r0, r5
 800b7c8:	f7ff fe95 	bl	800b4f6 <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE>
 800b7cc:	4603      	mov	r3, r0
 800b7ce:	2800      	cmp	r0, #0
 800b7d0:	f47f aeca 	bne.w	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
 800b7d4:	e6b2      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>
                if(!readLocatorIntoList(buffer, m_defaultUnicastLocatorList)) {
 800b7d6:	f505 7286 	add.w	r2, r5, #268	; 0x10c
 800b7da:	4621      	mov	r1, r4
 800b7dc:	4628      	mov	r0, r5
 800b7de:	f7ff fe8a 	bl	800b4f6 <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE>
 800b7e2:	4603      	mov	r3, r0
 800b7e4:	2800      	cmp	r0, #0
 800b7e6:	f47f aebf 	bne.w	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
 800b7ea:	e6a7      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>
                if(!readLocatorIntoList(buffer, m_defaultMulticastLocatorList)) {
 800b7ec:	f505 72c2 	add.w	r2, r5, #388	; 0x184
 800b7f0:	4621      	mov	r1, r4
 800b7f2:	4628      	mov	r0, r5
 800b7f4:	f7ff fe7f 	bl	800b4f6 <_ZN4rtps20ParticipantProxyData19readLocatorIntoListER10ucdrBufferRSt5arrayINS_7LocatorELj5EE>
 800b7f8:	4603      	mov	r3, r0
 800b7fa:	2800      	cmp	r0, #0
 800b7fc:	f47f aeb4 	bne.w	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
 800b800:	e69c      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>
                ucdr_deserialize_int32_t(&buffer, &m_leaseDuration.seconds);
 800b802:	f505 7100 	add.w	r1, r5, #512	; 0x200
 800b806:	4620      	mov	r0, r4
 800b808:	f003 f8b8 	bl	800e97c <ucdr_deserialize_int32_t>
                ucdr_deserialize_uint32_t(&buffer, &m_leaseDuration.fraction);
 800b80c:	f505 7101 	add.w	r1, r5, #516	; 0x204
 800b810:	4620      	mov	r0, r4
 800b812:	f003 f8ad 	bl	800e970 <ucdr_deserialize_uint32_t>
 800b816:	e6a7      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                ucdr_deserialize_uint32_t(&buffer, &m_availableBuiltInEndpoints);
 800b818:	f105 0118 	add.w	r1, r5, #24
 800b81c:	4620      	mov	r0, r4
 800b81e:	f003 f8a7 	bl	800e970 <ucdr_deserialize_uint32_t>
 800b822:	e6a1      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                buffer.iterator+=length;
 800b824:	68a3      	ldr	r3, [r4, #8]
 800b826:	441a      	add	r2, r3
 800b828:	60a2      	str	r2, [r4, #8]
                buffer.last_data_size = 1;
 800b82a:	2301      	movs	r3, #1
 800b82c:	6123      	str	r3, [r4, #16]
                break;
 800b82e:	e69b      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                buffer.iterator+=length;
 800b830:	68a3      	ldr	r3, [r4, #8]
 800b832:	441a      	add	r2, r3
 800b834:	60a2      	str	r2, [r4, #8]
                buffer.last_data_size = 1;
 800b836:	2301      	movs	r3, #1
 800b838:	6123      	str	r3, [r4, #16]
                break;
 800b83a:	e695      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                buffer.iterator+=length;
 800b83c:	68a3      	ldr	r3, [r4, #8]
 800b83e:	441a      	add	r2, r3
 800b840:	60a2      	str	r2, [r4, #8]
                buffer.last_data_size = 1;
 800b842:	2301      	movs	r3, #1
 800b844:	6123      	str	r3, [r4, #16]
                break;
 800b846:	e68f      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
                buffer.iterator+=length;
 800b848:	68a3      	ldr	r3, [r4, #8]
 800b84a:	441a      	add	r2, r3
 800b84c:	60a2      	str	r2, [r4, #8]
                buffer.last_data_size = 1;
 800b84e:	2301      	movs	r3, #1
 800b850:	6123      	str	r3, [r4, #16]
                break;
 800b852:	e689      	b.n	800b568 <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x3c>
    return true;
 800b854:	2301      	movs	r3, #1
 800b856:	e671      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>
            return false;
 800b858:	2300      	movs	r3, #0
 800b85a:	e66f      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>
                return false;
 800b85c:	2300      	movs	r3, #0
 800b85e:	e66d      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>
                    return false;
 800b860:	2300      	movs	r3, #0
 800b862:	e66b      	b.n	800b53c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer+0x10>

0800b864 <_ZN4rtps9SEDPAgent4initERNS_11ParticipantERKNS_16BuiltInEndpointsE>:
		line_ = (line_+1)%30; 							 \
		}

#endif

void SEDPAgent::init(Participant& part, const BuiltInEndpoints& endpoints){
 800b864:	b570      	push	{r4, r5, r6, lr}
 800b866:	4606      	mov	r6, r0
 800b868:	460d      	mov	r5, r1
 800b86a:	4614      	mov	r4, r2
    // TODO move
    if(sys_mutex_new(&m_mutex) != ERR_OK){
 800b86c:	3004      	adds	r0, #4
 800b86e:	f7fd fbf3 	bl	8009058 <sys_mutex_new>
 800b872:	b9c0      	cbnz	r0, 800b8a6 <_ZN4rtps9SEDPAgent4initERNS_11ParticipantERKNS_16BuiltInEndpointsE+0x42>
        printf("SEDPAgent failed to create mutex\n");
#endif
        return;
    }

    m_part = &part;
 800b874:	6035      	str	r5, [r6, #0]
    m_endpoints = endpoints;
 800b876:	f506 759a 	add.w	r5, r6, #308	; 0x134
 800b87a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b87c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b87e:	e894 0003 	ldmia.w	r4, {r0, r1}
 800b882:	e885 0003 	stmia.w	r5, {r0, r1}
    if(m_endpoints.sedpPubReader != nullptr){
 800b886:	f8d6 0140 	ldr.w	r0, [r6, #320]	; 0x140
 800b88a:	b120      	cbz	r0, 800b896 <_ZN4rtps9SEDPAgent4initERNS_11ParticipantERKNS_16BuiltInEndpointsE+0x32>
        m_endpoints.sedpPubReader->registerCallback(receiveCallbackPublisher, this);
 800b88c:	6803      	ldr	r3, [r0, #0]
 800b88e:	685b      	ldr	r3, [r3, #4]
 800b890:	4632      	mov	r2, r6
 800b892:	4905      	ldr	r1, [pc, #20]	; (800b8a8 <_ZN4rtps9SEDPAgent4initERNS_11ParticipantERKNS_16BuiltInEndpointsE+0x44>)
 800b894:	4798      	blx	r3
    }
    if(m_endpoints.sedpSubReader != nullptr){
 800b896:	f8d6 0148 	ldr.w	r0, [r6, #328]	; 0x148
 800b89a:	b120      	cbz	r0, 800b8a6 <_ZN4rtps9SEDPAgent4initERNS_11ParticipantERKNS_16BuiltInEndpointsE+0x42>
        m_endpoints.sedpSubReader->registerCallback(receiveCallbackSubscriber, this);
 800b89c:	6803      	ldr	r3, [r0, #0]
 800b89e:	685b      	ldr	r3, [r3, #4]
 800b8a0:	4632      	mov	r2, r6
 800b8a2:	4902      	ldr	r1, [pc, #8]	; (800b8ac <_ZN4rtps9SEDPAgent4initERNS_11ParticipantERKNS_16BuiltInEndpointsE+0x48>)
 800b8a4:	4798      	blx	r3
    }
}
 800b8a6:	bd70      	pop	{r4, r5, r6, pc}
 800b8a8:	0800b99f 	.word	0x0800b99f
 800b8ac:	0800ba87 	.word	0x0800ba87

0800b8b0 <_ZN4rtps9SEDPAgent37registerOnNewPublisherMatchedCallbackEPFvPvES1_>:


void SEDPAgent::registerOnNewPublisherMatchedCallback(void (*callback)(void* arg), void* args){
    mfp_onNewPublisherCallback = callback;
 800b8b0:	f8c0 114c 	str.w	r1, [r0, #332]	; 0x14c
    m_onNewPublisherArgs = args;
 800b8b4:	f8c0 2150 	str.w	r2, [r0, #336]	; 0x150
}
 800b8b8:	4770      	bx	lr

0800b8ba <_ZN4rtps9SEDPAgent38registerOnNewSubscriberMatchedCallbackEPFvPvES1_>:

void SEDPAgent::registerOnNewSubscriberMatchedCallback(void (*callback)(void* arg), void* args){
    mfp_onNewSubscriberCallback = callback;
 800b8ba:	f8c0 1154 	str.w	r1, [r0, #340]	; 0x154
    m_onNewSubscriberArgs = args;
 800b8be:	f8c0 2158 	str.w	r2, [r0, #344]	; 0x158
}
 800b8c2:	4770      	bx	lr

0800b8c4 <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_9TopicDataE>:
    if(topicData.readFromUcdrBuffer(cdrBuffer)){
        onNewPublisher(topicData);
    }
}

void SEDPAgent::onNewPublisher(const TopicData& writerData) {
 800b8c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b8c8:	b08e      	sub	sp, #56	; 0x38
 800b8ca:	4606      	mov	r6, r0
 800b8cc:	460c      	mov	r4, r1
	// TODO Is it okay to add Endpoint if the respective participant is unknown participant?
	if(!m_part->findRemoteParticipant(writerData.endpointGuid.prefix)){
 800b8ce:	6800      	ldr	r0, [r0, #0]
 800b8d0:	f002 fa49 	bl	800dd66 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE>
 800b8d4:	b338      	cbz	r0, 800b926 <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_9TopicDataE+0x62>
		return;
	}
#if SEDP_VERBOSE
    SEDP_LOG("PUB T/D %s/%s", writerData.topicName, writerData.typeName);
#endif
	Reader* reader = m_part->getMatchingReader(writerData);
 800b8d6:	4621      	mov	r1, r4
 800b8d8:	6830      	ldr	r0, [r6, #0]
 800b8da:	f002 f9ed 	bl	800dcb8 <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE>
    if(reader == nullptr){
 800b8de:	4607      	mov	r7, r0
 800b8e0:	b308      	cbz	r0, 800b926 <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_9TopicDataE+0x62>
        }else{
            SEDP_LOG("best-effort ");
        }
        SEDP_LOG("publisher\n");
#endif
    reader->addNewMatchedWriter(WriterProxy{writerData.endpointGuid, writerData.unicastLocator});
 800b8e2:	6803      	ldr	r3, [r0, #0]
 800b8e4:	f8d3 800c 	ldr.w	r8, [r3, #12]
                hbCount{0}, remoteLocator(loc){
 800b8e8:	466d      	mov	r5, sp
 800b8ea:	6820      	ldr	r0, [r4, #0]
 800b8ec:	6861      	ldr	r1, [r4, #4]
 800b8ee:	68a2      	ldr	r2, [r4, #8]
 800b8f0:	68e3      	ldr	r3, [r4, #12]
 800b8f2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b8f4:	2300      	movs	r3, #0
 800b8f6:	9304      	str	r3, [sp, #16]
 800b8f8:	2201      	movs	r2, #1
 800b8fa:	9205      	str	r2, [sp, #20]
 800b8fc:	9206      	str	r2, [sp, #24]
 800b8fe:	9307      	str	r3, [sp, #28]
 800b900:	ad08      	add	r5, sp, #32
 800b902:	f854 0f3c 	ldr.w	r0, [r4, #60]!
 800b906:	6861      	ldr	r1, [r4, #4]
 800b908:	68a2      	ldr	r2, [r4, #8]
 800b90a:	68e3      	ldr	r3, [r4, #12]
 800b90c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b90e:	6920      	ldr	r0, [r4, #16]
 800b910:	6961      	ldr	r1, [r4, #20]
 800b912:	c503      	stmia	r5!, {r0, r1}
 800b914:	4669      	mov	r1, sp
 800b916:	4638      	mov	r0, r7
 800b918:	47c0      	blx	r8
    if(mfp_onNewPublisherCallback != nullptr) {
 800b91a:	f8d6 314c 	ldr.w	r3, [r6, #332]	; 0x14c
 800b91e:	b113      	cbz	r3, 800b926 <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_9TopicDataE+0x62>
        mfp_onNewPublisherCallback(m_onNewPublisherArgs);
 800b920:	f8d6 0150 	ldr.w	r0, [r6, #336]	; 0x150
 800b924:	4798      	blx	r3
    }
}
 800b926:	b00e      	add	sp, #56	; 0x38
 800b928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b92c <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_17ReaderCacheChangeE>:
void SEDPAgent::onNewPublisher(const ReaderCacheChange& change){
 800b92c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b92e:	b09d      	sub	sp, #116	; 0x74
 800b930:	4604      	mov	r4, r0
 800b932:	460e      	mov	r6, r1
    Lock lock{m_mutex};
 800b934:	1d05      	adds	r5, r0, #4
            sys_mutex_lock(&m_mutex);
 800b936:	4628      	mov	r0, r5
 800b938:	f7fd fba4 	bl	8009084 <sys_mutex_lock>
        ReaderCacheChange& operator=(const ReaderCacheChange &other) = delete;
        ReaderCacheChange& operator=(ReaderCacheChange&& other) = delete;


        bool copyInto(uint8_t* buffer, DataSize_t destSize) const{
            if(destSize < size){
 800b93c:	88f2      	ldrh	r2, [r6, #6]
 800b93e:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
 800b942:	d80c      	bhi.n	800b95e <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_17ReaderCacheChangeE+0x32>
 800b944:	f104 0708 	add.w	r7, r4, #8
                return false;
            }else{
                memcpy(buffer, data, size);
 800b948:	6831      	ldr	r1, [r6, #0]
 800b94a:	4638      	mov	r0, r7
 800b94c:	f003 fd9b 	bl	800f486 <memcpy>
    ucdr_init_buffer(&cdrBuffer, m_buffer, sizeof(m_buffer));
 800b950:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800b954:	4639      	mov	r1, r7
 800b956:	a816      	add	r0, sp, #88	; 0x58
 800b958:	f002 fe94 	bl	800e684 <ucdr_init_buffer>
 800b95c:	e003      	b.n	800b966 <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_17ReaderCacheChangeE+0x3a>
            sys_mutex_unlock(&m_mutex);
 800b95e:	4628      	mov	r0, r5
 800b960:	f7fd fb97 	bl	8009092 <sys_mutex_unlock>
 800b964:	e014      	b.n	800b990 <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_17ReaderCacheChangeE+0x64>
    struct Locator{
 800b966:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b96a:	9310      	str	r3, [sp, #64]	; 0x40
 800b96c:	2300      	movs	r3, #0
 800b96e:	9311      	str	r3, [sp, #68]	; 0x44
 800b970:	9312      	str	r3, [sp, #72]	; 0x48
 800b972:	9313      	str	r3, [sp, #76]	; 0x4c
 800b974:	9314      	str	r3, [sp, #80]	; 0x50
 800b976:	9315      	str	r3, [sp, #84]	; 0x54
    if(topicData.readFromUcdrBuffer(cdrBuffer)){
 800b978:	a916      	add	r1, sp, #88	; 0x58
 800b97a:	a801      	add	r0, sp, #4
 800b97c:	f000 fbff 	bl	800c17e <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer>
 800b980:	b118      	cbz	r0, 800b98a <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_17ReaderCacheChangeE+0x5e>
        onNewPublisher(topicData);
 800b982:	a901      	add	r1, sp, #4
 800b984:	4620      	mov	r0, r4
 800b986:	f7ff ff9d 	bl	800b8c4 <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_9TopicDataE>
 800b98a:	4628      	mov	r0, r5
 800b98c:	f7fd fb81 	bl	8009092 <sys_mutex_unlock>
}
 800b990:	b01d      	add	sp, #116	; 0x74
 800b992:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b994:	4628      	mov	r0, r5
 800b996:	f7fd fb7c 	bl	8009092 <sys_mutex_unlock>
 800b99a:	f003 f81e 	bl	800e9da <__cxa_end_cleanup>

0800b99e <_ZN4rtps9SEDPAgent24receiveCallbackPublisherEPvRKNS_17ReaderCacheChangeE>:
void SEDPAgent::receiveCallbackPublisher(void* callee, const ReaderCacheChange& cacheChange){
 800b99e:	b508      	push	{r3, lr}
    agent->onNewPublisher(cacheChange);
 800b9a0:	f7ff ffc4 	bl	800b92c <_ZN4rtps9SEDPAgent14onNewPublisherERKNS_17ReaderCacheChangeE>
}
 800b9a4:	bd08      	pop	{r3, pc}

0800b9a6 <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_9TopicDataE>:
    if(topicData.readFromUcdrBuffer(cdrBuffer)){
        onNewSubscriber(topicData);
    }
}

void SEDPAgent::onNewSubscriber(const TopicData& readerData) {
 800b9a6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b9aa:	b096      	sub	sp, #88	; 0x58
 800b9ac:	4606      	mov	r6, r0
 800b9ae:	460c      	mov	r4, r1
    if(!m_part->findRemoteParticipant(readerData.endpointGuid.prefix)){
 800b9b0:	6800      	ldr	r0, [r0, #0]
 800b9b2:	f002 f9d8 	bl	800dd66 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE>
 800b9b6:	b350      	cbz	r0, 800ba0e <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_9TopicDataE+0x68>
		return;
	}
    Writer* writer = m_part->getMatchingWriter(readerData);
 800b9b8:	4621      	mov	r1, r4
 800b9ba:	6830      	ldr	r0, [r6, #0]
 800b9bc:	f002 f958 	bl	800dc70 <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE>
#if SEDP_VERBOSE
    SEDP_LOG("SUB T/D %s/%s", readerData.topicName, readerData.typeName);
#endif
    if(writer == nullptr) {
 800b9c0:	4607      	mov	r7, r0
 800b9c2:	b320      	cbz	r0, 800ba0e <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_9TopicDataE+0x68>
        }else{
            SEDP_LOG("best-effort ");
        }
        SEDP_LOG("Subscriber\n");
#endif
    writer->addNewMatchedReader(ReaderProxy{readerData.endpointGuid, readerData.unicastLocator});
 800b9c4:	6803      	ldr	r3, [r0, #0]
 800b9c6:	f8d3 8000 	ldr.w	r8, [r3]
        Count_t ackNackCount;

        ReaderProxy() : remoteReaderGuid({GUIDPREFIX_UNKNOWN, ENTITYID_UNKNOWN}){};
        ReaderProxy(const Guid& guid, const Locator& loc)
            : remoteReaderGuid(guid), remoteLocator(loc),
              ackNackSet(), ackNackCount{0}{};
 800b9ca:	466d      	mov	r5, sp
 800b9cc:	6820      	ldr	r0, [r4, #0]
 800b9ce:	6861      	ldr	r1, [r4, #4]
 800b9d0:	68a2      	ldr	r2, [r4, #8]
 800b9d2:	68e3      	ldr	r3, [r4, #12]
 800b9d4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b9d6:	f854 0f3c 	ldr.w	r0, [r4, #60]!
 800b9da:	6861      	ldr	r1, [r4, #4]
 800b9dc:	68a2      	ldr	r2, [r4, #8]
 800b9de:	68e3      	ldr	r3, [r4, #12]
 800b9e0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b9e2:	6920      	ldr	r0, [r4, #16]
 800b9e4:	6961      	ldr	r1, [r4, #20]
 800b9e6:	c503      	stmia	r5!, {r0, r1}
 800b9e8:	2400      	movs	r4, #0
 800b9ea:	940a      	str	r4, [sp, #40]	; 0x28
 800b9ec:	940b      	str	r4, [sp, #44]	; 0x2c
        SequenceNumberSet() = default;
 800b9ee:	2220      	movs	r2, #32
 800b9f0:	920c      	str	r2, [sp, #48]	; 0x30
 800b9f2:	4621      	mov	r1, r4
 800b9f4:	a80d      	add	r0, sp, #52	; 0x34
 800b9f6:	f003 fd51 	bl	800f49c <memset>
 800b9fa:	9415      	str	r4, [sp, #84]	; 0x54
 800b9fc:	4669      	mov	r1, sp
 800b9fe:	4638      	mov	r0, r7
 800ba00:	47c0      	blx	r8
    if(mfp_onNewSubscriberCallback != nullptr){
 800ba02:	f8d6 3154 	ldr.w	r3, [r6, #340]	; 0x154
 800ba06:	b113      	cbz	r3, 800ba0e <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_9TopicDataE+0x68>
        mfp_onNewSubscriberCallback(m_onNewSubscriberArgs);
 800ba08:	f8d6 0158 	ldr.w	r0, [r6, #344]	; 0x158
 800ba0c:	4798      	blx	r3
    }
}
 800ba0e:	b016      	add	sp, #88	; 0x58
 800ba10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800ba14 <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_17ReaderCacheChangeE>:
void SEDPAgent::onNewSubscriber(const ReaderCacheChange& change){
 800ba14:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ba16:	b09d      	sub	sp, #116	; 0x74
 800ba18:	4604      	mov	r4, r0
 800ba1a:	460e      	mov	r6, r1
	Lock lock{m_mutex};
 800ba1c:	1d05      	adds	r5, r0, #4
            sys_mutex_lock(&m_mutex);
 800ba1e:	4628      	mov	r0, r5
 800ba20:	f7fd fb30 	bl	8009084 <sys_mutex_lock>
            if(destSize < size){
 800ba24:	88f2      	ldrh	r2, [r6, #6]
 800ba26:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
 800ba2a:	d80c      	bhi.n	800ba46 <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_17ReaderCacheChangeE+0x32>
 800ba2c:	f104 0708 	add.w	r7, r4, #8
                memcpy(buffer, data, size);
 800ba30:	6831      	ldr	r1, [r6, #0]
 800ba32:	4638      	mov	r0, r7
 800ba34:	f003 fd27 	bl	800f486 <memcpy>
    ucdr_init_buffer(&cdrBuffer, m_buffer, sizeof(m_buffer));
 800ba38:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800ba3c:	4639      	mov	r1, r7
 800ba3e:	a816      	add	r0, sp, #88	; 0x58
 800ba40:	f002 fe20 	bl	800e684 <ucdr_init_buffer>
 800ba44:	e003      	b.n	800ba4e <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_17ReaderCacheChangeE+0x3a>
            sys_mutex_unlock(&m_mutex);
 800ba46:	4628      	mov	r0, r5
 800ba48:	f7fd fb23 	bl	8009092 <sys_mutex_unlock>
 800ba4c:	e014      	b.n	800ba78 <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_17ReaderCacheChangeE+0x64>
 800ba4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ba52:	9310      	str	r3, [sp, #64]	; 0x40
 800ba54:	2300      	movs	r3, #0
 800ba56:	9311      	str	r3, [sp, #68]	; 0x44
 800ba58:	9312      	str	r3, [sp, #72]	; 0x48
 800ba5a:	9313      	str	r3, [sp, #76]	; 0x4c
 800ba5c:	9314      	str	r3, [sp, #80]	; 0x50
 800ba5e:	9315      	str	r3, [sp, #84]	; 0x54
    if(topicData.readFromUcdrBuffer(cdrBuffer)){
 800ba60:	a916      	add	r1, sp, #88	; 0x58
 800ba62:	a801      	add	r0, sp, #4
 800ba64:	f000 fb8b 	bl	800c17e <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer>
 800ba68:	b118      	cbz	r0, 800ba72 <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_17ReaderCacheChangeE+0x5e>
        onNewSubscriber(topicData);
 800ba6a:	a901      	add	r1, sp, #4
 800ba6c:	4620      	mov	r0, r4
 800ba6e:	f7ff ff9a 	bl	800b9a6 <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_9TopicDataE>
 800ba72:	4628      	mov	r0, r5
 800ba74:	f7fd fb0d 	bl	8009092 <sys_mutex_unlock>
}
 800ba78:	b01d      	add	sp, #116	; 0x74
 800ba7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ba7c:	4628      	mov	r0, r5
 800ba7e:	f7fd fb08 	bl	8009092 <sys_mutex_unlock>
 800ba82:	f002 ffaa 	bl	800e9da <__cxa_end_cleanup>

0800ba86 <_ZN4rtps9SEDPAgent25receiveCallbackSubscriberEPvRKNS_17ReaderCacheChangeE>:
void SEDPAgent::receiveCallbackSubscriber(void* callee, const ReaderCacheChange& cacheChange){
 800ba86:	b508      	push	{r3, lr}
    agent->onNewSubscriber(cacheChange);
 800ba88:	f7ff ffc4 	bl	800ba14 <_ZN4rtps9SEDPAgent15onNewSubscriberERKNS_17ReaderCacheChangeE>
}
 800ba8c:	bd08      	pop	{r3, pc}
	...

0800ba90 <_ZN4rtps9SEDPAgent9addWriterERNS_6WriterE>:

void SEDPAgent::addWriter(Writer& writer){
    if(m_endpoints.sedpPubWriter == nullptr){
 800ba90:	f8d0 313c 	ldr.w	r3, [r0, #316]	; 0x13c
 800ba94:	b123      	cbz	r3, 800baa0 <_ZN4rtps9SEDPAgent9addWriterERNS_6WriterE+0x10>
        return;
    }
    EntityKind_t writerKind = writer.m_attributes.endpointGuid.entityId.entityKind;
 800ba96:	7ccb      	ldrb	r3, [r1, #19]
    if(writerKind == EntityKind_t::BUILD_IN_WRITER_WITH_KEY || writerKind == EntityKind_t::BUILD_IN_WRITER_WITHOUT_KEY){
 800ba98:	333e      	adds	r3, #62	; 0x3e
 800ba9a:	b2db      	uxtb	r3, r3
 800ba9c:	2b01      	cmp	r3, #1
 800ba9e:	d800      	bhi.n	800baa2 <_ZN4rtps9SEDPAgent9addWriterERNS_6WriterE+0x12>
 800baa0:	4770      	bx	lr
void SEDPAgent::addWriter(Writer& writer){
 800baa2:	b5f0      	push	{r4, r5, r6, r7, lr}
 800baa4:	b087      	sub	sp, #28
 800baa6:	460d      	mov	r5, r1
 800baa8:	4604      	mov	r4, r0
        return; // No need to announce builtin endpoints
    }

    Lock lock{m_mutex};
 800baaa:	1d06      	adds	r6, r0, #4
            sys_mutex_lock(&m_mutex);
 800baac:	4630      	mov	r0, r6
 800baae:	f7fd fae9 	bl	8009084 <sys_mutex_lock>
    ucdrBuffer microbuffer;
    ucdr_init_buffer(&microbuffer, m_buffer, sizeof(m_buffer)/sizeof(m_buffer[0]));
 800bab2:	f104 0708 	add.w	r7, r4, #8
 800bab6:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800baba:	4639      	mov	r1, r7
 800babc:	4668      	mov	r0, sp
 800babe:	f002 fde1 	bl	800e684 <ucdr_init_buffer>
    const uint16_t zero_options = 0;

    ucdr_serialize_array_uint8_t(&microbuffer, rtps::SMElement::SCHEME_PL_CDR_LE.data(), rtps::SMElement::SCHEME_PL_CDR_LE.size());
 800bac2:	2202      	movs	r2, #2
 800bac4:	4910      	ldr	r1, [pc, #64]	; (800bb08 <_ZN4rtps9SEDPAgent9addWriterERNS_6WriterE+0x78>)
 800bac6:	4668      	mov	r0, sp
 800bac8:	f002 fe39 	bl	800e73e <ucdr_serialize_array_uint8_t>
    ucdr_serialize_uint16_t(&microbuffer, zero_options);
 800bacc:	2100      	movs	r1, #0
 800bace:	4668      	mov	r0, sp
 800bad0:	f002 ff1f 	bl	800e912 <ucdr_serialize_uint16_t>
    writer.m_attributes.serializeIntoUcdrBuffer(microbuffer);
 800bad4:	4669      	mov	r1, sp
 800bad6:	1d28      	adds	r0, r5, #4
 800bad8:	f000 fbd1 	bl	800c27e <_ZNK4rtps9TopicData23serializeIntoUcdrBufferER10ucdrBuffer>
    m_endpoints.sedpPubWriter->newChange(ChangeKind_t::ALIVE, m_buffer, ucdr_buffer_length(&microbuffer));
 800badc:	f8d4 413c 	ldr.w	r4, [r4, #316]	; 0x13c
 800bae0:	6823      	ldr	r3, [r4, #0]
 800bae2:	68dd      	ldr	r5, [r3, #12]
 800bae4:	4668      	mov	r0, sp
 800bae6:	f002 fdf0 	bl	800e6ca <ucdr_buffer_length>
 800baea:	b283      	uxth	r3, r0
 800baec:	463a      	mov	r2, r7
 800baee:	2101      	movs	r1, #1
 800baf0:	4620      	mov	r0, r4
 800baf2:	47a8      	blx	r5
            sys_mutex_unlock(&m_mutex);
 800baf4:	4630      	mov	r0, r6
 800baf6:	f7fd facc 	bl	8009092 <sys_mutex_unlock>
#if SEDP_VERBOSE
    SEDP_LOG("Added new change to sedpPubWriter.\n");
#endif
}
 800bafa:	b007      	add	sp, #28
 800bafc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bafe:	4630      	mov	r0, r6
 800bb00:	f7fd fac7 	bl	8009092 <sys_mutex_unlock>
 800bb04:	f002 ff69 	bl	800e9da <__cxa_end_cleanup>
 800bb08:	08010930 	.word	0x08010930

0800bb0c <_ZN4rtps9SEDPAgent9addReaderERNS_6ReaderE>:

void SEDPAgent::addReader(Reader& reader){
    if(m_endpoints.sedpSubWriter == nullptr){
 800bb0c:	f8d0 3144 	ldr.w	r3, [r0, #324]	; 0x144
 800bb10:	b123      	cbz	r3, 800bb1c <_ZN4rtps9SEDPAgent9addReaderERNS_6ReaderE+0x10>
        return;
    }

    EntityKind_t readerKind = reader.m_attributes.endpointGuid.entityId.entityKind;
 800bb12:	7ccb      	ldrb	r3, [r1, #19]
    if(readerKind == EntityKind_t::BUILD_IN_READER_WITH_KEY || readerKind == EntityKind_t::BUILD_IN_READER_WITHOUT_KEY){
 800bb14:	2bc4      	cmp	r3, #196	; 0xc4
 800bb16:	bf18      	it	ne
 800bb18:	2bc7      	cmpne	r3, #199	; 0xc7
 800bb1a:	d100      	bne.n	800bb1e <_ZN4rtps9SEDPAgent9addReaderERNS_6ReaderE+0x12>
 800bb1c:	4770      	bx	lr
void SEDPAgent::addReader(Reader& reader){
 800bb1e:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bb20:	b087      	sub	sp, #28
 800bb22:	460d      	mov	r5, r1
 800bb24:	4604      	mov	r4, r0
        return; // No need to announce builtin endpoints
    }

    Lock lock{m_mutex};
 800bb26:	1d06      	adds	r6, r0, #4
            sys_mutex_lock(&m_mutex);
 800bb28:	4630      	mov	r0, r6
 800bb2a:	f7fd faab 	bl	8009084 <sys_mutex_lock>
    ucdrBuffer microbuffer;
    ucdr_init_buffer(&microbuffer, m_buffer, sizeof(m_buffer)/sizeof(m_buffer[0]));
 800bb2e:	f104 0708 	add.w	r7, r4, #8
 800bb32:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800bb36:	4639      	mov	r1, r7
 800bb38:	4668      	mov	r0, sp
 800bb3a:	f002 fda3 	bl	800e684 <ucdr_init_buffer>
    const uint16_t zero_options = 0;

    ucdr_serialize_array_uint8_t(&microbuffer, rtps::SMElement::SCHEME_PL_CDR_LE.data(), rtps::SMElement::SCHEME_PL_CDR_LE.size());
 800bb3e:	2202      	movs	r2, #2
 800bb40:	4910      	ldr	r1, [pc, #64]	; (800bb84 <_ZN4rtps9SEDPAgent9addReaderERNS_6ReaderE+0x78>)
 800bb42:	4668      	mov	r0, sp
 800bb44:	f002 fdfb 	bl	800e73e <ucdr_serialize_array_uint8_t>
    ucdr_serialize_uint16_t(&microbuffer, zero_options);
 800bb48:	2100      	movs	r1, #0
 800bb4a:	4668      	mov	r0, sp
 800bb4c:	f002 fee1 	bl	800e912 <ucdr_serialize_uint16_t>
    reader.m_attributes.serializeIntoUcdrBuffer(microbuffer);
 800bb50:	4669      	mov	r1, sp
 800bb52:	1d28      	adds	r0, r5, #4
 800bb54:	f000 fb93 	bl	800c27e <_ZNK4rtps9TopicData23serializeIntoUcdrBufferER10ucdrBuffer>
    m_endpoints.sedpSubWriter->newChange(ChangeKind_t::ALIVE, m_buffer, ucdr_buffer_length(&microbuffer));
 800bb58:	f8d4 4144 	ldr.w	r4, [r4, #324]	; 0x144
 800bb5c:	6823      	ldr	r3, [r4, #0]
 800bb5e:	68dd      	ldr	r5, [r3, #12]
 800bb60:	4668      	mov	r0, sp
 800bb62:	f002 fdb2 	bl	800e6ca <ucdr_buffer_length>
 800bb66:	b283      	uxth	r3, r0
 800bb68:	463a      	mov	r2, r7
 800bb6a:	2101      	movs	r1, #1
 800bb6c:	4620      	mov	r0, r4
 800bb6e:	47a8      	blx	r5
            sys_mutex_unlock(&m_mutex);
 800bb70:	4630      	mov	r0, r6
 800bb72:	f7fd fa8e 	bl	8009092 <sys_mutex_unlock>

#if SEDP_VERBOSE
    SEDP_LOG("Added new change to sedpSubWriter.\n");
#endif
}
 800bb76:	b007      	add	sp, #28
 800bb78:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bb7a:	4630      	mov	r0, r6
 800bb7c:	f7fd fa89 	bl	8009092 <sys_mutex_unlock>
 800bb80:	f002 ff2b 	bl	800e9da <__cxa_end_cleanup>
 800bb84:	08010930 	.word	0x08010930

0800bb88 <_ZN4rtps9SPDPAgent12runBroadcastEPv>:
void SPDPAgent::stop(){
    m_running = false;
}


void SPDPAgent::runBroadcast(void *args){
 800bb88:	b570      	push	{r4, r5, r6, lr}
 800bb8a:	4604      	mov	r4, r0
    SPDPAgent& agent = *static_cast<SPDPAgent*>(args);
    const DataSize_t size = ucdr_buffer_length(&agent.m_microbuffer);
 800bb8c:	f500 60a9 	add.w	r0, r0, #1352	; 0x548
 800bb90:	f002 fd9b 	bl	800e6ca <ucdr_buffer_length>
    agent.m_buildInEndpoints.spdpWriter->newChange(ChangeKind_t::ALIVE, agent.m_microbuffer.init, size);
 800bb94:	6865      	ldr	r5, [r4, #4]
 800bb96:	682b      	ldr	r3, [r5, #0]
 800bb98:	68de      	ldr	r6, [r3, #12]
 800bb9a:	b283      	uxth	r3, r0
 800bb9c:	f8d4 2548 	ldr.w	r2, [r4, #1352]	; 0x548
 800bba0:	2101      	movs	r1, #1
 800bba2:	4628      	mov	r0, r5
 800bba4:	47b0      	blx	r6
    while(agent.m_running){
 800bba6:	7f23      	ldrb	r3, [r4, #28]
 800bba8:	b143      	cbz	r3, 800bbbc <_ZN4rtps9SPDPAgent12runBroadcastEPv+0x34>
        sys_msleep(Config::SPDP_RESEND_PERIOD_MS);
 800bbaa:	f242 7010 	movw	r0, #10000	; 0x2710
 800bbae:	f7fa ffdf 	bl	8006b70 <sys_msleep>
        agent.m_buildInEndpoints.spdpWriter->setAllChangesToUnsent();
 800bbb2:	6860      	ldr	r0, [r4, #4]
 800bbb4:	6803      	ldr	r3, [r0, #0]
 800bbb6:	691b      	ldr	r3, [r3, #16]
 800bbb8:	4798      	blx	r3
    while(agent.m_running){
 800bbba:	e7f4      	b.n	800bba6 <_ZN4rtps9SPDPAgent12runBroadcastEPv+0x1e>
    }
}
 800bbbc:	bd70      	pop	{r4, r5, r6, pc}

0800bbbe <_ZN4rtps9SPDPAgentD1Ev>:
SPDPAgent::~SPDPAgent(){
 800bbbe:	b510      	push	{r4, lr}
 800bbc0:	4604      	mov	r4, r0
    if(initialized){
 800bbc2:	f890 3564 	ldrb.w	r3, [r0, #1380]	; 0x564
 800bbc6:	b90b      	cbnz	r3, 800bbcc <_ZN4rtps9SPDPAgentD1Ev+0xe>
}
 800bbc8:	4620      	mov	r0, r4
 800bbca:	bd10      	pop	{r4, pc}
        sys_mutex_free(&m_mutex);
 800bbcc:	f500 60ac 	add.w	r0, r0, #1376	; 0x560
 800bbd0:	f7fd fa53 	bl	800907a <sys_mutex_free>
 800bbd4:	e7f8      	b.n	800bbc8 <_ZN4rtps9SPDPAgentD1Ev+0xa>
	...

0800bbd8 <_ZN4rtps9SPDPAgent5startEv>:
    if(m_running){
 800bbd8:	7f03      	ldrb	r3, [r0, #28]
 800bbda:	b103      	cbz	r3, 800bbde <_ZN4rtps9SPDPAgent5startEv+0x6>
 800bbdc:	4770      	bx	lr
void SPDPAgent::start(){
 800bbde:	b500      	push	{lr}
 800bbe0:	b083      	sub	sp, #12
 800bbe2:	4602      	mov	r2, r0
    m_running = true;
 800bbe4:	2301      	movs	r3, #1
 800bbe6:	7703      	strb	r3, [r0, #28]
    sys_thread_new("SPDPThread", runBroadcast, this, Config::SPDP_WRITER_STACKSIZE, Config::SPDP_WRITER_PRIO);
 800bbe8:	2303      	movs	r3, #3
 800bbea:	9300      	str	r3, [sp, #0]
 800bbec:	f240 2326 	movw	r3, #550	; 0x226
 800bbf0:	4903      	ldr	r1, [pc, #12]	; (800bc00 <_ZN4rtps9SPDPAgent5startEv+0x28>)
 800bbf2:	4804      	ldr	r0, [pc, #16]	; (800bc04 <_ZN4rtps9SPDPAgent5startEv+0x2c>)
 800bbf4:	f7fd fa52 	bl	800909c <sys_thread_new>
}
 800bbf8:	b003      	add	sp, #12
 800bbfa:	f85d fb04 	ldr.w	pc, [sp], #4
 800bbfe:	bf00      	nop
 800bc00:	0800bb89 	.word	0x0800bb89
 800bc04:	08011c54 	.word	0x08011c54

0800bc08 <_ZN4rtps9SPDPAgent4stopEv>:
    m_running = false;
 800bc08:	2300      	movs	r3, #0
 800bc0a:	7703      	strb	r3, [r0, #28]
}
 800bc0c:	4770      	bx	lr
	...

0800bc10 <_ZN4rtps9SPDPAgent28configureEndianessAndOptionsER10ucdrBuffer>:
    }else{
        // TODO RemoveParticipant
    }
}

void SPDPAgent::configureEndianessAndOptions(ucdrBuffer& buffer){
 800bc10:	b530      	push	{r4, r5, lr}
 800bc12:	b083      	sub	sp, #12
 800bc14:	460d      	mov	r5, r1
    std::array<uint8_t,2> encapsulation{};
 800bc16:	ac02      	add	r4, sp, #8
 800bc18:	2300      	movs	r3, #0
 800bc1a:	f824 3d04 	strh.w	r3, [r4, #-4]!
    // Endianess doesn't matter for this since those are single bytes
    ucdr_deserialize_array_uint8_t(&buffer, encapsulation.data(), encapsulation.size());
 800bc1e:	2202      	movs	r2, #2
 800bc20:	4621      	mov	r1, r4
 800bc22:	4628      	mov	r0, r5
 800bc24:	f002 fd93 	bl	800e74e <ucdr_deserialize_array_uint8_t>
 800bc28:	2202      	movs	r2, #2
 800bc2a:	4908      	ldr	r1, [pc, #32]	; (800bc4c <_ZN4rtps9SPDPAgent28configureEndianessAndOptionsER10ucdrBuffer+0x3c>)
 800bc2c:	4620      	mov	r0, r4
 800bc2e:	f003 fc1b 	bl	800f468 <memcmp>
    if(encapsulation == SMElement::SCHEME_PL_CDR_LE) {
 800bc32:	b140      	cbz	r0, 800bc46 <_ZN4rtps9SPDPAgent28configureEndianessAndOptionsER10ucdrBuffer+0x36>
        buffer.endianness = UCDR_LITTLE_ENDIANNESS;
    }else{
        buffer.endianness = UCDR_BIG_ENDIANNESS;
 800bc34:	2300      	movs	r3, #0
 800bc36:	732b      	strb	r3, [r5, #12]
    }
    // Reuse encapsulation buffer to skip options
    ucdr_deserialize_array_uint8_t(&buffer, encapsulation.data(), encapsulation.size());
 800bc38:	2202      	movs	r2, #2
 800bc3a:	a901      	add	r1, sp, #4
 800bc3c:	4628      	mov	r0, r5
 800bc3e:	f002 fd86 	bl	800e74e <ucdr_deserialize_array_uint8_t>
}
 800bc42:	b003      	add	sp, #12
 800bc44:	bd30      	pop	{r4, r5, pc}
        buffer.endianness = UCDR_LITTLE_ENDIANNESS;
 800bc46:	2301      	movs	r3, #1
 800bc48:	732b      	strb	r3, [r5, #12]
 800bc4a:	e7f5      	b.n	800bc38 <_ZN4rtps9SPDPAgent28configureEndianessAndOptionsER10ucdrBuffer+0x28>
 800bc4c:	08010934 	.word	0x08010934

0800bc50 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv>:
        printf("Failed to add new participant");
#endif
    }
}

bool SPDPAgent::addProxiesForBuiltInEndpoints(){
 800bc50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bc54:	b0a6      	sub	sp, #152	; 0x98
 800bc56:	4606      	mov	r6, r0

	Locator* locator = nullptr;

	// Check if the remote participants has a locator in our subnet
	for(unsigned int i = 0; i < m_proxyDataBuffer.m_metatrafficUnicastLocatorList.size(); i++){
 800bc58:	2500      	movs	r5, #0
 800bc5a:	e000      	b.n	800bc5e <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0xe>
 800bc5c:	3501      	adds	r5, #1
 800bc5e:	2d04      	cmp	r5, #4
 800bc60:	d81a      	bhi.n	800bc98 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x48>
      { return const_cast<_Tp&>(__t[__n]); }
 800bc62:	f506 7457 	add.w	r4, r6, #860	; 0x35c
 800bc66:	006b      	lsls	r3, r5, #1
 800bc68:	1959      	adds	r1, r3, r5
 800bc6a:	00ca      	lsls	r2, r1, #3
 800bc6c:	4414      	add	r4, r2
            return kind != LocatorKind_t::LOCATOR_KIND_INVALID;
 800bc6e:	4432      	add	r2, r6
 800bc70:	f8d2 335c 	ldr.w	r3, [r2, #860]	; 0x35c
		Locator* l = &(m_proxyDataBuffer.m_metatrafficUnicastLocatorList[i]);
		if(l->isValid() && l->isSameSubnet()){
 800bc74:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800bc78:	d0f0      	beq.n	800bc5c <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0xc>
            return transformIP4ToU32(address[12], address[13], address[14], address[15]);
 800bc7a:	7d20      	ldrb	r0, [r4, #20]
 800bc7c:	7d62      	ldrb	r2, [r4, #21]
 800bc7e:	7da3      	ldrb	r3, [r4, #22]
 800bc80:	7de1      	ldrb	r1, [r4, #23]
                ((uint32_t) (p1 << 16)) |
 800bc82:	041b      	lsls	r3, r3, #16
        return {((uint32_t) (LSB << 24)) |
 800bc84:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
                ((uint32_t) (p1 << 16)) |
 800bc88:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        }

        inline bool isSameSubnet() const{
        	return UdpDriver::isSameSubnet(getIp4Address());
 800bc8c:	4318      	orrs	r0, r3
 800bc8e:	f7ff fb9b 	bl	800b3c8 <_ZN4rtps9UdpDriver12isSameSubnetE8ip4_addr>
 800bc92:	2800      	cmp	r0, #0
 800bc94:	d0e2      	beq.n	800bc5c <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0xc>
 800bc96:	e000      	b.n	800bc9a <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x4a>
	Locator* locator = nullptr;
 800bc98:	2400      	movs	r4, #0
	        locator = l;
	        break;
		}
	}

	if(!locator){
 800bc9a:	2c00      	cmp	r4, #0
 800bc9c:	f000 80d3 	beq.w	800be46 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x1f6>
    bool ParticipantProxyData::hasParticipantReader(){
        return (m_availableBuiltInEndpoints & DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR) != 0;
    }

    bool ParticipantProxyData::hasPublicationWriter(){
        return (m_availableBuiltInEndpoints & DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER) != 0;
 800bca0:	f8d6 3358 	ldr.w	r3, [r6, #856]	; 0x358
		return false;
	}


    if (m_proxyDataBuffer.hasPublicationWriter()){
 800bca4:	f013 0f04 	tst.w	r3, #4
 800bca8:	d113      	bne.n	800bcd2 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x82>
    bool ParticipantProxyData::hasPublicationReader(){
        return (m_availableBuiltInEndpoints & DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR) != 0;
    }

    bool ParticipantProxyData::hasSubscriptionWriter(){
        return (m_availableBuiltInEndpoints & DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER) != 0;
 800bcaa:	f8d6 3358 	ldr.w	r3, [r6, #856]	; 0x358
        const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER}, *locator};
        m_buildInEndpoints.sedpPubReader->addNewMatchedWriter(proxy);
    }

    if (m_proxyDataBuffer.hasSubscriptionWriter()){
 800bcae:	f013 0f10 	tst.w	r3, #16
 800bcb2:	d13a      	bne.n	800bd2a <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0xda>
        return (m_availableBuiltInEndpoints & DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR) != 0;
 800bcb4:	f8d6 3358 	ldr.w	r3, [r6, #856]	; 0x358
        const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_WRITER}, *locator};
        m_buildInEndpoints.sedpSubReader->addNewMatchedWriter(proxy);
    }

    if(m_proxyDataBuffer.hasPublicationReader()){
 800bcb8:	f013 0f08 	tst.w	r3, #8
 800bcbc:	d161      	bne.n	800bd82 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x132>
    }

    bool ParticipantProxyData::hasSubscriptionReader(){
        return (m_availableBuiltInEndpoints & DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR) != 0;
 800bcbe:	f8d6 3358 	ldr.w	r3, [r6, #856]	; 0x358
        const ReaderProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER}, *locator};
        m_buildInEndpoints.sedpPubWriter->addNewMatchedReader(proxy);
    }

    if(m_proxyDataBuffer.hasSubscriptionReader()){
 800bcc2:	f013 0f20 	tst.w	r3, #32
 800bcc6:	f040 808c 	bne.w	800bde2 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x192>
        const ReaderProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_READER}, *locator};
        m_buildInEndpoints.sedpSubWriter->addNewMatchedReader(proxy);
    }

    return true;
 800bcca:	2001      	movs	r0, #1
}
 800bccc:	b026      	add	sp, #152	; 0x98
 800bcce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER}, *locator};
 800bcd2:	ab16      	add	r3, sp, #88	; 0x58
 800bcd4:	f8d6 0342 	ldr.w	r0, [r6, #834]	; 0x342
 800bcd8:	f8d6 1346 	ldr.w	r1, [r6, #838]	; 0x346
 800bcdc:	f8d6 234a 	ldr.w	r2, [r6, #842]	; 0x34a
 800bce0:	c307      	stmia	r3!, {r0, r1, r2}
 800bce2:	2500      	movs	r5, #0
 800bce4:	f88d 5064 	strb.w	r5, [sp, #100]	; 0x64
 800bce8:	f88d 5065 	strb.w	r5, [sp, #101]	; 0x65
 800bcec:	2303      	movs	r3, #3
 800bcee:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
 800bcf2:	23c2      	movs	r3, #194	; 0xc2
 800bcf4:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
 800bcf8:	466f      	mov	r7, sp
 800bcfa:	ab16      	add	r3, sp, #88	; 0x58
 800bcfc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800bcfe:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
 800bd02:	9504      	str	r5, [sp, #16]
 800bd04:	2301      	movs	r3, #1
 800bd06:	9305      	str	r3, [sp, #20]
 800bd08:	9306      	str	r3, [sp, #24]
 800bd0a:	9507      	str	r5, [sp, #28]
 800bd0c:	ad08      	add	r5, sp, #32
 800bd0e:	6820      	ldr	r0, [r4, #0]
 800bd10:	6861      	ldr	r1, [r4, #4]
 800bd12:	68a2      	ldr	r2, [r4, #8]
 800bd14:	68e3      	ldr	r3, [r4, #12]
 800bd16:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800bd18:	6920      	ldr	r0, [r4, #16]
 800bd1a:	6961      	ldr	r1, [r4, #20]
 800bd1c:	c503      	stmia	r5!, {r0, r1}
        m_buildInEndpoints.sedpPubReader->addNewMatchedWriter(proxy);
 800bd1e:	6930      	ldr	r0, [r6, #16]
 800bd20:	6803      	ldr	r3, [r0, #0]
 800bd22:	68db      	ldr	r3, [r3, #12]
 800bd24:	4639      	mov	r1, r7
 800bd26:	4798      	blx	r3
 800bd28:	e7bf      	b.n	800bcaa <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x5a>
        const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_WRITER}, *locator};
 800bd2a:	ab1a      	add	r3, sp, #104	; 0x68
 800bd2c:	f8d6 0342 	ldr.w	r0, [r6, #834]	; 0x342
 800bd30:	f8d6 1346 	ldr.w	r1, [r6, #838]	; 0x346
 800bd34:	f8d6 234a 	ldr.w	r2, [r6, #842]	; 0x34a
 800bd38:	c307      	stmia	r3!, {r0, r1, r2}
 800bd3a:	2500      	movs	r5, #0
 800bd3c:	f88d 5074 	strb.w	r5, [sp, #116]	; 0x74
 800bd40:	f88d 5075 	strb.w	r5, [sp, #117]	; 0x75
 800bd44:	2304      	movs	r3, #4
 800bd46:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
 800bd4a:	23c2      	movs	r3, #194	; 0xc2
 800bd4c:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
 800bd50:	466f      	mov	r7, sp
 800bd52:	ab1a      	add	r3, sp, #104	; 0x68
 800bd54:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800bd56:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
 800bd5a:	9504      	str	r5, [sp, #16]
 800bd5c:	2301      	movs	r3, #1
 800bd5e:	9305      	str	r3, [sp, #20]
 800bd60:	9306      	str	r3, [sp, #24]
 800bd62:	9507      	str	r5, [sp, #28]
 800bd64:	ad08      	add	r5, sp, #32
 800bd66:	6820      	ldr	r0, [r4, #0]
 800bd68:	6861      	ldr	r1, [r4, #4]
 800bd6a:	68a2      	ldr	r2, [r4, #8]
 800bd6c:	68e3      	ldr	r3, [r4, #12]
 800bd6e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800bd70:	6920      	ldr	r0, [r4, #16]
 800bd72:	6961      	ldr	r1, [r4, #20]
 800bd74:	c503      	stmia	r5!, {r0, r1}
        m_buildInEndpoints.sedpSubReader->addNewMatchedWriter(proxy);
 800bd76:	69b0      	ldr	r0, [r6, #24]
 800bd78:	6803      	ldr	r3, [r0, #0]
 800bd7a:	68db      	ldr	r3, [r3, #12]
 800bd7c:	4639      	mov	r1, r7
 800bd7e:	4798      	blx	r3
 800bd80:	e798      	b.n	800bcb4 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x64>
        const ReaderProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER}, *locator};
 800bd82:	ab1e      	add	r3, sp, #120	; 0x78
 800bd84:	f8d6 0342 	ldr.w	r0, [r6, #834]	; 0x342
 800bd88:	f8d6 1346 	ldr.w	r1, [r6, #838]	; 0x346
 800bd8c:	f8d6 234a 	ldr.w	r2, [r6, #842]	; 0x34a
 800bd90:	c307      	stmia	r3!, {r0, r1, r2}
 800bd92:	2700      	movs	r7, #0
 800bd94:	f88d 7084 	strb.w	r7, [sp, #132]	; 0x84
 800bd98:	f88d 7085 	strb.w	r7, [sp, #133]	; 0x85
 800bd9c:	2303      	movs	r3, #3
 800bd9e:	f88d 3086 	strb.w	r3, [sp, #134]	; 0x86
 800bda2:	23c7      	movs	r3, #199	; 0xc7
 800bda4:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
 800bda8:	46e8      	mov	r8, sp
 800bdaa:	ab1e      	add	r3, sp, #120	; 0x78
 800bdac:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800bdae:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
 800bdb2:	ad04      	add	r5, sp, #16
 800bdb4:	6820      	ldr	r0, [r4, #0]
 800bdb6:	6861      	ldr	r1, [r4, #4]
 800bdb8:	68a2      	ldr	r2, [r4, #8]
 800bdba:	68e3      	ldr	r3, [r4, #12]
 800bdbc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800bdbe:	6920      	ldr	r0, [r4, #16]
 800bdc0:	6961      	ldr	r1, [r4, #20]
 800bdc2:	c503      	stmia	r5!, {r0, r1}
 800bdc4:	970a      	str	r7, [sp, #40]	; 0x28
 800bdc6:	970b      	str	r7, [sp, #44]	; 0x2c
 800bdc8:	2220      	movs	r2, #32
 800bdca:	920c      	str	r2, [sp, #48]	; 0x30
 800bdcc:	4639      	mov	r1, r7
 800bdce:	a80d      	add	r0, sp, #52	; 0x34
 800bdd0:	f003 fb64 	bl	800f49c <memset>
 800bdd4:	9715      	str	r7, [sp, #84]	; 0x54
        m_buildInEndpoints.sedpPubWriter->addNewMatchedReader(proxy);
 800bdd6:	68f0      	ldr	r0, [r6, #12]
 800bdd8:	6803      	ldr	r3, [r0, #0]
 800bdda:	681b      	ldr	r3, [r3, #0]
 800bddc:	4641      	mov	r1, r8
 800bdde:	4798      	blx	r3
 800bde0:	e76d      	b.n	800bcbe <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x6e>
        const ReaderProxy proxy{{m_proxyDataBuffer.m_guid.prefix, ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_READER}, *locator};
 800bde2:	ab22      	add	r3, sp, #136	; 0x88
 800bde4:	f8d6 0342 	ldr.w	r0, [r6, #834]	; 0x342
 800bde8:	f8d6 1346 	ldr.w	r1, [r6, #838]	; 0x346
 800bdec:	f8d6 234a 	ldr.w	r2, [r6, #842]	; 0x34a
 800bdf0:	c307      	stmia	r3!, {r0, r1, r2}
 800bdf2:	2700      	movs	r7, #0
 800bdf4:	f88d 7094 	strb.w	r7, [sp, #148]	; 0x94
 800bdf8:	f88d 7095 	strb.w	r7, [sp, #149]	; 0x95
 800bdfc:	2304      	movs	r3, #4
 800bdfe:	f88d 3096 	strb.w	r3, [sp, #150]	; 0x96
 800be02:	23c7      	movs	r3, #199	; 0xc7
 800be04:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
 800be08:	46e8      	mov	r8, sp
 800be0a:	ab26      	add	r3, sp, #152	; 0x98
 800be0c:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 800be10:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
 800be14:	ad04      	add	r5, sp, #16
 800be16:	6820      	ldr	r0, [r4, #0]
 800be18:	6861      	ldr	r1, [r4, #4]
 800be1a:	68a2      	ldr	r2, [r4, #8]
 800be1c:	68e3      	ldr	r3, [r4, #12]
 800be1e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800be20:	6920      	ldr	r0, [r4, #16]
 800be22:	6961      	ldr	r1, [r4, #20]
 800be24:	c503      	stmia	r5!, {r0, r1}
 800be26:	970a      	str	r7, [sp, #40]	; 0x28
 800be28:	970b      	str	r7, [sp, #44]	; 0x2c
 800be2a:	2220      	movs	r2, #32
 800be2c:	920c      	str	r2, [sp, #48]	; 0x30
 800be2e:	4639      	mov	r1, r7
 800be30:	a80d      	add	r0, sp, #52	; 0x34
 800be32:	f003 fb33 	bl	800f49c <memset>
 800be36:	9715      	str	r7, [sp, #84]	; 0x54
        m_buildInEndpoints.sedpSubWriter->addNewMatchedReader(proxy);
 800be38:	6970      	ldr	r0, [r6, #20]
 800be3a:	6803      	ldr	r3, [r0, #0]
 800be3c:	681b      	ldr	r3, [r3, #0]
 800be3e:	4641      	mov	r1, r8
 800be40:	4798      	blx	r3
    return true;
 800be42:	2001      	movs	r0, #1
 800be44:	e742      	b.n	800bccc <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x7c>
		return false;
 800be46:	2000      	movs	r0, #0
 800be48:	e740      	b.n	800bccc <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv+0x7c>

0800be4a <_ZN4rtps9SPDPAgent16processProxyDataEv>:
void SPDPAgent::processProxyData(){
 800be4a:	b538      	push	{r3, r4, r5, lr}
    if(m_proxyDataBuffer.m_guid.prefix.id == mp_participant->m_guidPrefix.id){
 800be4c:	6805      	ldr	r5, [r0, #0]

      _GLIBCXX17_CONSTEXPR const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
 800be4e:	f200 3342 	addw	r3, r0, #834	; 0x342
      { return const_iterator(data() + _Nm); }
 800be52:	f200 324e 	addw	r2, r0, #846	; 0x34e
	  if (const size_t __len = (__last1 - __first1))
 800be56:	1ad2      	subs	r2, r2, r3
 800be58:	d005      	beq.n	800be66 <_ZN4rtps9SPDPAgent16processProxyDataEv+0x1c>
 800be5a:	4604      	mov	r4, r0
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800be5c:	4629      	mov	r1, r5
 800be5e:	4618      	mov	r0, r3
 800be60:	f003 fb02 	bl	800f468 <memcmp>
 800be64:	b900      	cbnz	r0, 800be68 <_ZN4rtps9SPDPAgent16processProxyDataEv+0x1e>
}
 800be66:	bd38      	pop	{r3, r4, r5, pc}
    if(mp_participant->findRemoteParticipant(m_proxyDataBuffer.m_guid.prefix) != nullptr){
 800be68:	f204 3142 	addw	r1, r4, #834	; 0x342
 800be6c:	4628      	mov	r0, r5
 800be6e:	f001 ff7a 	bl	800dd66 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE>
 800be72:	b120      	cbz	r0, 800be7e <_ZN4rtps9SPDPAgent16processProxyDataEv+0x34>
    	 m_buildInEndpoints.spdpWriter->setAllChangesToUnsent();
 800be74:	6860      	ldr	r0, [r4, #4]
 800be76:	6803      	ldr	r3, [r0, #0]
 800be78:	691b      	ldr	r3, [r3, #16]
 800be7a:	4798      	blx	r3
    	return; // Already in our list
 800be7c:	e7f3      	b.n	800be66 <_ZN4rtps9SPDPAgent16processProxyDataEv+0x1c>
    if(mp_participant->addNewRemoteParticipant(m_proxyDataBuffer)) {
 800be7e:	f504 7150 	add.w	r1, r4, #832	; 0x340
 800be82:	6820      	ldr	r0, [r4, #0]
 800be84:	f001 ff3c 	bl	800dd00 <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE>
 800be88:	2800      	cmp	r0, #0
 800be8a:	d0ec      	beq.n	800be66 <_ZN4rtps9SPDPAgent16processProxyDataEv+0x1c>
    	addProxiesForBuiltInEndpoints();
 800be8c:	4620      	mov	r0, r4
 800be8e:	f7ff fedf 	bl	800bc50 <_ZN4rtps9SPDPAgent29addProxiesForBuiltInEndpointsEv>
        m_buildInEndpoints.spdpWriter->setAllChangesToUnsent();
 800be92:	6860      	ldr	r0, [r4, #4]
 800be94:	6803      	ldr	r3, [r0, #0]
 800be96:	691b      	ldr	r3, [r3, #16]
 800be98:	4798      	blx	r3
 800be9a:	e7e4      	b.n	800be66 <_ZN4rtps9SPDPAgent16processProxyDataEv+0x1c>

0800be9c <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE>:
    if(!initialized){
 800be9c:	f890 3564 	ldrb.w	r3, [r0, #1380]	; 0x564
 800bea0:	b903      	cbnz	r3, 800bea4 <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE+0x8>
 800bea2:	4770      	bx	lr
void SPDPAgent::handleSPDPPackage(const ReaderCacheChange& cacheChange){
 800bea4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bea6:	b089      	sub	sp, #36	; 0x24
 800bea8:	460d      	mov	r5, r1
 800beaa:	4604      	mov	r4, r0
    Lock lock{m_mutex};
 800beac:	f500 66ac 	add.w	r6, r0, #1376	; 0x560
            sys_mutex_lock(&m_mutex);
 800beb0:	4630      	mov	r0, r6
 800beb2:	f7fd f8e7 	bl	8009084 <sys_mutex_lock>
    if(cacheChange.size > m_inputBuffer.size()){
 800beb6:	88ea      	ldrh	r2, [r5, #6]
 800beb8:	f5b2 7fc8 	cmp.w	r2, #400	; 0x190
 800bebc:	d826      	bhi.n	800bf0c <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE+0x70>
      { return _AT_Type::_S_ptr(_M_elems); }
 800bebe:	f204 17ad 	addw	r7, r4, #429	; 0x1ad
 800bec2:	6829      	ldr	r1, [r5, #0]
 800bec4:	4638      	mov	r0, r7
 800bec6:	f003 fade 	bl	800f486 <memcpy>
    ucdr_init_buffer(&buffer, m_inputBuffer.data(), m_inputBuffer.size());
 800beca:	f44f 72c8 	mov.w	r2, #400	; 0x190
 800bece:	4639      	mov	r1, r7
 800bed0:	a802      	add	r0, sp, #8
 800bed2:	f002 fbd7 	bl	800e684 <ucdr_init_buffer>
    if(cacheChange.kind == ChangeKind_t::ALIVE){
 800bed6:	792b      	ldrb	r3, [r5, #4]
 800bed8:	2b01      	cmp	r3, #1
 800beda:	d004      	beq.n	800bee6 <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE+0x4a>
            sys_mutex_unlock(&m_mutex);
 800bedc:	4630      	mov	r0, r6
 800bede:	f7fd f8d8 	bl	8009092 <sys_mutex_unlock>
}
 800bee2:	b009      	add	sp, #36	; 0x24
 800bee4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        configureEndianessAndOptions(buffer);
 800bee6:	a902      	add	r1, sp, #8
 800bee8:	4620      	mov	r0, r4
 800beea:	f7ff fe91 	bl	800bc10 <_ZN4rtps9SPDPAgent28configureEndianessAndOptionsER10ucdrBuffer>
        volatile bool success = m_proxyDataBuffer.readFromUcdrBuffer(buffer);
 800beee:	a902      	add	r1, sp, #8
 800bef0:	f504 7050 	add.w	r0, r4, #832	; 0x340
 800bef4:	f7ff fb1a 	bl	800b52c <_ZN4rtps20ParticipantProxyData18readFromUcdrBufferER10ucdrBuffer>
 800bef8:	f88d 0007 	strb.w	r0, [sp, #7]
        if(success){
 800befc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800bf00:	2b00      	cmp	r3, #0
 800bf02:	d0eb      	beq.n	800bedc <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE+0x40>
            processProxyData();
 800bf04:	4620      	mov	r0, r4
 800bf06:	f7ff ffa0 	bl	800be4a <_ZN4rtps9SPDPAgent16processProxyDataEv>
 800bf0a:	e7e7      	b.n	800bedc <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE+0x40>
 800bf0c:	4630      	mov	r0, r6
 800bf0e:	f7fd f8c0 	bl	8009092 <sys_mutex_unlock>
 800bf12:	e7e6      	b.n	800bee2 <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE+0x46>
 800bf14:	4630      	mov	r0, r6
 800bf16:	f7fd f8bc 	bl	8009092 <sys_mutex_unlock>
 800bf1a:	f002 fd5e 	bl	800e9da <__cxa_end_cleanup>

0800bf1e <_ZN4rtps9SPDPAgent15receiveCallbackEPvRKNS_17ReaderCacheChangeE>:
void SPDPAgent::receiveCallback(void *callee, const ReaderCacheChange& cacheChange) {
 800bf1e:	b508      	push	{r3, lr}
    agent->handleSPDPPackage(cacheChange);
 800bf20:	f7ff ffbc 	bl	800be9c <_ZN4rtps9SPDPAgent17handleSPDPPackageERKNS_17ReaderCacheChangeE>
}
 800bf24:	bd08      	pop	{r3, pc}

0800bf26 <_ZN4rtps9SPDPAgent14endCurrentListEv>:
    ucdr_serialize_uint8_t(&m_microbuffer,       static_cast<uint8_t>(ENTITYID_BUILD_IN_PARTICIPANT.entityKind));

    endCurrentList();
}

void SPDPAgent::endCurrentList(){
 800bf26:	b510      	push	{r4, lr}
    ucdr_serialize_uint16_t(&m_microbuffer, ParameterId::PID_SENTINEL);
 800bf28:	f500 64a9 	add.w	r4, r0, #1352	; 0x548
 800bf2c:	2101      	movs	r1, #1
 800bf2e:	4620      	mov	r0, r4
 800bf30:	f002 fcef 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer, 0);
 800bf34:	2100      	movs	r1, #0
 800bf36:	4620      	mov	r0, r4
 800bf38:	f002 fceb 	bl	800e912 <ucdr_serialize_uint16_t>
}
 800bf3c:	bd10      	pop	{r4, pc}
	...

0800bf40 <_ZN4rtps9SPDPAgent24addParticipantParametersEv>:

void SPDPAgent::addParticipantParameters(){
 800bf40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bf44:	b092      	sub	sp, #72	; 0x48
 800bf46:	4606      	mov	r6, r0
    const uint16_t entityKeySize = 3;
    const uint16_t entityKindSize = 1;
    const uint16_t entityIdSize = entityKeySize + entityKindSize;
    const uint16_t guidSize = sizeof(GuidPrefix_t::id) + entityIdSize;

    const Locator userUniCastLocator = getUserUnicastLocator(mp_participant->m_participantId);
 800bf48:	6807      	ldr	r7, [r0, #0]
 800bf4a:	f997 200c 	ldrsb.w	r2, [r7, #12]

    constexpr Ip4Port_t getUserUnicastPort(ParticipantId_t participantId) {
        return PB +
               DG * Config::DOMAIN_ID +
               D3 +
               PG * participantId;
 800bf4e:	0052      	lsls	r2, r2, #1
 800bf50:	b292      	uxth	r2, r2
 800bf52:	f641 43f3 	movw	r3, #7411	; 0x1cf3
 800bf56:	4413      	add	r3, r2
 800bf58:	b29b      	uxth	r3, r3
    struct Locator{
 800bf5a:	2500      	movs	r5, #0
 800bf5c:	950e      	str	r5, [sp, #56]	; 0x38
 800bf5e:	950f      	str	r5, [sp, #60]	; 0x3c
 800bf60:	9510      	str	r5, [sp, #64]	; 0x40
            locator.kind = LocatorKind_t::LOCATOR_KIND_UDPv4;
 800bf62:	2201      	movs	r2, #1
 800bf64:	920c      	str	r2, [sp, #48]	; 0x30
            locator.address = {0,0,0,0,0,0,0,0,0,0,0,0,a,b,c,d};
 800bf66:	24c0      	movs	r4, #192	; 0xc0
 800bf68:	f88d 4044 	strb.w	r4, [sp, #68]	; 0x44
 800bf6c:	20a8      	movs	r0, #168	; 0xa8
 800bf6e:	f88d 0045 	strb.w	r0, [sp, #69]	; 0x45
 800bf72:	f88d 5046 	strb.w	r5, [sp, #70]	; 0x46
 800bf76:	212f      	movs	r1, #47	; 0x2f
 800bf78:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
            locator.port = port;
 800bf7c:	930d      	str	r3, [sp, #52]	; 0x34
    const Locator builtInUniCastLocator = getBuiltInUnicastLocator(mp_participant->m_participantId);
 800bf7e:	f997 300c 	ldrsb.w	r3, [r7, #12]
               D1 +
 800bf82:	f603 6379 	addw	r3, r3, #3705	; 0xe79
               PG * participantId;
 800bf86:	4093      	lsls	r3, r2
 800bf88:	b29b      	uxth	r3, r3
    struct Locator{
 800bf8a:	9508      	str	r5, [sp, #32]
 800bf8c:	9509      	str	r5, [sp, #36]	; 0x24
 800bf8e:	950a      	str	r5, [sp, #40]	; 0x28
            locator.kind = LocatorKind_t::LOCATOR_KIND_UDPv4;
 800bf90:	9206      	str	r2, [sp, #24]
            locator.address = {0,0,0,0,0,0,0,0,0,0,0,0,a,b,c,d};
 800bf92:	f88d 402c 	strb.w	r4, [sp, #44]	; 0x2c
 800bf96:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
 800bf9a:	f88d 502e 	strb.w	r5, [sp, #46]	; 0x2e
 800bf9e:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
            locator.port = port;
 800bfa2:	9307      	str	r3, [sp, #28]
    struct Locator{
 800bfa4:	9502      	str	r5, [sp, #8]
 800bfa6:	9503      	str	r5, [sp, #12]
 800bfa8:	9504      	str	r5, [sp, #16]
            locator.kind = LocatorKind_t::LOCATOR_KIND_UDPv4;
 800bfaa:	9200      	str	r2, [sp, #0]
            locator.address = {0,0,0,0,0,0,0,0,0,0,0,0,a,b,c,d};
 800bfac:	23ef      	movs	r3, #239	; 0xef
 800bfae:	f88d 3014 	strb.w	r3, [sp, #20]
 800bfb2:	23ff      	movs	r3, #255	; 0xff
 800bfb4:	f88d 3015 	strb.w	r3, [sp, #21]
 800bfb8:	f88d 5016 	strb.w	r5, [sp, #22]
 800bfbc:	f88d 2017 	strb.w	r2, [sp, #23]
            locator.port = port;
 800bfc0:	f641 43e8 	movw	r3, #7400	; 0x1ce8
 800bfc4:	9301      	str	r3, [sp, #4]
    const Locator builtInMultiCastLocator = getBuiltInMulticastLocator();

    ucdr_serialize_array_uint8_t(&m_microbuffer, rtps::SMElement::SCHEME_PL_CDR_LE.data(), rtps::SMElement::SCHEME_PL_CDR_LE.size());
 800bfc6:	f506 64a9 	add.w	r4, r6, #1352	; 0x548
 800bfca:	f8df 8130 	ldr.w	r8, [pc, #304]	; 800c0fc <_ZN4rtps9SPDPAgent24addParticipantParametersEv+0x1bc>
 800bfce:	2202      	movs	r2, #2
 800bfd0:	4641      	mov	r1, r8
 800bfd2:	4620      	mov	r0, r4
 800bfd4:	f002 fbb3 	bl	800e73e <ucdr_serialize_array_uint8_t>
    ucdr_serialize_uint16_t(&m_microbuffer, zero_options);
 800bfd8:	4629      	mov	r1, r5
 800bfda:	4620      	mov	r0, r4
 800bfdc:	f002 fc99 	bl	800e912 <ucdr_serialize_uint16_t>

    ucdr_serialize_uint16_t(&m_microbuffer, ParameterId::PID_PROTOCOL_VERSION);
 800bfe0:	2115      	movs	r1, #21
 800bfe2:	4620      	mov	r0, r4
 800bfe4:	f002 fc95 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer, protocolVersionSize + 2);
 800bfe8:	2104      	movs	r1, #4
 800bfea:	4620      	mov	r0, r4
 800bfec:	f002 fc91 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint8_t(&m_microbuffer,  PROTOCOLVERSION.major);
 800bff0:	2102      	movs	r1, #2
 800bff2:	4620      	mov	r0, r4
 800bff4:	f002 fc82 	bl	800e8fc <ucdr_serialize_uint8_t>
    ucdr_serialize_uint8_t(&m_microbuffer,  PROTOCOLVERSION.minor);
 800bff8:	2102      	movs	r1, #2
 800bffa:	4620      	mov	r0, r4
 800bffc:	f002 fc7e 	bl	800e8fc <ucdr_serialize_uint8_t>
    m_microbuffer.iterator += 2;      // padding
 800c000:	f8d6 3550 	ldr.w	r3, [r6, #1360]	; 0x550
 800c004:	3302      	adds	r3, #2
 800c006:	f8c6 3550 	str.w	r3, [r6, #1360]	; 0x550
    m_microbuffer.last_data_size = 4; // to 4 byte
 800c00a:	2704      	movs	r7, #4
 800c00c:	f8c6 7558 	str.w	r7, [r6, #1368]	; 0x558

    ucdr_serialize_uint16_t(&m_microbuffer,      ParameterId::PID_VENDORID);
 800c010:	2116      	movs	r1, #22
 800c012:	4620      	mov	r0, r4
 800c014:	f002 fc7d 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer,      vendorIdSize + 2);
 800c018:	4639      	mov	r1, r7
 800c01a:	4620      	mov	r0, r4
 800c01c:	f002 fc79 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_array_uint8_t(&m_microbuffer, Config::VENDOR_ID.vendorId.data(), vendorIdSize);
 800c020:	2202      	movs	r2, #2
 800c022:	f108 0108 	add.w	r1, r8, #8
 800c026:	4620      	mov	r0, r4
 800c028:	f002 fb89 	bl	800e73e <ucdr_serialize_array_uint8_t>
    m_microbuffer.iterator += 2;      // padding
 800c02c:	f8d6 3550 	ldr.w	r3, [r6, #1360]	; 0x550
 800c030:	3302      	adds	r3, #2
 800c032:	f8c6 3550 	str.w	r3, [r6, #1360]	; 0x550
    m_microbuffer.last_data_size = 4; // to 4 byte
 800c036:	f8c6 7558 	str.w	r7, [r6, #1368]	; 0x558

    ucdr_serialize_uint16_t(&m_microbuffer,      ParameterId::PID_DEFAULT_UNICAST_LOCATOR);
 800c03a:	2131      	movs	r1, #49	; 0x31
 800c03c:	4620      	mov	r0, r4
 800c03e:	f002 fc68 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer,      locatorSize);
 800c042:	2118      	movs	r1, #24
 800c044:	4620      	mov	r0, r4
 800c046:	f002 fc64 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_array_uint8_t(&m_microbuffer, reinterpret_cast<const uint8_t*>(&userUniCastLocator), locatorSize);
 800c04a:	2218      	movs	r2, #24
 800c04c:	a90c      	add	r1, sp, #48	; 0x30
 800c04e:	4620      	mov	r0, r4
 800c050:	f002 fb75 	bl	800e73e <ucdr_serialize_array_uint8_t>

    ucdr_serialize_uint16_t(&m_microbuffer,      ParameterId::PID_METATRAFFIC_UNICAST_LOCATOR);
 800c054:	2132      	movs	r1, #50	; 0x32
 800c056:	4620      	mov	r0, r4
 800c058:	f002 fc5b 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer,      locatorSize);
 800c05c:	2118      	movs	r1, #24
 800c05e:	4620      	mov	r0, r4
 800c060:	f002 fc57 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_array_uint8_t(&m_microbuffer, reinterpret_cast<const uint8_t*>(&builtInUniCastLocator), locatorSize);
 800c064:	2218      	movs	r2, #24
 800c066:	eb0d 0102 	add.w	r1, sp, r2
 800c06a:	4620      	mov	r0, r4
 800c06c:	f002 fb67 	bl	800e73e <ucdr_serialize_array_uint8_t>

    ucdr_serialize_uint16_t(&m_microbuffer,      ParameterId::PID_METATRAFFIC_MULTICAST_LOCATOR);
 800c070:	2133      	movs	r1, #51	; 0x33
 800c072:	4620      	mov	r0, r4
 800c074:	f002 fc4d 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer,      locatorSize);
 800c078:	2118      	movs	r1, #24
 800c07a:	4620      	mov	r0, r4
 800c07c:	f002 fc49 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_array_uint8_t(&m_microbuffer, reinterpret_cast<const uint8_t*>(&builtInMultiCastLocator), locatorSize);
 800c080:	2218      	movs	r2, #24
 800c082:	4669      	mov	r1, sp
 800c084:	4620      	mov	r0, r4
 800c086:	f002 fb5a 	bl	800e73e <ucdr_serialize_array_uint8_t>

    ucdr_serialize_uint16_t(&m_microbuffer,      ParameterId::PID_PARTICIPANT_LEASE_DURATION);
 800c08a:	2102      	movs	r1, #2
 800c08c:	4620      	mov	r0, r4
 800c08e:	f002 fc40 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer,      durationSize);
 800c092:	2108      	movs	r1, #8
 800c094:	4620      	mov	r0, r4
 800c096:	f002 fc3c 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_int32_t(&m_microbuffer,       Config::SPDP_LEASE_DURATION.seconds);
 800c09a:	2164      	movs	r1, #100	; 0x64
 800c09c:	4620      	mov	r0, r4
 800c09e:	f002 fc4e 	bl	800e93e <ucdr_serialize_int32_t>
    ucdr_serialize_uint32_t(&m_microbuffer,      Config::SPDP_LEASE_DURATION.fraction);
 800c0a2:	4629      	mov	r1, r5
 800c0a4:	4620      	mov	r0, r4
 800c0a6:	f002 fc3f 	bl	800e928 <ucdr_serialize_uint32_t>

    ucdr_serialize_uint16_t(&m_microbuffer,      ParameterId::PID_PARTICIPANT_GUID);
 800c0aa:	2150      	movs	r1, #80	; 0x50
 800c0ac:	4620      	mov	r0, r4
 800c0ae:	f002 fc30 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer,      guidSize);
 800c0b2:	2110      	movs	r1, #16
 800c0b4:	4620      	mov	r0, r4
 800c0b6:	f002 fc2c 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_array_uint8_t(&m_microbuffer, mp_participant->m_guidPrefix.id.data(), sizeof(GuidPrefix_t::id));
 800c0ba:	220c      	movs	r2, #12
 800c0bc:	6831      	ldr	r1, [r6, #0]
 800c0be:	4620      	mov	r0, r4
 800c0c0:	f002 fb3d 	bl	800e73e <ucdr_serialize_array_uint8_t>
    ucdr_serialize_array_uint8_t(&m_microbuffer, ENTITYID_BUILD_IN_PARTICIPANT.entityKey.data(), entityKeySize);
 800c0c4:	2203      	movs	r2, #3
 800c0c6:	eb08 0107 	add.w	r1, r8, r7
 800c0ca:	4620      	mov	r0, r4
 800c0cc:	f002 fb37 	bl	800e73e <ucdr_serialize_array_uint8_t>
    ucdr_serialize_uint8_t(&m_microbuffer,       static_cast<uint8_t>(ENTITYID_BUILD_IN_PARTICIPANT.entityKind));
 800c0d0:	21c1      	movs	r1, #193	; 0xc1
 800c0d2:	4620      	mov	r0, r4
 800c0d4:	f002 fc12 	bl	800e8fc <ucdr_serialize_uint8_t>

    ucdr_serialize_uint16_t(&m_microbuffer,      ParameterId::PID_BUILTIN_ENDPOINT_SET);
 800c0d8:	2158      	movs	r1, #88	; 0x58
 800c0da:	4620      	mov	r0, r4
 800c0dc:	f002 fc19 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint16_t(&m_microbuffer,      sizeof(BuildInEndpointSet));
 800c0e0:	4639      	mov	r1, r7
 800c0e2:	4620      	mov	r0, r4
 800c0e4:	f002 fc15 	bl	800e912 <ucdr_serialize_uint16_t>
    ucdr_serialize_uint32_t(&m_microbuffer,      BuildInEndpointSet::DISC_BIE_PARTICIPANT_ANNOUNCER |
 800c0e8:	213f      	movs	r1, #63	; 0x3f
 800c0ea:	4620      	mov	r0, r4
 800c0ec:	f002 fc1c 	bl	800e928 <ucdr_serialize_uint32_t>
                                                 BuildInEndpointSet::DISC_BIE_PUBLICATION_ANNOUNCER |
                                                 BuildInEndpointSet::DISC_BIE_PUBLICATION_DETECTOR |
                                                 BuildInEndpointSet::DISC_BIE_SUBSCRIPTION_ANNOUNCER |
                                                 BuildInEndpointSet::DISC_BIE_SUBSCRIPTION_DETECTOR);

    endCurrentList();
 800c0f0:	4630      	mov	r0, r6
 800c0f2:	f7ff ff18 	bl	800bf26 <_ZN4rtps9SPDPAgent14endCurrentListEv>
}
 800c0f6:	b012      	add	sp, #72	; 0x48
 800c0f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c0fc:	08010934 	.word	0x08010934

0800c100 <_ZN4rtps9SPDPAgent4initERNS_11ParticipantERNS_16BuiltInEndpointsE>:
void SPDPAgent::init(Participant& participant, BuiltInEndpoints& endpoints){
 800c100:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c102:	4605      	mov	r5, r0
 800c104:	460f      	mov	r7, r1
 800c106:	4614      	mov	r4, r2
    if(sys_mutex_new(&m_mutex) != ERR_OK){
 800c108:	f500 60ac 	add.w	r0, r0, #1376	; 0x560
 800c10c:	f7fc ffa4 	bl	8009058 <sys_mutex_new>
 800c110:	b100      	cbz	r0, 800c114 <_ZN4rtps9SPDPAgent4initERNS_11ParticipantERNS_16BuiltInEndpointsE+0x14>
}
 800c112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    mp_participant = &participant;
 800c114:	462e      	mov	r6, r5
 800c116:	f846 7b04 	str.w	r7, [r6], #4
    m_buildInEndpoints = endpoints;
 800c11a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800c11c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800c11e:	e894 0003 	ldmia.w	r4, {r0, r1}
 800c122:	e886 0003 	stmia.w	r6, {r0, r1}
    m_buildInEndpoints.spdpReader->registerCallback(receiveCallback, this);
 800c126:	68a8      	ldr	r0, [r5, #8]
 800c128:	6803      	ldr	r3, [r0, #0]
 800c12a:	685b      	ldr	r3, [r3, #4]
 800c12c:	462a      	mov	r2, r5
 800c12e:	4908      	ldr	r1, [pc, #32]	; (800c150 <_ZN4rtps9SPDPAgent4initERNS_11ParticipantERNS_16BuiltInEndpointsE+0x50>)
 800c130:	4798      	blx	r3
    ucdr_init_buffer(&m_microbuffer, m_outputBuffer.data(), m_outputBuffer.size());
 800c132:	f44f 72c8 	mov.w	r2, #400	; 0x190
 800c136:	f105 011d 	add.w	r1, r5, #29
 800c13a:	f505 60a9 	add.w	r0, r5, #1352	; 0x548
 800c13e:	f002 faa1 	bl	800e684 <ucdr_init_buffer>
    addParticipantParameters();
 800c142:	4628      	mov	r0, r5
 800c144:	f7ff fefc 	bl	800bf40 <_ZN4rtps9SPDPAgent24addParticipantParametersEv>
    initialized = true;
 800c148:	2301      	movs	r3, #1
 800c14a:	f885 3564 	strb.w	r3, [r5, #1380]	; 0x564
 800c14e:	e7e0      	b.n	800c112 <_ZN4rtps9SPDPAgent4initERNS_11ParticipantERNS_16BuiltInEndpointsE+0x12>
 800c150:	0800bf1f 	.word	0x0800bf1f

0800c154 <_ZN4rtps9TopicData14matchesTopicOfERKS0_>:

using rtps::TopicData;
using rtps::SMElement::ParameterId;


bool TopicData::matchesTopicOf(const TopicData& other){
 800c154:	b538      	push	{r3, r4, r5, lr}
 800c156:	4604      	mov	r4, r0
 800c158:	460d      	mov	r5, r1
	return strcmp(this->topicName, other.topicName) == 0 && strcmp(this->typeName, other.typeName) == 0;
 800c15a:	3124      	adds	r1, #36	; 0x24
 800c15c:	3024      	adds	r0, #36	; 0x24
 800c15e:	f7f4 f86f 	bl	8000240 <strcmp>
 800c162:	b940      	cbnz	r0, 800c176 <_ZN4rtps9TopicData14matchesTopicOfERKS0_+0x22>
 800c164:	f105 0110 	add.w	r1, r5, #16
 800c168:	f104 0010 	add.w	r0, r4, #16
 800c16c:	f7f4 f868 	bl	8000240 <strcmp>
 800c170:	b118      	cbz	r0, 800c17a <_ZN4rtps9TopicData14matchesTopicOfERKS0_+0x26>
 800c172:	2000      	movs	r0, #0
 800c174:	e000      	b.n	800c178 <_ZN4rtps9TopicData14matchesTopicOfERKS0_+0x24>
 800c176:	2000      	movs	r0, #0
}
 800c178:	bd38      	pop	{r3, r4, r5, pc}
	return strcmp(this->topicName, other.topicName) == 0 && strcmp(this->typeName, other.typeName) == 0;
 800c17a:	2001      	movs	r0, #1
 800c17c:	e7fc      	b.n	800c178 <_ZN4rtps9TopicData14matchesTopicOfERKS0_+0x24>

0800c17e <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer>:

bool TopicData::readFromUcdrBuffer(ucdrBuffer& buffer){
 800c17e:	b570      	push	{r4, r5, r6, lr}
 800c180:	b082      	sub	sp, #8
 800c182:	4605      	mov	r5, r0
 800c184:	460c      	mov	r4, r1
 800c186:	e027      	b.n	800c1d8 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x5a>

        if(ucdr_buffer_remaining(&buffer) < length){
            return false;
        }

        switch(pid){
 800c188:	2b01      	cmp	r3, #1
 800c18a:	d054      	beq.n	800c236 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xb8>
 800c18c:	2b05      	cmp	r3, #5
 800c18e:	d143      	bne.n	800c218 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x9a>
                break;
            case ParameterId::PID_SENTINEL:
                return true;
            case ParameterId::PID_TOPIC_NAME:
                uint32_t topicNameLength;
                ucdr_deserialize_uint32_t(&buffer, &topicNameLength);
 800c190:	a901      	add	r1, sp, #4
 800c192:	4620      	mov	r0, r4
 800c194:	f002 fbec 	bl	800e970 <ucdr_deserialize_uint32_t>
                ucdr_deserialize_array_char(&buffer, topicName, topicNameLength);
 800c198:	9a01      	ldr	r2, [sp, #4]
 800c19a:	f105 0124 	add.w	r1, r5, #36	; 0x24
 800c19e:	4620      	mov	r0, r4
 800c1a0:	f002 fad1 	bl	800e746 <ucdr_deserialize_array_char>
 800c1a4:	e00f      	b.n	800c1c6 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x48>
                ucdr_deserialize_array_uint8_t(&buffer, endpointGuid.prefix.id.data(), endpointGuid.prefix.id.size());
 800c1a6:	220c      	movs	r2, #12
 800c1a8:	4629      	mov	r1, r5
 800c1aa:	4620      	mov	r0, r4
 800c1ac:	f002 facf 	bl	800e74e <ucdr_deserialize_array_uint8_t>
                ucdr_deserialize_array_uint8_t(&buffer, endpointGuid.entityId.entityKey.data(), endpointGuid.entityId.entityKey.size());
 800c1b0:	2203      	movs	r2, #3
 800c1b2:	f105 010c 	add.w	r1, r5, #12
 800c1b6:	4620      	mov	r0, r4
 800c1b8:	f002 fac9 	bl	800e74e <ucdr_deserialize_array_uint8_t>
                ucdr_deserialize_uint8_t(&buffer, reinterpret_cast<uint8_t*>(&endpointGuid.entityId.entityKind));
 800c1bc:	f105 010f 	add.w	r1, r5, #15
 800c1c0:	4620      	mov	r0, r4
 800c1c2:	f002 fbcb 	bl	800e95c <ucdr_deserialize_uint8_t>
            default:
                buffer.iterator+=length;
                buffer.last_data_size = 1;
        }

        uint32_t alignment = ucdr_buffer_alignment(&buffer, 4);
 800c1c6:	2104      	movs	r1, #4
 800c1c8:	4620      	mov	r0, r4
 800c1ca:	f002 fa60 	bl	800e68e <ucdr_buffer_alignment>
        buffer.iterator += alignment;
 800c1ce:	68a3      	ldr	r3, [r4, #8]
 800c1d0:	4418      	add	r0, r3
 800c1d2:	60a0      	str	r0, [r4, #8]
        buffer.last_data_size = 4; // 4 Byte alignment per element
 800c1d4:	2304      	movs	r3, #4
 800c1d6:	6123      	str	r3, [r4, #16]
    while(ucdr_buffer_remaining(&buffer) >= 4){
 800c1d8:	4620      	mov	r0, r4
 800c1da:	f002 fa7a 	bl	800e6d2 <ucdr_buffer_remaining>
 800c1de:	2803      	cmp	r0, #3
 800c1e0:	d946      	bls.n	800c270 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xf2>
        ucdr_deserialize_uint16_t(&buffer, reinterpret_cast<uint16_t*>(&pid));
 800c1e2:	4669      	mov	r1, sp
 800c1e4:	4620      	mov	r0, r4
 800c1e6:	f002 fbbd 	bl	800e964 <ucdr_deserialize_uint16_t>
        ucdr_deserialize_uint16_t(&buffer, &length);
 800c1ea:	f10d 0102 	add.w	r1, sp, #2
 800c1ee:	4620      	mov	r0, r4
 800c1f0:	f002 fbb8 	bl	800e964 <ucdr_deserialize_uint16_t>
        if(ucdr_buffer_remaining(&buffer) < length){
 800c1f4:	4620      	mov	r0, r4
 800c1f6:	f002 fa6c 	bl	800e6d2 <ucdr_buffer_remaining>
 800c1fa:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 800c1fe:	4282      	cmp	r2, r0
 800c200:	d834      	bhi.n	800c26c <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xee>
        switch(pid){
 800c202:	f8bd 3000 	ldrh.w	r3, [sp]
 800c206:	2b07      	cmp	r3, #7
 800c208:	d018      	beq.n	800c23c <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xbe>
 800c20a:	d9bd      	bls.n	800c188 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xa>
 800c20c:	2b2f      	cmp	r3, #47	; 0x2f
 800c20e:	d020      	beq.n	800c252 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xd4>
 800c210:	2b5a      	cmp	r3, #90	; 0x5a
 800c212:	d0c8      	beq.n	800c1a6 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x28>
 800c214:	2b1a      	cmp	r3, #26
 800c216:	d005      	beq.n	800c224 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xa6>
                buffer.iterator+=length;
 800c218:	68a3      	ldr	r3, [r4, #8]
 800c21a:	441a      	add	r2, r3
 800c21c:	60a2      	str	r2, [r4, #8]
                buffer.last_data_size = 1;
 800c21e:	2301      	movs	r3, #1
 800c220:	6123      	str	r3, [r4, #16]
 800c222:	e7d0      	b.n	800c1c6 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x48>
                ucdr_deserialize_uint32_t(&buffer, reinterpret_cast<uint32_t*>(&reliabilityKind));
 800c224:	f105 0138 	add.w	r1, r5, #56	; 0x38
 800c228:	4620      	mov	r0, r4
 800c22a:	f002 fba1 	bl	800e970 <ucdr_deserialize_uint32_t>
                buffer.iterator+=8;
 800c22e:	68a3      	ldr	r3, [r4, #8]
 800c230:	3308      	adds	r3, #8
 800c232:	60a3      	str	r3, [r4, #8]
                break;
 800c234:	e7c7      	b.n	800c1c6 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x48>
                return true;
 800c236:	2001      	movs	r0, #1
    }
    return ucdr_buffer_remaining(&buffer) == 0;
}
 800c238:	b002      	add	sp, #8
 800c23a:	bd70      	pop	{r4, r5, r6, pc}
                ucdr_deserialize_uint32_t(&buffer, &typeNameLength);
 800c23c:	a901      	add	r1, sp, #4
 800c23e:	4620      	mov	r0, r4
 800c240:	f002 fb96 	bl	800e970 <ucdr_deserialize_uint32_t>
                ucdr_deserialize_array_char(&buffer, typeName, typeNameLength);
 800c244:	9a01      	ldr	r2, [sp, #4]
 800c246:	f105 0110 	add.w	r1, r5, #16
 800c24a:	4620      	mov	r0, r4
 800c24c:	f002 fa7b 	bl	800e746 <ucdr_deserialize_array_char>
 800c250:	e7b9      	b.n	800c1c6 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x48>
                unicastLocator.readFromUcdrBuffer(buffer);
 800c252:	f105 063c 	add.w	r6, r5, #60	; 0x3c
            if(ucdr_buffer_remaining(&buffer) < sizeof(Locator)){
 800c256:	4620      	mov	r0, r4
 800c258:	f002 fa3b 	bl	800e6d2 <ucdr_buffer_remaining>
 800c25c:	2817      	cmp	r0, #23
 800c25e:	d9b2      	bls.n	800c1c6 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x48>
                ucdr_deserialize_array_uint8_t(&buffer, reinterpret_cast<uint8_t*>(this), sizeof(Locator));
 800c260:	2218      	movs	r2, #24
 800c262:	4631      	mov	r1, r6
 800c264:	4620      	mov	r0, r4
 800c266:	f002 fa72 	bl	800e74e <ucdr_deserialize_array_uint8_t>
 800c26a:	e7ac      	b.n	800c1c6 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0x48>
            return false;
 800c26c:	2000      	movs	r0, #0
 800c26e:	e7e3      	b.n	800c238 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xba>
    return ucdr_buffer_remaining(&buffer) == 0;
 800c270:	4620      	mov	r0, r4
 800c272:	f002 fa2e 	bl	800e6d2 <ucdr_buffer_remaining>
 800c276:	fab0 f080 	clz	r0, r0
 800c27a:	0940      	lsrs	r0, r0, #5
 800c27c:	e7dc      	b.n	800c238 <_ZN4rtps9TopicData18readFromUcdrBufferER10ucdrBuffer+0xba>

0800c27e <_ZNK4rtps9TopicData23serializeIntoUcdrBufferER10ucdrBuffer>:

bool TopicData::serializeIntoUcdrBuffer(ucdrBuffer& buffer) const{
 800c27e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c282:	4606      	mov	r6, r0
 800c284:	460c      	mov	r4, r1
	// TODO Check if buffer length is sufficient
	const uint16_t guidSize = sizeof(GuidPrefix_t::id) + 4;

	ucdr_serialize_uint16_t(&buffer, ParameterId::PID_UNICAST_LOCATOR);
 800c286:	212f      	movs	r1, #47	; 0x2f
 800c288:	4620      	mov	r0, r4
 800c28a:	f002 fb42 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint16_t(&buffer, sizeof(Locator));
 800c28e:	2118      	movs	r1, #24
 800c290:	4620      	mov	r0, r4
 800c292:	f002 fb3e 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_array_uint8_t(&buffer, reinterpret_cast<const uint8_t*>(&unicastLocator), sizeof(Locator));
 800c296:	2218      	movs	r2, #24
 800c298:	f106 013c 	add.w	r1, r6, #60	; 0x3c
 800c29c:	4620      	mov	r0, r4
 800c29e:	f002 fa4e 	bl	800e73e <ucdr_serialize_array_uint8_t>

	// It's a 32 bit instead of 16 because it seems like the field is padded.
	const auto lenTopicName = static_cast<uint32_t>(strlen(topicName) + 1); // + \0
 800c2a2:	f106 0824 	add.w	r8, r6, #36	; 0x24
 800c2a6:	4640      	mov	r0, r8
 800c2a8:	f7f3 ffd4 	bl	8000254 <strlen>
 800c2ac:	1c47      	adds	r7, r0, #1
	uint16_t topicAlignment = 0;
	if(lenTopicName % 4 != 0){
 800c2ae:	f017 0f03 	tst.w	r7, #3
 800c2b2:	f000 8092 	beq.w	800c3da <_ZNK4rtps9TopicData23serializeIntoUcdrBufferER10ucdrBuffer+0x15c>
		topicAlignment = static_cast<uint8_t>(4 - (lenTopicName % 4));
 800c2b6:	f007 0503 	and.w	r5, r7, #3
 800c2ba:	f1c5 0504 	rsb	r5, r5, #4
 800c2be:	b2ed      	uxtb	r5, r5
	}
	const auto totalLengthTopicNameField = static_cast<uint16_t>(sizeof(lenTopicName) + lenTopicName + topicAlignment);
 800c2c0:	443d      	add	r5, r7
 800c2c2:	b2ad      	uxth	r5, r5
 800c2c4:	3504      	adds	r5, #4
 800c2c6:	b2ad      	uxth	r5, r5
	ucdr_serialize_uint16_t(&buffer, ParameterId::PID_TOPIC_NAME);
 800c2c8:	2105      	movs	r1, #5
 800c2ca:	4620      	mov	r0, r4
 800c2cc:	f002 fb21 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint16_t(&buffer, totalLengthTopicNameField);
 800c2d0:	4629      	mov	r1, r5
 800c2d2:	4620      	mov	r0, r4
 800c2d4:	f002 fb1d 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint32_t(&buffer, lenTopicName);
 800c2d8:	4639      	mov	r1, r7
 800c2da:	4620      	mov	r0, r4
 800c2dc:	f002 fb24 	bl	800e928 <ucdr_serialize_uint32_t>
	ucdr_serialize_array_char(&buffer, topicName, lenTopicName);
 800c2e0:	463a      	mov	r2, r7
 800c2e2:	4641      	mov	r1, r8
 800c2e4:	4620      	mov	r0, r4
 800c2e6:	f002 fa26 	bl	800e736 <ucdr_serialize_array_char>
	ucdr_align_to(&buffer,4);
 800c2ea:	2104      	movs	r1, #4
 800c2ec:	4620      	mov	r0, r4
 800c2ee:	f002 f9de 	bl	800e6ae <ucdr_align_to>

	// It's a 32 bit instead of 16 because it seems like the field is padded.
	const auto lenTypeName = static_cast<uint32_t>(strlen(typeName) + 1); // + \0
 800c2f2:	f106 0810 	add.w	r8, r6, #16
 800c2f6:	4640      	mov	r0, r8
 800c2f8:	f7f3 ffac 	bl	8000254 <strlen>
 800c2fc:	1c47      	adds	r7, r0, #1
	uint16_t typeAlignment = 0;
	if(lenTypeName % 4 != 0){
 800c2fe:	f017 0f03 	tst.w	r7, #3
 800c302:	d06c      	beq.n	800c3de <_ZNK4rtps9TopicData23serializeIntoUcdrBufferER10ucdrBuffer+0x160>
		typeAlignment = static_cast<uint8_t>(4 - (lenTypeName % 4));
 800c304:	f007 0503 	and.w	r5, r7, #3
 800c308:	f1c5 0504 	rsb	r5, r5, #4
 800c30c:	b2ed      	uxtb	r5, r5
	}
	const auto totalLengthTypeNameField = static_cast<uint16_t>(sizeof(lenTypeName) + lenTypeName + typeAlignment);
 800c30e:	443d      	add	r5, r7
 800c310:	b2ad      	uxth	r5, r5
 800c312:	3504      	adds	r5, #4
 800c314:	b2ad      	uxth	r5, r5

	ucdr_serialize_uint16_t(&buffer, ParameterId::PID_TYPE_NAME);
 800c316:	2107      	movs	r1, #7
 800c318:	4620      	mov	r0, r4
 800c31a:	f002 fafa 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint16_t(&buffer, totalLengthTypeNameField);
 800c31e:	4629      	mov	r1, r5
 800c320:	4620      	mov	r0, r4
 800c322:	f002 faf6 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint32_t(&buffer, lenTypeName);
 800c326:	4639      	mov	r1, r7
 800c328:	4620      	mov	r0, r4
 800c32a:	f002 fafd 	bl	800e928 <ucdr_serialize_uint32_t>
	ucdr_serialize_array_char(&buffer, typeName, lenTypeName);
 800c32e:	463a      	mov	r2, r7
 800c330:	4641      	mov	r1, r8
 800c332:	4620      	mov	r0, r4
 800c334:	f002 f9ff 	bl	800e736 <ucdr_serialize_array_char>
	ucdr_align_to(&buffer,4);
 800c338:	2104      	movs	r1, #4
 800c33a:	4620      	mov	r0, r4
 800c33c:	f002 f9b7 	bl	800e6ae <ucdr_align_to>

	ucdr_serialize_uint16_t(&buffer, ParameterId::PID_KEY_HASH);
 800c340:	2170      	movs	r1, #112	; 0x70
 800c342:	4620      	mov	r0, r4
 800c344:	f002 fae5 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint16_t(&buffer, guidSize);
 800c348:	2110      	movs	r1, #16
 800c34a:	4620      	mov	r0, r4
 800c34c:	f002 fae1 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_array_uint8_t(&buffer, endpointGuid.prefix.id.data(), endpointGuid.prefix.id.size());
 800c350:	220c      	movs	r2, #12
 800c352:	4631      	mov	r1, r6
 800c354:	4620      	mov	r0, r4
 800c356:	f002 f9f2 	bl	800e73e <ucdr_serialize_array_uint8_t>
      { return _AT_Type::_S_ptr(_M_elems); }
 800c35a:	f106 050c 	add.w	r5, r6, #12
	ucdr_serialize_array_uint8_t(&buffer, endpointGuid.entityId.entityKey.data(), endpointGuid.entityId.entityKey.size());
 800c35e:	2203      	movs	r2, #3
 800c360:	4629      	mov	r1, r5
 800c362:	4620      	mov	r0, r4
 800c364:	f002 f9eb 	bl	800e73e <ucdr_serialize_array_uint8_t>
	ucdr_serialize_uint8_t(&buffer, static_cast<uint8_t>(endpointGuid.entityId.entityKind));
 800c368:	7bf1      	ldrb	r1, [r6, #15]
 800c36a:	4620      	mov	r0, r4
 800c36c:	f002 fac6 	bl	800e8fc <ucdr_serialize_uint8_t>

	ucdr_serialize_uint16_t(&buffer, ParameterId::PID_ENDPOINT_GUID);
 800c370:	215a      	movs	r1, #90	; 0x5a
 800c372:	4620      	mov	r0, r4
 800c374:	f002 facd 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint16_t(&buffer, guidSize);
 800c378:	2110      	movs	r1, #16
 800c37a:	4620      	mov	r0, r4
 800c37c:	f002 fac9 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_array_uint8_t(&buffer, endpointGuid.prefix.id.data(), endpointGuid.prefix.id.size());
 800c380:	220c      	movs	r2, #12
 800c382:	4631      	mov	r1, r6
 800c384:	4620      	mov	r0, r4
 800c386:	f002 f9da 	bl	800e73e <ucdr_serialize_array_uint8_t>
	ucdr_serialize_array_uint8_t(&buffer, endpointGuid.entityId.entityKey.data(), endpointGuid.entityId.entityKey.size());
 800c38a:	2203      	movs	r2, #3
 800c38c:	4629      	mov	r1, r5
 800c38e:	4620      	mov	r0, r4
 800c390:	f002 f9d5 	bl	800e73e <ucdr_serialize_array_uint8_t>
	ucdr_serialize_uint8_t(&buffer, static_cast<uint8_t>(endpointGuid.entityId.entityKind));
 800c394:	7bf1      	ldrb	r1, [r6, #15]
 800c396:	4620      	mov	r0, r4
 800c398:	f002 fab0 	bl	800e8fc <ucdr_serialize_uint8_t>

	const uint8_t unidentifiedOffset = 8;
	ucdr_serialize_uint16_t(&buffer, ParameterId::PID_RELIABILITY);
 800c39c:	211a      	movs	r1, #26
 800c39e:	4620      	mov	r0, r4
 800c3a0:	f002 fab7 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint16_t(&buffer, sizeof(ReliabilityKind_t) + unidentifiedOffset);
 800c3a4:	210c      	movs	r1, #12
 800c3a6:	4620      	mov	r0, r4
 800c3a8:	f002 fab3 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint32_t(&buffer, static_cast<uint32_t>(reliabilityKind));
 800c3ac:	6bb1      	ldr	r1, [r6, #56]	; 0x38
 800c3ae:	4620      	mov	r0, r4
 800c3b0:	f002 faba 	bl	800e928 <ucdr_serialize_uint32_t>
	ucdr_serialize_uint32_t(&buffer, 0); // unidentified additional value
 800c3b4:	2100      	movs	r1, #0
 800c3b6:	4620      	mov	r0, r4
 800c3b8:	f002 fab6 	bl	800e928 <ucdr_serialize_uint32_t>
	ucdr_serialize_uint32_t(&buffer, 0); // unidentified additional value
 800c3bc:	2100      	movs	r1, #0
 800c3be:	4620      	mov	r0, r4
 800c3c0:	f002 fab2 	bl	800e928 <ucdr_serialize_uint32_t>


	ucdr_serialize_uint16_t(&buffer, ParameterId::PID_SENTINEL);
 800c3c4:	2101      	movs	r1, #1
 800c3c6:	4620      	mov	r0, r4
 800c3c8:	f002 faa3 	bl	800e912 <ucdr_serialize_uint16_t>
	ucdr_serialize_uint16_t(&buffer, 0);
 800c3cc:	2100      	movs	r1, #0
 800c3ce:	4620      	mov	r0, r4
 800c3d0:	f002 fa9f 	bl	800e912 <ucdr_serialize_uint16_t>

	return true;
}
 800c3d4:	2001      	movs	r0, #1
 800c3d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint16_t topicAlignment = 0;
 800c3da:	2500      	movs	r5, #0
 800c3dc:	e770      	b.n	800c2c0 <_ZNK4rtps9TopicData23serializeIntoUcdrBufferER10ucdrBuffer+0x42>
	uint16_t typeAlignment = 0;
 800c3de:	2500      	movs	r5, #0
 800c3e0:	e795      	b.n	800c30e <_ZNK4rtps9TopicData23serializeIntoUcdrBufferER10ucdrBuffer+0x90>

0800c3e2 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12onNewAckNackERKNS_17SubmessageAckNackERKNS_12GuidPrefix_tE>:
}

template <typename NetworkDriver>
void StatelessWriterT<NetworkDriver>::onNewAckNack(const SubmessageAckNack& /*msg*/, const GuidPrefix_t& sourceGuidPrefix){
    // Too lazy to respond
}
 800c3e2:	4770      	bx	lr

0800c3e4 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEED1Ev>:
StatelessWriterT<NetworkDriver>::~StatelessWriterT(){
 800c3e4:	b570      	push	{r4, r5, r6, lr}
 800c3e6:	4605      	mov	r5, r0
}
 800c3e8:	4b0b      	ldr	r3, [pc, #44]	; (800c418 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEED1Ev+0x34>)
 800c3ea:	f840 3b58 	str.w	r3, [r0], #88
        sys_mutex_free(&m_mutex);
 800c3ee:	f7fc fe44 	bl	800907a <sys_mutex_free>
    struct array
 800c3f2:	f115 0684 	adds.w	r6, r5, #132	; 0x84
 800c3f6:	d009      	beq.n	800c40c <_ZN4rtps16StatelessWriterTINS_9UdpDriverEED1Ev+0x28>
 800c3f8:	f505 74b0 	add.w	r4, r5, #352	; 0x160
 800c3fc:	42a6      	cmp	r6, r4
 800c3fe:	d005      	beq.n	800c40c <_ZN4rtps16StatelessWriterTINS_9UdpDriverEED1Ev+0x28>
 800c400:	3c14      	subs	r4, #20
 800c402:	f104 000c 	add.w	r0, r4, #12
 800c406:	f001 ffec 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800c40a:	e7f7      	b.n	800c3fc <_ZN4rtps16StatelessWriterTINS_9UdpDriverEED1Ev+0x18>
 800c40c:	f105 006c 	add.w	r0, r5, #108	; 0x6c
 800c410:	f001 ffe7 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
}
 800c414:	4628      	mov	r0, r5
 800c416:	bd70      	pop	{r4, r5, r6, pc}
 800c418:	08011c68 	.word	0x08011c68

0800c41c <_ZN4rtps16StatelessWriterTINS_9UdpDriverEED0Ev>:
StatelessWriterT<NetworkDriver>::~StatelessWriterT(){
 800c41c:	b510      	push	{r4, lr}
 800c41e:	4604      	mov	r4, r0
}
 800c420:	f7ff ffe0 	bl	800c3e4 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEED1Ev>
 800c424:	4620      	mov	r0, r4
 800c426:	f7fd fd27 	bl	8009e78 <_ZdlPv>
 800c42a:	4620      	mov	r0, r4
 800c42c:	bd10      	pop	{r4, pc}

0800c42e <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE21setAllChangesToUnsentEv>:
void StatelessWriterT<NetworkDriver>::setAllChangesToUnsent() {
 800c42e:	b538      	push	{r3, r4, r5, lr}
 800c430:	4604      	mov	r4, r0
    Lock lock(m_mutex);
 800c432:	f100 0558 	add.w	r5, r0, #88	; 0x58
            sys_mutex_lock(&m_mutex);
 800c436:	4628      	mov	r0, r5
 800c438:	f7fc fe24 	bl	8009084 <sys_mutex_lock>
    m_nextSequenceNumberToSend = m_history.getSeqNumMin();
 800c43c:	f104 0084 	add.w	r0, r4, #132	; 0x84
 800c440:	f002 f840 	bl	800e4c4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv>
 800c444:	f104 037c 	add.w	r3, r4, #124	; 0x7c
 800c448:	c803      	ldmia	r0, {r0, r1}
 800c44a:	e883 0003 	stmia.w	r3, {r0, r1}
    if(mp_threadPool != nullptr){
 800c44e:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800c450:	b110      	cbz	r0, 800c458 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE21setAllChangesToUnsentEv+0x2a>
        mp_threadPool->addWorkload(this);
 800c452:	4621      	mov	r1, r4
 800c454:	f7fe fde3 	bl	800b01e <_ZN4rtps10ThreadPool11addWorkloadEPNS_6WriterE>
            sys_mutex_unlock(&m_mutex);
 800c458:	4628      	mov	r0, r5
 800c45a:	f7fc fe1a 	bl	8009092 <sys_mutex_unlock>
}
 800c45e:	bd38      	pop	{r3, r4, r5, pc}
 800c460:	4628      	mov	r0, r5
 800c462:	f7fc fe16 	bl	8009092 <sys_mutex_unlock>
 800c466:	f002 fab8 	bl	800e9da <__cxa_end_cleanup>

0800c46a <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE>:
bool StatelessWriterT<NetworkDriver>::addNewMatchedReader(const ReaderProxy& newProxy){
 800c46a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    return m_proxies.add(newProxy);
 800c46c:	f500 75b6 	add.w	r5, r0, #364	; 0x16c
            return m_numElements == SIZE;
 800c470:	686e      	ldr	r6, [r5, #4]
            if(isFull()){
 800c472:	2e03      	cmp	r6, #3
 800c474:	d025      	beq.n	800c4c2 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x58>
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 800c476:	2400      	movs	r4, #0
 800c478:	bb2c      	cbnz	r4, 800c4c6 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x5c>
                if(bucket != 0xFF){
 800c47a:	2cff      	cmp	r4, #255	; 0xff
 800c47c:	d01e      	beq.n	800c4bc <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x52>
                    uint8_t byte = m_bitMap[bucket];
 800c47e:	4620      	mov	r0, r4
 800c480:	5d2f      	ldrb	r7, [r5, r4]
                    for(uint8_t bit=0; bit < 8; ++bit){
 800c482:	4623      	mov	r3, r4
                    uint8_t byte = m_bitMap[bucket];
 800c484:	463a      	mov	r2, r7
                    for(uint8_t bit=0; bit < 8; ++bit){
 800c486:	2b07      	cmp	r3, #7
 800c488:	d818      	bhi.n	800c4bc <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x52>
                        if(!(byte & 1)){
 800c48a:	f012 0f01 	tst.w	r2, #1
 800c48e:	d003      	beq.n	800c498 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x2e>
                        byte = byte>>1;
 800c490:	0852      	lsrs	r2, r2, #1
                    for(uint8_t bit=0; bit < 8; ++bit){
 800c492:	3301      	adds	r3, #1
 800c494:	b2db      	uxtb	r3, r3
 800c496:	e7f6      	b.n	800c486 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x1c>
                            m_bitMap[bucket] |= 1 << bit;
 800c498:	2401      	movs	r4, #1
 800c49a:	fa04 f203 	lsl.w	r2, r4, r3
 800c49e:	4317      	orrs	r7, r2
 800c4a0:	542f      	strb	r7, [r5, r0]
                            m_data[bucket*8+bit] = data;
 800c4a2:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800c4a6:	2258      	movs	r2, #88	; 0x58
 800c4a8:	fb02 5303 	mla	r3, r2, r3, r5
 800c4ac:	f103 0008 	add.w	r0, r3, #8
 800c4b0:	f002 ffe9 	bl	800f486 <memcpy>
                            ++m_numElements;
 800c4b4:	4426      	add	r6, r4
 800c4b6:	606e      	str	r6, [r5, #4]
                            return true;
 800c4b8:	4620      	mov	r0, r4
 800c4ba:	e005      	b.n	800c4c8 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x5e>
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 800c4bc:	3401      	adds	r4, #1
 800c4be:	b2e4      	uxtb	r4, r4
 800c4c0:	e7da      	b.n	800c478 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0xe>
                return false;
 800c4c2:	2000      	movs	r0, #0
 800c4c4:	e000      	b.n	800c4c8 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE19addNewMatchedReaderERKNS_11ReaderProxyE+0x5e>
            return false;
 800c4c6:	2000      	movs	r0, #0
}
 800c4c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800c4ca <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE>:
void StatelessWriterT<NetworkDriver>::removeReader(const Guid& guid){
 800c4ca:	b570      	push	{r4, r5, r6, lr}
 800c4cc:	b084      	sub	sp, #16
    auto isElementToRemove=[&](const ReaderProxy& proxy){
 800c4ce:	9103      	str	r1, [sp, #12]
    m_proxies.remove(thunk, &isElementToRemove);
 800c4d0:	f500 74b6 	add.w	r4, r0, #364	; 0x16c
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 800c4d4:	9401      	str	r4, [sp, #4]
 800c4d6:	2300      	movs	r3, #0
 800c4d8:	f88d 3009 	strb.w	r3, [sp, #9]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 800c4dc:	f890 316c 	ldrb.w	r3, [r0, #364]	; 0x16c
 800c4e0:	f88d 3008 	strb.w	r3, [sp, #8]
            if(!(m_bitMap[0] & 1)){
 800c4e4:	f013 0f01 	tst.w	r3, #1
 800c4e8:	d12a      	bne.n	800c540 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
                if(m_pool.m_numElements == 0){
 800c4ea:	6863      	ldr	r3, [r4, #4]
 800c4ec:	b19b      	cbz	r3, 800c516 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x4c>
                    ++m_bit;
 800c4ee:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800c4f2:	3301      	adds	r3, #1
 800c4f4:	b2db      	uxtb	r3, r3
 800c4f6:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800c4fa:	aa04      	add	r2, sp, #16
 800c4fc:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800c500:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 800c504:	0852      	lsrs	r2, r2, #1
 800c506:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800c50a:	f012 0f01 	tst.w	r2, #1
 800c50e:	d117      	bne.n	800c540 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
 800c510:	2b02      	cmp	r3, #2
 800c512:	d9ec      	bls.n	800c4ee <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x24>
 800c514:	e014      	b.n	800c540 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
                    m_bit = SIZE;
 800c516:	2303      	movs	r3, #3
 800c518:	f88d 3009 	strb.w	r3, [sp, #9]
 800c51c:	e010      	b.n	800c540 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
                    const uint8_t bucket = it.m_bit/uint8_t{8};
 800c51e:	08ea      	lsrs	r2, r5, #3
                    const uint8_t pos = it.m_bit & uint8_t{7}; // 7 sets all bits above and including the one for 8 to 0
 800c520:	f005 0507 	and.w	r5, r5, #7
                    m_bitMap[bucket] &= ~(static_cast<uint8_t>(1) << pos);
 800c524:	2301      	movs	r3, #1
 800c526:	40ab      	lsls	r3, r5
 800c528:	5ca5      	ldrb	r5, [r4, r2]
 800c52a:	ea25 0503 	bic.w	r5, r5, r3
 800c52e:	54a5      	strb	r5, [r4, r2]
                    --m_numElements;
 800c530:	6863      	ldr	r3, [r4, #4]
 800c532:	3b01      	subs	r3, #1
 800c534:	6063      	str	r3, [r4, #4]
}
 800c536:	b004      	add	sp, #16
 800c538:	bd70      	pop	{r4, r5, r6, pc}
                    m_bit = SIZE;
 800c53a:	2303      	movs	r3, #3
 800c53c:	f88d 3009 	strb.w	r3, [sp, #9]
                 return m_bit != other.m_bit;
 800c540:	f89d 5009 	ldrb.w	r5, [sp, #9]
            for(auto it=begin(); it!=end();++it){
 800c544:	2d03      	cmp	r5, #3
 800c546:	d0f6      	beq.n	800c536 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x6c>
                return m_pool.m_data[m_bit];
 800c548:	9e01      	ldr	r6, [sp, #4]
 800c54a:	2158      	movs	r1, #88	; 0x58
 800c54c:	fb01 f105 	mul.w	r1, r1, r5
 800c550:	3108      	adds	r1, #8
                if(jumppad(isCorrectElement, *it)){
 800c552:	4431      	add	r1, r6
 800c554:	a803      	add	r0, sp, #12
 800c556:	f000 f819 	bl	800c58c <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_>
 800c55a:	2800      	cmp	r0, #0
 800c55c:	d1df      	bne.n	800c51e <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x54>
                if(m_pool.m_numElements == 0){
 800c55e:	6873      	ldr	r3, [r6, #4]
 800c560:	2b00      	cmp	r3, #0
 800c562:	d0ea      	beq.n	800c53a <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x70>
                    ++m_bit;
 800c564:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800c568:	3301      	adds	r3, #1
 800c56a:	b2db      	uxtb	r3, r3
 800c56c:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800c570:	aa04      	add	r2, sp, #16
 800c572:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800c576:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 800c57a:	0852      	lsrs	r2, r2, #1
 800c57c:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800c580:	f012 0f01 	tst.w	r2, #1
 800c584:	d1dc      	bne.n	800c540 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>
 800c586:	2b02      	cmp	r3, #2
 800c588:	d9ec      	bls.n	800c564 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x9a>
 800c58a:	e7d9      	b.n	800c540 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidE+0x76>

0800c58c <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_>:
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800c58c:	b538      	push	{r3, r4, r5, lr}
 800c58e:	460b      	mov	r3, r1
        return proxy.remoteReaderGuid == guid;
 800c590:	6804      	ldr	r4, [r0, #0]
      { return const_iterator(data() + _Nm); }
 800c592:	f101 050c 	add.w	r5, r1, #12
 800c596:	220c      	movs	r2, #12
 800c598:	4621      	mov	r1, r4
 800c59a:	4618      	mov	r0, r3
 800c59c:	f002 ff64 	bl	800f468 <memcmp>
 800c5a0:	fab0 f080 	clz	r0, r0
 800c5a4:	0940      	lsrs	r0, r0, #5
            return this->prefix == other.prefix &&
 800c5a6:	b150      	cbz	r0, 800c5be <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x32>
                   this->entityId == other.entityId;
 800c5a8:	340c      	adds	r4, #12
 800c5aa:	2203      	movs	r2, #3
 800c5ac:	4621      	mov	r1, r4
 800c5ae:	4628      	mov	r0, r5
 800c5b0:	f002 ff5a 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 800c5b4:	b920      	cbnz	r0, 800c5c0 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x34>
                   this->entityKind == other.entityKind;
 800c5b6:	78ea      	ldrb	r2, [r5, #3]
 800c5b8:	78e3      	ldrb	r3, [r4, #3]
            return this->entityKey == other.entityKey &&
 800c5ba:	429a      	cmp	r2, r3
 800c5bc:	d002      	beq.n	800c5c4 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x38>
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800c5be:	bd38      	pop	{r3, r4, r5, pc}
 800c5c0:	2000      	movs	r0, #0
 800c5c2:	e7fc      	b.n	800c5be <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x32>
 800c5c4:	2001      	movs	r0, #1
 800c5c6:	e7fa      	b.n	800c5be <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENUlPvRKNS_11ReaderProxyEE0_4_FUNES6_S9_+0x32>

0800c5c8 <_ZN4rtps6DomainC1Ev>:

#define DOMAIN_VERBOSE 0

using rtps::Domain;

Domain::Domain() : m_threadPool(receiveJumppad, this), m_transport(ThreadPool::readCallback, &m_threadPool){
 800c5c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c5cc:	b083      	sub	sp, #12
 800c5ce:	4607      	mov	r7, r0
 800c5d0:	4602      	mov	r2, r0
 800c5d2:	49cd      	ldr	r1, [pc, #820]	; (800c908 <_ZN4rtps6DomainC1Ev+0x340>)
 800c5d4:	f7fe fcb2 	bl	800af3c <_ZN4rtps10ThreadPoolC1EPFvPvRKNS_10PacketInfoEES1_>
 800c5d8:	f507 799e 	add.w	r9, r7, #316	; 0x13c
 800c5dc:	463a      	mov	r2, r7
 800c5de:	49cb      	ldr	r1, [pc, #812]	; (800c90c <_ZN4rtps6DomainC1Ev+0x344>)
 800c5e0:	4648      	mov	r0, r9
 800c5e2:	f7fe fe57 	bl	800b294 <_ZN4rtps9UdpDriverC1EPFvPvP7udp_pcbP4pbufPK8ip4_addrtES1_>
 800c5e6:	f507 76cc 	add.w	r6, r7, #408	; 0x198
    struct array
 800c5ea:	4634      	mov	r4, r6
 800c5ec:	2500      	movs	r5, #0
 800c5ee:	2d00      	cmp	r5, #0
 800c5f0:	db07      	blt.n	800c602 <_ZN4rtps6DomainC1Ev+0x3a>
 800c5f2:	4620      	mov	r0, r4
 800c5f4:	f001 f912 	bl	800d81c <_ZN4rtps11ParticipantC1Ev>
 800c5f8:	f504 548a 	add.w	r4, r4, #4416	; 0x1140
 800c5fc:	3408      	adds	r4, #8
 800c5fe:	3d01      	subs	r5, #1
 800c600:	e7f5      	b.n	800c5ee <_ZN4rtps6DomainC1Ev+0x26>
 800c602:	f507 5397 	add.w	r3, r7, #4832	; 0x12e0
 800c606:	2200      	movs	r2, #0
 800c608:	701a      	strb	r2, [r3, #0]
 800c60a:	f241 23e1 	movw	r3, #4833	; 0x12e1
 800c60e:	54fa      	strb	r2, [r7, r3]
 800c610:	f241 2ae4 	movw	sl, #4836	; 0x12e4
 800c614:	44ba      	add	sl, r7
 800c616:	4655      	mov	r5, sl
 800c618:	2601      	movs	r6, #1
 800c61a:	e012      	b.n	800c642 <_ZN4rtps6DomainC1Ev+0x7a>
 800c61c:	2e00      	cmp	r6, #0
 800c61e:	f000 82ba 	beq.w	800cb96 <_ZN4rtps6DomainC1Ev+0x5ce>
 800c622:	4bbb      	ldr	r3, [pc, #748]	; (800c910 <_ZN4rtps6DomainC1Ev+0x348>)
 800c624:	fb03 6505 	mla	r5, r3, r5, r6
 800c628:	42ae      	cmp	r6, r5
 800c62a:	f000 82b4 	beq.w	800cb96 <_ZN4rtps6DomainC1Ev+0x5ce>
 800c62e:	f5a5 558a 	sub.w	r5, r5, #4416	; 0x1140
 800c632:	3d08      	subs	r5, #8
 800c634:	4628      	mov	r0, r5
 800c636:	f001 fa35 	bl	800daa4 <_ZN4rtps11ParticipantD1Ev>
 800c63a:	e7f5      	b.n	800c628 <_ZN4rtps6DomainC1Ev+0x60>
 800c63c:	f505 751f 	add.w	r5, r5, #636	; 0x27c
 800c640:	3e01      	subs	r6, #1
 800c642:	2e00      	cmp	r6, #0
 800c644:	f2c0 80da 	blt.w	800c7fc <_ZN4rtps6DomainC1Ev+0x234>
    struct Locator{
 800c648:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c64c:	f885 1040 	strb.w	r1, [r5, #64]	; 0x40
 800c650:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
 800c654:	f885 1042 	strb.w	r1, [r5, #66]	; 0x42
 800c658:	f885 1043 	strb.w	r1, [r5, #67]	; 0x43
 800c65c:	2300      	movs	r3, #0
 800c65e:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 800c662:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 800c666:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
 800c66a:	f885 3047 	strb.w	r3, [r5, #71]	; 0x47
 800c66e:	64ab      	str	r3, [r5, #72]	; 0x48
 800c670:	64eb      	str	r3, [r5, #76]	; 0x4c
 800c672:	652b      	str	r3, [r5, #80]	; 0x50
 800c674:	656b      	str	r3, [r5, #84]	; 0x54
namespace rtps {

    struct PBufWrapper;

    template <typename NetworkDriver>
    class StatelessWriterT : public Writer{
 800c676:	4aa7      	ldr	r2, [pc, #668]	; (800c914 <_ZN4rtps6DomainC1Ev+0x34c>)
 800c678:	602a      	str	r2, [r5, #0]
 800c67a:	65eb      	str	r3, [r5, #92]	; 0x5c
 800c67c:	66eb      	str	r3, [r5, #108]	; 0x6c
 800c67e:	f8a5 3070 	strh.w	r3, [r5, #112]	; 0x70
 800c682:	2201      	movs	r2, #1
 800c684:	f885 2078 	strb.w	r2, [r5, #120]	; 0x78
 800c688:	67eb      	str	r3, [r5, #124]	; 0x7c
 800c68a:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
 800c68e:	f105 0284 	add.w	r2, r5, #132	; 0x84
     * the ChangeKind and dropping it when passing it during deleting of other sequence numbers
     */

    class SimpleHistoryCache{
    public:
        SimpleHistoryCache() = default;
 800c692:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
 800c696:	6093      	str	r3, [r2, #8]
 800c698:	60d3      	str	r3, [r2, #12]
 800c69a:	6113      	str	r3, [r2, #16]
        ChangeKind_t kind = ChangeKind_t::INVALID;
        SequenceNumber_t sequenceNumber = SEQUENCENUMBER_UNKNOWN;
        PBufWrapper data{};

        CacheChange() = default;
 800c69c:	f885 3084 	strb.w	r3, [r5, #132]	; 0x84
 800c6a0:	6051      	str	r1, [r2, #4]
 800c6a2:	8213      	strh	r3, [r2, #16]
 800c6a4:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
 800c6a8:	f8c5 30a8 	str.w	r3, [r5, #168]	; 0xa8
 800c6ac:	7513      	strb	r3, [r2, #20]
 800c6ae:	6191      	str	r1, [r2, #24]
 800c6b0:	61d3      	str	r3, [r2, #28]
 800c6b2:	6213      	str	r3, [r2, #32]
 800c6b4:	8493      	strh	r3, [r2, #36]	; 0x24
 800c6b6:	f8c5 30ac 	str.w	r3, [r5, #172]	; 0xac
 800c6ba:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
 800c6be:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 800c6c2:	62d1      	str	r1, [r2, #44]	; 0x2c
 800c6c4:	6313      	str	r3, [r2, #48]	; 0x30
 800c6c6:	6353      	str	r3, [r2, #52]	; 0x34
 800c6c8:	8713      	strh	r3, [r2, #56]	; 0x38
 800c6ca:	f8c5 30c0 	str.w	r3, [r5, #192]	; 0xc0
 800c6ce:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
 800c6d2:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
 800c6d6:	6411      	str	r1, [r2, #64]	; 0x40
 800c6d8:	6453      	str	r3, [r2, #68]	; 0x44
 800c6da:	6493      	str	r3, [r2, #72]	; 0x48
 800c6dc:	f8a2 304c 	strh.w	r3, [r2, #76]	; 0x4c
 800c6e0:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
 800c6e4:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
 800c6e8:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
 800c6ec:	6551      	str	r1, [r2, #84]	; 0x54
 800c6ee:	6593      	str	r3, [r2, #88]	; 0x58
 800c6f0:	65d3      	str	r3, [r2, #92]	; 0x5c
 800c6f2:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
 800c6f6:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
 800c6fa:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8
 800c6fe:	f882 3064 	strb.w	r3, [r2, #100]	; 0x64
 800c702:	6691      	str	r1, [r2, #104]	; 0x68
 800c704:	66d3      	str	r3, [r2, #108]	; 0x6c
 800c706:	6713      	str	r3, [r2, #112]	; 0x70
 800c708:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
 800c70c:	f8c5 30fc 	str.w	r3, [r5, #252]	; 0xfc
 800c710:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
 800c714:	f882 3078 	strb.w	r3, [r2, #120]	; 0x78
 800c718:	67d1      	str	r1, [r2, #124]	; 0x7c
 800c71a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 800c71e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 800c722:	f8a2 3088 	strh.w	r3, [r2, #136]	; 0x88
 800c726:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
 800c72a:	f8c5 3120 	str.w	r3, [r5, #288]	; 0x120
 800c72e:	f882 308c 	strb.w	r3, [r2, #140]	; 0x8c
 800c732:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
 800c736:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 800c73a:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
 800c73e:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
 800c742:	f8c5 3124 	str.w	r3, [r5, #292]	; 0x124
 800c746:	f8c5 3134 	str.w	r3, [r5, #308]	; 0x134
 800c74a:	f882 30a0 	strb.w	r3, [r2, #160]	; 0xa0
 800c74e:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
 800c752:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
 800c756:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
 800c75a:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
 800c75e:	f8c5 3138 	str.w	r3, [r5, #312]	; 0x138
 800c762:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
 800c766:	f882 30b4 	strb.w	r3, [r2, #180]	; 0xb4
 800c76a:	f8c2 10b8 	str.w	r1, [r2, #184]	; 0xb8
 800c76e:	f8c2 30bc 	str.w	r3, [r2, #188]	; 0xbc
 800c772:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
 800c776:	f8a2 30c4 	strh.w	r3, [r2, #196]	; 0xc4
 800c77a:	f8c5 314c 	str.w	r3, [r5, #332]	; 0x14c
 800c77e:	f8c5 315c 	str.w	r3, [r5, #348]	; 0x15c
 800c782:	f882 30c8 	strb.w	r3, [r2, #200]	; 0xc8
 800c786:	f8c2 10cc 	str.w	r1, [r2, #204]	; 0xcc
 800c78a:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
 800c78e:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
 800c792:	f8a2 30d8 	strh.w	r3, [r2, #216]	; 0xd8
 800c796:	f8a2 30dc 	strh.w	r3, [r2, #220]	; 0xdc
 800c79a:	f8a2 30de 	strh.w	r3, [r2, #222]	; 0xde
 800c79e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800c7a2:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
    class MemoryPool{
 800c7a6:	f885 316c 	strb.w	r3, [r5, #364]	; 0x16c
 800c7aa:	f8c5 3170 	str.w	r3, [r5, #368]	; 0x170
 800c7ae:	f505 74ba 	add.w	r4, r5, #372	; 0x174
 800c7b2:	f04f 0802 	mov.w	r8, #2
 800c7b6:	f1b8 0f00 	cmp.w	r8, #0
 800c7ba:	f6ff af3f 	blt.w	800c63c <_ZN4rtps6DomainC1Ev+0x74>
        ReaderProxy() : remoteReaderGuid({GUIDPREFIX_UNKNOWN, ENTITYID_UNKNOWN}){};
 800c7be:	2100      	movs	r1, #0
 800c7c0:	6021      	str	r1, [r4, #0]
 800c7c2:	6061      	str	r1, [r4, #4]
 800c7c4:	60a1      	str	r1, [r4, #8]
 800c7c6:	60e1      	str	r1, [r4, #12]
 800c7c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800c7cc:	7423      	strb	r3, [r4, #16]
 800c7ce:	7463      	strb	r3, [r4, #17]
 800c7d0:	74a3      	strb	r3, [r4, #18]
 800c7d2:	74e3      	strb	r3, [r4, #19]
 800c7d4:	7521      	strb	r1, [r4, #20]
 800c7d6:	7561      	strb	r1, [r4, #21]
 800c7d8:	75a1      	strb	r1, [r4, #22]
 800c7da:	75e1      	strb	r1, [r4, #23]
 800c7dc:	61a1      	str	r1, [r4, #24]
 800c7de:	61e1      	str	r1, [r4, #28]
 800c7e0:	6221      	str	r1, [r4, #32]
 800c7e2:	6261      	str	r1, [r4, #36]	; 0x24
        SequenceNumberSet() = default;
 800c7e4:	62a1      	str	r1, [r4, #40]	; 0x28
 800c7e6:	62e1      	str	r1, [r4, #44]	; 0x2c
 800c7e8:	2220      	movs	r2, #32
 800c7ea:	6322      	str	r2, [r4, #48]	; 0x30
 800c7ec:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800c7f0:	f002 fe54 	bl	800f49c <memset>
 800c7f4:	3458      	adds	r4, #88	; 0x58
 800c7f6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800c7fa:	e7dc      	b.n	800c7b6 <_ZN4rtps6DomainC1Ev+0x1ee>
 800c7fc:	f241 73dc 	movw	r3, #6108	; 0x17dc
 800c800:	2200      	movs	r2, #0
 800c802:	54fa      	strb	r2, [r7, r3]
 800c804:	f507 53bf 	add.w	r3, r7, #6112	; 0x17e0
 800c808:	9301      	str	r3, [sp, #4]
 800c80a:	2101      	movs	r1, #1
 800c80c:	2900      	cmp	r1, #0
 800c80e:	db1d      	blt.n	800c84c <_ZN4rtps6DomainC1Ev+0x284>
 800c810:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c814:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 800c818:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 800c81c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 800c820:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
 800c824:	2200      	movs	r2, #0
 800c826:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800c82a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800c82e:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 800c832:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
 800c836:	649a      	str	r2, [r3, #72]	; 0x48
 800c838:	64da      	str	r2, [r3, #76]	; 0x4c
 800c83a:	651a      	str	r2, [r3, #80]	; 0x50
 800c83c:	655a      	str	r2, [r3, #84]	; 0x54

#include "rtps/entities/Reader.h"
#include "rtps/storages/HistoryCache.h"

namespace rtps{
    class StatelessReader final: public Reader{
 800c83e:	4836      	ldr	r0, [pc, #216]	; (800c918 <_ZN4rtps6DomainC1Ev+0x350>)
 800c840:	6018      	str	r0, [r3, #0]
 800c842:	659a      	str	r2, [r3, #88]	; 0x58
 800c844:	65da      	str	r2, [r3, #92]	; 0x5c
 800c846:	3360      	adds	r3, #96	; 0x60
 800c848:	3901      	subs	r1, #1
 800c84a:	e7df      	b.n	800c80c <_ZN4rtps6DomainC1Ev+0x244>
 800c84c:	f507 53c5 	add.w	r3, r7, #6304	; 0x18a0
 800c850:	2200      	movs	r2, #0
 800c852:	701a      	strb	r2, [r3, #0]
 800c854:	f641 0ba4 	movw	fp, #6308	; 0x18a4
 800c858:	44bb      	add	fp, r7
 800c85a:	4659      	mov	r1, fp
 800c85c:	2501      	movs	r5, #1
 800c85e:	e007      	b.n	800c870 <_ZN4rtps6DomainC1Ev+0x2a8>

namespace rtps{
    struct SubmessageHeartbeat;

    template <class NetworkDriver>
    class StatefulReaderT final: public Reader{
 800c860:	2300      	movs	r3, #0
 800c862:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
 800c866:	f8c1 3124 	str.w	r3, [r1, #292]	; 0x124
 800c86a:	f501 7196 	add.w	r1, r1, #300	; 0x12c
 800c86e:	3d01      	subs	r5, #1
 800c870:	2d00      	cmp	r5, #0
 800c872:	db3d      	blt.n	800c8f0 <_ZN4rtps6DomainC1Ev+0x328>
 800c874:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800c878:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
 800c87c:	f881 3041 	strb.w	r3, [r1, #65]	; 0x41
 800c880:	f881 3042 	strb.w	r3, [r1, #66]	; 0x42
 800c884:	f881 3043 	strb.w	r3, [r1, #67]	; 0x43
 800c888:	2300      	movs	r3, #0
 800c88a:	f881 3044 	strb.w	r3, [r1, #68]	; 0x44
 800c88e:	f881 3045 	strb.w	r3, [r1, #69]	; 0x45
 800c892:	f881 3046 	strb.w	r3, [r1, #70]	; 0x46
 800c896:	f881 3047 	strb.w	r3, [r1, #71]	; 0x47
 800c89a:	648b      	str	r3, [r1, #72]	; 0x48
 800c89c:	64cb      	str	r3, [r1, #76]	; 0x4c
 800c89e:	650b      	str	r3, [r1, #80]	; 0x50
 800c8a0:	654b      	str	r3, [r1, #84]	; 0x54
 800c8a2:	4a1e      	ldr	r2, [pc, #120]	; (800c91c <_ZN4rtps6DomainC1Ev+0x354>)
 800c8a4:	600a      	str	r2, [r1, #0]
 800c8a6:	664b      	str	r3, [r1, #100]	; 0x64
 800c8a8:	f8a1 3068 	strh.w	r3, [r1, #104]	; 0x68
 800c8ac:	f881 3070 	strb.w	r3, [r1, #112]	; 0x70
 800c8b0:	674b      	str	r3, [r1, #116]	; 0x74
 800c8b2:	f101 0378 	add.w	r3, r1, #120	; 0x78
 800c8b6:	2402      	movs	r4, #2
 800c8b8:	2c00      	cmp	r4, #0
 800c8ba:	dbd1      	blt.n	800c860 <_ZN4rtps6DomainC1Ev+0x298>
 800c8bc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c8c0:	f883 2020 	strb.w	r2, [r3, #32]
 800c8c4:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 800c8c8:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 800c8cc:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
 800c8d0:	2200      	movs	r2, #0
 800c8d2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 800c8d6:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 800c8da:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 800c8de:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
 800c8e2:	629a      	str	r2, [r3, #40]	; 0x28
 800c8e4:	62da      	str	r2, [r3, #44]	; 0x2c
 800c8e6:	631a      	str	r2, [r3, #48]	; 0x30
 800c8e8:	635a      	str	r2, [r3, #52]	; 0x34
 800c8ea:	3338      	adds	r3, #56	; 0x38
 800c8ec:	3c01      	subs	r4, #1
 800c8ee:	e7e3      	b.n	800c8b8 <_ZN4rtps6DomainC1Ev+0x2f0>
 800c8f0:	f641 23fc 	movw	r3, #6908	; 0x1afc
 800c8f4:	2200      	movs	r2, #0
 800c8f6:	54fa      	strb	r2, [r7, r3]
 800c8f8:	f507 53d8 	add.w	r3, r7, #6912	; 0x1b00
 800c8fc:	9300      	str	r3, [sp, #0]
 800c8fe:	461d      	mov	r5, r3
 800c900:	f04f 0801 	mov.w	r8, #1
 800c904:	e010      	b.n	800c928 <_ZN4rtps6DomainC1Ev+0x360>
 800c906:	bf00      	nop
 800c908:	0800cc95 	.word	0x0800cc95
 800c90c:	0800b0fb 	.word	0x0800b0fb
 800c910:	ffffeeb8 	.word	0xffffeeb8
 800c914:	08011c68 	.word	0x08011c68
 800c918:	0801096c 	.word	0x0801096c
 800c91c:	08011ba4 	.word	0x08011ba4
 800c920:	f505 7522 	add.w	r5, r5, #648	; 0x288
 800c924:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800c928:	f1b8 0f00 	cmp.w	r8, #0
 800c92c:	f2c0 80db 	blt.w	800cae6 <_ZN4rtps6DomainC1Ev+0x51e>
 800c930:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c934:	f885 1040 	strb.w	r1, [r5, #64]	; 0x40
 800c938:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
 800c93c:	f885 1042 	strb.w	r1, [r5, #66]	; 0x42
 800c940:	f885 1043 	strb.w	r1, [r5, #67]	; 0x43
 800c944:	2300      	movs	r3, #0
 800c946:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 800c94a:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 800c94e:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
 800c952:	f885 3047 	strb.w	r3, [r5, #71]	; 0x47
 800c956:	64ab      	str	r3, [r5, #72]	; 0x48
 800c958:	64eb      	str	r3, [r5, #76]	; 0x4c
 800c95a:	652b      	str	r3, [r5, #80]	; 0x50
 800c95c:	656b      	str	r3, [r5, #84]	; 0x54
#include "rtps/storages/SimpleHistoryCache.h"

namespace rtps{

    template <class NetworkDriver>
    class StatefulWriterT final : public Writer{
 800c95e:	4a9e      	ldr	r2, [pc, #632]	; (800cbd8 <_ZN4rtps6DomainC1Ev+0x610>)
 800c960:	602a      	str	r2, [r5, #0]
 800c962:	65eb      	str	r3, [r5, #92]	; 0x5c
 800c964:	66eb      	str	r3, [r5, #108]	; 0x6c
 800c966:	f8a5 3070 	strh.w	r3, [r5, #112]	; 0x70
 800c96a:	2001      	movs	r0, #1
 800c96c:	f885 0078 	strb.w	r0, [r5, #120]	; 0x78
 800c970:	67eb      	str	r3, [r5, #124]	; 0x7c
 800c972:	f8c5 0080 	str.w	r0, [r5, #128]	; 0x80
 800c976:	f105 0284 	add.w	r2, r5, #132	; 0x84
 800c97a:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
 800c97e:	6093      	str	r3, [r2, #8]
 800c980:	60d3      	str	r3, [r2, #12]
 800c982:	6113      	str	r3, [r2, #16]
 800c984:	f885 3084 	strb.w	r3, [r5, #132]	; 0x84
 800c988:	6051      	str	r1, [r2, #4]
 800c98a:	8213      	strh	r3, [r2, #16]
 800c98c:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
 800c990:	f8c5 30a8 	str.w	r3, [r5, #168]	; 0xa8
 800c994:	7513      	strb	r3, [r2, #20]
 800c996:	6191      	str	r1, [r2, #24]
 800c998:	61d3      	str	r3, [r2, #28]
 800c99a:	6213      	str	r3, [r2, #32]
 800c99c:	8493      	strh	r3, [r2, #36]	; 0x24
 800c99e:	f8c5 30ac 	str.w	r3, [r5, #172]	; 0xac
 800c9a2:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
 800c9a6:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 800c9aa:	62d1      	str	r1, [r2, #44]	; 0x2c
 800c9ac:	6313      	str	r3, [r2, #48]	; 0x30
 800c9ae:	6353      	str	r3, [r2, #52]	; 0x34
 800c9b0:	8713      	strh	r3, [r2, #56]	; 0x38
 800c9b2:	f8c5 30c0 	str.w	r3, [r5, #192]	; 0xc0
 800c9b6:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
 800c9ba:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
 800c9be:	6411      	str	r1, [r2, #64]	; 0x40
 800c9c0:	6453      	str	r3, [r2, #68]	; 0x44
 800c9c2:	6493      	str	r3, [r2, #72]	; 0x48
 800c9c4:	f8a2 304c 	strh.w	r3, [r2, #76]	; 0x4c
 800c9c8:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
 800c9cc:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
 800c9d0:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
 800c9d4:	6551      	str	r1, [r2, #84]	; 0x54
 800c9d6:	6593      	str	r3, [r2, #88]	; 0x58
 800c9d8:	65d3      	str	r3, [r2, #92]	; 0x5c
 800c9da:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
 800c9de:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
 800c9e2:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8
 800c9e6:	f882 3064 	strb.w	r3, [r2, #100]	; 0x64
 800c9ea:	6691      	str	r1, [r2, #104]	; 0x68
 800c9ec:	66d3      	str	r3, [r2, #108]	; 0x6c
 800c9ee:	6713      	str	r3, [r2, #112]	; 0x70
 800c9f0:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
 800c9f4:	f8c5 30fc 	str.w	r3, [r5, #252]	; 0xfc
 800c9f8:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
 800c9fc:	f882 3078 	strb.w	r3, [r2, #120]	; 0x78
 800ca00:	67d1      	str	r1, [r2, #124]	; 0x7c
 800ca02:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 800ca06:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 800ca0a:	f8a2 3088 	strh.w	r3, [r2, #136]	; 0x88
 800ca0e:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
 800ca12:	f8c5 3120 	str.w	r3, [r5, #288]	; 0x120
 800ca16:	f882 308c 	strb.w	r3, [r2, #140]	; 0x8c
 800ca1a:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
 800ca1e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 800ca22:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
 800ca26:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
 800ca2a:	f8c5 3124 	str.w	r3, [r5, #292]	; 0x124
 800ca2e:	f8c5 3134 	str.w	r3, [r5, #308]	; 0x134
 800ca32:	f882 30a0 	strb.w	r3, [r2, #160]	; 0xa0
 800ca36:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
 800ca3a:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
 800ca3e:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
 800ca42:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
 800ca46:	f8c5 3138 	str.w	r3, [r5, #312]	; 0x138
 800ca4a:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
 800ca4e:	f882 30b4 	strb.w	r3, [r2, #180]	; 0xb4
 800ca52:	f8c2 10b8 	str.w	r1, [r2, #184]	; 0xb8
 800ca56:	f8c2 30bc 	str.w	r3, [r2, #188]	; 0xbc
 800ca5a:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
 800ca5e:	f8a2 30c4 	strh.w	r3, [r2, #196]	; 0xc4
 800ca62:	f8c5 314c 	str.w	r3, [r5, #332]	; 0x14c
 800ca66:	f8c5 315c 	str.w	r3, [r5, #348]	; 0x15c
 800ca6a:	f882 30c8 	strb.w	r3, [r2, #200]	; 0xc8
 800ca6e:	f8c2 10cc 	str.w	r1, [r2, #204]	; 0xcc
 800ca72:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
 800ca76:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
 800ca7a:	f8a2 30d8 	strh.w	r3, [r2, #216]	; 0xd8
 800ca7e:	f8a2 30dc 	strh.w	r3, [r2, #220]	; 0xdc
 800ca82:	f8a2 30de 	strh.w	r3, [r2, #222]	; 0xde
 800ca86:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ca8a:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 800ca8e:	f8c5 0170 	str.w	r0, [r5, #368]	; 0x170
 800ca92:	f885 0174 	strb.w	r0, [r5, #372]	; 0x174
 800ca96:	f885 3178 	strb.w	r3, [r5, #376]	; 0x178
 800ca9a:	f8c5 317c 	str.w	r3, [r5, #380]	; 0x17c
 800ca9e:	f505 74c0 	add.w	r4, r5, #384	; 0x180
 800caa2:	2602      	movs	r6, #2
 800caa4:	2e00      	cmp	r6, #0
 800caa6:	f6ff af3b 	blt.w	800c920 <_ZN4rtps6DomainC1Ev+0x358>
 800caaa:	2100      	movs	r1, #0
 800caac:	6021      	str	r1, [r4, #0]
 800caae:	6061      	str	r1, [r4, #4]
 800cab0:	60a1      	str	r1, [r4, #8]
 800cab2:	60e1      	str	r1, [r4, #12]
 800cab4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800cab8:	7423      	strb	r3, [r4, #16]
 800caba:	7463      	strb	r3, [r4, #17]
 800cabc:	74a3      	strb	r3, [r4, #18]
 800cabe:	74e3      	strb	r3, [r4, #19]
 800cac0:	7521      	strb	r1, [r4, #20]
 800cac2:	7561      	strb	r1, [r4, #21]
 800cac4:	75a1      	strb	r1, [r4, #22]
 800cac6:	75e1      	strb	r1, [r4, #23]
 800cac8:	61a1      	str	r1, [r4, #24]
 800caca:	61e1      	str	r1, [r4, #28]
 800cacc:	6221      	str	r1, [r4, #32]
 800cace:	6261      	str	r1, [r4, #36]	; 0x24
 800cad0:	62a1      	str	r1, [r4, #40]	; 0x28
 800cad2:	62e1      	str	r1, [r4, #44]	; 0x2c
 800cad4:	2220      	movs	r2, #32
 800cad6:	6322      	str	r2, [r4, #48]	; 0x30
 800cad8:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800cadc:	f002 fcde 	bl	800f49c <memset>
 800cae0:	3458      	adds	r4, #88	; 0x58
 800cae2:	3e01      	subs	r6, #1
 800cae4:	e7de      	b.n	800caa4 <_ZN4rtps6DomainC1Ev+0x4dc>
 800cae6:	2300      	movs	r3, #0
 800cae8:	f242 0210 	movw	r2, #8208	; 0x2010
 800caec:	54bb      	strb	r3, [r7, r2]
 800caee:	f242 0211 	movw	r2, #8209	; 0x2011
 800caf2:	54bb      	strb	r3, [r7, r2]
    m_transport.createUdpConnection(getUserMulticastPort());
 800caf4:	f641 41e9 	movw	r1, #7401	; 0x1ce9
 800caf8:	4648      	mov	r0, r9
 800cafa:	f7fe fbd9 	bl	800b2b0 <_ZN4rtps9UdpDriver19createUdpConnectionEt>
    m_transport.createUdpConnection(getBuiltInMulticastPort());
 800cafe:	f641 41e8 	movw	r1, #7400	; 0x1ce8
 800cb02:	4648      	mov	r0, r9
 800cb04:	f7fe fbd4 	bl	800b2b0 <_ZN4rtps9UdpDriver19createUdpConnectionEt>
    m_transport.joinMultiCastGroup(transformIP4ToU32(239, 255, 0, 1));
 800cb08:	4934      	ldr	r1, [pc, #208]	; (800cbdc <_ZN4rtps6DomainC1Ev+0x614>)
 800cb0a:	4648      	mov	r0, r9
 800cb0c:	f7fe fc68 	bl	800b3e0 <_ZNK4rtps9UdpDriver18joinMultiCastGroupE8ip4_addr>
 800cb10:	e05e      	b.n	800cbd0 <_ZN4rtps6DomainC1Ev+0x608>
 800cb12:	9b00      	ldr	r3, [sp, #0]
 800cb14:	b15b      	cbz	r3, 800cb2e <_ZN4rtps6DomainC1Ev+0x566>
 800cb16:	f242 0410 	movw	r4, #8208	; 0x2010
 800cb1a:	443c      	add	r4, r7
 800cb1c:	9b00      	ldr	r3, [sp, #0]
 800cb1e:	42a3      	cmp	r3, r4
 800cb20:	d005      	beq.n	800cb2e <_ZN4rtps6DomainC1Ev+0x566>
 800cb22:	f5a4 7422 	sub.w	r4, r4, #648	; 0x288
 800cb26:	4620      	mov	r0, r4
 800cb28:	f7fc ff2c 	bl	8009984 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEED1Ev>
 800cb2c:	e7f6      	b.n	800cb1c <_ZN4rtps6DomainC1Ev+0x554>
 800cb2e:	f1bb 0f00 	cmp.w	fp, #0
 800cb32:	d00a      	beq.n	800cb4a <_ZN4rtps6DomainC1Ev+0x582>
 800cb34:	f641 24fc 	movw	r4, #6908	; 0x1afc
 800cb38:	443c      	add	r4, r7
 800cb3a:	45a3      	cmp	fp, r4
 800cb3c:	d005      	beq.n	800cb4a <_ZN4rtps6DomainC1Ev+0x582>
 800cb3e:	f5a4 7496 	sub.w	r4, r4, #300	; 0x12c
 800cb42:	4620      	mov	r0, r4
 800cb44:	f7fc ff42 	bl	80099cc <_ZN4rtps15StatefulReaderTINS_9UdpDriverEED1Ev>
 800cb48:	e7f7      	b.n	800cb3a <_ZN4rtps6DomainC1Ev+0x572>
 800cb4a:	9b01      	ldr	r3, [sp, #4]
 800cb4c:	b133      	cbz	r3, 800cb5c <_ZN4rtps6DomainC1Ev+0x594>
 800cb4e:	f507 53c5 	add.w	r3, r7, #6304	; 0x18a0
 800cb52:	9a01      	ldr	r2, [sp, #4]
 800cb54:	429a      	cmp	r2, r3
 800cb56:	d001      	beq.n	800cb5c <_ZN4rtps6DomainC1Ev+0x594>
 800cb58:	3b60      	subs	r3, #96	; 0x60
 800cb5a:	e7fa      	b.n	800cb52 <_ZN4rtps6DomainC1Ev+0x58a>
 800cb5c:	f1ba 0f00 	cmp.w	sl, #0
 800cb60:	d00b      	beq.n	800cb7a <_ZN4rtps6DomainC1Ev+0x5b2>
 800cb62:	f241 74dc 	movw	r4, #6108	; 0x17dc
 800cb66:	443c      	add	r4, r7
 800cb68:	45a2      	cmp	sl, r4
 800cb6a:	d006      	beq.n	800cb7a <_ZN4rtps6DomainC1Ev+0x5b2>
 800cb6c:	f5a4 741f 	sub.w	r4, r4, #636	; 0x27c
 800cb70:	6823      	ldr	r3, [r4, #0]
 800cb72:	699b      	ldr	r3, [r3, #24]
 800cb74:	4620      	mov	r0, r4
 800cb76:	4798      	blx	r3
 800cb78:	e7f6      	b.n	800cb68 <_ZN4rtps6DomainC1Ev+0x5a0>
 800cb7a:	f517 75cc 	adds.w	r5, r7, #408	; 0x198
 800cb7e:	d00a      	beq.n	800cb96 <_ZN4rtps6DomainC1Ev+0x5ce>
 800cb80:	f507 5497 	add.w	r4, r7, #4832	; 0x12e0
 800cb84:	42a5      	cmp	r5, r4
 800cb86:	d006      	beq.n	800cb96 <_ZN4rtps6DomainC1Ev+0x5ce>
 800cb88:	f5a4 548a 	sub.w	r4, r4, #4416	; 0x1140
 800cb8c:	3c08      	subs	r4, #8
 800cb8e:	4620      	mov	r0, r4
 800cb90:	f000 ff88 	bl	800daa4 <_ZN4rtps11ParticipantD1Ev>
 800cb94:	e7f6      	b.n	800cb84 <_ZN4rtps6DomainC1Ev+0x5bc>
 800cb96:	f517 769e 	adds.w	r6, r7, #316	; 0x13c
 800cb9a:	d014      	beq.n	800cbc6 <_ZN4rtps6DomainC1Ev+0x5fe>
 800cb9c:	f507 74c6 	add.w	r4, r7, #396	; 0x18c
 800cba0:	42a6      	cmp	r6, r4
 800cba2:	d010      	beq.n	800cbc6 <_ZN4rtps6DomainC1Ev+0x5fe>
            if (pcb != nullptr) {
 800cba4:	f854 3d08 	ldr.w	r3, [r4, #-8]!
 800cba8:	2b00      	cmp	r3, #0
 800cbaa:	d0f9      	beq.n	800cba0 <_ZN4rtps6DomainC1Ev+0x5d8>
                LOCK_TCPIP_CORE();
 800cbac:	4d0c      	ldr	r5, [pc, #48]	; (800cbe0 <_ZN4rtps6DomainC1Ev+0x618>)
 800cbae:	4628      	mov	r0, r5
 800cbb0:	f7fc fa68 	bl	8009084 <sys_mutex_lock>
                udp_remove(pcb);
 800cbb4:	6820      	ldr	r0, [r4, #0]
 800cbb6:	f7fa fadf 	bl	8007178 <udp_remove>
                pcb = nullptr;
 800cbba:	2300      	movs	r3, #0
 800cbbc:	6023      	str	r3, [r4, #0]
                UNLOCK_TCPIP_CORE();
 800cbbe:	4628      	mov	r0, r5
 800cbc0:	f7fc fa67 	bl	8009092 <sys_mutex_unlock>
 800cbc4:	e7ec      	b.n	800cba0 <_ZN4rtps6DomainC1Ev+0x5d8>
Domain::Domain() : m_threadPool(receiveJumppad, this), m_transport(ThreadPool::readCallback, &m_threadPool){
 800cbc6:	4638      	mov	r0, r7
 800cbc8:	f7fe f96f 	bl	800aeaa <_ZN4rtps10ThreadPoolD1Ev>
 800cbcc:	f001 ff05 	bl	800e9da <__cxa_end_cleanup>
}
 800cbd0:	4638      	mov	r0, r7
 800cbd2:	b003      	add	sp, #12
 800cbd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cbd8:	08011bc8 	.word	0x08011bc8
 800cbdc:	0100ffef 	.word	0x0100ffef
 800cbe0:	20005a2c 	.word	0x20005a2c

0800cbe4 <_ZN4rtps6Domain12completeInitEv>:

bool Domain::completeInit(){
 800cbe4:	b510      	push	{r4, lr}
 800cbe6:	4604      	mov	r4, r0
    m_initComplete = m_threadPool.startThreads();
 800cbe8:	f7fe f8f2 	bl	800add0 <_ZN4rtps10ThreadPool12startThreadsEv>
 800cbec:	f242 0311 	movw	r3, #8209	; 0x2011
 800cbf0:	54e0      	strb	r0, [r4, r3]
    if(!started){
        printf("Domain: Failed starting threads\n");
    }
#endif
    return m_initComplete;
}
 800cbf2:	bd10      	pop	{r4, pc}

0800cbf4 <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE>:
void Domain::receiveJumppad(void* callee, const PacketInfo& packet){
    auto domain = static_cast<Domain*>(callee);
    domain->receiveCallback(packet);
}

void Domain::receiveCallback(const PacketInfo& packet){
 800cbf4:	b570      	push	{r4, r5, r6, lr}
 800cbf6:	4605      	mov	r5, r0
 800cbf8:	460e      	mov	r6, r1
    if(packet.buffer.firstElement->next != nullptr){
 800cbfa:	68c9      	ldr	r1, [r1, #12]
#if DOMAIN_VERBOSE
        Log::printLine("Domain: Cannot handle multiple elements chained. You might want to increase PBUF_POOL_BUFSIZE\n");
#endif
    }

    if(isMultiCastPort(packet.destPort)){
 800cbfc:	8932      	ldrh	r2, [r6, #8]
    constexpr bool isUserPort(Ip4Port_t port){
        return (port & 1) == 1;
    }

    inline bool isMultiCastPort(Ip4Port_t port){
        const auto idWithoutBase = port - PB - DG*Config::DOMAIN_ID;
 800cbfe:	4b24      	ldr	r3, [pc, #144]	; (800cc90 <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x9c>)
 800cc00:	4413      	add	r3, r2
 800cc02:	2b01      	cmp	r3, #1
 800cc04:	d912      	bls.n	800cc2c <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x38>
        //if(isMultiCastPort(port)){ // TODO remove?
        //    return PARTICIPANT_ID_INVALID;
        //}

        const auto basePart = PB + DG*Config::DOMAIN_ID;
        ParticipantId_t participantPart = port - basePart;
 800cc06:	f102 0018 	add.w	r0, r2, #24
 800cc0a:	b2c0      	uxtb	r0, r0

        uint16_t offset = 0;
        if(isUserPort){
 800cc0c:	f012 0f01 	tst.w	r2, #1
 800cc10:	d023      	beq.n	800cc5a <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x66>
            offset = D3;
 800cc12:	230b      	movs	r3, #11
        }else{
            offset = D1;
        }

        participantPart -= offset;
 800cc14:	1ac0      	subs	r0, r0, r3
 800cc16:	b240      	sxtb	r0, r0

        auto id = static_cast<ParticipantId_t>(participantPart / PG);
 800cc18:	2800      	cmp	r0, #0
 800cc1a:	db20      	blt.n	800cc5e <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x6a>
 800cc1c:	1040      	asrs	r0, r0, #1
        if(id*PG + basePart + offset == port){
 800cc1e:	f600 6474 	addw	r4, r0, #3700	; 0xe74
 800cc22:	eb03 0344 	add.w	r3, r3, r4, lsl #1
 800cc26:	429a      	cmp	r2, r3
 800cc28:	d01b      	beq.n	800cc62 <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x6e>
#if DOMAIN_VERBOSE
            printf("Domain: Got message to port %u: no matching participant\n", packet.destPort);
#endif
        }
    }
}
 800cc2a:	bd70      	pop	{r4, r5, r6, pc}
        for(auto i=0; i < m_nextParticipantId - PARTICIPANT_START_ID; ++i) {
 800cc2c:	2400      	movs	r4, #0
 800cc2e:	f241 23e1 	movw	r3, #4833	; 0x12e1
 800cc32:	56eb      	ldrsb	r3, [r5, r3]
 800cc34:	f505 5297 	add.w	r2, r5, #4832	; 0x12e0
 800cc38:	7812      	ldrb	r2, [r2, #0]
 800cc3a:	1a9b      	subs	r3, r3, r2
 800cc3c:	42a3      	cmp	r3, r4
 800cc3e:	ddf4      	ble.n	800cc2a <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x36>
      { return const_cast<_Tp&>(__t[__n]); }
 800cc40:	f505 70cc 	add.w	r0, r5, #408	; 0x198
            m_participants[i].newMessage(static_cast<uint8_t*>(packet.buffer.firstElement->payload), packet.buffer.firstElement->len);
 800cc44:	68f3      	ldr	r3, [r6, #12]
 800cc46:	895a      	ldrh	r2, [r3, #10]
 800cc48:	6859      	ldr	r1, [r3, #4]
 800cc4a:	f241 1348 	movw	r3, #4424	; 0x1148
 800cc4e:	fb03 0004 	mla	r0, r3, r4, r0
 800cc52:	f001 f90e 	bl	800de72 <_ZN4rtps11Participant10newMessageEPKht>
        for(auto i=0; i < m_nextParticipantId - PARTICIPANT_START_ID; ++i) {
 800cc56:	3401      	adds	r4, #1
 800cc58:	e7e9      	b.n	800cc2e <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x3a>
            offset = D1;
 800cc5a:	230a      	movs	r3, #10
 800cc5c:	e7da      	b.n	800cc14 <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x20>
        auto id = static_cast<ParticipantId_t>(participantPart / PG);
 800cc5e:	3001      	adds	r0, #1
 800cc60:	e7dc      	b.n	800cc1c <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x28>
        if(id != PARTICIPANT_ID_INVALID){
 800cc62:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800cc66:	d0e0      	beq.n	800cc2a <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x36>
            if(id < m_nextParticipantId) {
 800cc68:	f241 23e1 	movw	r3, #4833	; 0x12e1
 800cc6c:	56eb      	ldrsb	r3, [r5, r3]
 800cc6e:	4283      	cmp	r3, r0
 800cc70:	dddb      	ble.n	800cc2a <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x36>
                m_participants[id - PARTICIPANT_START_ID].newMessage(
 800cc72:	f505 5397 	add.w	r3, r5, #4832	; 0x12e0
 800cc76:	781b      	ldrb	r3, [r3, #0]
 800cc78:	1ac0      	subs	r0, r0, r3
 800cc7a:	f505 75cc 	add.w	r5, r5, #408	; 0x198
 800cc7e:	894a      	ldrh	r2, [r1, #10]
 800cc80:	6849      	ldr	r1, [r1, #4]
 800cc82:	f241 1348 	movw	r3, #4424	; 0x1148
 800cc86:	fb03 5000 	mla	r0, r3, r0, r5
 800cc8a:	f001 f8f2 	bl	800de72 <_ZN4rtps11Participant10newMessageEPKht>
}
 800cc8e:	e7cc      	b.n	800cc2a <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE+0x36>
 800cc90:	ffffe318 	.word	0xffffe318

0800cc94 <_ZN4rtps6Domain14receiveJumppadEPvRKNS_10PacketInfoE>:
void Domain::receiveJumppad(void* callee, const PacketInfo& packet){
 800cc94:	b508      	push	{r3, lr}
    domain->receiveCallback(packet);
 800cc96:	f7ff ffad 	bl	800cbf4 <_ZN4rtps6Domain15receiveCallbackERKNS_10PacketInfoE>
}
 800cc9a:	bd08      	pop	{r3, pc}

0800cc9c <_ZN4rtps6Domain12registerPortERKNS_11ParticipantE>:
    endpoints.sedpSubWriter = &sedpSubWriter;

    part.addBuiltInEndpoints(endpoints);
}

void Domain::registerPort(const Participant& part){
 800cc9c:	b538      	push	{r3, r4, r5, lr}
 800cc9e:	460d      	mov	r5, r1
    m_transport.createUdpConnection(getUserUnicastPort(part.m_participantId));
 800cca0:	f500 749e 	add.w	r4, r0, #316	; 0x13c
 800cca4:	f991 300c 	ldrsb.w	r3, [r1, #12]
               PG * participantId;
 800cca8:	005b      	lsls	r3, r3, #1
 800ccaa:	b29b      	uxth	r3, r3
 800ccac:	f641 41f3 	movw	r1, #7411	; 0x1cf3
 800ccb0:	4419      	add	r1, r3
 800ccb2:	b289      	uxth	r1, r1
 800ccb4:	4620      	mov	r0, r4
 800ccb6:	f7fe fafb 	bl	800b2b0 <_ZN4rtps9UdpDriver19createUdpConnectionEt>
    m_transport.createUdpConnection(getBuiltInUnicastPort(part.m_participantId));
 800ccba:	f995 100c 	ldrsb.w	r1, [r5, #12]
               D1 +
 800ccbe:	f601 6179 	addw	r1, r1, #3705	; 0xe79
               PG * participantId;
 800ccc2:	0049      	lsls	r1, r1, #1
 800ccc4:	b289      	uxth	r1, r1
 800ccc6:	4620      	mov	r0, r4
 800ccc8:	f7fe faf2 	bl	800b2b0 <_ZN4rtps9UdpDriver19createUdpConnectionEt>
}
 800cccc:	bd38      	pop	{r3, r4, r5, pc}

0800ccce <_ZNK4rtps6Domain18generateGuidPrefixEa>:
        return &reader;
    }
}

rtps::GuidPrefix_t Domain::generateGuidPrefix(ParticipantId_t id) const{
    GuidPrefix_t prefix = Config::BASE_GUID_PREFIX;
 800ccce:	2101      	movs	r1, #1
 800ccd0:	7001      	strb	r1, [r0, #0]
 800ccd2:	2102      	movs	r1, #2
 800ccd4:	7041      	strb	r1, [r0, #1]
 800ccd6:	2103      	movs	r1, #3
 800ccd8:	7081      	strb	r1, [r0, #2]
 800ccda:	2104      	movs	r1, #4
 800ccdc:	70c1      	strb	r1, [r0, #3]
 800ccde:	2105      	movs	r1, #5
 800cce0:	7101      	strb	r1, [r0, #4]
 800cce2:	2106      	movs	r1, #6
 800cce4:	7141      	strb	r1, [r0, #5]
 800cce6:	2107      	movs	r1, #7
 800cce8:	7181      	strb	r1, [r0, #6]
 800ccea:	2108      	movs	r1, #8
 800ccec:	71c1      	strb	r1, [r0, #7]
 800ccee:	2109      	movs	r1, #9
 800ccf0:	7201      	strb	r1, [r0, #8]
 800ccf2:	210a      	movs	r1, #10
 800ccf4:	7241      	strb	r1, [r0, #9]
 800ccf6:	210c      	movs	r1, #12
 800ccf8:	7281      	strb	r1, [r0, #10]
    prefix.id[prefix.id.size()-1] = *reinterpret_cast<uint8_t*>(&id);
 800ccfa:	72c2      	strb	r2, [r0, #11]
    return prefix;
}
 800ccfc:	4770      	bx	lr

0800ccfe <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_>:
bool StatelessWriterT<NetworkDriver>::init(TopicData attributes, TopicKind_t topicKind, ThreadPool* threadPool, NetworkDriver& driver){
 800ccfe:	b084      	sub	sp, #16
 800cd00:	b510      	push	{r4, lr}
 800cd02:	4604      	mov	r4, r0
 800cd04:	a803      	add	r0, sp, #12
 800cd06:	e880 000e 	stmia.w	r0, {r1, r2, r3}
    if (sys_mutex_new(&m_mutex) != ERR_OK) {
 800cd0a:	f104 0058 	add.w	r0, r4, #88	; 0x58
 800cd0e:	f7fc f9a3 	bl	8009058 <sys_mutex_new>
 800cd12:	b9a0      	cbnz	r0, 800cd3e <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x40>
    m_attributes = attributes;
 800cd14:	2254      	movs	r2, #84	; 0x54
 800cd16:	a903      	add	r1, sp, #12
 800cd18:	1d20      	adds	r0, r4, #4
 800cd1a:	f002 fbb4 	bl	800f486 <memcpy>
    m_packetInfo.srcPort = attributes.unicastLocator.port;
 800cd1e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800cd20:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    m_topicKind = topicKind;
 800cd24:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 800cd28:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    mp_threadPool = threadPool;
 800cd2c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800cd2e:	65e3      	str	r3, [r4, #92]	; 0x5c
    m_transport = &driver;
 800cd30:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800cd32:	6763      	str	r3, [r4, #116]	; 0x74
    return true;
 800cd34:	2001      	movs	r0, #1
}
 800cd36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800cd3a:	b004      	add	sp, #16
 800cd3c:	4770      	bx	lr
        return false;
 800cd3e:	2000      	movs	r0, #0
 800cd40:	e7f9      	b.n	800cd36 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x38>

0800cd42 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE4initERKNS_9TopicDataERS1_>:
void StatefulReaderT<NetworkDriver>::init(const TopicData& attributes, NetworkDriver& driver){
 800cd42:	b570      	push	{r4, r5, r6, lr}
 800cd44:	4604      	mov	r4, r0
 800cd46:	460d      	mov	r5, r1
 800cd48:	4616      	mov	r6, r2
    m_attributes = attributes;
 800cd4a:	2254      	movs	r2, #84	; 0x54
 800cd4c:	3004      	adds	r0, #4
 800cd4e:	f002 fb9a 	bl	800f486 <memcpy>
    m_transport = &driver;
 800cd52:	66e6      	str	r6, [r4, #108]	; 0x6c
    m_packetInfo.srcPort = attributes.unicastLocator.port;
 800cd54:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800cd56:	f8a4 3058 	strh.w	r3, [r4, #88]	; 0x58
    sys_mutex_new(&m_mutex);
 800cd5a:	f504 7094 	add.w	r0, r4, #296	; 0x128
 800cd5e:	f7fc f97b 	bl	8009058 <sys_mutex_new>
}
 800cd62:	bd70      	pop	{r4, r5, r6, pc}

0800cd64 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_>:
bool StatefulWriterT<NetworkDriver>::init(TopicData attributes, TopicKind_t topicKind, ThreadPool* /*threadPool*/, NetworkDriver& driver){
 800cd64:	b084      	sub	sp, #16
 800cd66:	b570      	push	{r4, r5, r6, lr}
 800cd68:	b082      	sub	sp, #8
 800cd6a:	4604      	mov	r4, r0
 800cd6c:	a807      	add	r0, sp, #28
 800cd6e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
    if (sys_mutex_new(&m_mutex) != ERR_OK) {
 800cd72:	f104 0058 	add.w	r0, r4, #88	; 0x58
 800cd76:	f7fc f96f 	bl	8009058 <sys_mutex_new>
 800cd7a:	2800      	cmp	r0, #0
 800cd7c:	d152      	bne.n	800ce24 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xc0>
    m_transport = &driver;
 800cd7e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800cd80:	6763      	str	r3, [r4, #116]	; 0x74
    m_attributes = attributes;
 800cd82:	2254      	movs	r2, #84	; 0x54
 800cd84:	a907      	add	r1, sp, #28
 800cd86:	1d20      	adds	r0, r4, #4
 800cd88:	f002 fb7d 	bl	800f486 <memcpy>
    m_topicKind = topicKind;
 800cd8c:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 800cd90:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_packetInfo.srcPort = attributes.unicastLocator.port;
 800cd94:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800cd96:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    if(m_attributes.endpointGuid.entityId == ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER){
 800cd9a:	f104 0610 	add.w	r6, r4, #16
      { return const_iterator(data() + _Nm); }
 800cd9e:	f104 0213 	add.w	r2, r4, #19
	  if (const size_t __len = (__last1 - __first1))
 800cda2:	1b92      	subs	r2, r2, r6
 800cda4:	d004      	beq.n	800cdb0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x4c>
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800cda6:	4923      	ldr	r1, [pc, #140]	; (800ce34 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xd0>)
 800cda8:	4630      	mov	r0, r6
 800cdaa:	f002 fb5d 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 800cdae:	b9d8      	cbnz	r0, 800cde8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x84>
                   this->entityKind == other.entityKind;
 800cdb0:	78f3      	ldrb	r3, [r6, #3]
            return this->entityKey == other.entityKey &&
 800cdb2:	2bc2      	cmp	r3, #194	; 0xc2
 800cdb4:	d01a      	beq.n	800cdec <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x88>
 800cdb6:	2500      	movs	r5, #0
 800cdb8:	b9d5      	cbnz	r5, 800cdf0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x8c>
 800cdba:	2203      	movs	r2, #3
 800cdbc:	491e      	ldr	r1, [pc, #120]	; (800ce38 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xd4>)
 800cdbe:	4630      	mov	r0, r6
 800cdc0:	f002 fb52 	bl	800f468 <memcmp>
 800cdc4:	b910      	cbnz	r0, 800cdcc <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x68>
                   this->entityKind == other.entityKind;
 800cdc6:	78f3      	ldrb	r3, [r6, #3]
            return this->entityKey == other.entityKey &&
 800cdc8:	2bc2      	cmp	r3, #194	; 0xc2
 800cdca:	d01d      	beq.n	800ce08 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xa4>
    }else if(m_attributes.endpointGuid.entityId == ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_WRITER){
 800cdcc:	b9f5      	cbnz	r5, 800ce0c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xa8>
    	 m_heartbeatThread = sys_thread_new("HBThread", hbFunctionJumppad, this, Config::HEARTBEAT_STACKSIZE, Config::THREAD_POOL_WRITER_PRIO);
 800cdce:	2303      	movs	r3, #3
 800cdd0:	9300      	str	r3, [sp, #0]
 800cdd2:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 800cdd6:	4622      	mov	r2, r4
 800cdd8:	4918      	ldr	r1, [pc, #96]	; (800ce3c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xd8>)
 800cdda:	4819      	ldr	r0, [pc, #100]	; (800ce40 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xdc>)
 800cddc:	f7fc f95e 	bl	800909c <sys_thread_new>
 800cde0:	f8c4 016c 	str.w	r0, [r4, #364]	; 0x16c
    return true;
 800cde4:	2501      	movs	r5, #1
 800cde6:	e01e      	b.n	800ce26 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xc2>
 800cde8:	2500      	movs	r5, #0
 800cdea:	e7e5      	b.n	800cdb8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x54>
 800cdec:	2501      	movs	r5, #1
 800cdee:	e7e3      	b.n	800cdb8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x54>
    	m_heartbeatThread = sys_thread_new("HBThreadPub", hbFunctionJumppad, this, Config::HEARTBEAT_STACKSIZE, Config::THREAD_POOL_WRITER_PRIO);
 800cdf0:	2303      	movs	r3, #3
 800cdf2:	9300      	str	r3, [sp, #0]
 800cdf4:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 800cdf8:	4622      	mov	r2, r4
 800cdfa:	4910      	ldr	r1, [pc, #64]	; (800ce3c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xd8>)
 800cdfc:	4811      	ldr	r0, [pc, #68]	; (800ce44 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xe0>)
 800cdfe:	f7fc f94d 	bl	800909c <sys_thread_new>
 800ce02:	f8c4 016c 	str.w	r0, [r4, #364]	; 0x16c
 800ce06:	e00e      	b.n	800ce26 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xc2>
 800ce08:	2501      	movs	r5, #1
 800ce0a:	e7df      	b.n	800cdcc <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0x68>
    	m_heartbeatThread = sys_thread_new("HBThreadSub", hbFunctionJumppad, this, Config::HEARTBEAT_STACKSIZE, Config::THREAD_POOL_WRITER_PRIO);
 800ce0c:	2303      	movs	r3, #3
 800ce0e:	9300      	str	r3, [sp, #0]
 800ce10:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 800ce14:	4622      	mov	r2, r4
 800ce16:	4909      	ldr	r1, [pc, #36]	; (800ce3c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xd8>)
 800ce18:	480b      	ldr	r0, [pc, #44]	; (800ce48 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xe4>)
 800ce1a:	f7fc f93f 	bl	800909c <sys_thread_new>
 800ce1e:	f8c4 016c 	str.w	r0, [r4, #364]	; 0x16c
 800ce22:	e000      	b.n	800ce26 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_+0xc2>
        return false;
 800ce24:	2500      	movs	r5, #0
}
 800ce26:	4628      	mov	r0, r5
 800ce28:	b002      	add	sp, #8
 800ce2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800ce2e:	b004      	add	sp, #16
 800ce30:	4770      	bx	lr
 800ce32:	bf00      	nop
 800ce34:	08010940 	.word	0x08010940
 800ce38:	08010944 	.word	0x08010944
 800ce3c:	0800d59b 	.word	0x0800d59b
 800ce40:	08011ca0 	.word	0x08011ca0
 800ce44:	08011c88 	.word	0x08011c88
 800ce48:	08011c94 	.word	0x08011c94

0800ce4c <_ZN4rtps6Domain30createBuiltinWritersAndReadersERNS_11ParticipantE>:
void Domain::createBuiltinWritersAndReaders(Participant &part) {
 800ce4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ce50:	b0ff      	sub	sp, #508	; 0x1fc
 800ce52:	4605      	mov	r5, r0
 800ce54:	468c      	mov	ip, r1
    StatelessWriter& spdpWriter = m_statelessWriters[m_numStatelessWriters++];
 800ce56:	f241 72dc 	movw	r2, #6108	; 0x17dc
 800ce5a:	5c83      	ldrb	r3, [r0, r2]
 800ce5c:	1c59      	adds	r1, r3, #1
 800ce5e:	5481      	strb	r1, [r0, r2]
      { return const_cast<_Tp&>(__t[__n]); }
 800ce60:	f241 2ae4 	movw	sl, #4836	; 0x12e4
 800ce64:	4482      	add	sl, r0
 800ce66:	f44f 791f 	mov.w	r9, #636	; 0x27c
 800ce6a:	fb09 f903 	mul.w	r9, r9, r3
 800ce6e:	eb0a 0309 	add.w	r3, sl, r9
 800ce72:	9319      	str	r3, [sp, #100]	; 0x64
    StatelessReader& spdpReader = m_statelessReaders[m_numStatelessReaders++];
 800ce74:	f500 53c5 	add.w	r3, r0, #6304	; 0x18a0
 800ce78:	7818      	ldrb	r0, [r3, #0]
 800ce7a:	9018      	str	r0, [sp, #96]	; 0x60
 800ce7c:	1c42      	adds	r2, r0, #1
 800ce7e:	701a      	strb	r2, [r3, #0]
    spdpWriterAttributes.topicName[0] = '\0';
 800ce80:	2400      	movs	r4, #0
 800ce82:	f88d 4164 	strb.w	r4, [sp, #356]	; 0x164
    spdpWriterAttributes.typeName[0] = '\0';
 800ce86:	f88d 4150 	strb.w	r4, [sp, #336]	; 0x150
    spdpWriterAttributes.reliabilityKind = ReliabilityKind_t::BEST_EFFORT;
 800ce8a:	2601      	movs	r6, #1
 800ce8c:	965e      	str	r6, [sp, #376]	; 0x178
    spdpWriterAttributes.endpointGuid.prefix = part.m_guidPrefix;
 800ce8e:	af50      	add	r7, sp, #320	; 0x140
 800ce90:	f8cd c05c 	str.w	ip, [sp, #92]	; 0x5c
 800ce94:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 800ce98:	e887 0007 	stmia.w	r7, {r0, r1, r2}
    spdpWriterAttributes.endpointGuid.entityId = ENTITYID_SPDP_BUILTIN_PARTICIPANT_WRITER;
 800ce9c:	f8df 825c 	ldr.w	r8, [pc, #604]	; 800d0fc <_ZN4rtps6Domain30createBuiltinWritersAndReadersERNS_11ParticipantE+0x2b0>
 800cea0:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800cea4:	9353      	str	r3, [sp, #332]	; 0x14c
 800cea6:	9474      	str	r4, [sp, #464]	; 0x1d0
 800cea8:	9475      	str	r4, [sp, #468]	; 0x1d4
 800ceaa:	9476      	str	r4, [sp, #472]	; 0x1d8
            locator.kind = LocatorKind_t::LOCATOR_KIND_UDPv4;
 800ceac:	9672      	str	r6, [sp, #456]	; 0x1c8
            locator.address = {0,0,0,0,0,0,0,0,0,0,0,0,a,b,c,d};
 800ceae:	f04f 0bef 	mov.w	fp, #239	; 0xef
 800ceb2:	f88d b1dc 	strb.w	fp, [sp, #476]	; 0x1dc
 800ceb6:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 800ceba:	f88d c1dd 	strb.w	ip, [sp, #477]	; 0x1dd
 800cebe:	f88d 41de 	strb.w	r4, [sp, #478]	; 0x1de
 800cec2:	f88d 61df 	strb.w	r6, [sp, #479]	; 0x1df
            locator.port = port;
 800cec6:	f641 43e8 	movw	r3, #7400	; 0x1ce8
 800ceca:	9373      	str	r3, [sp, #460]	; 0x1cc
    spdpWriterAttributes.unicastLocator = getBuiltInMulticastLocator();
 800cecc:	f50d 7cbe 	add.w	ip, sp, #380	; 0x17c
 800ced0:	f50d 7ee4 	add.w	lr, sp, #456	; 0x1c8
 800ced4:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800ced8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800cedc:	e89e 0003 	ldmia.w	lr, {r0, r1}
 800cee0:	e88c 0003 	stmia.w	ip, {r0, r1}
    spdpWriter.init(spdpWriterAttributes, TopicKind_t::WITH_KEY, &m_threadPool, m_transport);
 800cee4:	f505 739e 	add.w	r3, r5, #316	; 0x13c
 800cee8:	931d      	str	r3, [sp, #116]	; 0x74
 800ceea:	9314      	str	r3, [sp, #80]	; 0x50
 800ceec:	9513      	str	r5, [sp, #76]	; 0x4c
 800ceee:	f04f 0e02 	mov.w	lr, #2
 800cef2:	f8cd e048 	str.w	lr, [sp, #72]	; 0x48
 800cef6:	2248      	movs	r2, #72	; 0x48
 800cef8:	a953      	add	r1, sp, #332	; 0x14c
 800cefa:	4668      	mov	r0, sp
 800cefc:	f002 fac3 	bl	800f486 <memcpy>
 800cf00:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 800cf04:	9819      	ldr	r0, [sp, #100]	; 0x64
 800cf06:	f7ff fefa 	bl	800ccfe <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_>
    spdpWriter.addNewMatchedReader(ReaderProxy{{part.m_guidPrefix, ENTITYID_SPDP_BUILTIN_PARTICIPANT_READER}, getBuiltInMulticastLocator()});
 800cf0a:	f85a 3009 	ldr.w	r3, [sl, r9]
 800cf0e:	f8d3 9000 	ldr.w	r9, [r3]
 800cf12:	ab65      	add	r3, sp, #404	; 0x194
 800cf14:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800cf16:	c907      	ldmia	r1, {r0, r1, r2}
 800cf18:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800cf1c:	f88d 41a0 	strb.w	r4, [sp, #416]	; 0x1a0
 800cf20:	f88d 61a1 	strb.w	r6, [sp, #417]	; 0x1a1
 800cf24:	f88d 41a2 	strb.w	r4, [sp, #418]	; 0x1a2
 800cf28:	27c7      	movs	r7, #199	; 0xc7
 800cf2a:	f88d 71a3 	strb.w	r7, [sp, #419]	; 0x1a3
    struct Locator{
 800cf2e:	946b      	str	r4, [sp, #428]	; 0x1ac
 800cf30:	946c      	str	r4, [sp, #432]	; 0x1b0
 800cf32:	946d      	str	r4, [sp, #436]	; 0x1b4
            locator.kind = LocatorKind_t::LOCATOR_KIND_UDPv4;
 800cf34:	9669      	str	r6, [sp, #420]	; 0x1a4
            locator.address = {0,0,0,0,0,0,0,0,0,0,0,0,a,b,c,d};
 800cf36:	f88d b1b8 	strb.w	fp, [sp, #440]	; 0x1b8
 800cf3a:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 800cf3e:	f88d c1b9 	strb.w	ip, [sp, #441]	; 0x1b9
 800cf42:	f88d 41ba 	strb.w	r4, [sp, #442]	; 0x1ba
 800cf46:	f88d 61bb 	strb.w	r6, [sp, #443]	; 0x1bb
            locator.port = port;
 800cf4a:	f641 42e8 	movw	r2, #7400	; 0x1ce8
 800cf4e:	926a      	str	r2, [sp, #424]	; 0x1a8
              ackNackSet(), ackNackCount{0}{};
 800cf50:	f10d 0a7c 	add.w	sl, sp, #124	; 0x7c
 800cf54:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800cf56:	e88a 000f 	stmia.w	sl, {r0, r1, r2, r3}
 800cf5a:	f10d 0c8c 	add.w	ip, sp, #140	; 0x8c
 800cf5e:	f50d 7ed2 	add.w	lr, sp, #420	; 0x1a4
 800cf62:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800cf66:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800cf6a:	e89e 0003 	ldmia.w	lr, {r0, r1}
 800cf6e:	e88c 0003 	stmia.w	ip, {r0, r1}
 800cf72:	9429      	str	r4, [sp, #164]	; 0xa4
 800cf74:	942a      	str	r4, [sp, #168]	; 0xa8
        SequenceNumberSet() = default;
 800cf76:	2220      	movs	r2, #32
 800cf78:	f8ca 2030 	str.w	r2, [sl, #48]	; 0x30
 800cf7c:	4621      	mov	r1, r4
 800cf7e:	a82c      	add	r0, sp, #176	; 0xb0
 800cf80:	f002 fa8c 	bl	800f49c <memset>
 800cf84:	f8ca 4054 	str.w	r4, [sl, #84]	; 0x54
 800cf88:	4651      	mov	r1, sl
 800cf8a:	9819      	ldr	r0, [sp, #100]	; 0x64
 800cf8c:	47c8      	blx	r9
    spdpReader.m_attributes.endpointGuid = {part.m_guidPrefix, ENTITYID_SPDP_BUILTIN_PARTICIPANT_READER};
 800cf8e:	f50d 7cde 	add.w	ip, sp, #444	; 0x1bc
 800cf92:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800cf94:	ca07      	ldmia	r2, {r0, r1, r2}
 800cf96:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
 800cf9a:	f505 5abf 	add.w	sl, r5, #6112	; 0x17e0
 800cf9e:	9918      	ldr	r1, [sp, #96]	; 0x60
 800cfa0:	fa01 f906 	lsl.w	r9, r1, r6
 800cfa4:	eb09 0301 	add.w	r3, r9, r1
 800cfa8:	eb0a 1343 	add.w	r3, sl, r3, lsl #5
 800cfac:	f103 0e04 	add.w	lr, r3, #4
 800cfb0:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 800cfb4:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
 800cfb8:	741c      	strb	r4, [r3, #16]
 800cfba:	745e      	strb	r6, [r3, #17]
 800cfbc:	749c      	strb	r4, [r3, #18]
 800cfbe:	74df      	strb	r7, [r3, #19]
    StatefulReader& sedpPubReader = m_statefulReaders[m_numStatefulReaders++];
 800cfc0:	f641 20fc 	movw	r0, #6908	; 0x1afc
 800cfc4:	5c2f      	ldrb	r7, [r5, r0]
 800cfc6:	19ba      	adds	r2, r7, r6
 800cfc8:	b2d2      	uxtb	r2, r2
 800cfca:	f641 03a4 	movw	r3, #6308	; 0x18a4
 800cfce:	442b      	add	r3, r5
 800cfd0:	f44f 7196 	mov.w	r1, #300	; 0x12c
 800cfd4:	fb01 3707 	mla	r7, r1, r7, r3
 800cfd8:	971c      	str	r7, [sp, #112]	; 0x70
    StatefulReader& sedpSubReader = m_statefulReaders[m_numStatefulReaders++];
 800cfda:	1997      	adds	r7, r2, r6
 800cfdc:	542f      	strb	r7, [r5, r0]
 800cfde:	fb01 3202 	mla	r2, r1, r2, r3
 800cfe2:	921b      	str	r2, [sp, #108]	; 0x6c
    StatefulWriter& sedpPubWriter = m_statefulWriters[m_numStatefulWriters++];
 800cfe4:	f242 0110 	movw	r1, #8208	; 0x2010
 800cfe8:	5c68      	ldrb	r0, [r5, r1]
 800cfea:	eb00 0b06 	add.w	fp, r0, r6
 800cfee:	fa5f fb8b 	uxtb.w	fp, fp
 800cff2:	f505 53d8 	add.w	r3, r5, #6912	; 0x1b00
 800cff6:	f44f 7222 	mov.w	r2, #648	; 0x288
 800cffa:	fb02 3000 	mla	r0, r2, r0, r3
 800cffe:	901a      	str	r0, [sp, #104]	; 0x68
    StatefulWriter& sedpSubWriter = m_statefulWriters[m_numStatefulWriters++];
 800d000:	eb0b 0006 	add.w	r0, fp, r6
 800d004:	5468      	strb	r0, [r5, r1]
 800d006:	fb02 3b0b 	mla	fp, r2, fp, r3
    struct Locator{
 800d00a:	af3b      	add	r7, sp, #236	; 0xec
 800d00c:	944f      	str	r4, [sp, #316]	; 0x13c
    sedpAttributes.topicName[0] = '\0';
 800d00e:	f887 4024 	strb.w	r4, [r7, #36]	; 0x24
    sedpAttributes.typeName[0] = '\0';
 800d012:	743c      	strb	r4, [r7, #16]
    sedpAttributes.reliabilityKind = ReliabilityKind_t::RELIABLE;
 800d014:	f04f 0c02 	mov.w	ip, #2
 800d018:	f8c7 c038 	str.w	ip, [r7, #56]	; 0x38
    sedpAttributes.endpointGuid.prefix = part.m_guidPrefix;
 800d01c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800d01e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800d022:	e887 0007 	stmia.w	r7, {r0, r1, r2}
    sedpAttributes.unicastLocator = getBuiltInUnicastLocator(part.m_participantId);
 800d026:	f993 300c 	ldrsb.w	r3, [r3, #12]
               D1 +
 800d02a:	f603 6379 	addw	r3, r3, #3705	; 0xe79
               PG * participantId;
 800d02e:	40b3      	lsls	r3, r6
 800d030:	b29b      	uxth	r3, r3
 800d032:	947a      	str	r4, [sp, #488]	; 0x1e8
 800d034:	947b      	str	r4, [sp, #492]	; 0x1ec
 800d036:	947c      	str	r4, [sp, #496]	; 0x1f0
            locator.kind = LocatorKind_t::LOCATOR_KIND_UDPv4;
 800d038:	9678      	str	r6, [sp, #480]	; 0x1e0
            locator.address = {0,0,0,0,0,0,0,0,0,0,0,0,a,b,c,d};
 800d03a:	22c0      	movs	r2, #192	; 0xc0
 800d03c:	f88d 21f4 	strb.w	r2, [sp, #500]	; 0x1f4
 800d040:	22a8      	movs	r2, #168	; 0xa8
 800d042:	f88d 21f5 	strb.w	r2, [sp, #501]	; 0x1f5
 800d046:	f88d 41f6 	strb.w	r4, [sp, #502]	; 0x1f6
 800d04a:	222f      	movs	r2, #47	; 0x2f
 800d04c:	f88d 21f7 	strb.w	r2, [sp, #503]	; 0x1f7
            locator.port = port;
 800d050:	9379      	str	r3, [sp, #484]	; 0x1e4
 800d052:	ac4a      	add	r4, sp, #296	; 0x128
 800d054:	f50d 7cf0 	add.w	ip, sp, #480	; 0x1e0
 800d058:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800d05c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800d05e:	e89c 0003 	ldmia.w	ip, {r0, r1}
 800d062:	e884 0003 	stmia.w	r4, {r0, r1}
    sedpAttributes.endpointGuid.entityId = ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER;
 800d066:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800d06a:	60fb      	str	r3, [r7, #12]
    sedpPubReader.init(sedpAttributes, m_transport);
 800d06c:	9c1d      	ldr	r4, [sp, #116]	; 0x74
 800d06e:	4622      	mov	r2, r4
 800d070:	4639      	mov	r1, r7
 800d072:	981c      	ldr	r0, [sp, #112]	; 0x70
 800d074:	f7ff fe65 	bl	800cd42 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE4initERKNS_9TopicDataERS1_>
    sedpAttributes.endpointGuid.entityId = ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_READER;
 800d078:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800d07c:	60fb      	str	r3, [r7, #12]
    sedpSubReader.init(sedpAttributes, m_transport);
 800d07e:	4622      	mov	r2, r4
 800d080:	4639      	mov	r1, r7
 800d082:	981b      	ldr	r0, [sp, #108]	; 0x6c
 800d084:	f7ff fe5d 	bl	800cd42 <_ZN4rtps15StatefulReaderTINS_9UdpDriverEE4initERKNS_9TopicDataERS1_>
    sedpAttributes.endpointGuid.entityId = ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER;
 800d088:	f8d8 3000 	ldr.w	r3, [r8]
 800d08c:	60fb      	str	r3, [r7, #12]
    sedpPubWriter.init(sedpAttributes, TopicKind_t::NO_KEY, &m_threadPool, m_transport);
 800d08e:	9414      	str	r4, [sp, #80]	; 0x50
 800d090:	9513      	str	r5, [sp, #76]	; 0x4c
 800d092:	9612      	str	r6, [sp, #72]	; 0x48
 800d094:	2248      	movs	r2, #72	; 0x48
 800d096:	f10d 0cf8 	add.w	ip, sp, #248	; 0xf8
 800d09a:	4661      	mov	r1, ip
 800d09c:	4668      	mov	r0, sp
 800d09e:	f002 f9f2 	bl	800f486 <memcpy>
 800d0a2:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 800d0a6:	981a      	ldr	r0, [sp, #104]	; 0x68
 800d0a8:	f7ff fe5c 	bl	800cd64 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_>
    sedpAttributes.endpointGuid.entityId = ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_WRITER;
 800d0ac:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800d0b0:	60fb      	str	r3, [r7, #12]
    sedpSubWriter.init(sedpAttributes, TopicKind_t::NO_KEY, &m_threadPool, m_transport);
 800d0b2:	9414      	str	r4, [sp, #80]	; 0x50
 800d0b4:	9513      	str	r5, [sp, #76]	; 0x4c
 800d0b6:	9612      	str	r6, [sp, #72]	; 0x48
 800d0b8:	2248      	movs	r2, #72	; 0x48
 800d0ba:	ad3e      	add	r5, sp, #248	; 0xf8
 800d0bc:	4629      	mov	r1, r5
 800d0be:	4668      	mov	r0, sp
 800d0c0:	f002 f9e1 	bl	800f486 <memcpy>
 800d0c4:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 800d0c8:	4658      	mov	r0, fp
 800d0ca:	f7ff fe4b 	bl	800cd64 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_>
    endpoints.spdpWriter = &spdpWriter;
 800d0ce:	9c19      	ldr	r4, [sp, #100]	; 0x64
 800d0d0:	9435      	str	r4, [sp, #212]	; 0xd4
    endpoints.spdpReader = &spdpReader;
 800d0d2:	9918      	ldr	r1, [sp, #96]	; 0x60
 800d0d4:	4489      	add	r9, r1
 800d0d6:	eb0a 1349 	add.w	r3, sl, r9, lsl #5
 800d0da:	9336      	str	r3, [sp, #216]	; 0xd8
    endpoints.sedpPubReader = &sedpPubReader;
 800d0dc:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 800d0de:	9738      	str	r7, [sp, #224]	; 0xe0
    endpoints.sedpSubReader = &sedpSubReader;
 800d0e0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800d0e2:	923a      	str	r2, [sp, #232]	; 0xe8
    endpoints.sedpPubWriter = &sedpPubWriter;
 800d0e4:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800d0e6:	9237      	str	r2, [sp, #220]	; 0xdc
    endpoints.sedpSubWriter = &sedpSubWriter;
 800d0e8:	f8cd b0e4 	str.w	fp, [sp, #228]	; 0xe4
    part.addBuiltInEndpoints(endpoints);
 800d0ec:	a935      	add	r1, sp, #212	; 0xd4
 800d0ee:	9817      	ldr	r0, [sp, #92]	; 0x5c
 800d0f0:	f000 fe90 	bl	800de14 <_ZN4rtps11Participant19addBuiltInEndpointsERNS_16BuiltInEndpointsE>
}
 800d0f4:	b07f      	add	sp, #508	; 0x1fc
 800d0f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d0fa:	bf00      	nop
 800d0fc:	08010940 	.word	0x08010940

0800d100 <_ZN4rtps6Domain17createParticipantEv>:
rtps::Participant* Domain::createParticipant(){
 800d100:	b570      	push	{r4, r5, r6, lr}
 800d102:	b084      	sub	sp, #16
    auto nextSlot = static_cast<uint8_t>(m_nextParticipantId - PARTICIPANT_START_ID);
 800d104:	f241 23e1 	movw	r3, #4833	; 0x12e1
 800d108:	56c2      	ldrsb	r2, [r0, r3]
 800d10a:	b2d4      	uxtb	r4, r2
 800d10c:	f500 5397 	add.w	r3, r0, #4832	; 0x12e0
 800d110:	781b      	ldrb	r3, [r3, #0]
 800d112:	1ae4      	subs	r4, r4, r3
    if(!m_initComplete || m_participants.size() <= nextSlot){
 800d114:	f242 0311 	movw	r3, #8209	; 0x2011
 800d118:	5cc3      	ldrb	r3, [r0, r3]
 800d11a:	b30b      	cbz	r3, 800d160 <_ZN4rtps6Domain17createParticipantEv+0x60>
 800d11c:	b2e4      	uxtb	r4, r4
 800d11e:	bb0c      	cbnz	r4, 800d164 <_ZN4rtps6Domain17createParticipantEv+0x64>
 800d120:	4605      	mov	r5, r0
 800d122:	f500 73cc 	add.w	r3, r0, #408	; 0x198
 800d126:	f241 1148 	movw	r1, #4424	; 0x1148
 800d12a:	fb01 3404 	mla	r4, r1, r4, r3
    entry.reuse(generateGuidPrefix(m_nextParticipantId), m_nextParticipantId);
 800d12e:	4601      	mov	r1, r0
 800d130:	a801      	add	r0, sp, #4
 800d132:	f7ff fdcc 	bl	800ccce <_ZNK4rtps6Domain18generateGuidPrefixEa>
 800d136:	f241 26e1 	movw	r6, #4833	; 0x12e1
 800d13a:	57aa      	ldrsb	r2, [r5, r6]
 800d13c:	a901      	add	r1, sp, #4
 800d13e:	4620      	mov	r0, r4
 800d140:	f000 fcbc 	bl	800dabc <_ZN4rtps11Participant5reuseERKNS_12GuidPrefix_tEa>
    registerPort(entry);
 800d144:	4621      	mov	r1, r4
 800d146:	4628      	mov	r0, r5
 800d148:	f7ff fda8 	bl	800cc9c <_ZN4rtps6Domain12registerPortERKNS_11ParticipantE>
    createBuiltinWritersAndReaders(entry);
 800d14c:	4621      	mov	r1, r4
 800d14e:	4628      	mov	r0, r5
 800d150:	f7ff fe7c 	bl	800ce4c <_ZN4rtps6Domain30createBuiltinWritersAndReadersERNS_11ParticipantE>
    ++m_nextParticipantId;
 800d154:	57ab      	ldrsb	r3, [r5, r6]
 800d156:	3301      	adds	r3, #1
 800d158:	55ab      	strb	r3, [r5, r6]
}
 800d15a:	4620      	mov	r0, r4
 800d15c:	b004      	add	sp, #16
 800d15e:	bd70      	pop	{r4, r5, r6, pc}
        return nullptr;
 800d160:	2400      	movs	r4, #0
 800d162:	e7fa      	b.n	800d15a <_ZN4rtps6Domain17createParticipantEv+0x5a>
 800d164:	2400      	movs	r4, #0
 800d166:	e7f8      	b.n	800d15a <_ZN4rtps6Domain17createParticipantEv+0x5a>

0800d168 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b>:
rtps::Writer* Domain::createWriter(Participant& part, const char* topicName, const char* typeName, bool reliable){
 800d168:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d16c:	b0b3      	sub	sp, #204	; 0xcc
 800d16e:	f89d 80e8 	ldrb.w	r8, [sp, #232]	; 0xe8
       (!reliable && m_statelessWriters.size() <= m_numStatelessWriters) ||
 800d172:	f1b8 0f00 	cmp.w	r8, #0
 800d176:	d005      	beq.n	800d184 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x1c>
    if((reliable && m_statefulWriters.size() <= m_numStatefulWriters) ||
 800d178:	f242 0410 	movw	r4, #8208	; 0x2010
 800d17c:	5d04      	ldrb	r4, [r0, r4]
 800d17e:	2c01      	cmp	r4, #1
 800d180:	f200 80ba 	bhi.w	800d2f8 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x190>
 800d184:	f1b8 0f00 	cmp.w	r8, #0
 800d188:	d105      	bne.n	800d196 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x2e>
       (!reliable && m_statelessWriters.size() <= m_numStatelessWriters) ||
 800d18a:	f241 74dc 	movw	r4, #6108	; 0x17dc
 800d18e:	5d04      	ldrb	r4, [r0, r4]
 800d190:	2c01      	cmp	r4, #1
 800d192:	f200 80b3 	bhi.w	800d2fc <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x194>
 800d196:	461f      	mov	r7, r3
 800d198:	4616      	mov	r6, r2
 800d19a:	460c      	mov	r4, r1
 800d19c:	4605      	mov	r5, r0
	    part.isWritersFull()){
 800d19e:	4608      	mov	r0, r1
 800d1a0:	f000 fcf2 	bl	800db88 <_ZN4rtps11Participant13isWritersFullEv>
       (!reliable && m_statelessWriters.size() <= m_numStatelessWriters) ||
 800d1a4:	2800      	cmp	r0, #0
 800d1a6:	f040 80ab 	bne.w	800d300 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x198>
    struct Locator{
 800d1aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d1ae:	9325      	str	r3, [sp, #148]	; 0x94
 800d1b0:	2100      	movs	r1, #0
 800d1b2:	9126      	str	r1, [sp, #152]	; 0x98
 800d1b4:	9127      	str	r1, [sp, #156]	; 0x9c
 800d1b6:	9128      	str	r1, [sp, #160]	; 0xa0
 800d1b8:	9129      	str	r1, [sp, #164]	; 0xa4
 800d1ba:	912a      	str	r1, [sp, #168]	; 0xa8
    if(strlen(topicName) > Config::MAX_TOPICNAME_LENGTH || strlen(typeName) > Config::MAX_TYPENAME_LENGTH){
 800d1bc:	4630      	mov	r0, r6
 800d1be:	f7f3 f849 	bl	8000254 <strlen>
 800d1c2:	2814      	cmp	r0, #20
 800d1c4:	f200 809e 	bhi.w	800d304 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x19c>
 800d1c8:	4638      	mov	r0, r7
 800d1ca:	f7f3 f843 	bl	8000254 <strlen>
 800d1ce:	2814      	cmp	r0, #20
 800d1d0:	f200 809a 	bhi.w	800d308 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x1a0>
    strcpy(attributes.topicName, topicName);
 800d1d4:	f10d 0958 	add.w	r9, sp, #88	; 0x58
 800d1d8:	4631      	mov	r1, r6
 800d1da:	a81f      	add	r0, sp, #124	; 0x7c
 800d1dc:	f002 fa2a 	bl	800f634 <strcpy>
    strcpy(attributes.typeName, typeName);
 800d1e0:	4639      	mov	r1, r7
 800d1e2:	a81a      	add	r0, sp, #104	; 0x68
 800d1e4:	f002 fa26 	bl	800f634 <strcpy>
    attributes.endpointGuid.prefix = part.m_guidPrefix;
 800d1e8:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 800d1ec:	e889 0007 	stmia.w	r9, {r0, r1, r2}
    attributes.endpointGuid.entityId = {part.getNextUserEntityKey(), EntityKind_t::USER_DEFINED_WRITER_WITHOUT_KEY};
 800d1f0:	4620      	mov	r0, r4
 800d1f2:	f000 fc6f 	bl	800dad4 <_ZN4rtps11Participant20getNextUserEntityKeyEv>
 800d1f6:	f88d 00ac 	strb.w	r0, [sp, #172]	; 0xac
 800d1fa:	f3c0 2307 	ubfx	r3, r0, #8, #8
 800d1fe:	f88d 30ad 	strb.w	r3, [sp, #173]	; 0xad
 800d202:	f3c0 4007 	ubfx	r0, r0, #16, #8
 800d206:	f88d 00ae 	strb.w	r0, [sp, #174]	; 0xae
 800d20a:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800d20c:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
 800d210:	0c1b      	lsrs	r3, r3, #16
 800d212:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
 800d216:	2303      	movs	r3, #3
 800d218:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    attributes.unicastLocator = getUserUnicastLocator(part.m_participantId);
 800d21c:	f994 200c 	ldrsb.w	r2, [r4, #12]
               PG * participantId;
 800d220:	0052      	lsls	r2, r2, #1
 800d222:	b292      	uxth	r2, r2
 800d224:	f641 43f3 	movw	r3, #7411	; 0x1cf3
 800d228:	4413      	add	r3, r2
 800d22a:	b29b      	uxth	r3, r3
 800d22c:	2200      	movs	r2, #0
 800d22e:	922e      	str	r2, [sp, #184]	; 0xb8
 800d230:	922f      	str	r2, [sp, #188]	; 0xbc
 800d232:	9230      	str	r2, [sp, #192]	; 0xc0
            locator.kind = LocatorKind_t::LOCATOR_KIND_UDPv4;
 800d234:	2101      	movs	r1, #1
 800d236:	912c      	str	r1, [sp, #176]	; 0xb0
            locator.address = {0,0,0,0,0,0,0,0,0,0,0,0,a,b,c,d};
 800d238:	21c0      	movs	r1, #192	; 0xc0
 800d23a:	f88d 10c4 	strb.w	r1, [sp, #196]	; 0xc4
 800d23e:	21a8      	movs	r1, #168	; 0xa8
 800d240:	f88d 10c5 	strb.w	r1, [sp, #197]	; 0xc5
 800d244:	f88d 20c6 	strb.w	r2, [sp, #198]	; 0xc6
 800d248:	222f      	movs	r2, #47	; 0x2f
 800d24a:	f88d 20c7 	strb.w	r2, [sp, #199]	; 0xc7
            locator.port = port;
 800d24e:	932d      	str	r3, [sp, #180]	; 0xb4
 800d250:	ae25      	add	r6, sp, #148	; 0x94
 800d252:	af2c      	add	r7, sp, #176	; 0xb0
 800d254:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800d256:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800d258:	e897 0003 	ldmia.w	r7, {r0, r1}
 800d25c:	e886 0003 	stmia.w	r6, {r0, r1}
    if(reliable){
 800d260:	f1b8 0f00 	cmp.w	r8, #0
 800d264:	d125      	bne.n	800d2b2 <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x14a>
        attributes.reliabilityKind = ReliabilityKind_t::BEST_EFFORT;
 800d266:	2201      	movs	r2, #1
 800d268:	9224      	str	r2, [sp, #144]	; 0x90
        StatelessWriter& writer = m_statelessWriters[m_numStatelessWriters++];
 800d26a:	f241 73dc 	movw	r3, #6108	; 0x17dc
 800d26e:	5cee      	ldrb	r6, [r5, r3]
 800d270:	18b1      	adds	r1, r6, r2
 800d272:	54e9      	strb	r1, [r5, r3]
 800d274:	f241 23e4 	movw	r3, #4836	; 0x12e4
 800d278:	442b      	add	r3, r5
 800d27a:	f44f 711f 	mov.w	r1, #636	; 0x27c
 800d27e:	fb01 3606 	mla	r6, r1, r6, r3
        writer.init(attributes, TopicKind_t::NO_KEY, &m_threadPool, m_transport);
 800d282:	f505 739e 	add.w	r3, r5, #316	; 0x13c
 800d286:	9314      	str	r3, [sp, #80]	; 0x50
 800d288:	9513      	str	r5, [sp, #76]	; 0x4c
 800d28a:	9212      	str	r2, [sp, #72]	; 0x48
 800d28c:	2248      	movs	r2, #72	; 0x48
 800d28e:	a919      	add	r1, sp, #100	; 0x64
 800d290:	4668      	mov	r0, sp
 800d292:	f002 f8f8 	bl	800f486 <memcpy>
 800d296:	ab16      	add	r3, sp, #88	; 0x58
 800d298:	cb0e      	ldmia	r3, {r1, r2, r3}
 800d29a:	4630      	mov	r0, r6
 800d29c:	f7ff fd2f 	bl	800ccfe <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_>
        part.addWriter(&writer);
 800d2a0:	4635      	mov	r5, r6
 800d2a2:	4631      	mov	r1, r6
 800d2a4:	4620      	mov	r0, r4
 800d2a6:	f000 fc56 	bl	800db56 <_ZN4rtps11Participant9addWriterEPNS_6WriterE>
}
 800d2aa:	4628      	mov	r0, r5
 800d2ac:	b033      	add	sp, #204	; 0xcc
 800d2ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        attributes.reliabilityKind = ReliabilityKind_t::RELIABLE;
 800d2b2:	2302      	movs	r3, #2
 800d2b4:	9324      	str	r3, [sp, #144]	; 0x90
        StatefulWriter& writer = m_statefulWriters[m_numStatefulWriters++];
 800d2b6:	f242 0310 	movw	r3, #8208	; 0x2010
 800d2ba:	5cee      	ldrb	r6, [r5, r3]
 800d2bc:	1c72      	adds	r2, r6, #1
 800d2be:	54ea      	strb	r2, [r5, r3]
 800d2c0:	f505 53d8 	add.w	r3, r5, #6912	; 0x1b00
 800d2c4:	f44f 7222 	mov.w	r2, #648	; 0x288
 800d2c8:	fb02 3606 	mla	r6, r2, r6, r3
        writer.init(attributes, TopicKind_t::NO_KEY, &m_threadPool, m_transport);
 800d2cc:	f505 739e 	add.w	r3, r5, #316	; 0x13c
 800d2d0:	9314      	str	r3, [sp, #80]	; 0x50
 800d2d2:	9513      	str	r5, [sp, #76]	; 0x4c
 800d2d4:	2301      	movs	r3, #1
 800d2d6:	9312      	str	r3, [sp, #72]	; 0x48
 800d2d8:	2248      	movs	r2, #72	; 0x48
 800d2da:	a919      	add	r1, sp, #100	; 0x64
 800d2dc:	4668      	mov	r0, sp
 800d2de:	f002 f8d2 	bl	800f486 <memcpy>
 800d2e2:	ab16      	add	r3, sp, #88	; 0x58
 800d2e4:	cb0e      	ldmia	r3, {r1, r2, r3}
 800d2e6:	4630      	mov	r0, r6
 800d2e8:	f7ff fd3c 	bl	800cd64 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE4initENS_9TopicDataENS_11TopicKind_tEPNS_10ThreadPoolERS1_>
        part.addWriter(&writer);
 800d2ec:	4635      	mov	r5, r6
 800d2ee:	4631      	mov	r1, r6
 800d2f0:	4620      	mov	r0, r4
 800d2f2:	f000 fc30 	bl	800db56 <_ZN4rtps11Participant9addWriterEPNS_6WriterE>
 800d2f6:	e7d8      	b.n	800d2aa <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x142>
        return nullptr;
 800d2f8:	2500      	movs	r5, #0
 800d2fa:	e7d6      	b.n	800d2aa <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x142>
 800d2fc:	2500      	movs	r5, #0
 800d2fe:	e7d4      	b.n	800d2aa <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x142>
 800d300:	2500      	movs	r5, #0
 800d302:	e7d2      	b.n	800d2aa <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x142>
        return nullptr;
 800d304:	2500      	movs	r5, #0
 800d306:	e7d0      	b.n	800d2aa <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x142>
 800d308:	2500      	movs	r5, #0
 800d30a:	e7ce      	b.n	800d2aa <_ZN4rtps6Domain12createWriterERNS_11ParticipantEPKcS4_b+0x142>

0800d30c <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_19SubmessageHeartbeatE>:
    bool serializeMessage(Buffer& buffer, SubmessageHeartbeat& msg){
 800d30c:	b570      	push	{r4, r5, r6, lr}
 800d30e:	4604      	mov	r4, r0
 800d310:	460d      	mov	r5, r1
        if(!buffer.reserve(SubmessageHeartbeat::getRawSize())){
 800d312:	2120      	movs	r1, #32
 800d314:	f001 f8bd 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>
 800d318:	4606      	mov	r6, r0
 800d31a:	b908      	cbnz	r0, 800d320 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_19SubmessageHeartbeatE+0x14>
	}
 800d31c:	4630      	mov	r0, r6
 800d31e:	bd70      	pop	{r4, r5, r6, pc}
		serializeMessage(buffer, msg.header);
 800d320:	4629      	mov	r1, r5
 800d322:	4620      	mov	r0, r4
 800d324:	f7fc ff98 	bl	800a258 <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_16SubmessageHeaderE>
		buffer.append(msg.readerId.entityKey.data(), msg.readerId.entityKey.size());
 800d328:	2203      	movs	r2, #3
 800d32a:	1d29      	adds	r1, r5, #4
 800d32c:	4620      	mov	r0, r4
 800d32e:	f001 f86e 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.readerId.entityKind), sizeof(EntityKind_t));
 800d332:	2201      	movs	r2, #1
 800d334:	1de9      	adds	r1, r5, #7
 800d336:	4620      	mov	r0, r4
 800d338:	f001 f869 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(msg.writerId.entityKey.data(), msg.writerId.entityKey.size());
 800d33c:	2203      	movs	r2, #3
 800d33e:	f105 0108 	add.w	r1, r5, #8
 800d342:	4620      	mov	r0, r4
 800d344:	f001 f863 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.writerId.entityKind), sizeof(EntityKind_t));
 800d348:	2201      	movs	r2, #1
 800d34a:	f105 010b 	add.w	r1, r5, #11
 800d34e:	4620      	mov	r0, r4
 800d350:	f001 f85d 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.firstSN.high), sizeof(msg.firstSN.high));
 800d354:	2204      	movs	r2, #4
 800d356:	f105 010c 	add.w	r1, r5, #12
 800d35a:	4620      	mov	r0, r4
 800d35c:	f001 f857 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.firstSN.low), sizeof(msg.firstSN.low));
 800d360:	2204      	movs	r2, #4
 800d362:	f105 0110 	add.w	r1, r5, #16
 800d366:	4620      	mov	r0, r4
 800d368:	f001 f851 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.lastSN.high), sizeof(msg.lastSN.high));
 800d36c:	2204      	movs	r2, #4
 800d36e:	f105 0114 	add.w	r1, r5, #20
 800d372:	4620      	mov	r0, r4
 800d374:	f001 f84b 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.lastSN.low), sizeof(msg.lastSN.low));
 800d378:	2204      	movs	r2, #4
 800d37a:	f105 0118 	add.w	r1, r5, #24
 800d37e:	4620      	mov	r0, r4
 800d380:	f001 f845 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
		buffer.append(reinterpret_cast<uint8_t*>(&msg.count.value), sizeof(msg.count.value));
 800d384:	2204      	movs	r2, #4
 800d386:	f105 011c 	add.w	r1, r5, #28
 800d38a:	4620      	mov	r0, r4
 800d38c:	f001 f83f 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
        return true;
 800d390:	e7c4      	b.n	800d31c <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_19SubmessageHeartbeatE+0x10>

0800d392 <_ZN4rtps14MessageFactory12addHeartbeatINS_11PBufWrapperEEEvRT_NS_10EntityId_tES5_NS_16SequenceNumber_tES6_NS_7Count_tE>:
        void addHeartbeat(Buffer& buffer, EntityId_t writerId, EntityId_t readerId, SequenceNumber_t firstSN,
 800d392:	b082      	sub	sp, #8
 800d394:	b510      	push	{r4, lr}
 800d396:	b08a      	sub	sp, #40	; 0x28
 800d398:	4604      	mov	r4, r0
 800d39a:	9101      	str	r1, [sp, #4]
 800d39c:	9200      	str	r2, [sp, #0]
 800d39e:	930d      	str	r3, [sp, #52]	; 0x34
            subMsg.header.submessageId = SubmessageKind::HEARTBEAT;
 800d3a0:	2307      	movs	r3, #7
 800d3a2:	f88d 3008 	strb.w	r3, [sp, #8]
            subMsg.header.submessageLength = SubmessageHeartbeat::getRawSize() - numBytesUntilEndOfLength;
 800d3a6:	231c      	movs	r3, #28
 800d3a8:	f8ad 300a 	strh.w	r3, [sp, #10]
            subMsg.header.flags = FLAG_LITTLE_ENDIAN;
 800d3ac:	2301      	movs	r3, #1
 800d3ae:	f88d 3009 	strb.w	r3, [sp, #9]
            subMsg.writerId = writerId;
 800d3b2:	9104      	str	r1, [sp, #16]
            subMsg.readerId = readerId;
 800d3b4:	9203      	str	r2, [sp, #12]
            subMsg.firstSN = firstSN;
 800d3b6:	ab05      	add	r3, sp, #20
 800d3b8:	aa0d      	add	r2, sp, #52	; 0x34
 800d3ba:	e892 0003 	ldmia.w	r2, {r0, r1}
 800d3be:	e883 0003 	stmia.w	r3, {r0, r1}
            subMsg.lastSN = lastSN;
 800d3c2:	ab07      	add	r3, sp, #28
 800d3c4:	aa0f      	add	r2, sp, #60	; 0x3c
 800d3c6:	e892 0003 	ldmia.w	r2, {r0, r1}
 800d3ca:	e883 0003 	stmia.w	r3, {r0, r1}
            subMsg.count = count;
 800d3ce:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800d3d0:	9309      	str	r3, [sp, #36]	; 0x24
            serializeMessage(buffer, subMsg);
 800d3d2:	a902      	add	r1, sp, #8
 800d3d4:	4620      	mov	r0, r4
 800d3d6:	f7ff ff99 	bl	800d30c <_ZN4rtps16serializeMessageINS_11PBufWrapperEEEbRT_RNS_19SubmessageHeartbeatE>
        }
 800d3da:	b00a      	add	sp, #40	; 0x28
 800d3dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3e0:	b002      	add	sp, #8
 800d3e2:	4770      	bx	lr

0800d3e4 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv>:
            return m_numElements == 0;
 800d3e4:	f8d0 317c 	ldr.w	r3, [r0, #380]	; 0x17c
    }
}

template <class NetworkDriver>
void StatefulWriterT<NetworkDriver>::sendHeartBeat() {
    if(m_proxies.isEmpty()){
 800d3e8:	b903      	cbnz	r3, 800d3ec <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x8>
 800d3ea:	4770      	bx	lr
void StatefulWriterT<NetworkDriver>::sendHeartBeat() {
 800d3ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d3f0:	b093      	sub	sp, #76	; 0x4c
        log("StatefulWriter[%s]: Skipping heartbeat. No proxies.\n", this->m_attributes.topicName);
#endif
        return;
    }

    for(auto& proxy : m_proxies) {
 800d3f2:	f500 72bc 	add.w	r2, r0, #376	; 0x178
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 800d3f6:	9205      	str	r2, [sp, #20]
 800d3f8:	2300      	movs	r3, #0
 800d3fa:	f88d 3019 	strb.w	r3, [sp, #25]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 800d3fe:	f890 3178 	ldrb.w	r3, [r0, #376]	; 0x178
 800d402:	f88d 3018 	strb.w	r3, [sp, #24]
            if(!(m_bitMap[0] & 1)){
 800d406:	f013 0f01 	tst.w	r3, #1
 800d40a:	d119      	bne.n	800d440 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x5c>
                if(m_pool.m_numElements == 0){
 800d40c:	f8d0 317c 	ldr.w	r3, [r0, #380]	; 0x17c
 800d410:	b19b      	cbz	r3, 800d43a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x56>
                    ++m_bit;
 800d412:	f89d 3019 	ldrb.w	r3, [sp, #25]
 800d416:	3301      	adds	r3, #1
 800d418:	b2db      	uxtb	r3, r3
 800d41a:	f88d 3019 	strb.w	r3, [sp, #25]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800d41e:	aa12      	add	r2, sp, #72	; 0x48
 800d420:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800d424:	f811 2c30 	ldrb.w	r2, [r1, #-48]
 800d428:	0852      	lsrs	r2, r2, #1
 800d42a:	f801 2c30 	strb.w	r2, [r1, #-48]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800d42e:	f012 0f01 	tst.w	r2, #1
 800d432:	d105      	bne.n	800d440 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x5c>
 800d434:	2b02      	cmp	r3, #2
 800d436:	d9ec      	bls.n	800d412 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x2e>
 800d438:	e002      	b.n	800d440 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x5c>
                    m_bit = SIZE;
 800d43a:	2303      	movs	r3, #3
 800d43c:	f88d 3019 	strb.w	r3, [sp, #25]
 800d440:	4604      	mov	r4, r0
            endIt.m_bit = SIZE;
 800d442:	2303      	movs	r3, #3
 800d444:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
 800d448:	e05b      	b.n	800d502 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x11e>

        SequenceNumber_t firstSN;
        SequenceNumber_t lastSN;
        MessageFactory::addHeader(info.buffer, m_attributes.endpointGuid.prefix);
        {
            Lock lock(m_mutex);
 800d44a:	f104 0858 	add.w	r8, r4, #88	; 0x58
            sys_mutex_lock(&m_mutex);
 800d44e:	4640      	mov	r0, r8
 800d450:	f7fb fe18 	bl	8009084 <sys_mutex_lock>
            firstSN = m_history.getSeqNumMin();
 800d454:	f104 0984 	add.w	r9, r4, #132	; 0x84
 800d458:	4648      	mov	r0, r9
 800d45a:	f001 f833 	bl	800e4c4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv>
 800d45e:	ab09      	add	r3, sp, #36	; 0x24
 800d460:	c803      	ldmia	r0, {r0, r1}
 800d462:	e883 0003 	stmia.w	r3, {r0, r1}
            lastSN = m_history.getSeqNumMax();
 800d466:	4648      	mov	r0, r9
 800d468:	f001 f83c 	bl	800e4e4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMaxEv>
 800d46c:	ab0b      	add	r3, sp, #44	; 0x2c
 800d46e:	c803      	ldmia	r0, {r0, r1}
 800d470:	e883 0003 	stmia.w	r3, {r0, r1}
            sys_mutex_unlock(&m_mutex);
 800d474:	4640      	mov	r0, r8
 800d476:	f7fb fe0c 	bl	8009092 <sys_mutex_unlock>
            return high == other.high && low == other.low;
 800d47a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d47c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800d480:	d017      	beq.n	800d4b2 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0xce>
 800d482:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d484:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800d488:	d101      	bne.n	800d48e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0xaa>
 800d48a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d48c:	b1a3      	cbz	r3, 800d4b8 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0xd4>
            }
#endif
            return;
        }

        MessageFactory::addHeartbeat(info.buffer, m_attributes.endpointGuid.entityId,
 800d48e:	f8d4 3170 	ldr.w	r3, [r4, #368]	; 0x170
 800d492:	9303      	str	r3, [sp, #12]
 800d494:	ab01      	add	r3, sp, #4
 800d496:	aa0b      	add	r2, sp, #44	; 0x2c
 800d498:	e892 0003 	ldmia.w	r2, {r0, r1}
 800d49c:	e883 0003 	stmia.w	r3, {r0, r1}
 800d4a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d4a2:	9300      	str	r3, [sp, #0]
 800d4a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d4a6:	68f2      	ldr	r2, [r6, #12]
 800d4a8:	6921      	ldr	r1, [r4, #16]
 800d4aa:	a810      	add	r0, sp, #64	; 0x40
 800d4ac:	f7ff ff71 	bl	800d392 <_ZN4rtps14MessageFactory12addHeartbeatINS_11PBufWrapperEEEvRT_NS_10EntityId_tES5_NS_16SequenceNumber_tES6_NS_7Count_tE>
 800d4b0:	e006      	b.n	800d4c0 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0xdc>
 800d4b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d4b4:	2b00      	cmp	r3, #0
 800d4b6:	d1e4      	bne.n	800d482 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x9e>
 800d4b8:	a810      	add	r0, sp, #64	; 0x40
 800d4ba:	f000 ff92 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800d4be:	e052      	b.n	800d566 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x182>
                                     proxy.remoteReaderGuid.entityId, firstSN, lastSN, m_hbCount);

        info.destAddr = proxy.remoteLocator.getIp4Address();
 800d4c0:	2258      	movs	r2, #88	; 0x58
 800d4c2:	fb02 f207 	mul.w	r2, r2, r7
 800d4c6:	f102 0118 	add.w	r1, r2, #24
 800d4ca:	4429      	add	r1, r5
            return transformIP4ToU32(address[12], address[13], address[14], address[15]);
 800d4cc:	7d08      	ldrb	r0, [r1, #20]
 800d4ce:	7d4e      	ldrb	r6, [r1, #21]
 800d4d0:	7d8b      	ldrb	r3, [r1, #22]
 800d4d2:	7dc9      	ldrb	r1, [r1, #23]
                ((uint32_t) (p1 << 16)) |
 800d4d4:	041b      	lsls	r3, r3, #16
        return {((uint32_t) (LSB << 24)) |
 800d4d6:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
                ((uint32_t) (p1 << 16)) |
 800d4da:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
                ((uint32_t) (p2 << 8)) |
 800d4de:	4303      	orrs	r3, r0
 800d4e0:	930e      	str	r3, [sp, #56]	; 0x38
        info.destPort = proxy.remoteLocator.port;
 800d4e2:	442a      	add	r2, r5
 800d4e4:	69d3      	ldr	r3, [r2, #28]
 800d4e6:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c

        m_transport->sendPacket(info);
 800d4ea:	a90d      	add	r1, sp, #52	; 0x34
 800d4ec:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800d4ee:	f7fd ffb5 	bl	800b45c <_ZN4rtps9UdpDriver10sendPacketERNS_10PacketInfoE>
 800d4f2:	a810      	add	r0, sp, #64	; 0x40
 800d4f4:	f000 ff75 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
                if(m_pool.m_numElements == 0){
 800d4f8:	686b      	ldr	r3, [r5, #4]
 800d4fa:	b9db      	cbnz	r3, 800d534 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x150>
                    m_bit = SIZE;
 800d4fc:	2303      	movs	r3, #3
 800d4fe:	f88d 3019 	strb.w	r3, [sp, #25]
                 return m_bit != other.m_bit;
 800d502:	f89d 7019 	ldrb.w	r7, [sp, #25]
 800d506:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    for(auto& proxy : m_proxies) {
 800d50a:	42bb      	cmp	r3, r7
 800d50c:	d026      	beq.n	800d55c <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x178>
                return m_pool.m_data[m_bit];
 800d50e:	9d05      	ldr	r5, [sp, #20]
 800d510:	2358      	movs	r3, #88	; 0x58
 800d512:	fb03 f307 	mul.w	r3, r3, r7
 800d516:	3308      	adds	r3, #8
 800d518:	18ee      	adds	r6, r5, r3
 800d51a:	2300      	movs	r3, #0
 800d51c:	9310      	str	r3, [sp, #64]	; 0x40
 800d51e:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
        info.srcPort = m_packetInfo.srcPort;
 800d522:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 800d526:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
        MessageFactory::addHeader(info.buffer, m_attributes.endpointGuid.prefix);
 800d52a:	1d21      	adds	r1, r4, #4
 800d52c:	a810      	add	r0, sp, #64	; 0x40
 800d52e:	f7fc fe79 	bl	800a224 <_ZN4rtps14MessageFactory9addHeaderINS_11PBufWrapperEEEvRT_RKNS_12GuidPrefix_tE>
 800d532:	e78a      	b.n	800d44a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x66>
                    ++m_bit;
 800d534:	f89d 3019 	ldrb.w	r3, [sp, #25]
 800d538:	3301      	adds	r3, #1
 800d53a:	b2db      	uxtb	r3, r3
 800d53c:	f88d 3019 	strb.w	r3, [sp, #25]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800d540:	aa12      	add	r2, sp, #72	; 0x48
 800d542:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800d546:	f811 2c30 	ldrb.w	r2, [r1, #-48]
 800d54a:	0852      	lsrs	r2, r2, #1
 800d54c:	f801 2c30 	strb.w	r2, [r1, #-48]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800d550:	f012 0f01 	tst.w	r2, #1
 800d554:	d1d5      	bne.n	800d502 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x11e>
 800d556:	2b02      	cmp	r3, #2
 800d558:	d9ec      	bls.n	800d534 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x150>
 800d55a:	e7d2      	b.n	800d502 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x11e>
    }
    m_hbCount.value++;
 800d55c:	f8d4 3170 	ldr.w	r3, [r4, #368]	; 0x170
 800d560:	3301      	adds	r3, #1
 800d562:	f8c4 3170 	str.w	r3, [r4, #368]	; 0x170
}
 800d566:	b013      	add	sp, #76	; 0x4c
 800d568:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d56c:	4640      	mov	r0, r8
 800d56e:	f7fb fd90 	bl	8009092 <sys_mutex_unlock>
 800d572:	a810      	add	r0, sp, #64	; 0x40
 800d574:	f000 ff35 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800d578:	f001 fa2f 	bl	800e9da <__cxa_end_cleanup>
 800d57c:	e7f9      	b.n	800d572 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv+0x18e>

0800d57e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE17sendHeartBeatLoopEv>:
void StatefulWriterT<NetworkDriver>::sendHeartBeatLoop(){
 800d57e:	b510      	push	{r4, lr}
 800d580:	4604      	mov	r4, r0
    while(m_running){
 800d582:	f894 3174 	ldrb.w	r3, [r4, #372]	; 0x174
 800d586:	b13b      	cbz	r3, 800d598 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE17sendHeartBeatLoopEv+0x1a>
        sendHeartBeat();
 800d588:	4620      	mov	r0, r4
 800d58a:	f7ff ff2b 	bl	800d3e4 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE13sendHeartBeatEv>
        sys_msleep(Config::SF_WRITER_HB_PERIOD_MS);
 800d58e:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800d592:	f7f9 faed 	bl	8006b70 <sys_msleep>
    while(m_running){
 800d596:	e7f4      	b.n	800d582 <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE17sendHeartBeatLoopEv+0x4>
}
 800d598:	bd10      	pop	{r4, pc}

0800d59a <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE17hbFunctionJumppadEPv>:
void StatefulWriterT<NetworkDriver>::hbFunctionJumppad(void* thisPointer){
 800d59a:	b508      	push	{r3, lr}
    writer->sendHeartBeatLoop();
 800d59c:	f7ff ffef 	bl	800d57e <_ZN4rtps15StatefulWriterTINS_9UdpDriverEE17sendHeartBeatLoopEv>
}
 800d5a0:	bd08      	pop	{r3, pc}

0800d5a2 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_>:
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800d5a2:	b538      	push	{r3, r4, r5, lr}
 800d5a4:	4610      	mov	r0, r2
        return proxy.remoteReaderGuid == guid;
 800d5a6:	680c      	ldr	r4, [r1, #0]
      { return const_iterator(data() + _Nm); }
 800d5a8:	f102 050c 	add.w	r5, r2, #12
 800d5ac:	220c      	movs	r2, #12
 800d5ae:	4621      	mov	r1, r4
 800d5b0:	f001 ff5a 	bl	800f468 <memcmp>
 800d5b4:	fab0 f080 	clz	r0, r0
 800d5b8:	0940      	lsrs	r0, r0, #5
            return this->prefix == other.prefix &&
 800d5ba:	b150      	cbz	r0, 800d5d2 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x30>
                   this->entityId == other.entityId;
 800d5bc:	340c      	adds	r4, #12
 800d5be:	2203      	movs	r2, #3
 800d5c0:	4621      	mov	r1, r4
 800d5c2:	4628      	mov	r0, r5
 800d5c4:	f001 ff50 	bl	800f468 <memcmp>
            return this->entityKey == other.entityKey &&
 800d5c8:	b920      	cbnz	r0, 800d5d4 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x32>
                   this->entityKind == other.entityKind;
 800d5ca:	78ea      	ldrb	r2, [r5, #3]
 800d5cc:	78e3      	ldrb	r3, [r4, #3]
            return this->entityKey == other.entityKey &&
 800d5ce:	429a      	cmp	r2, r3
 800d5d0:	d002      	beq.n	800d5d8 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x36>
    auto thunk=[](void* arg, const ReaderProxy& value){return (*static_cast<decltype(isElementToRemove)*>(arg))(value);};
 800d5d2:	bd38      	pop	{r3, r4, r5, pc}
 800d5d4:	2000      	movs	r0, #0
 800d5d6:	e7fc      	b.n	800d5d2 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x30>
 800d5d8:	2001      	movs	r0, #1
 800d5da:	e7fa      	b.n	800d5d2 <_ZZN4rtps16StatelessWriterTINS_9UdpDriverEE12removeReaderERKNS_4GuidEENKUlPvRKNS_11ReaderProxyEE0_clES6_S9_+0x30>

0800d5dc <_ZNK4rtps16StatelessWriterTINS_9UdpDriverEE12isIrrelevantENS_12ChangeKind_tE>:
template <typename NetworkDriver>
bool StatelessWriterT<NetworkDriver>::isIrrelevant(ChangeKind_t kind) const{
    // Right now we only allow alive changes
    //return kind == ChangeKind_t::INVALID || (m_topicKind == TopicKind_t::NO_KEY && kind != ChangeKind_t::ALIVE);
    return kind != ChangeKind_t::ALIVE;
}
 800d5dc:	f111 30ff 	adds.w	r0, r1, #4294967295	; 0xffffffff
 800d5e0:	bf18      	it	ne
 800d5e2:	2001      	movne	r0, #1
 800d5e4:	4770      	bx	lr

0800d5e6 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht>:
const CacheChange* StatelessWriterT<NetworkDriver>::newChange(rtps::ChangeKind_t kind, const uint8_t* data, DataSize_t size) {
 800d5e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d5ea:	b084      	sub	sp, #16
 800d5ec:	4604      	mov	r4, r0
 800d5ee:	4617      	mov	r7, r2
 800d5f0:	4698      	mov	r8, r3
    if(isIrrelevant(kind)){
 800d5f2:	f7ff fff3 	bl	800d5dc <_ZNK4rtps16StatelessWriterTINS_9UdpDriverEE12isIrrelevantENS_12ChangeKind_tE>
 800d5f6:	2800      	cmp	r0, #0
 800d5f8:	d13f      	bne.n	800d67a <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x94>
    Lock lock(m_mutex);
 800d5fa:	f104 0658 	add.w	r6, r4, #88	; 0x58
            sys_mutex_lock(&m_mutex);
 800d5fe:	4630      	mov	r0, r6
 800d600:	f7fb fd40 	bl	8009084 <sys_mutex_lock>
    if(m_history.isFull()){
 800d604:	f104 0584 	add.w	r5, r4, #132	; 0x84
 800d608:	4628      	mov	r0, r5
 800d60a:	f000 ff4d 	bl	800e4a8 <_ZNK4rtps18SimpleHistoryCache6isFullEv>
 800d60e:	b310      	cbz	r0, 800d656 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x70>
        SequenceNumber_t newMin = ++SequenceNumber_t(m_history.getSeqNumMin());
 800d610:	4628      	mov	r0, r5
 800d612:	f000 ff57 	bl	800e4c4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv>
 800d616:	c803      	ldmia	r0, {r0, r1}
 800d618:	ab04      	add	r3, sp, #16
 800d61a:	e903 0003 	stmdb	r3, {r0, r1}
            ++low;
 800d61e:	9b03      	ldr	r3, [sp, #12]
 800d620:	3301      	adds	r3, #1
 800d622:	9303      	str	r3, [sp, #12]
            if(low == 0){
 800d624:	b913      	cbnz	r3, 800d62c <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x46>
                ++high;
 800d626:	9a02      	ldr	r2, [sp, #8]
 800d628:	3201      	adds	r2, #1
 800d62a:	9202      	str	r2, [sp, #8]
 800d62c:	466a      	mov	r2, sp
 800d62e:	a904      	add	r1, sp, #16
 800d630:	e911 0003 	ldmdb	r1, {r0, r1}
 800d634:	e882 0003 	stmia.w	r2, {r0, r1}
            return high < other.high || (high == other.high && low < other.low);
 800d638:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800d63a:	4290      	cmp	r0, r2
 800d63c:	dc04      	bgt.n	800d648 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x62>
 800d63e:	d10a      	bne.n	800d656 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x70>
 800d640:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800d644:	429a      	cmp	r2, r3
 800d646:	d206      	bcs.n	800d656 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x70>
            m_nextSequenceNumberToSend = newMin; // Make sure we have the correct sn to send
 800d648:	f104 037c 	add.w	r3, r4, #124	; 0x7c
 800d64c:	466a      	mov	r2, sp
 800d64e:	e892 0003 	ldmia.w	r2, {r0, r1}
 800d652:	e883 0003 	stmia.w	r3, {r0, r1}
    auto* result = m_history.addChange(data, size);
 800d656:	4642      	mov	r2, r8
 800d658:	4639      	mov	r1, r7
 800d65a:	4628      	mov	r0, r5
 800d65c:	f000 ff4e 	bl	800e4fc <_ZN4rtps18SimpleHistoryCache9addChangeEPKht>
 800d660:	4605      	mov	r5, r0
    if(mp_threadPool != nullptr){
 800d662:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800d664:	b110      	cbz	r0, 800d66c <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x86>
        mp_threadPool->addWorkload(this);
 800d666:	4621      	mov	r1, r4
 800d668:	f7fd fcd9 	bl	800b01e <_ZN4rtps10ThreadPool11addWorkloadEPNS_6WriterE>
            sys_mutex_unlock(&m_mutex);
 800d66c:	4630      	mov	r0, r6
 800d66e:	f7fb fd10 	bl	8009092 <sys_mutex_unlock>
}
 800d672:	4628      	mov	r0, r5
 800d674:	b004      	add	sp, #16
 800d676:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return nullptr;
 800d67a:	2500      	movs	r5, #0
 800d67c:	e7f9      	b.n	800d672 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE9newChangeENS_12ChangeKind_tEPKht+0x8c>
 800d67e:	4630      	mov	r0, r6
 800d680:	f7fb fd07 	bl	8009092 <sys_mutex_unlock>
 800d684:	f001 f9a9 	bl	800e9da <__cxa_end_cleanup>

0800d688 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv>:

template <typename NetworkDriver>
void StatelessWriterT<NetworkDriver>::progress(){
 800d688:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d68a:	b08d      	sub	sp, #52	; 0x34
 800d68c:	4604      	mov	r4, r0
    // TODO smarter packaging e.g. by creating MessageStruct and serialize after adjusting values
    // Reusing the pbuf is not possible. See https://www.nongnu.org/lwip/2_1_x/raw_api.html (Zero-Copy MACs)

    for(const auto& proxy : m_proxies){
 800d68e:	f500 72b6 	add.w	r2, r0, #364	; 0x16c
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 800d692:	9203      	str	r2, [sp, #12]
 800d694:	2300      	movs	r3, #0
 800d696:	f88d 3011 	strb.w	r3, [sp, #17]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 800d69a:	f890 316c 	ldrb.w	r3, [r0, #364]	; 0x16c
 800d69e:	f88d 3010 	strb.w	r3, [sp, #16]
            if(!(m_bitMap[0] & 1)){
 800d6a2:	f013 0f01 	tst.w	r3, #1
 800d6a6:	d119      	bne.n	800d6dc <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x54>
                if(m_pool.m_numElements == 0){
 800d6a8:	f8d0 3170 	ldr.w	r3, [r0, #368]	; 0x170
 800d6ac:	b19b      	cbz	r3, 800d6d6 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x4e>
                    ++m_bit;
 800d6ae:	f89d 3011 	ldrb.w	r3, [sp, #17]
 800d6b2:	3301      	adds	r3, #1
 800d6b4:	b2db      	uxtb	r3, r3
 800d6b6:	f88d 3011 	strb.w	r3, [sp, #17]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800d6ba:	aa0c      	add	r2, sp, #48	; 0x30
 800d6bc:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800d6c0:	f811 2c20 	ldrb.w	r2, [r1, #-32]
 800d6c4:	0852      	lsrs	r2, r2, #1
 800d6c6:	f801 2c20 	strb.w	r2, [r1, #-32]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800d6ca:	f012 0f01 	tst.w	r2, #1
 800d6ce:	d105      	bne.n	800d6dc <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x54>
 800d6d0:	2b02      	cmp	r3, #2
 800d6d2:	d9ec      	bls.n	800d6ae <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x26>
 800d6d4:	e002      	b.n	800d6dc <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x54>
                    m_bit = SIZE;
 800d6d6:	2303      	movs	r3, #3
 800d6d8:	f88d 3011 	strb.w	r3, [sp, #17]
            endIt.m_bit = SIZE;
 800d6dc:	2303      	movs	r3, #3
 800d6de:	f88d 3019 	strb.w	r3, [sp, #25]
 800d6e2:	e04f      	b.n	800d784 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0xfc>

        PacketInfo info;
        info.srcPort = m_packetInfo.srcPort;

        MessageFactory::addHeader(info.buffer, m_attributes.endpointGuid.prefix);
        MessageFactory::addSubMessageTimeStamp(info.buffer);
 800d6e4:	2100      	movs	r1, #0
 800d6e6:	a80a      	add	r0, sp, #40	; 0x28
 800d6e8:	f7fc fdd4 	bl	800a294 <_ZN4rtps14MessageFactory22addSubMessageTimeStampINS_11PBufWrapperEEEvRT_b>

        {
            Lock lock(m_mutex);
 800d6ec:	f104 0758 	add.w	r7, r4, #88	; 0x58
            sys_mutex_lock(&m_mutex);
 800d6f0:	4638      	mov	r0, r7
 800d6f2:	f7fb fcc7 	bl	8009084 <sys_mutex_lock>
            const CacheChange* next = m_history.getChangeBySN(m_nextSequenceNumberToSend);
 800d6f6:	f104 037c 	add.w	r3, r4, #124	; 0x7c
 800d6fa:	e893 0006 	ldmia.w	r3, {r1, r2}
 800d6fe:	f104 0084 	add.w	r0, r4, #132	; 0x84
 800d702:	f000 ff64 	bl	800e5ce <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE>
            if(next == nullptr){
 800d706:	4601      	mov	r1, r0
 800d708:	b360      	cbz	r0, 800d764 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0xdc>
#if SLW_VERBOSE
                printf("StatelessWriter[%s]: Sending change with SN (%i,%i)\n",
                        &m_attributes.topicName[0], m_nextSequenceNumberToSend.high, m_nextSequenceNumberToSend.low);
#endif
            }
            MessageFactory::addSubMessageData(info.buffer, next->data, false, next->sequenceNumber, m_attributes.endpointGuid.entityId,
 800d70a:	2358      	movs	r3, #88	; 0x58
 800d70c:	fb03 f306 	mul.w	r3, r3, r6
 800d710:	3310      	adds	r3, #16
 800d712:	442b      	add	r3, r5
 800d714:	3304      	adds	r3, #4
 800d716:	9301      	str	r3, [sp, #4]
 800d718:	f104 0310 	add.w	r3, r4, #16
 800d71c:	9300      	str	r3, [sp, #0]
 800d71e:	1d03      	adds	r3, r0, #4
 800d720:	2200      	movs	r2, #0
 800d722:	310c      	adds	r1, #12
 800d724:	a80a      	add	r0, sp, #40	; 0x28
 800d726:	f7fc ffb8 	bl	800a69a <_ZN4rtps14MessageFactory17addSubMessageDataINS_11PBufWrapperEEEvRT_RKS3_bRKNS_16SequenceNumber_tERKNS_10EntityId_tESC_>
            sys_mutex_unlock(&m_mutex);
 800d72a:	4638      	mov	r0, r7
 800d72c:	f7fb fcb1 	bl	8009092 <sys_mutex_unlock>
                                              proxy.remoteReaderGuid.entityId); // TODO
        }

        // Just usable for IPv4
        const Locator& locator = proxy.remoteLocator;
 800d730:	2358      	movs	r3, #88	; 0x58
 800d732:	fb03 f606 	mul.w	r6, r3, r6
 800d736:	f106 0218 	add.w	r2, r6, #24
 800d73a:	442a      	add	r2, r5
 800d73c:	7d11      	ldrb	r1, [r2, #20]
 800d73e:	7d50      	ldrb	r0, [r2, #21]
 800d740:	7d93      	ldrb	r3, [r2, #22]
 800d742:	7dd2      	ldrb	r2, [r2, #23]
                ((uint32_t) (p1 << 16)) |
 800d744:	041b      	lsls	r3, r3, #16
        return {((uint32_t) (LSB << 24)) |
 800d746:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                ((uint32_t) (p1 << 16)) |
 800d74a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t) (p2 << 8)) |
 800d74e:	430b      	orrs	r3, r1

        info.destAddr = locator.getIp4Address();
 800d750:	9308      	str	r3, [sp, #32]
        info.destPort = (Ip4Port_t) locator.port;
 800d752:	442e      	add	r6, r5
 800d754:	69f3      	ldr	r3, [r6, #28]
 800d756:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24

        m_transport->sendPacket(info);
 800d75a:	a907      	add	r1, sp, #28
 800d75c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800d75e:	f7fd fe7d 	bl	800b45c <_ZN4rtps9UdpDriver10sendPacketERNS_10PacketInfoE>
 800d762:	e007      	b.n	800d774 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0xec>
 800d764:	4638      	mov	r0, r7
 800d766:	f7fb fc94 	bl	8009092 <sys_mutex_unlock>
 800d76a:	a80a      	add	r0, sp, #40	; 0x28
 800d76c:	f000 fe39 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>

    }

    ++m_nextSequenceNumberToSend;
}
 800d770:	b00d      	add	sp, #52	; 0x34
 800d772:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d774:	a80a      	add	r0, sp, #40	; 0x28
 800d776:	f000 fe34 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
                if(m_pool.m_numElements == 0){
 800d77a:	686b      	ldr	r3, [r5, #4]
 800d77c:	b9b3      	cbnz	r3, 800d7ac <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x124>
                    m_bit = SIZE;
 800d77e:	2303      	movs	r3, #3
 800d780:	f88d 3011 	strb.w	r3, [sp, #17]
                 return m_bit != other.m_bit;
 800d784:	f89d 6011 	ldrb.w	r6, [sp, #17]
 800d788:	f89d 3019 	ldrb.w	r3, [sp, #25]
    for(const auto& proxy : m_proxies){
 800d78c:	429e      	cmp	r6, r3
 800d78e:	d021      	beq.n	800d7d4 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x14c>
                return m_pool.m_data[m_bit];
 800d790:	9d03      	ldr	r5, [sp, #12]
 800d792:	2300      	movs	r3, #0
 800d794:	930a      	str	r3, [sp, #40]	; 0x28
 800d796:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
        info.srcPort = m_packetInfo.srcPort;
 800d79a:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 800d79e:	f8ad 301c 	strh.w	r3, [sp, #28]
        MessageFactory::addHeader(info.buffer, m_attributes.endpointGuid.prefix);
 800d7a2:	1d21      	adds	r1, r4, #4
 800d7a4:	a80a      	add	r0, sp, #40	; 0x28
 800d7a6:	f7fc fd3d 	bl	800a224 <_ZN4rtps14MessageFactory9addHeaderINS_11PBufWrapperEEEvRT_RKNS_12GuidPrefix_tE>
 800d7aa:	e79b      	b.n	800d6e4 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x5c>
                    ++m_bit;
 800d7ac:	f89d 3011 	ldrb.w	r3, [sp, #17]
 800d7b0:	3301      	adds	r3, #1
 800d7b2:	b2db      	uxtb	r3, r3
 800d7b4:	f88d 3011 	strb.w	r3, [sp, #17]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800d7b8:	aa0c      	add	r2, sp, #48	; 0x30
 800d7ba:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800d7be:	f811 2c20 	ldrb.w	r2, [r1, #-32]
 800d7c2:	0852      	lsrs	r2, r2, #1
 800d7c4:	f801 2c20 	strb.w	r2, [r1, #-32]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800d7c8:	f012 0f01 	tst.w	r2, #1
 800d7cc:	d1da      	bne.n	800d784 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0xfc>
 800d7ce:	2b02      	cmp	r3, #2
 800d7d0:	d9ec      	bls.n	800d7ac <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x124>
 800d7d2:	e7d7      	b.n	800d784 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0xfc>
            ++low;
 800d7d4:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800d7d8:	3301      	adds	r3, #1
 800d7da:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
            if(low == 0){
 800d7de:	2b00      	cmp	r3, #0
 800d7e0:	d1c6      	bne.n	800d770 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0xe8>
                ++high;
 800d7e2:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 800d7e4:	3301      	adds	r3, #1
 800d7e6:	67e3      	str	r3, [r4, #124]	; 0x7c
 800d7e8:	e7c2      	b.n	800d770 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0xe8>
 800d7ea:	4638      	mov	r0, r7
 800d7ec:	f7fb fc51 	bl	8009092 <sys_mutex_unlock>
 800d7f0:	a80a      	add	r0, sp, #40	; 0x28
 800d7f2:	f000 fdf6 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800d7f6:	f001 f8f0 	bl	800e9da <__cxa_end_cleanup>
 800d7fa:	e7f9      	b.n	800d7f0 <_ZN4rtps16StatelessWriterTINS_9UdpDriverEE8progressEv+0x168>

0800d7fc <_ZZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tEENUlPvRKNS_20ParticipantProxyDataEE0_4_FUNES4_S7_>:

const rtps::ParticipantProxyData* Participant::findRemoteParticipant(const GuidPrefix_t& prefix){
    auto isElementToFind=[&](const ParticipantProxyData& proxy){
        return proxy.m_guid.prefix == prefix;
    };
    auto thunk=[](void* arg, const ParticipantProxyData& value){return (*static_cast<decltype(isElementToFind)*>(arg))(value);};
 800d7fc:	b508      	push	{r3, lr}
        return proxy.m_guid.prefix == prefix;
 800d7fe:	6803      	ldr	r3, [r0, #0]
      { return _AT_Type::_S_ptr(_M_elems); }
 800d800:	1c88      	adds	r0, r1, #2
      { return const_iterator(data() + _Nm); }
 800d802:	f101 020e 	add.w	r2, r1, #14
	  if (const size_t __len = (__last1 - __first1))
 800d806:	1a12      	subs	r2, r2, r0
 800d808:	d006      	beq.n	800d818 <_ZZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tEENUlPvRKNS_20ParticipantProxyDataEE0_4_FUNES4_S7_+0x1c>
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800d80a:	4619      	mov	r1, r3
 800d80c:	f001 fe2c 	bl	800f468 <memcmp>
 800d810:	fab0 f080 	clz	r0, r0
 800d814:	0940      	lsrs	r0, r0, #5
    auto thunk=[](void* arg, const ParticipantProxyData& value){return (*static_cast<decltype(isElementToFind)*>(arg))(value);};
 800d816:	bd08      	pop	{r3, pc}
	  return true;
 800d818:	2001      	movs	r0, #1
 800d81a:	e7fc      	b.n	800d816 <_ZZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tEENUlPvRKNS_20ParticipantProxyDataEE0_4_FUNES4_S7_+0x1a>

0800d81c <_ZN4rtps11ParticipantC1Ev>:
Participant::Participant() : m_guidPrefix(GUIDPREFIX_UNKNOWN), m_participantId(PARTICIPANT_ID_INVALID),
 800d81c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d81e:	4604      	mov	r4, r0
                             m_receiver(this){
 800d820:	2500      	movs	r5, #0
 800d822:	6005      	str	r5, [r0, #0]
 800d824:	6045      	str	r5, [r0, #4]
 800d826:	6085      	str	r5, [r0, #8]
 800d828:	23ff      	movs	r3, #255	; 0xff
 800d82a:	7303      	strb	r3, [r0, #12]
 800d82c:	4601      	mov	r1, r0
 800d82e:	3010      	adds	r0, #16
 800d830:	f000 fb3a 	bl	800dea8 <_ZN4rtps15MessageReceiverC1EPNS_11ParticipantE>
 800d834:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28
 800d838:	f884 5029 	strb.w	r5, [r4, #41]	; 0x29
 800d83c:	f884 502a 	strb.w	r5, [r4, #42]	; 0x2a
 800d840:	2301      	movs	r3, #1
 800d842:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
 800d846:	62e5      	str	r5, [r4, #44]	; 0x2c
 800d848:	6325      	str	r5, [r4, #48]	; 0x30
 800d84a:	6365      	str	r5, [r4, #52]	; 0x34
 800d84c:	63a5      	str	r5, [r4, #56]	; 0x38
 800d84e:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
 800d852:	6425      	str	r5, [r4, #64]	; 0x40
 800d854:	6465      	str	r5, [r4, #68]	; 0x44
 800d856:	64a5      	str	r5, [r4, #72]	; 0x48
 800d858:	64e5      	str	r5, [r4, #76]	; 0x4c
 800d85a:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    class MemoryPool{
 800d85e:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
 800d862:	65a5      	str	r5, [r4, #88]	; 0x58
 800d864:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800d868:	2504      	movs	r5, #4
 800d86a:	e047      	b.n	800d8fc <_ZN4rtps11ParticipantC1Ev+0xe0>
    struct array
 800d86c:	f100 0394 	add.w	r3, r0, #148	; 0x94
 800d870:	2604      	movs	r6, #4
 800d872:	2e00      	cmp	r6, #0
 800d874:	db0e      	blt.n	800d894 <_ZN4rtps11ParticipantC1Ev+0x78>
 800d876:	2200      	movs	r2, #0
 800d878:	605a      	str	r2, [r3, #4]
    struct Locator{
 800d87a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800d87e:	7019      	strb	r1, [r3, #0]
 800d880:	7059      	strb	r1, [r3, #1]
 800d882:	7099      	strb	r1, [r3, #2]
 800d884:	70d9      	strb	r1, [r3, #3]
 800d886:	609a      	str	r2, [r3, #8]
 800d888:	60da      	str	r2, [r3, #12]
 800d88a:	611a      	str	r2, [r3, #16]
 800d88c:	615a      	str	r2, [r3, #20]
 800d88e:	3318      	adds	r3, #24
 800d890:	3e01      	subs	r6, #1
 800d892:	e7ee      	b.n	800d872 <_ZN4rtps11ParticipantC1Ev+0x56>
 800d894:	f500 7386 	add.w	r3, r0, #268	; 0x10c
 800d898:	2604      	movs	r6, #4
 800d89a:	2e00      	cmp	r6, #0
 800d89c:	db0e      	blt.n	800d8bc <_ZN4rtps11ParticipantC1Ev+0xa0>
 800d89e:	2200      	movs	r2, #0
 800d8a0:	605a      	str	r2, [r3, #4]
 800d8a2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800d8a6:	7019      	strb	r1, [r3, #0]
 800d8a8:	7059      	strb	r1, [r3, #1]
 800d8aa:	7099      	strb	r1, [r3, #2]
 800d8ac:	70d9      	strb	r1, [r3, #3]
 800d8ae:	609a      	str	r2, [r3, #8]
 800d8b0:	60da      	str	r2, [r3, #12]
 800d8b2:	611a      	str	r2, [r3, #16]
 800d8b4:	615a      	str	r2, [r3, #20]
 800d8b6:	3318      	adds	r3, #24
 800d8b8:	3e01      	subs	r6, #1
 800d8ba:	e7ee      	b.n	800d89a <_ZN4rtps11ParticipantC1Ev+0x7e>
 800d8bc:	f500 73c2 	add.w	r3, r0, #388	; 0x184
 800d8c0:	2604      	movs	r6, #4
 800d8c2:	2e00      	cmp	r6, #0
 800d8c4:	db0e      	blt.n	800d8e4 <_ZN4rtps11ParticipantC1Ev+0xc8>
 800d8c6:	2200      	movs	r2, #0
 800d8c8:	605a      	str	r2, [r3, #4]
 800d8ca:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800d8ce:	7019      	strb	r1, [r3, #0]
 800d8d0:	7059      	strb	r1, [r3, #1]
 800d8d2:	7099      	strb	r1, [r3, #2]
 800d8d4:	70d9      	strb	r1, [r3, #3]
 800d8d6:	609a      	str	r2, [r3, #8]
 800d8d8:	60da      	str	r2, [r3, #12]
 800d8da:	611a      	str	r2, [r3, #16]
 800d8dc:	615a      	str	r2, [r3, #20]
 800d8de:	3318      	adds	r3, #24
 800d8e0:	3e01      	subs	r6, #1
 800d8e2:	e7ee      	b.n	800d8c2 <_ZN4rtps11ParticipantC1Ev+0xa6>
        ParticipantProxyData() = default;
 800d8e4:	2301      	movs	r3, #1
 800d8e6:	f8c0 31fc 	str.w	r3, [r0, #508]	; 0x1fc
 800d8ea:	2364      	movs	r3, #100	; 0x64
 800d8ec:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
 800d8f0:	2300      	movs	r3, #0
 800d8f2:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
 800d8f6:	f500 7002 	add.w	r0, r0, #520	; 0x208
 800d8fa:	3d01      	subs	r5, #1
 800d8fc:	2d00      	cmp	r5, #0
 800d8fe:	db20      	blt.n	800d942 <_ZN4rtps11ParticipantC1Ev+0x126>
 800d900:	4b67      	ldr	r3, [pc, #412]	; (800daa0 <_ZN4rtps11ParticipantC1Ev+0x284>)
 800d902:	881b      	ldrh	r3, [r3, #0]
 800d904:	4602      	mov	r2, r0
 800d906:	f822 3b02 	strh.w	r3, [r2], #2
 800d90a:	2300      	movs	r3, #0
 800d90c:	f8c0 3002 	str.w	r3, [r0, #2]
 800d910:	6053      	str	r3, [r2, #4]
 800d912:	6093      	str	r3, [r2, #8]
 800d914:	60d3      	str	r3, [r2, #12]
 800d916:	8243      	strh	r3, [r0, #18]
 800d918:	7503      	strb	r3, [r0, #20]
 800d91a:	f100 031c 	add.w	r3, r0, #28
 800d91e:	2604      	movs	r6, #4
 800d920:	2e00      	cmp	r6, #0
 800d922:	dba3      	blt.n	800d86c <_ZN4rtps11ParticipantC1Ev+0x50>
 800d924:	2200      	movs	r2, #0
 800d926:	605a      	str	r2, [r3, #4]
 800d928:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800d92c:	7019      	strb	r1, [r3, #0]
 800d92e:	7059      	strb	r1, [r3, #1]
 800d930:	7099      	strb	r1, [r3, #2]
 800d932:	70d9      	strb	r1, [r3, #3]
 800d934:	609a      	str	r2, [r3, #8]
 800d936:	60da      	str	r2, [r3, #12]
 800d938:	611a      	str	r2, [r3, #16]
 800d93a:	615a      	str	r2, [r3, #20]
 800d93c:	3318      	adds	r3, #24
 800d93e:	3e01      	subs	r6, #1
 800d940:	e7ee      	b.n	800d920 <_ZN4rtps11ParticipantC1Ev+0x104>
 800d942:	f604 2584 	addw	r5, r4, #2692	; 0xa84
    class Participant;
    class Writer;
    class Reader;
    class ReaderCacheChange;

    class SPDPAgent{
 800d946:	2600      	movs	r6, #0
 800d948:	f8c4 6a84 	str.w	r6, [r4, #2692]	; 0xa84
#include "rtps/entities/Writer.h"


namespace rtps{

    struct BuiltInEndpoints{
 800d94c:	606e      	str	r6, [r5, #4]
 800d94e:	60ae      	str	r6, [r5, #8]
 800d950:	60ee      	str	r6, [r5, #12]
 800d952:	612e      	str	r6, [r5, #16]
 800d954:	616e      	str	r6, [r5, #20]
 800d956:	61ae      	str	r6, [r5, #24]
 800d958:	772e      	strb	r6, [r5, #28]
 800d95a:	f44f 77c8 	mov.w	r7, #400	; 0x190
 800d95e:	463a      	mov	r2, r7
 800d960:	4631      	mov	r1, r6
 800d962:	f604 20a1 	addw	r0, r4, #2721	; 0xaa1
 800d966:	f001 fd99 	bl	800f49c <memset>
 800d96a:	463a      	mov	r2, r7
 800d96c:	4631      	mov	r1, r6
 800d96e:	f604 4031 	addw	r0, r4, #3121	; 0xc31
 800d972:	f001 fd93 	bl	800f49c <memset>
 800d976:	f44f 7202 	mov.w	r2, #520	; 0x208
 800d97a:	4631      	mov	r1, r6
 800d97c:	f604 50c4 	addw	r0, r4, #3524	; 0xdc4
 800d980:	f001 fd8c 	bl	800f49c <memset>
 800d984:	f604 50c4 	addw	r0, r4, #3524	; 0xdc4
 800d988:	4b45      	ldr	r3, [pc, #276]	; (800daa0 <_ZN4rtps11ParticipantC1Ev+0x284>)
 800d98a:	881b      	ldrh	r3, [r3, #0]
 800d98c:	f8a4 3dc4 	strh.w	r3, [r4, #3524]	; 0xdc4
 800d990:	f8c4 6dc6 	str.w	r6, [r4, #3526]	; 0xdc6
 800d994:	f8c4 6dca 	str.w	r6, [r4, #3530]	; 0xdca
 800d998:	f8c4 6dce 	str.w	r6, [r4, #3534]	; 0xdce
 800d99c:	f8c4 6dd2 	str.w	r6, [r4, #3538]	; 0xdd2
 800d9a0:	8246      	strh	r6, [r0, #18]
 800d9a2:	7506      	strb	r6, [r0, #20]
 800d9a4:	f504 635e 	add.w	r3, r4, #3552	; 0xde0
 800d9a8:	2604      	movs	r6, #4
 800d9aa:	2e00      	cmp	r6, #0
 800d9ac:	db0e      	blt.n	800d9cc <_ZN4rtps11ParticipantC1Ev+0x1b0>
 800d9ae:	2200      	movs	r2, #0
 800d9b0:	605a      	str	r2, [r3, #4]
 800d9b2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800d9b6:	7019      	strb	r1, [r3, #0]
 800d9b8:	7059      	strb	r1, [r3, #1]
 800d9ba:	7099      	strb	r1, [r3, #2]
 800d9bc:	70d9      	strb	r1, [r3, #3]
 800d9be:	609a      	str	r2, [r3, #8]
 800d9c0:	60da      	str	r2, [r3, #12]
 800d9c2:	611a      	str	r2, [r3, #16]
 800d9c4:	615a      	str	r2, [r3, #20]
 800d9c6:	3318      	adds	r3, #24
 800d9c8:	3e01      	subs	r6, #1
 800d9ca:	e7ee      	b.n	800d9aa <_ZN4rtps11ParticipantC1Ev+0x18e>
 800d9cc:	f100 0394 	add.w	r3, r0, #148	; 0x94
 800d9d0:	2604      	movs	r6, #4
 800d9d2:	2e00      	cmp	r6, #0
 800d9d4:	db0e      	blt.n	800d9f4 <_ZN4rtps11ParticipantC1Ev+0x1d8>
 800d9d6:	2200      	movs	r2, #0
 800d9d8:	605a      	str	r2, [r3, #4]
 800d9da:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800d9de:	7019      	strb	r1, [r3, #0]
 800d9e0:	7059      	strb	r1, [r3, #1]
 800d9e2:	7099      	strb	r1, [r3, #2]
 800d9e4:	70d9      	strb	r1, [r3, #3]
 800d9e6:	609a      	str	r2, [r3, #8]
 800d9e8:	60da      	str	r2, [r3, #12]
 800d9ea:	611a      	str	r2, [r3, #16]
 800d9ec:	615a      	str	r2, [r3, #20]
 800d9ee:	3318      	adds	r3, #24
 800d9f0:	3e01      	subs	r6, #1
 800d9f2:	e7ee      	b.n	800d9d2 <_ZN4rtps11ParticipantC1Ev+0x1b6>
 800d9f4:	f500 7386 	add.w	r3, r0, #268	; 0x10c
 800d9f8:	2604      	movs	r6, #4
 800d9fa:	2e00      	cmp	r6, #0
 800d9fc:	db0e      	blt.n	800da1c <_ZN4rtps11ParticipantC1Ev+0x200>
 800d9fe:	2200      	movs	r2, #0
 800da00:	605a      	str	r2, [r3, #4]
 800da02:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800da06:	7019      	strb	r1, [r3, #0]
 800da08:	7059      	strb	r1, [r3, #1]
 800da0a:	7099      	strb	r1, [r3, #2]
 800da0c:	70d9      	strb	r1, [r3, #3]
 800da0e:	609a      	str	r2, [r3, #8]
 800da10:	60da      	str	r2, [r3, #12]
 800da12:	611a      	str	r2, [r3, #16]
 800da14:	615a      	str	r2, [r3, #20]
 800da16:	3318      	adds	r3, #24
 800da18:	3e01      	subs	r6, #1
 800da1a:	e7ee      	b.n	800d9fa <_ZN4rtps11ParticipantC1Ev+0x1de>
 800da1c:	f500 73c2 	add.w	r3, r0, #388	; 0x184
 800da20:	2604      	movs	r6, #4
 800da22:	2e00      	cmp	r6, #0
 800da24:	db0e      	blt.n	800da44 <_ZN4rtps11ParticipantC1Ev+0x228>
 800da26:	2200      	movs	r2, #0
 800da28:	605a      	str	r2, [r3, #4]
 800da2a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800da2e:	7019      	strb	r1, [r3, #0]
 800da30:	7059      	strb	r1, [r3, #1]
 800da32:	7099      	strb	r1, [r3, #2]
 800da34:	70d9      	strb	r1, [r3, #3]
 800da36:	609a      	str	r2, [r3, #8]
 800da38:	60da      	str	r2, [r3, #12]
 800da3a:	611a      	str	r2, [r3, #16]
 800da3c:	615a      	str	r2, [r3, #20]
 800da3e:	3318      	adds	r3, #24
 800da40:	3e01      	subs	r6, #1
 800da42:	e7ee      	b.n	800da22 <_ZN4rtps11ParticipantC1Ev+0x206>
 800da44:	2301      	movs	r3, #1
 800da46:	f8c0 31fc 	str.w	r3, [r0, #508]	; 0x1fc
 800da4a:	2364      	movs	r3, #100	; 0x64
 800da4c:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
 800da50:	2300      	movs	r3, #0
 800da52:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
 800da56:	f8c5 3548 	str.w	r3, [r5, #1352]	; 0x548
 800da5a:	f8c5 354c 	str.w	r3, [r5, #1356]	; 0x54c
 800da5e:	f8c5 3550 	str.w	r3, [r5, #1360]	; 0x550
 800da62:	f8c5 3554 	str.w	r3, [r5, #1364]	; 0x554
 800da66:	f8c5 3558 	str.w	r3, [r5, #1368]	; 0x558
 800da6a:	f8c5 355c 	str.w	r3, [r5, #1372]	; 0x55c
 800da6e:	f885 3564 	strb.w	r3, [r5, #1380]	; 0x564
 800da72:	f504 5289 	add.w	r2, r4, #4384	; 0x1120
 800da76:	6013      	str	r3, [r2, #0]
 800da78:	6053      	str	r3, [r2, #4]
 800da7a:	6093      	str	r3, [r2, #8]
 800da7c:	60d3      	str	r3, [r2, #12]
 800da7e:	6113      	str	r3, [r2, #16]
 800da80:	6153      	str	r3, [r2, #20]
    class Participant;
    class ReaderCacheChange;
    class Writer;
    class Reader;

    class SEDPAgent{
 800da82:	f241 1238 	movw	r2, #4408	; 0x1138
 800da86:	50a3      	str	r3, [r4, r2]
 800da88:	f241 123c 	movw	r2, #4412	; 0x113c
 800da8c:	50a3      	str	r3, [r4, r2]
 800da8e:	f504 528a 	add.w	r2, r4, #4416	; 0x1140
 800da92:	6013      	str	r3, [r2, #0]
 800da94:	f241 1244 	movw	r2, #4420	; 0x1144
 800da98:	50a3      	str	r3, [r4, r2]
}
 800da9a:	4620      	mov	r0, r4
 800da9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800da9e:	bf00      	nop
 800daa0:	08010960 	.word	0x08010960

0800daa4 <_ZN4rtps11ParticipantD1Ev>:
Participant::~Participant() {
 800daa4:	b538      	push	{r3, r4, r5, lr}
 800daa6:	4604      	mov	r4, r0
    m_spdpAgent.stop();
 800daa8:	f600 2584 	addw	r5, r0, #2692	; 0xa84
 800daac:	4628      	mov	r0, r5
 800daae:	f7fe f8ab 	bl	800bc08 <_ZN4rtps9SPDPAgent4stopEv>
Participant::~Participant() {
 800dab2:	4628      	mov	r0, r5
 800dab4:	f7fe f883 	bl	800bbbe <_ZN4rtps9SPDPAgentD1Ev>
}
 800dab8:	4620      	mov	r0, r4
 800daba:	bd38      	pop	{r3, r4, r5, pc}

0800dabc <_ZN4rtps11Participant5reuseERKNS_12GuidPrefix_tEa>:
void Participant::reuse(const GuidPrefix_t& guidPrefix, ParticipantId_t participantId){
 800dabc:	b470      	push	{r4, r5, r6}
 800dabe:	4605      	mov	r5, r0
 800dac0:	460c      	mov	r4, r1
 800dac2:	4616      	mov	r6, r2
    m_guidPrefix = guidPrefix;
 800dac4:	4603      	mov	r3, r0
 800dac6:	6808      	ldr	r0, [r1, #0]
 800dac8:	6849      	ldr	r1, [r1, #4]
 800daca:	68a2      	ldr	r2, [r4, #8]
 800dacc:	c307      	stmia	r3!, {r0, r1, r2}
    m_participantId = participantId;
 800dace:	732e      	strb	r6, [r5, #12]
}
 800dad0:	bc70      	pop	{r4, r5, r6}
 800dad2:	4770      	bx	lr

0800dad4 <_ZN4rtps11Participant20getNextUserEntityKeyEv>:
std::array<uint8_t, 3> Participant::getNextUserEntityKey(){
 800dad4:	b082      	sub	sp, #8
    const auto result = m_nextUserEntityId;
 800dad6:	4603      	mov	r3, r0
 800dad8:	f833 2f29 	ldrh.w	r2, [r3, #41]!
 800dadc:	789b      	ldrb	r3, [r3, #2]
 800dade:	f8ad 2000 	strh.w	r2, [sp]
 800dae2:	f88d 3002 	strb.w	r3, [sp, #2]
    ++m_nextUserEntityId[2];
 800dae6:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 800daea:	3301      	adds	r3, #1
 800daec:	b2db      	uxtb	r3, r3
 800daee:	f880 302b 	strb.w	r3, [r0, #43]	; 0x2b
    if(m_nextUserEntityId[2] == 0){
 800daf2:	b95b      	cbnz	r3, 800db0c <_ZN4rtps11Participant20getNextUserEntityKeyEv+0x38>
        ++m_nextUserEntityId[1];
 800daf4:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 800daf8:	3301      	adds	r3, #1
 800dafa:	b2db      	uxtb	r3, r3
 800dafc:	f880 302a 	strb.w	r3, [r0, #42]	; 0x2a
        if(m_nextUserEntityId[1] == 0){
 800db00:	b923      	cbnz	r3, 800db0c <_ZN4rtps11Participant20getNextUserEntityKeyEv+0x38>
            ++m_nextUserEntityId[0];
 800db02:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 800db06:	3301      	adds	r3, #1
 800db08:	f880 3029 	strb.w	r3, [r0, #41]	; 0x29
    return result;
 800db0c:	9b00      	ldr	r3, [sp, #0]
 800db0e:	2000      	movs	r0, #0
 800db10:	b2da      	uxtb	r2, r3
 800db12:	f362 0007 	bfi	r0, r2, #0, #8
 800db16:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800db1a:	f362 200f 	bfi	r0, r2, #8, #8
 800db1e:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800db22:	f363 4017 	bfi	r0, r3, #16, #8
}
 800db26:	b002      	add	sp, #8
 800db28:	4770      	bx	lr

0800db2a <_ZN4rtps11Participant37registerOnNewPublisherMatchedCallbackEPFvPvES1_>:
bool Participant::registerOnNewPublisherMatchedCallback(void (*callback)(void* arg), void* args){
 800db2a:	b510      	push	{r4, lr}
    if(!m_hasBuilInEndpoints){
 800db2c:	f890 4028 	ldrb.w	r4, [r0, #40]	; 0x28
 800db30:	b90c      	cbnz	r4, 800db36 <_ZN4rtps11Participant37registerOnNewPublisherMatchedCallbackEPFvPvES1_+0xc>
}
 800db32:	4620      	mov	r0, r4
 800db34:	bd10      	pop	{r4, pc}
    m_sedpAgent.registerOnNewPublisherMatchedCallback(callback, args);
 800db36:	f600 70ec 	addw	r0, r0, #4076	; 0xfec
 800db3a:	f7fd feb9 	bl	800b8b0 <_ZN4rtps9SEDPAgent37registerOnNewPublisherMatchedCallbackEPFvPvES1_>
    return true;
 800db3e:	e7f8      	b.n	800db32 <_ZN4rtps11Participant37registerOnNewPublisherMatchedCallbackEPFvPvES1_+0x8>

0800db40 <_ZN4rtps11Participant38registerOnNewSubscriberMatchedCallbackEPFvPvES1_>:
bool Participant::registerOnNewSubscriberMatchedCallback(void (*callback)(void* arg), void* args){
 800db40:	b510      	push	{r4, lr}
    if(!m_hasBuilInEndpoints){
 800db42:	f890 4028 	ldrb.w	r4, [r0, #40]	; 0x28
 800db46:	b90c      	cbnz	r4, 800db4c <_ZN4rtps11Participant38registerOnNewSubscriberMatchedCallbackEPFvPvES1_+0xc>
}
 800db48:	4620      	mov	r0, r4
 800db4a:	bd10      	pop	{r4, pc}
    m_sedpAgent.registerOnNewSubscriberMatchedCallback(callback, args);
 800db4c:	f600 70ec 	addw	r0, r0, #4076	; 0xfec
 800db50:	f7fd feb3 	bl	800b8ba <_ZN4rtps9SEDPAgent38registerOnNewSubscriberMatchedCallbackEPFvPvES1_>
    return true;
 800db54:	e7f8      	b.n	800db48 <_ZN4rtps11Participant38registerOnNewSubscriberMatchedCallbackEPFvPvES1_+0x8>

0800db56 <_ZN4rtps11Participant9addWriterEPNS_6WriterE>:
rtps::Writer* Participant::addWriter(Writer* pWriter){
 800db56:	b510      	push	{r4, lr}
    if(pWriter != nullptr && m_numWriters != m_writers.size()){
 800db58:	460c      	mov	r4, r1
 800db5a:	b161      	cbz	r1, 800db76 <_ZN4rtps11Participant9addWriterEPNS_6WriterE+0x20>
 800db5c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800db60:	2b04      	cmp	r3, #4
 800db62:	d00f      	beq.n	800db84 <_ZN4rtps11Participant9addWriterEPNS_6WriterE+0x2e>
        m_writers[m_numWriters++] = pWriter;
 800db64:	1c5a      	adds	r2, r3, #1
 800db66:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
 800db6a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800db6e:	62d9      	str	r1, [r3, #44]	; 0x2c
        if(m_hasBuilInEndpoints){
 800db70:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
 800db74:	b90b      	cbnz	r3, 800db7a <_ZN4rtps11Participant9addWriterEPNS_6WriterE+0x24>
}
 800db76:	4620      	mov	r0, r4
 800db78:	bd10      	pop	{r4, pc}
            m_sedpAgent.addWriter(*pWriter);
 800db7a:	f600 70ec 	addw	r0, r0, #4076	; 0xfec
 800db7e:	f7fd ff87 	bl	800ba90 <_ZN4rtps9SEDPAgent9addWriterERNS_6WriterE>
 800db82:	e7f8      	b.n	800db76 <_ZN4rtps11Participant9addWriterEPNS_6WriterE+0x20>
        return nullptr;
 800db84:	2400      	movs	r4, #0
 800db86:	e7f6      	b.n	800db76 <_ZN4rtps11Participant9addWriterEPNS_6WriterE+0x20>

0800db88 <_ZN4rtps11Participant13isWritersFullEv>:
	return m_numWriters == m_writers.size();
 800db88:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
}
 800db8c:	2804      	cmp	r0, #4
 800db8e:	bf14      	ite	ne
 800db90:	2000      	movne	r0, #0
 800db92:	2001      	moveq	r0, #1
 800db94:	4770      	bx	lr

0800db96 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE>:
rtps::Reader* Participant::addReader(Reader* pReader){
 800db96:	b510      	push	{r4, lr}
    if(pReader != nullptr && m_numReaders != m_readers.size()){
 800db98:	460c      	mov	r4, r1
 800db9a:	b161      	cbz	r1, 800dbb6 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE+0x20>
 800db9c:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 800dba0:	2b04      	cmp	r3, #4
 800dba2:	d00f      	beq.n	800dbc4 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE+0x2e>
        m_readers[m_numReaders++] = pReader;
 800dba4:	1c5a      	adds	r2, r3, #1
 800dba6:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
 800dbaa:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800dbae:	6419      	str	r1, [r3, #64]	; 0x40
        if(m_hasBuilInEndpoints){
 800dbb0:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
 800dbb4:	b90b      	cbnz	r3, 800dbba <_ZN4rtps11Participant9addReaderEPNS_6ReaderE+0x24>
}
 800dbb6:	4620      	mov	r0, r4
 800dbb8:	bd10      	pop	{r4, pc}
            m_sedpAgent.addReader(*pReader);
 800dbba:	f600 70ec 	addw	r0, r0, #4076	; 0xfec
 800dbbe:	f7fd ffa5 	bl	800bb0c <_ZN4rtps9SEDPAgent9addReaderERNS_6ReaderE>
 800dbc2:	e7f8      	b.n	800dbb6 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE+0x20>
        return nullptr;
 800dbc4:	2400      	movs	r4, #0
 800dbc6:	e7f6      	b.n	800dbb6 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE+0x20>

0800dbc8 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE>:
rtps::Writer* Participant::getWriter(EntityId_t id) const{
 800dbc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dbca:	b083      	sub	sp, #12
 800dbcc:	4607      	mov	r7, r0
 800dbce:	9101      	str	r1, [sp, #4]
    for(uint8_t i=0; i < m_numWriters; ++i){
 800dbd0:	2400      	movs	r4, #0
 800dbd2:	e008      	b.n	800dbe6 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0x1e>
                   this->entityKind == other.entityKind;
 800dbd4:	78ea      	ldrb	r2, [r5, #3]
 800dbd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
            return this->entityKey == other.entityKey &&
 800dbda:	429a      	cmp	r2, r3
 800dbdc:	d018      	beq.n	800dc10 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0x48>
 800dbde:	2300      	movs	r3, #0
        if(m_writers[i]->m_attributes.endpointGuid.entityId == id){
 800dbe0:	b9cb      	cbnz	r3, 800dc16 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0x4e>
    for(uint8_t i=0; i < m_numWriters; ++i){
 800dbe2:	3401      	adds	r4, #1
 800dbe4:	b2e4      	uxtb	r4, r4
 800dbe6:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 800dbea:	42a3      	cmp	r3, r4
 800dbec:	d912      	bls.n	800dc14 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0x4c>
        if(m_writers[i]->m_attributes.endpointGuid.entityId == id){
 800dbee:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 800dbf2:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 800dbf4:	f106 0510 	add.w	r5, r6, #16
      { return const_iterator(data() + _Nm); }
 800dbf8:	f106 0213 	add.w	r2, r6, #19
	  if (const size_t __len = (__last1 - __first1))
 800dbfc:	1b52      	subs	r2, r2, r5
 800dbfe:	d0e9      	beq.n	800dbd4 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0xc>
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800dc00:	a901      	add	r1, sp, #4
 800dc02:	4628      	mov	r0, r5
 800dc04:	f001 fc30 	bl	800f468 <memcmp>
 800dc08:	2800      	cmp	r0, #0
 800dc0a:	d0e3      	beq.n	800dbd4 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0xc>
 800dc0c:	2300      	movs	r3, #0
 800dc0e:	e7e7      	b.n	800dbe0 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0x18>
 800dc10:	2301      	movs	r3, #1
 800dc12:	e7e5      	b.n	800dbe0 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE+0x18>
    return nullptr;
 800dc14:	2600      	movs	r6, #0
}
 800dc16:	4630      	mov	r0, r6
 800dc18:	b003      	add	sp, #12
 800dc1a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800dc1c <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE>:
rtps::Reader* Participant::getReader(EntityId_t id) const{
 800dc1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dc1e:	b083      	sub	sp, #12
 800dc20:	4607      	mov	r7, r0
 800dc22:	9101      	str	r1, [sp, #4]
    for(uint8_t i=0; i < m_numReaders; ++i){
 800dc24:	2400      	movs	r4, #0
 800dc26:	e008      	b.n	800dc3a <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0x1e>
                   this->entityKind == other.entityKind;
 800dc28:	78ea      	ldrb	r2, [r5, #3]
 800dc2a:	f89d 3007 	ldrb.w	r3, [sp, #7]
            return this->entityKey == other.entityKey &&
 800dc2e:	429a      	cmp	r2, r3
 800dc30:	d018      	beq.n	800dc64 <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0x48>
 800dc32:	2300      	movs	r3, #0
        if(m_readers[i]->m_attributes.endpointGuid.entityId == id){
 800dc34:	b9cb      	cbnz	r3, 800dc6a <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0x4e>
    for(uint8_t i=0; i < m_numReaders; ++i){
 800dc36:	3401      	adds	r4, #1
 800dc38:	b2e4      	uxtb	r4, r4
 800dc3a:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800dc3e:	42a3      	cmp	r3, r4
 800dc40:	d912      	bls.n	800dc68 <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0x4c>
        if(m_readers[i]->m_attributes.endpointGuid.entityId == id){
 800dc42:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 800dc46:	6c1e      	ldr	r6, [r3, #64]	; 0x40
 800dc48:	f106 0510 	add.w	r5, r6, #16
 800dc4c:	f106 0213 	add.w	r2, r6, #19
	  if (const size_t __len = (__last1 - __first1))
 800dc50:	1b52      	subs	r2, r2, r5
 800dc52:	d0e9      	beq.n	800dc28 <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0xc>
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
 800dc54:	a901      	add	r1, sp, #4
 800dc56:	4628      	mov	r0, r5
 800dc58:	f001 fc06 	bl	800f468 <memcmp>
 800dc5c:	2800      	cmp	r0, #0
 800dc5e:	d0e3      	beq.n	800dc28 <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0xc>
 800dc60:	2300      	movs	r3, #0
 800dc62:	e7e7      	b.n	800dc34 <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0x18>
 800dc64:	2301      	movs	r3, #1
 800dc66:	e7e5      	b.n	800dc34 <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE+0x18>
    return nullptr;
 800dc68:	2600      	movs	r6, #0
}
 800dc6a:	4630      	mov	r0, r6
 800dc6c:	b003      	add	sp, #12
 800dc6e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800dc70 <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE>:
rtps::Writer* Participant::getMatchingWriter(const TopicData& readerTopicData) const{
 800dc70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dc72:	4605      	mov	r5, r0
 800dc74:	460e      	mov	r6, r1
    for(uint8_t i=0; i < m_numWriters; ++i){
 800dc76:	2400      	movs	r4, #0
 800dc78:	e001      	b.n	800dc7e <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE+0xe>
 800dc7a:	3401      	adds	r4, #1
 800dc7c:	b2e4      	uxtb	r4, r4
 800dc7e:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
 800dc82:	42a3      	cmp	r3, r4
 800dc84:	d916      	bls.n	800dcb4 <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE+0x44>
        if(m_writers[i]->m_attributes.matchesTopicOf(readerTopicData) &&
 800dc86:	4627      	mov	r7, r4
 800dc88:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 800dc8c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800dc8e:	4631      	mov	r1, r6
 800dc90:	3004      	adds	r0, #4
 800dc92:	f7fe fa5f 	bl	800c154 <_ZN4rtps9TopicData14matchesTopicOfERKS0_>
 800dc96:	2800      	cmp	r0, #0
 800dc98:	d0ef      	beq.n	800dc7a <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE+0xa>
                (readerTopicData.reliabilityKind == ReliabilityKind_t::BEST_EFFORT ||
 800dc9a:	6bb3      	ldr	r3, [r6, #56]	; 0x38
        if(m_writers[i]->m_attributes.matchesTopicOf(readerTopicData) &&
 800dc9c:	2b01      	cmp	r3, #1
 800dc9e:	d005      	beq.n	800dcac <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE+0x3c>
                 m_writers[i]->m_attributes.reliabilityKind == ReliabilityKind_t::RELIABLE)){
 800dca0:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 800dca4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dca6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
                (readerTopicData.reliabilityKind == ReliabilityKind_t::BEST_EFFORT ||
 800dca8:	2b02      	cmp	r3, #2
 800dcaa:	d1e6      	bne.n	800dc7a <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE+0xa>
            return m_writers[i];
 800dcac:	eb05 0387 	add.w	r3, r5, r7, lsl #2
 800dcb0:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800dcb2:	e000      	b.n	800dcb6 <_ZNK4rtps11Participant17getMatchingWriterERKNS_9TopicDataE+0x46>
    return nullptr;
 800dcb4:	2000      	movs	r0, #0
}
 800dcb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800dcb8 <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE>:
rtps::Reader* Participant::getMatchingReader(const TopicData& writerTopicData) const{
 800dcb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dcba:	4605      	mov	r5, r0
 800dcbc:	460e      	mov	r6, r1
    for(uint8_t i=0; i < m_numReaders; ++i){
 800dcbe:	2400      	movs	r4, #0
 800dcc0:	e001      	b.n	800dcc6 <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE+0xe>
 800dcc2:	3401      	adds	r4, #1
 800dcc4:	b2e4      	uxtb	r4, r4
 800dcc6:	f895 3050 	ldrb.w	r3, [r5, #80]	; 0x50
 800dcca:	42a3      	cmp	r3, r4
 800dccc:	d916      	bls.n	800dcfc <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE+0x44>
        if(m_readers[i]->m_attributes.matchesTopicOf(writerTopicData) &&
 800dcce:	4627      	mov	r7, r4
 800dcd0:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 800dcd4:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800dcd6:	4631      	mov	r1, r6
 800dcd8:	3004      	adds	r0, #4
 800dcda:	f7fe fa3b 	bl	800c154 <_ZN4rtps9TopicData14matchesTopicOfERKS0_>
 800dcde:	2800      	cmp	r0, #0
 800dce0:	d0ef      	beq.n	800dcc2 <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE+0xa>
                (writerTopicData.reliabilityKind == ReliabilityKind_t::RELIABLE ||
 800dce2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
        if(m_readers[i]->m_attributes.matchesTopicOf(writerTopicData) &&
 800dce4:	2b02      	cmp	r3, #2
 800dce6:	d005      	beq.n	800dcf4 <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE+0x3c>
                 m_readers[i]->m_attributes.reliabilityKind == ReliabilityKind_t::BEST_EFFORT)){
 800dce8:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 800dcec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dcee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
                (writerTopicData.reliabilityKind == ReliabilityKind_t::RELIABLE ||
 800dcf0:	2b01      	cmp	r3, #1
 800dcf2:	d1e6      	bne.n	800dcc2 <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE+0xa>
            return m_readers[i];
 800dcf4:	eb05 0387 	add.w	r3, r5, r7, lsl #2
 800dcf8:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800dcfa:	e000      	b.n	800dcfe <_ZNK4rtps11Participant17getMatchingReaderERKNS_9TopicDataE+0x46>
    return nullptr;
 800dcfc:	2000      	movs	r0, #0
}
 800dcfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800dd00 <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE>:
bool Participant::addNewRemoteParticipant(const ParticipantProxyData& remotePart){
 800dd00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    return m_remoteParticipants.add(remotePart);
 800dd02:	f100 0454 	add.w	r4, r0, #84	; 0x54
            return m_numElements == SIZE;
 800dd06:	6865      	ldr	r5, [r4, #4]
            if(isFull()){
 800dd08:	2d05      	cmp	r5, #5
 800dd0a:	d028      	beq.n	800dd5e <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x5e>
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 800dd0c:	2000      	movs	r0, #0
 800dd0e:	bb40      	cbnz	r0, 800dd62 <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x62>
                if(bucket != 0xFF){
 800dd10:	28ff      	cmp	r0, #255	; 0xff
 800dd12:	d021      	beq.n	800dd58 <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x58>
                    uint8_t byte = m_bitMap[bucket];
 800dd14:	4684      	mov	ip, r0
 800dd16:	5c27      	ldrb	r7, [r4, r0]
                    for(uint8_t bit=0; bit < 8; ++bit){
 800dd18:	4603      	mov	r3, r0
                    uint8_t byte = m_bitMap[bucket];
 800dd1a:	463a      	mov	r2, r7
                    for(uint8_t bit=0; bit < 8; ++bit){
 800dd1c:	2b07      	cmp	r3, #7
 800dd1e:	d81b      	bhi.n	800dd58 <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x58>
                        if(!(byte & 1)){
 800dd20:	f012 0f01 	tst.w	r2, #1
 800dd24:	d003      	beq.n	800dd2e <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x2e>
                        byte = byte>>1;
 800dd26:	0852      	lsrs	r2, r2, #1
                    for(uint8_t bit=0; bit < 8; ++bit){
 800dd28:	3301      	adds	r3, #1
 800dd2a:	b2db      	uxtb	r3, r3
 800dd2c:	e7f6      	b.n	800dd1c <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x1c>
                            m_bitMap[bucket] |= 1 << bit;
 800dd2e:	2601      	movs	r6, #1
 800dd30:	fa06 f203 	lsl.w	r2, r6, r3
 800dd34:	4317      	orrs	r7, r2
 800dd36:	f804 700c 	strb.w	r7, [r4, ip]
                            m_data[bucket*8+bit] = data;
 800dd3a:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 800dd3e:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 800dd42:	00d8      	lsls	r0, r3, #3
 800dd44:	4420      	add	r0, r4
 800dd46:	f44f 7202 	mov.w	r2, #520	; 0x208
 800dd4a:	3008      	adds	r0, #8
 800dd4c:	f001 fb9b 	bl	800f486 <memcpy>
                            ++m_numElements;
 800dd50:	4435      	add	r5, r6
 800dd52:	6065      	str	r5, [r4, #4]
                            return true;
 800dd54:	4630      	mov	r0, r6
 800dd56:	e005      	b.n	800dd64 <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x64>
            for(uint8_t bucket=0; bucket < sizeof(m_bitMap); ++bucket){
 800dd58:	3001      	adds	r0, #1
 800dd5a:	b2c0      	uxtb	r0, r0
 800dd5c:	e7d7      	b.n	800dd0e <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0xe>
                return false;
 800dd5e:	2000      	movs	r0, #0
 800dd60:	e000      	b.n	800dd64 <_ZN4rtps11Participant23addNewRemoteParticipantERKNS_20ParticipantProxyDataE+0x64>
            return false;
 800dd62:	2000      	movs	r0, #0
}
 800dd64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800dd66 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE>:
const rtps::ParticipantProxyData* Participant::findRemoteParticipant(const GuidPrefix_t& prefix){
 800dd66:	b530      	push	{r4, r5, lr}
 800dd68:	b085      	sub	sp, #20
    };
 800dd6a:	9103      	str	r1, [sp, #12]

    return m_remoteParticipants.find(thunk, &isElementToFind);
 800dd6c:	f100 0254 	add.w	r2, r0, #84	; 0x54
            explicit MemoryPoolIterator(MemoryPool<TYPE, SIZE>& pool) : m_pool(pool){
 800dd70:	9201      	str	r2, [sp, #4]
 800dd72:	2300      	movs	r3, #0
 800dd74:	f88d 3009 	strb.w	r3, [sp, #9]
                memcpy(m_bitMap, m_pool.m_bitMap, sizeof(m_bitMap));
 800dd78:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 800dd7c:	f88d 3008 	strb.w	r3, [sp, #8]
            if(!(m_bitMap[0] & 1)){
 800dd80:	f013 0f01 	tst.w	r3, #1
 800dd84:	d11c      	bne.n	800ddc0 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x5a>
                if(m_pool.m_numElements == 0){
 800dd86:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800dd88:	b19b      	cbz	r3, 800ddb2 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x4c>
                    ++m_bit;
 800dd8a:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800dd8e:	3301      	adds	r3, #1
 800dd90:	b2db      	uxtb	r3, r3
 800dd92:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800dd96:	aa04      	add	r2, sp, #16
 800dd98:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800dd9c:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 800dda0:	0852      	lsrs	r2, r2, #1
 800dda2:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800dda6:	f012 0f01 	tst.w	r2, #1
 800ddaa:	d109      	bne.n	800ddc0 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x5a>
 800ddac:	2b04      	cmp	r3, #4
 800ddae:	d9ec      	bls.n	800dd8a <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x24>
 800ddb0:	e006      	b.n	800ddc0 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x5a>
                    m_bit = SIZE;
 800ddb2:	2305      	movs	r3, #5
 800ddb4:	f88d 3009 	strb.w	r3, [sp, #9]
 800ddb8:	e002      	b.n	800ddc0 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x5a>
 800ddba:	2305      	movs	r3, #5
 800ddbc:	f88d 3009 	strb.w	r3, [sp, #9]
                 return m_bit != other.m_bit;
 800ddc0:	f89d 3009 	ldrb.w	r3, [sp, #9]
            for(auto it=begin(); it!=end();++it){
 800ddc4:	2b05      	cmp	r3, #5
 800ddc6:	d021      	beq.n	800de0c <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0xa6>
                return m_pool.m_data[m_bit];
 800ddc8:	9d01      	ldr	r5, [sp, #4]
 800ddca:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 800ddce:	00d9      	lsls	r1, r3, #3
 800ddd0:	3108      	adds	r1, #8
 800ddd2:	186c      	adds	r4, r5, r1
                if(jumppad(isCorrectElement, *it)){
 800ddd4:	4621      	mov	r1, r4
 800ddd6:	a803      	add	r0, sp, #12
 800ddd8:	f7ff fd10 	bl	800d7fc <_ZZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tEENUlPvRKNS_20ParticipantProxyDataEE0_4_FUNES4_S7_>
 800dddc:	b9b8      	cbnz	r0, 800de0e <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0xa8>
                if(m_pool.m_numElements == 0){
 800ddde:	686b      	ldr	r3, [r5, #4]
 800dde0:	2b00      	cmp	r3, #0
 800dde2:	d0ea      	beq.n	800ddba <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x54>
                    ++m_bit;
 800dde4:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800dde8:	3301      	adds	r3, #1
 800ddea:	b2db      	uxtb	r3, r3
 800ddec:	f88d 3009 	strb.w	r3, [sp, #9]
                    m_bitMap[bucket] = m_bitMap[bucket] >> 1;
 800ddf0:	aa04      	add	r2, sp, #16
 800ddf2:	eb02 01d3 	add.w	r1, r2, r3, lsr #3
 800ddf6:	f811 2c08 	ldrb.w	r2, [r1, #-8]
 800ddfa:	0852      	lsrs	r2, r2, #1
 800ddfc:	f801 2c08 	strb.w	r2, [r1, #-8]
                }while(!(m_bitMap[bucket] & 1) && m_bit < SIZE);
 800de00:	f012 0f01 	tst.w	r2, #1
 800de04:	d1dc      	bne.n	800ddc0 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x5a>
 800de06:	2b04      	cmp	r3, #4
 800de08:	d9ec      	bls.n	800dde4 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x7e>
 800de0a:	e7d9      	b.n	800ddc0 <_ZN4rtps11Participant21findRemoteParticipantERKNS_12GuidPrefix_tE+0x5a>
            return nullptr;
 800de0c:	2400      	movs	r4, #0
}
 800de0e:	4620      	mov	r0, r4
 800de10:	b005      	add	sp, #20
 800de12:	bd30      	pop	{r4, r5, pc}

0800de14 <_ZN4rtps11Participant19addBuiltInEndpointsERNS_16BuiltInEndpointsE>:

rtps::MessageReceiver* Participant::getMessageReceiver(){
    return &m_receiver;
}

void Participant::addBuiltInEndpoints(BuiltInEndpoints& endpoints){
 800de14:	b570      	push	{r4, r5, r6, lr}
 800de16:	4604      	mov	r4, r0
 800de18:	460d      	mov	r5, r1
    m_hasBuilInEndpoints = true;
 800de1a:	2301      	movs	r3, #1
 800de1c:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
    m_spdpAgent.init(*this, endpoints);
 800de20:	f600 2684 	addw	r6, r0, #2692	; 0xa84
 800de24:	460a      	mov	r2, r1
 800de26:	4601      	mov	r1, r0
 800de28:	4630      	mov	r0, r6
 800de2a:	f7fe f969 	bl	800c100 <_ZN4rtps9SPDPAgent4initERNS_11ParticipantERNS_16BuiltInEndpointsE>
    m_sedpAgent.init(*this, endpoints);
 800de2e:	462a      	mov	r2, r5
 800de30:	4621      	mov	r1, r4
 800de32:	f604 70ec 	addw	r0, r4, #4076	; 0xfec
 800de36:	f7fd fd15 	bl	800b864 <_ZN4rtps9SEDPAgent4initERNS_11ParticipantERKNS_16BuiltInEndpointsE>

    // This needs to be done after initializing the agents
    addWriter(endpoints.spdpWriter);
 800de3a:	6829      	ldr	r1, [r5, #0]
 800de3c:	4620      	mov	r0, r4
 800de3e:	f7ff fe8a 	bl	800db56 <_ZN4rtps11Participant9addWriterEPNS_6WriterE>
    addReader(endpoints.spdpReader);
 800de42:	6869      	ldr	r1, [r5, #4]
 800de44:	4620      	mov	r0, r4
 800de46:	f7ff fea6 	bl	800db96 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE>
    addWriter(endpoints.sedpPubWriter);
 800de4a:	68a9      	ldr	r1, [r5, #8]
 800de4c:	4620      	mov	r0, r4
 800de4e:	f7ff fe82 	bl	800db56 <_ZN4rtps11Participant9addWriterEPNS_6WriterE>
    addReader(endpoints.sedpPubReader);
 800de52:	68e9      	ldr	r1, [r5, #12]
 800de54:	4620      	mov	r0, r4
 800de56:	f7ff fe9e 	bl	800db96 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE>
    addWriter(endpoints.sedpSubWriter);
 800de5a:	6929      	ldr	r1, [r5, #16]
 800de5c:	4620      	mov	r0, r4
 800de5e:	f7ff fe7a 	bl	800db56 <_ZN4rtps11Participant9addWriterEPNS_6WriterE>
    addReader(endpoints.sedpSubReader);
 800de62:	6969      	ldr	r1, [r5, #20]
 800de64:	4620      	mov	r0, r4
 800de66:	f7ff fe96 	bl	800db96 <_ZN4rtps11Participant9addReaderEPNS_6ReaderE>

    m_spdpAgent.start();
 800de6a:	4630      	mov	r0, r6
 800de6c:	f7fd feb4 	bl	800bbd8 <_ZN4rtps9SPDPAgent5startEv>
}
 800de70:	bd70      	pop	{r4, r5, r6, pc}

0800de72 <_ZN4rtps11Participant10newMessageEPKht>:

void Participant::newMessage(const uint8_t* data, DataSize_t size){
 800de72:	b508      	push	{r3, lr}
    m_receiver.processMessage(data, size);
 800de74:	3010      	adds	r0, #16
 800de76:	f000 f908 	bl	800e08a <_ZN4rtps15MessageReceiver14processMessageEPKht>
}
 800de7a:	bd08      	pop	{r3, pc}

0800de7c <_ZN4rtps15StatelessReader9newChangeERKNS_17ReaderCacheChangeE>:

void StatelessReader::init(const TopicData& attributes){
    m_attributes = attributes;
}

void StatelessReader::newChange(const ReaderCacheChange& cacheChange){
 800de7c:	b508      	push	{r3, lr}
    if(m_callback != nullptr){
 800de7e:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800de80:	b10b      	cbz	r3, 800de86 <_ZN4rtps15StatelessReader9newChangeERKNS_17ReaderCacheChangeE+0xa>
        m_callback(m_callee, cacheChange);
 800de82:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 800de84:	4798      	blx	r3
    }
}
 800de86:	bd08      	pop	{r3, pc}

0800de88 <_ZN4rtps15StatelessReader16registerCallbackEPFvPvRKNS_17ReaderCacheChangeEES1_>:

void StatelessReader::registerCallback(ddsReaderCallback_fp cb, void* callee){
    if(cb != nullptr){
 800de88:	b109      	cbz	r1, 800de8e <_ZN4rtps15StatelessReader16registerCallbackEPFvPvRKNS_17ReaderCacheChangeEES1_+0x6>
        m_callback = cb;
 800de8a:	6581      	str	r1, [r0, #88]	; 0x58
        m_callee = callee; // It's okay if this is null
 800de8c:	65c2      	str	r2, [r0, #92]	; 0x5c
    }else{
#if SLR_VERBOSE
        printf("StatelessReader[%s]: Passed callback is nullptr\n", &m_attributes.topicName[0]);
#endif
    }
}
 800de8e:	4770      	bx	lr

0800de90 <_ZN4rtps15StatelessReader19addNewMatchedWriterERKNS_11WriterProxyE>:

bool StatelessReader::addNewMatchedWriter(const WriterProxy& /*newProxy*/){
    // Nothing to do
    return true;
}
 800de90:	2001      	movs	r0, #1
 800de92:	4770      	bx	lr

0800de94 <_ZN4rtps15StatelessReader12removeWriterERKNS_4GuidE>:

void StatelessReader::removeWriter(const Guid& /*guid*/){
    // Nothing to do
}
 800de94:	4770      	bx	lr

0800de96 <_ZN4rtps15StatelessReader14onNewHeartbeatERKNS_19SubmessageHeartbeatERKNS_12GuidPrefix_tE>:

bool StatelessReader::onNewHeartbeat(const SubmessageHeartbeat&, const GuidPrefix_t&){
    // nothing to do
    return true;
}
 800de96:	2001      	movs	r0, #1
 800de98:	4770      	bx	lr

0800de9a <_ZN4rtps15StatelessReaderD1Ev>:
 800de9a:	4770      	bx	lr

0800de9c <_ZN4rtps15StatelessReaderD0Ev>:
 800de9c:	b510      	push	{r4, lr}
 800de9e:	4604      	mov	r4, r0
 800dea0:	f7fb ffea 	bl	8009e78 <_ZdlPv>
 800dea4:	4620      	mov	r0, r4
 800dea6:	bd10      	pop	{r4, pc}

0800dea8 <_ZN4rtps15MessageReceiverC1EPNS_11ParticipantE>:

#if RECV_VERBOSE
#include "rtps/utils/printutils.h"
#endif

MessageReceiver::MessageReceiver(Participant* part)
 800dea8:	b410      	push	{r4}
: mp_part(part){
 800deaa:	2200      	movs	r2, #0
 800deac:	6002      	str	r2, [r0, #0]
 800deae:	6042      	str	r2, [r0, #4]
 800deb0:	6082      	str	r2, [r0, #8]
 800deb2:	4c04      	ldr	r4, [pc, #16]	; (800dec4 <_ZN4rtps15MessageReceiverC1EPNS_11ParticipantE+0x1c>)
 800deb4:	8824      	ldrh	r4, [r4, #0]
 800deb6:	8184      	strh	r4, [r0, #12]
 800deb8:	81c2      	strh	r2, [r0, #14]
 800deba:	7402      	strb	r2, [r0, #16]
 800debc:	6141      	str	r1, [r0, #20]

}
 800debe:	f85d 4b04 	ldr.w	r4, [sp], #4
 800dec2:	4770      	bx	lr
 800dec4:	08010988 	.word	0x08010988

0800dec8 <_ZN4rtps15MessageReceiver10resetStateEv>:

void MessageReceiver::resetState(){
    sourceGuidPrefix = GUIDPREFIX_UNKNOWN;
 800dec8:	2300      	movs	r3, #0
 800deca:	6003      	str	r3, [r0, #0]
 800decc:	6043      	str	r3, [r0, #4]
 800dece:	6083      	str	r3, [r0, #8]
    sourceVersion = PROTOCOLVERSION;
 800ded0:	4a02      	ldr	r2, [pc, #8]	; (800dedc <_ZN4rtps15MessageReceiver10resetStateEv+0x14>)
 800ded2:	8812      	ldrh	r2, [r2, #0]
 800ded4:	8182      	strh	r2, [r0, #12]
    sourceVendor = VENDOR_UNKNOWN;
 800ded6:	81c3      	strh	r3, [r0, #14]
    haveTimeStamp = false;
 800ded8:	7403      	strb	r3, [r0, #16]
}
 800deda:	4770      	bx	lr
 800dedc:	08010988 	.word	0x08010988

0800dee0 <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE>:

    return true;

}

bool MessageReceiver::processHeader(MessageProcessingInfo& msgInfo){
 800dee0:	b570      	push	{r4, r5, r6, lr}
 800dee2:	b086      	sub	sp, #24
 800dee4:	4606      	mov	r6, r0
 800dee6:	460d      	mov	r5, r1
    Header header;
    if(!deserializeMessage(msgInfo, header)){
 800dee8:	a901      	add	r1, sp, #4
 800deea:	4628      	mov	r0, r5
 800deec:	f000 f8ff 	bl	800e0ee <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_6HeaderE>
 800def0:	4604      	mov	r4, r0
 800def2:	b318      	cbz	r0, 800df3c <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x5c>
 800def4:	220c      	movs	r2, #12
 800def6:	6971      	ldr	r1, [r6, #20]
 800def8:	eb0d 0002 	add.w	r0, sp, r2
 800defc:	f001 fab4 	bl	800f468 <memcmp>
        return false;
    }

    if(header.guidPrefix.id == mp_part->m_guidPrefix.id){
 800df00:	b1d8      	cbz	r0, 800df3a <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x5a>
 800df02:	2204      	movs	r2, #4
 800df04:	4910      	ldr	r1, [pc, #64]	; (800df48 <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x68>)
 800df06:	eb0d 0002 	add.w	r0, sp, r2
 800df0a:	f001 faad 	bl	800f468 <memcmp>
      printf("[MessageReceiver]: Received own message.\n");
#endif
        return false; // Don't process our own packet
    }

    if(header.protocolName != RTPS_PROTOCOL_NAME ||
 800df0e:	b9c0      	cbnz	r0, 800df42 <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x62>
       header.protocolVersion.major != PROTOCOLVERSION.major){
 800df10:	f89d 3008 	ldrb.w	r3, [sp, #8]
    if(header.protocolName != RTPS_PROTOCOL_NAME ||
 800df14:	2b02      	cmp	r3, #2
 800df16:	d001      	beq.n	800df1c <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x3c>
        return false;
 800df18:	2400      	movs	r4, #0
 800df1a:	e00f      	b.n	800df3c <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x5c>
    }

    sourceGuidPrefix = header.guidPrefix;
 800df1c:	ab06      	add	r3, sp, #24
 800df1e:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 800df22:	e886 0007 	stmia.w	r6, {r0, r1, r2}
    sourceVendor = header.vendorId;
 800df26:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 800df2a:	81f3      	strh	r3, [r6, #14]
    sourceVersion = header.protocolVersion;
 800df2c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 800df30:	81b3      	strh	r3, [r6, #12]

    msgInfo.nextPos += Header::getRawSize();
 800df32:	88eb      	ldrh	r3, [r5, #6]
 800df34:	3314      	adds	r3, #20
 800df36:	80eb      	strh	r3, [r5, #6]
    return true;
 800df38:	e000      	b.n	800df3c <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x5c>
        return false; // Don't process our own packet
 800df3a:	2400      	movs	r4, #0
}
 800df3c:	4620      	mov	r0, r4
 800df3e:	b006      	add	sp, #24
 800df40:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 800df42:	2400      	movs	r4, #0
 800df44:	e7fa      	b.n	800df3c <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE+0x5c>
 800df46:	bf00      	nop
 800df48:	0801098c 	.word	0x0801098c

0800df4c <_ZN4rtps15MessageReceiver21processDataSubmessageERNS_21MessageProcessingInfoE>:
    }
    msgInfo.nextPos += submsgHeader.submessageLength + SubmessageHeader::getRawSize();
    return success;
}

bool MessageReceiver::processDataSubmessage(MessageProcessingInfo& msgInfo){
 800df4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800df4e:	b095      	sub	sp, #84	; 0x54
 800df50:	4605      	mov	r5, r0
 800df52:	460c      	mov	r4, r1
    SubmessageData dataSubmsg;
    if(!deserializeMessage(msgInfo, dataSubmsg)){
 800df54:	a90e      	add	r1, sp, #56	; 0x38
 800df56:	4620      	mov	r0, r4
 800df58:	f000 f90f 	bl	800e17a <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_14SubmessageDataE>
 800df5c:	4606      	mov	r6, r0
 800df5e:	b910      	cbnz	r0, 800df66 <_ZN4rtps15MessageReceiver21processDataSubmessageERNS_21MessageProcessingInfoE+0x1a>
        printf("\n");
#endif
    }

    return true;
}
 800df60:	4630      	mov	r0, r6
 800df62:	b015      	add	sp, #84	; 0x54
 800df64:	bdf0      	pop	{r4, r5, r6, r7, pc}

        //! Offset to the next unprocessed byte
        DataSize_t nextPos = 0;

        inline const uint8_t* getPointerToCurrentPos() const{
            return &data[nextPos];
 800df66:	6827      	ldr	r7, [r4, #0]
 800df68:	88e2      	ldrh	r2, [r4, #6]
    const uint8_t* serializedData = msgInfo.getPointerToCurrentPos() + SubmessageData::getRawSize();
 800df6a:	f102 0318 	add.w	r3, r2, #24
 800df6e:	441f      	add	r7, r3
    const DataSize_t size = msgInfo.size - (msgInfo.nextPos + SubmessageData::getRawSize());
 800df70:	88a3      	ldrh	r3, [r4, #4]
 800df72:	1a9b      	subs	r3, r3, r2
 800df74:	b29b      	uxth	r3, r3
 800df76:	3b18      	subs	r3, #24
 800df78:	b29c      	uxth	r4, r3
    Reader* reader = mp_part->getReader(dataSubmsg.readerId);
 800df7a:	9910      	ldr	r1, [sp, #64]	; 0x40
 800df7c:	6968      	ldr	r0, [r5, #20]
 800df7e:	f7ff fe4d 	bl	800dc1c <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE>
    if(reader != nullptr){
 800df82:	4684      	mov	ip, r0
 800df84:	2800      	cmp	r0, #0
 800df86:	d0eb      	beq.n	800df60 <_ZN4rtps15MessageReceiver21processDataSubmessageERNS_21MessageProcessingInfoE+0x14>
        Guid writerGuid{sourceGuidPrefix, dataSubmsg.writerId};
 800df88:	ab02      	add	r3, sp, #8
 800df8a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800df8e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800df92:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800df94:	9205      	str	r2, [sp, #20]
 800df96:	466d      	mov	r5, sp
 800df98:	aa14      	add	r2, sp, #80	; 0x50
 800df9a:	e912 0003 	ldmdb	r2, {r0, r1}
 800df9e:	e885 0003 	stmia.w	r5, {r0, r1}
            : data(data), kind(kind), size(size), writerGuid(writerGuid), sn(sn){};
 800dfa2:	9706      	str	r7, [sp, #24]
 800dfa4:	2201      	movs	r2, #1
 800dfa6:	f88d 201c 	strb.w	r2, [sp, #28]
 800dfaa:	f8ad 401e 	strh.w	r4, [sp, #30]
 800dfae:	ac08      	add	r4, sp, #32
 800dfb0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800dfb2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800dfb6:	ab0c      	add	r3, sp, #48	; 0x30
 800dfb8:	e895 0003 	ldmia.w	r5, {r0, r1}
 800dfbc:	e883 0003 	stmia.w	r3, {r0, r1}
        reader->newChange(change);
 800dfc0:	f8dc 3000 	ldr.w	r3, [ip]
 800dfc4:	681b      	ldr	r3, [r3, #0]
 800dfc6:	a906      	add	r1, sp, #24
 800dfc8:	4660      	mov	r0, ip
 800dfca:	4798      	blx	r3
 800dfcc:	e7c8      	b.n	800df60 <_ZN4rtps15MessageReceiver21processDataSubmessageERNS_21MessageProcessingInfoE+0x14>

0800dfce <_ZN4rtps15MessageReceiver26processHeartbeatSubmessageERNS_21MessageProcessingInfoE>:

bool MessageReceiver::processHeartbeatSubmessage(MessageProcessingInfo& msgInfo){
 800dfce:	b570      	push	{r4, r5, r6, lr}
 800dfd0:	b088      	sub	sp, #32
 800dfd2:	4605      	mov	r5, r0
 800dfd4:	4608      	mov	r0, r1
    SubmessageHeartbeat submsgHB;
    if(!deserializeMessage(msgInfo, submsgHB)){
 800dfd6:	4669      	mov	r1, sp
 800dfd8:	f000 f91f 	bl	800e21a <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_19SubmessageHeartbeatE>
 800dfdc:	4604      	mov	r4, r0
 800dfde:	b910      	cbnz	r0, 800dfe6 <_ZN4rtps15MessageReceiver26processHeartbeatSubmessageERNS_21MessageProcessingInfoE+0x18>
        reader->onNewHeartbeat(submsgHB, sourceGuidPrefix);
        return true;
    }else{
        return false;
    }
}
 800dfe0:	4620      	mov	r0, r4
 800dfe2:	b008      	add	sp, #32
 800dfe4:	bd70      	pop	{r4, r5, r6, pc}
    Reader* reader = mp_part->getReader(submsgHB.readerId);
 800dfe6:	9901      	ldr	r1, [sp, #4]
 800dfe8:	6968      	ldr	r0, [r5, #20]
 800dfea:	f7ff fe17 	bl	800dc1c <_ZNK4rtps11Participant9getReaderENS_10EntityId_tE>
    if(reader != nullptr){
 800dfee:	b128      	cbz	r0, 800dffc <_ZN4rtps15MessageReceiver26processHeartbeatSubmessageERNS_21MessageProcessingInfoE+0x2e>
        reader->onNewHeartbeat(submsgHB, sourceGuidPrefix);
 800dff0:	6802      	ldr	r2, [r0, #0]
 800dff2:	6896      	ldr	r6, [r2, #8]
 800dff4:	462a      	mov	r2, r5
 800dff6:	4669      	mov	r1, sp
 800dff8:	47b0      	blx	r6
 800dffa:	e7f1      	b.n	800dfe0 <_ZN4rtps15MessageReceiver26processHeartbeatSubmessageERNS_21MessageProcessingInfoE+0x12>
        return false;
 800dffc:	2400      	movs	r4, #0
 800dffe:	e7ef      	b.n	800dfe0 <_ZN4rtps15MessageReceiver26processHeartbeatSubmessageERNS_21MessageProcessingInfoE+0x12>

0800e000 <_ZN4rtps15MessageReceiver24processAckNackSubmessageERNS_21MessageProcessingInfoE>:

bool MessageReceiver::processAckNackSubmessage(MessageProcessingInfo& msgInfo){
 800e000:	b570      	push	{r4, r5, r6, lr}
 800e002:	b090      	sub	sp, #64	; 0x40
 800e004:	4605      	mov	r5, r0
 800e006:	460c      	mov	r4, r1
        SequenceNumberSet() = default;
 800e008:	2100      	movs	r1, #0
 800e00a:	9104      	str	r1, [sp, #16]
 800e00c:	9105      	str	r1, [sp, #20]
 800e00e:	2220      	movs	r2, #32
 800e010:	9206      	str	r2, [sp, #24]
 800e012:	a807      	add	r0, sp, #28
 800e014:	f001 fa42 	bl	800f49c <memset>
    SubmessageAckNack submsgAckNack;
    if(!deserializeMessage(msgInfo, submsgAckNack)){
 800e018:	a901      	add	r1, sp, #4
 800e01a:	4620      	mov	r0, r4
 800e01c:	f000 f94b 	bl	800e2b6 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE>
 800e020:	4604      	mov	r4, r0
 800e022:	b910      	cbnz	r0, 800e02a <_ZN4rtps15MessageReceiver24processAckNackSubmessageERNS_21MessageProcessingInfoE+0x2a>
        writer->onNewAckNack(submsgAckNack, sourceGuidPrefix);
        return true;
    }else{
        return false;
    }
}
 800e024:	4620      	mov	r0, r4
 800e026:	b010      	add	sp, #64	; 0x40
 800e028:	bd70      	pop	{r4, r5, r6, pc}
    Writer* writer = mp_part->getWriter(submsgAckNack.writerId);
 800e02a:	9903      	ldr	r1, [sp, #12]
 800e02c:	6968      	ldr	r0, [r5, #20]
 800e02e:	f7ff fdcb 	bl	800dbc8 <_ZNK4rtps11Participant9getWriterENS_10EntityId_tE>
    if(writer != nullptr){
 800e032:	b128      	cbz	r0, 800e040 <_ZN4rtps15MessageReceiver24processAckNackSubmessageERNS_21MessageProcessingInfoE+0x40>
        writer->onNewAckNack(submsgAckNack, sourceGuidPrefix);
 800e034:	6802      	ldr	r2, [r0, #0]
 800e036:	6956      	ldr	r6, [r2, #20]
 800e038:	462a      	mov	r2, r5
 800e03a:	a901      	add	r1, sp, #4
 800e03c:	47b0      	blx	r6
 800e03e:	e7f1      	b.n	800e024 <_ZN4rtps15MessageReceiver24processAckNackSubmessageERNS_21MessageProcessingInfoE+0x24>
        return false;
 800e040:	2400      	movs	r4, #0
 800e042:	e7ef      	b.n	800e024 <_ZN4rtps15MessageReceiver24processAckNackSubmessageERNS_21MessageProcessingInfoE+0x24>

0800e044 <_ZN4rtps15MessageReceiver17processSubmessageERNS_21MessageProcessingInfoERKNS_16SubmessageHeaderE>:
bool MessageReceiver::processSubmessage(MessageProcessingInfo& msgInfo, const SubmessageHeader& submsgHeader){
 800e044:	b538      	push	{r3, r4, r5, lr}
 800e046:	460c      	mov	r4, r1
 800e048:	4615      	mov	r5, r2
    switch(submsgHeader.submessageId){
 800e04a:	7813      	ldrb	r3, [r2, #0]
 800e04c:	3b06      	subs	r3, #6
 800e04e:	2b0f      	cmp	r3, #15
 800e050:	d819      	bhi.n	800e086 <_ZN4rtps15MessageReceiver17processSubmessageERNS_21MessageProcessingInfoERKNS_16SubmessageHeaderE+0x42>
 800e052:	e8df f003 	tbb	[pc, r3]
 800e056:	150f      	.short	0x150f
 800e058:	18180818 	.word	0x18180818
 800e05c:	18081818 	.word	0x18081818
 800e060:	18181818 	.word	0x18181818
 800e064:	1218      	.short	0x1218
            success = true; // Not relevant
 800e066:	2001      	movs	r0, #1
    msgInfo.nextPos += submsgHeader.submessageLength + SubmessageHeader::getRawSize();
 800e068:	886b      	ldrh	r3, [r5, #2]
 800e06a:	3304      	adds	r3, #4
 800e06c:	88e2      	ldrh	r2, [r4, #6]
 800e06e:	4413      	add	r3, r2
 800e070:	80e3      	strh	r3, [r4, #6]
}
 800e072:	bd38      	pop	{r3, r4, r5, pc}
            success = processAckNackSubmessage(msgInfo);
 800e074:	f7ff ffc4 	bl	800e000 <_ZN4rtps15MessageReceiver24processAckNackSubmessageERNS_21MessageProcessingInfoE>
            break;
 800e078:	e7f6      	b.n	800e068 <_ZN4rtps15MessageReceiver17processSubmessageERNS_21MessageProcessingInfoERKNS_16SubmessageHeaderE+0x24>
            success = processDataSubmessage(msgInfo);
 800e07a:	f7ff ff67 	bl	800df4c <_ZN4rtps15MessageReceiver21processDataSubmessageERNS_21MessageProcessingInfoE>
            break;
 800e07e:	e7f3      	b.n	800e068 <_ZN4rtps15MessageReceiver17processSubmessageERNS_21MessageProcessingInfoERKNS_16SubmessageHeaderE+0x24>
            success = processHeartbeatSubmessage(msgInfo);
 800e080:	f7ff ffa5 	bl	800dfce <_ZN4rtps15MessageReceiver26processHeartbeatSubmessageERNS_21MessageProcessingInfoE>
            break;
 800e084:	e7f0      	b.n	800e068 <_ZN4rtps15MessageReceiver17processSubmessageERNS_21MessageProcessingInfoERKNS_16SubmessageHeaderE+0x24>
            success = false;
 800e086:	2000      	movs	r0, #0
 800e088:	e7ee      	b.n	800e068 <_ZN4rtps15MessageReceiver17processSubmessageERNS_21MessageProcessingInfoERKNS_16SubmessageHeaderE+0x24>

0800e08a <_ZN4rtps15MessageReceiver14processMessageEPKht>:
bool MessageReceiver::processMessage(const uint8_t* data, DataSize_t size){
 800e08a:	b570      	push	{r4, r5, r6, lr}
 800e08c:	b084      	sub	sp, #16
 800e08e:	4604      	mov	r4, r0
 800e090:	460e      	mov	r6, r1
 800e092:	4615      	mov	r5, r2
    resetState();
 800e094:	f7ff ff18 	bl	800dec8 <_ZN4rtps15MessageReceiver10resetStateEv>
                : data(data), size(size){}
 800e098:	9602      	str	r6, [sp, #8]
 800e09a:	f8ad 500c 	strh.w	r5, [sp, #12]
 800e09e:	2300      	movs	r3, #0
 800e0a0:	f8ad 300e 	strh.w	r3, [sp, #14]
    if(!processHeader(msgInfo)){
 800e0a4:	a902      	add	r1, sp, #8
 800e0a6:	4620      	mov	r0, r4
 800e0a8:	f7ff ff1a 	bl	800dee0 <_ZN4rtps15MessageReceiver13processHeaderERNS_21MessageProcessingInfoE>
 800e0ac:	4605      	mov	r5, r0
 800e0ae:	b188      	cbz	r0, 800e0d4 <_ZN4rtps15MessageReceiver14processMessageEPKht+0x4a>
    while(msgInfo.nextPos < msgInfo.size){
 800e0b0:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 800e0b4:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 800e0b8:	429a      	cmp	r2, r3
 800e0ba:	d20b      	bcs.n	800e0d4 <_ZN4rtps15MessageReceiver14processMessageEPKht+0x4a>
        if(!deserializeMessage(msgInfo, submsgHeader)){
 800e0bc:	a901      	add	r1, sp, #4
 800e0be:	a802      	add	r0, sp, #8
 800e0c0:	f000 f83d 	bl	800e13e <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_16SubmessageHeaderE>
 800e0c4:	b128      	cbz	r0, 800e0d2 <_ZN4rtps15MessageReceiver14processMessageEPKht+0x48>
        processSubmessage(msgInfo, submsgHeader);
 800e0c6:	aa01      	add	r2, sp, #4
 800e0c8:	a902      	add	r1, sp, #8
 800e0ca:	4620      	mov	r0, r4
 800e0cc:	f7ff ffba 	bl	800e044 <_ZN4rtps15MessageReceiver17processSubmessageERNS_21MessageProcessingInfoERKNS_16SubmessageHeaderE>
 800e0d0:	e7ee      	b.n	800e0b0 <_ZN4rtps15MessageReceiver14processMessageEPKht+0x26>
            return false;
 800e0d2:	4605      	mov	r5, r0
}
 800e0d4:	4628      	mov	r0, r5
 800e0d6:	b004      	add	sp, #16
 800e0d8:	bd70      	pop	{r4, r5, r6, pc}

0800e0da <_Z15doCopyAndMoveOnPhRPKhj>:
#include <cstring>

#include <stdio.h>
using namespace rtps;

void doCopyAndMoveOn(uint8_t* dst, const uint8_t*& src, size_t size){
 800e0da:	b538      	push	{r3, r4, r5, lr}
 800e0dc:	460c      	mov	r4, r1
 800e0de:	4615      	mov	r5, r2
    memcpy(dst, src, size);
 800e0e0:	6809      	ldr	r1, [r1, #0]
 800e0e2:	f001 f9d0 	bl	800f486 <memcpy>
    src += size;
 800e0e6:	6822      	ldr	r2, [r4, #0]
 800e0e8:	442a      	add	r2, r5
 800e0ea:	6022      	str	r2, [r4, #0]
}
 800e0ec:	bd38      	pop	{r3, r4, r5, pc}

0800e0ee <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_6HeaderE>:
        }

        //! Returns the size of data which isn't processed yet
        inline DataSize_t getRemainingSize() const{
            return size - nextPos;
 800e0ee:	8883      	ldrh	r3, [r0, #4]
 800e0f0:	88c2      	ldrh	r2, [r0, #6]
 800e0f2:	1a9b      	subs	r3, r3, r2
 800e0f4:	b29b      	uxth	r3, r3

bool rtps::deserializeMessage(const MessageProcessingInfo& info, Header& header){
    if(info.getRemainingSize() < Header::getRawSize()){
 800e0f6:	2b13      	cmp	r3, #19
 800e0f8:	d801      	bhi.n	800e0fe <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_6HeaderE+0x10>
        return false;
 800e0fa:	2000      	movs	r0, #0
    doCopyAndMoveOn(header.protocolName.data(), currentPos, sizeof(std::array<uint8_t, 4>));
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&header.protocolVersion), currentPos, sizeof(ProtocolVersion_t));
    doCopyAndMoveOn(header.vendorId.vendorId.data(), currentPos, header.vendorId.vendorId.size());
    doCopyAndMoveOn(header.guidPrefix.id.data(), currentPos, header.guidPrefix.id.size());
    return true;
}
 800e0fc:	4770      	bx	lr
bool rtps::deserializeMessage(const MessageProcessingInfo& info, Header& header){
 800e0fe:	b530      	push	{r4, r5, lr}
 800e100:	b083      	sub	sp, #12
 800e102:	460c      	mov	r4, r1
            return &data[nextPos];
 800e104:	6803      	ldr	r3, [r0, #0]
 800e106:	441a      	add	r2, r3
    const uint8_t* currentPos = info.getPointerToCurrentPos();
 800e108:	ad02      	add	r5, sp, #8
 800e10a:	f845 2d04 	str.w	r2, [r5, #-4]!
    doCopyAndMoveOn(header.protocolName.data(), currentPos, sizeof(std::array<uint8_t, 4>));
 800e10e:	2204      	movs	r2, #4
 800e110:	4629      	mov	r1, r5
 800e112:	4620      	mov	r0, r4
 800e114:	f7ff ffe1 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&header.protocolVersion), currentPos, sizeof(ProtocolVersion_t));
 800e118:	2202      	movs	r2, #2
 800e11a:	4629      	mov	r1, r5
 800e11c:	1d20      	adds	r0, r4, #4
 800e11e:	f7ff ffdc 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(header.vendorId.vendorId.data(), currentPos, header.vendorId.vendorId.size());
 800e122:	2202      	movs	r2, #2
 800e124:	4629      	mov	r1, r5
 800e126:	1da0      	adds	r0, r4, #6
 800e128:	f7ff ffd7 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(header.guidPrefix.id.data(), currentPos, header.guidPrefix.id.size());
 800e12c:	220c      	movs	r2, #12
 800e12e:	4629      	mov	r1, r5
 800e130:	f104 0008 	add.w	r0, r4, #8
 800e134:	f7ff ffd1 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    return true;
 800e138:	2001      	movs	r0, #1
}
 800e13a:	b003      	add	sp, #12
 800e13c:	bd30      	pop	{r4, r5, pc}

0800e13e <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_16SubmessageHeaderE>:
            return size - nextPos;
 800e13e:	8883      	ldrh	r3, [r0, #4]
 800e140:	88c2      	ldrh	r2, [r0, #6]
 800e142:	1a9b      	subs	r3, r3, r2
 800e144:	b29b      	uxth	r3, r3

bool rtps::deserializeMessage(const MessageProcessingInfo& info, SubmessageHeader& header){
    if(info.getRemainingSize() < SubmessageHeader::getRawSize()){
 800e146:	2b03      	cmp	r3, #3
 800e148:	d801      	bhi.n	800e14e <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_16SubmessageHeaderE+0x10>
        return false;
 800e14a:	2000      	movs	r0, #0
    const uint8_t* currentPos = info.getPointerToCurrentPos();
    header.submessageId = static_cast<SubmessageKind>(*currentPos++);
    header.flags = *(currentPos++);
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&header.submessageLength), currentPos, sizeof(uint16_t));
    return true;
}
 800e14c:	4770      	bx	lr
bool rtps::deserializeMessage(const MessageProcessingInfo& info, SubmessageHeader& header){
 800e14e:	b510      	push	{r4, lr}
 800e150:	b082      	sub	sp, #8
 800e152:	460b      	mov	r3, r1
            return &data[nextPos];
 800e154:	6804      	ldr	r4, [r0, #0]
 800e156:	18a0      	adds	r0, r4, r2
    header.submessageId = static_cast<SubmessageKind>(*currentPos++);
 800e158:	1c41      	adds	r1, r0, #1
 800e15a:	9101      	str	r1, [sp, #4]
 800e15c:	5ca2      	ldrb	r2, [r4, r2]
 800e15e:	701a      	strb	r2, [r3, #0]
    header.flags = *(currentPos++);
 800e160:	1c82      	adds	r2, r0, #2
 800e162:	a902      	add	r1, sp, #8
 800e164:	f841 2d04 	str.w	r2, [r1, #-4]!
 800e168:	7842      	ldrb	r2, [r0, #1]
 800e16a:	705a      	strb	r2, [r3, #1]
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&header.submessageLength), currentPos, sizeof(uint16_t));
 800e16c:	2202      	movs	r2, #2
 800e16e:	1898      	adds	r0, r3, r2
 800e170:	f7ff ffb3 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    return true;
 800e174:	2001      	movs	r0, #1
}
 800e176:	b002      	add	sp, #8
 800e178:	bd10      	pop	{r4, pc}

0800e17a <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_14SubmessageDataE>:

bool rtps::deserializeMessage(const MessageProcessingInfo& info, SubmessageData& msg){
 800e17a:	b570      	push	{r4, r5, r6, lr}
 800e17c:	b082      	sub	sp, #8
            return size - nextPos;
 800e17e:	8883      	ldrh	r3, [r0, #4]
 800e180:	88c2      	ldrh	r2, [r0, #6]
 800e182:	1a9b      	subs	r3, r3, r2
 800e184:	b29b      	uxth	r3, r3
    if(info.getRemainingSize() < SubmessageHeader::getRawSize()){
 800e186:	2b03      	cmp	r3, #3
 800e188:	d803      	bhi.n	800e192 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_14SubmessageDataE+0x18>
        return false;
 800e18a:	2600      	movs	r6, #0
    doCopyAndMoveOn(msg.writerId.entityKey.data(), currentPos, msg.writerId.entityKey.size());
    msg.writerId.entityKind = static_cast<EntityKind_t>(*currentPos++);
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.writerSN.high), currentPos, sizeof(msg.writerSN.high));
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.writerSN.low), currentPos, sizeof(msg.writerSN.low));
    return true;
}
 800e18c:	4630      	mov	r0, r6
 800e18e:	b002      	add	sp, #8
 800e190:	bd70      	pop	{r4, r5, r6, pc}
 800e192:	460d      	mov	r5, r1
 800e194:	4604      	mov	r4, r0
    if(!deserializeMessage(info, msg.header)){
 800e196:	f7ff ffd2 	bl	800e13e <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_16SubmessageHeaderE>
 800e19a:	4606      	mov	r6, r0
 800e19c:	2800      	cmp	r0, #0
 800e19e:	d0f5      	beq.n	800e18c <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_14SubmessageDataE+0x12>
 800e1a0:	88a3      	ldrh	r3, [r4, #4]
 800e1a2:	88e1      	ldrh	r1, [r4, #6]
 800e1a4:	1a5b      	subs	r3, r3, r1
 800e1a6:	b29b      	uxth	r3, r3
    if(info.getRemainingSize() < SubmessageHeader::getRawSize() + msg.header.submessageLength){
 800e1a8:	886a      	ldrh	r2, [r5, #2]
 800e1aa:	3204      	adds	r2, #4
 800e1ac:	4293      	cmp	r3, r2
 800e1ae:	da01      	bge.n	800e1b4 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_14SubmessageDataE+0x3a>
        return false;
 800e1b0:	2600      	movs	r6, #0
 800e1b2:	e7eb      	b.n	800e18c <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_14SubmessageDataE+0x12>
            return &data[nextPos];
 800e1b4:	6823      	ldr	r3, [r4, #0]
    const uint8_t* currentPos = info.getPointerToCurrentPos() + SubmessageHeader::getRawSize();
 800e1b6:	3104      	adds	r1, #4
 800e1b8:	4419      	add	r1, r3
 800e1ba:	ac02      	add	r4, sp, #8
 800e1bc:	f844 1d04 	str.w	r1, [r4, #-4]!
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.extraFlags), currentPos, sizeof(uint16_t));
 800e1c0:	2202      	movs	r2, #2
 800e1c2:	4621      	mov	r1, r4
 800e1c4:	1d28      	adds	r0, r5, #4
 800e1c6:	f7ff ff88 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.octetsToInlineQos), currentPos, sizeof(uint16_t));
 800e1ca:	2202      	movs	r2, #2
 800e1cc:	4621      	mov	r1, r4
 800e1ce:	1da8      	adds	r0, r5, #6
 800e1d0:	f7ff ff83 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(msg.readerId.entityKey.data(), currentPos, msg.readerId.entityKey.size());
 800e1d4:	2203      	movs	r2, #3
 800e1d6:	4621      	mov	r1, r4
 800e1d8:	f105 0008 	add.w	r0, r5, #8
 800e1dc:	f7ff ff7d 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    msg.readerId.entityKind = static_cast<EntityKind_t>(*currentPos++);
 800e1e0:	9b01      	ldr	r3, [sp, #4]
 800e1e2:	1c5a      	adds	r2, r3, #1
 800e1e4:	9201      	str	r2, [sp, #4]
 800e1e6:	781b      	ldrb	r3, [r3, #0]
 800e1e8:	72eb      	strb	r3, [r5, #11]
    doCopyAndMoveOn(msg.writerId.entityKey.data(), currentPos, msg.writerId.entityKey.size());
 800e1ea:	2203      	movs	r2, #3
 800e1ec:	4621      	mov	r1, r4
 800e1ee:	f105 000c 	add.w	r0, r5, #12
 800e1f2:	f7ff ff72 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    msg.writerId.entityKind = static_cast<EntityKind_t>(*currentPos++);
 800e1f6:	9b01      	ldr	r3, [sp, #4]
 800e1f8:	1c5a      	adds	r2, r3, #1
 800e1fa:	9201      	str	r2, [sp, #4]
 800e1fc:	781b      	ldrb	r3, [r3, #0]
 800e1fe:	73eb      	strb	r3, [r5, #15]
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.writerSN.high), currentPos, sizeof(msg.writerSN.high));
 800e200:	2204      	movs	r2, #4
 800e202:	4621      	mov	r1, r4
 800e204:	f105 0010 	add.w	r0, r5, #16
 800e208:	f7ff ff67 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.writerSN.low), currentPos, sizeof(msg.writerSN.low));
 800e20c:	2204      	movs	r2, #4
 800e20e:	4621      	mov	r1, r4
 800e210:	f105 0014 	add.w	r0, r5, #20
 800e214:	f7ff ff61 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    return true;
 800e218:	e7b8      	b.n	800e18c <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_14SubmessageDataE+0x12>

0800e21a <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_19SubmessageHeartbeatE>:


bool rtps::deserializeMessage(const MessageProcessingInfo& info, SubmessageHeartbeat& msg){
 800e21a:	b570      	push	{r4, r5, r6, lr}
 800e21c:	b082      	sub	sp, #8
            return size - nextPos;
 800e21e:	8883      	ldrh	r3, [r0, #4]
 800e220:	88c2      	ldrh	r2, [r0, #6]
 800e222:	1a9b      	subs	r3, r3, r2
 800e224:	b29b      	uxth	r3, r3
    if(info.getRemainingSize() < SubmessageHeartbeat::getRawSize()){
 800e226:	2b1f      	cmp	r3, #31
 800e228:	d803      	bhi.n	800e232 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_19SubmessageHeartbeatE+0x18>
        return false;
 800e22a:	2600      	movs	r6, #0
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.firstSN.low), currentPos, sizeof(msg.firstSN.low));
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.lastSN.high), currentPos, sizeof(msg.lastSN.high));
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.lastSN.low), currentPos, sizeof(msg.lastSN.low));
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.count.value), currentPos, sizeof(msg.count.value));
    return true;
}
 800e22c:	4630      	mov	r0, r6
 800e22e:	b002      	add	sp, #8
 800e230:	bd70      	pop	{r4, r5, r6, pc}
 800e232:	460d      	mov	r5, r1
 800e234:	4604      	mov	r4, r0
    if(!deserializeMessage(info, msg.header)){
 800e236:	f7ff ff82 	bl	800e13e <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_16SubmessageHeaderE>
 800e23a:	4606      	mov	r6, r0
 800e23c:	2800      	cmp	r0, #0
 800e23e:	d0f5      	beq.n	800e22c <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_19SubmessageHeartbeatE+0x12>
            return &data[nextPos];
 800e240:	6823      	ldr	r3, [r4, #0]
 800e242:	88e2      	ldrh	r2, [r4, #6]
    const uint8_t* currentPos = info.getPointerToCurrentPos() + SubmessageHeader::getRawSize();
 800e244:	3204      	adds	r2, #4
 800e246:	4413      	add	r3, r2
 800e248:	ac02      	add	r4, sp, #8
 800e24a:	f844 3d04 	str.w	r3, [r4, #-4]!
    doCopyAndMoveOn(msg.readerId.entityKey.data(), currentPos, msg.readerId.entityKey.size());
 800e24e:	2203      	movs	r2, #3
 800e250:	4621      	mov	r1, r4
 800e252:	1d28      	adds	r0, r5, #4
 800e254:	f7ff ff41 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    msg.readerId.entityKind = static_cast<EntityKind_t>(*currentPos++);
 800e258:	9b01      	ldr	r3, [sp, #4]
 800e25a:	1c5a      	adds	r2, r3, #1
 800e25c:	9201      	str	r2, [sp, #4]
 800e25e:	781b      	ldrb	r3, [r3, #0]
 800e260:	71eb      	strb	r3, [r5, #7]
    doCopyAndMoveOn(msg.writerId.entityKey.data(), currentPos, msg.writerId.entityKey.size());
 800e262:	2203      	movs	r2, #3
 800e264:	4621      	mov	r1, r4
 800e266:	f105 0008 	add.w	r0, r5, #8
 800e26a:	f7ff ff36 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    msg.writerId.entityKind = static_cast<EntityKind_t>(*currentPos++);
 800e26e:	9b01      	ldr	r3, [sp, #4]
 800e270:	1c5a      	adds	r2, r3, #1
 800e272:	9201      	str	r2, [sp, #4]
 800e274:	781b      	ldrb	r3, [r3, #0]
 800e276:	72eb      	strb	r3, [r5, #11]
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.firstSN.high), currentPos, sizeof(msg.firstSN.high));
 800e278:	2204      	movs	r2, #4
 800e27a:	4621      	mov	r1, r4
 800e27c:	f105 000c 	add.w	r0, r5, #12
 800e280:	f7ff ff2b 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.firstSN.low), currentPos, sizeof(msg.firstSN.low));
 800e284:	2204      	movs	r2, #4
 800e286:	4621      	mov	r1, r4
 800e288:	f105 0010 	add.w	r0, r5, #16
 800e28c:	f7ff ff25 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.lastSN.high), currentPos, sizeof(msg.lastSN.high));
 800e290:	2204      	movs	r2, #4
 800e292:	4621      	mov	r1, r4
 800e294:	f105 0014 	add.w	r0, r5, #20
 800e298:	f7ff ff1f 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.lastSN.low), currentPos, sizeof(msg.lastSN.low));
 800e29c:	2204      	movs	r2, #4
 800e29e:	4621      	mov	r1, r4
 800e2a0:	f105 0018 	add.w	r0, r5, #24
 800e2a4:	f7ff ff19 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.count.value), currentPos, sizeof(msg.count.value));
 800e2a8:	2204      	movs	r2, #4
 800e2aa:	4621      	mov	r1, r4
 800e2ac:	f105 001c 	add.w	r0, r5, #28
 800e2b0:	f7ff ff13 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    return true;
 800e2b4:	e7ba      	b.n	800e22c <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_19SubmessageHeartbeatE+0x12>

0800e2b6 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE>:

bool rtps::deserializeMessage(const MessageProcessingInfo& info, SubmessageAckNack& msg){
 800e2b6:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e2b8:	b083      	sub	sp, #12
            return size - nextPos;
 800e2ba:	8884      	ldrh	r4, [r0, #4]
 800e2bc:	88c3      	ldrh	r3, [r0, #6]
 800e2be:	1ae4      	subs	r4, r4, r3
 800e2c0:	b2a4      	uxth	r4, r4
    const DataSize_t remainingSizeAtBeginning = info.getRemainingSize();
    if(remainingSizeAtBeginning < SubmessageAckNack::getRawSizeWithoutSNSet()){ // Size of SequenceNumberSet unknown
 800e2c2:	2c0f      	cmp	r4, #15
 800e2c4:	d803      	bhi.n	800e2ce <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0x18>
        return false;
 800e2c6:	2700      	movs	r7, #0
    	}
    	doCopyAndMoveOn(reinterpret_cast<uint8_t*>(msg.readerSNState.bitMap.data()), currentPos, 4*((msg.readerSNState.numBits / 32) + 1));
    }
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.count.value), currentPos, sizeof(msg.count.value));
    return true;
}
 800e2c8:	4638      	mov	r0, r7
 800e2ca:	b003      	add	sp, #12
 800e2cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e2ce:	460d      	mov	r5, r1
 800e2d0:	4606      	mov	r6, r0
    if(!deserializeMessage(info, msg.header)){
 800e2d2:	f7ff ff34 	bl	800e13e <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_16SubmessageHeaderE>
 800e2d6:	4607      	mov	r7, r0
 800e2d8:	2800      	cmp	r0, #0
 800e2da:	d0f5      	beq.n	800e2c8 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0x12>
            return &data[nextPos];
 800e2dc:	6833      	ldr	r3, [r6, #0]
 800e2de:	88f2      	ldrh	r2, [r6, #6]
    const uint8_t* currentPos = info.getPointerToCurrentPos() + SubmessageHeader::getRawSize();
 800e2e0:	3204      	adds	r2, #4
 800e2e2:	4413      	add	r3, r2
 800e2e4:	ae02      	add	r6, sp, #8
 800e2e6:	f846 3d04 	str.w	r3, [r6, #-4]!
    doCopyAndMoveOn(msg.readerId.entityKey.data(), currentPos, msg.readerId.entityKey.size());
 800e2ea:	2203      	movs	r2, #3
 800e2ec:	4631      	mov	r1, r6
 800e2ee:	1d28      	adds	r0, r5, #4
 800e2f0:	f7ff fef3 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    msg.readerId.entityKind = static_cast<EntityKind_t>(*currentPos++);
 800e2f4:	9b01      	ldr	r3, [sp, #4]
 800e2f6:	1c5a      	adds	r2, r3, #1
 800e2f8:	9201      	str	r2, [sp, #4]
 800e2fa:	781b      	ldrb	r3, [r3, #0]
 800e2fc:	71eb      	strb	r3, [r5, #7]
    doCopyAndMoveOn(msg.writerId.entityKey.data(), currentPos, msg.writerId.entityKey.size());
 800e2fe:	2203      	movs	r2, #3
 800e300:	4631      	mov	r1, r6
 800e302:	f105 0008 	add.w	r0, r5, #8
 800e306:	f7ff fee8 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    msg.writerId.entityKind = static_cast<EntityKind_t>(*currentPos++);
 800e30a:	9b01      	ldr	r3, [sp, #4]
 800e30c:	1c5a      	adds	r2, r3, #1
 800e30e:	9201      	str	r2, [sp, #4]
 800e310:	781b      	ldrb	r3, [r3, #0]
 800e312:	72eb      	strb	r3, [r5, #11]
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.readerSNState.base.high), currentPos, sizeof(msg.readerSNState.base.high));
 800e314:	2204      	movs	r2, #4
 800e316:	4631      	mov	r1, r6
 800e318:	f105 000c 	add.w	r0, r5, #12
 800e31c:	f7ff fedd 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.readerSNState.base.low), currentPos, sizeof(msg.readerSNState.base.low));
 800e320:	2204      	movs	r2, #4
 800e322:	4631      	mov	r1, r6
 800e324:	f105 0010 	add.w	r0, r5, #16
 800e328:	f7ff fed7 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.readerSNState.numBits), currentPos, sizeof(uint32_t));
 800e32c:	2204      	movs	r2, #4
 800e32e:	4631      	mov	r1, r6
 800e330:	f105 0014 	add.w	r0, r5, #20
 800e334:	f7ff fed1 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
			if(set.numBits != 0){
 800e338:	696a      	ldr	r2, [r5, #20]
 800e33a:	b172      	cbz	r2, 800e35a <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0xa4>
				bitMapSize = 4*((set.numBits/32) + 1);
 800e33c:	0953      	lsrs	r3, r2, #5
 800e33e:	3301      	adds	r3, #1
 800e340:	009b      	lsls	r3, r3, #2
 800e342:	b29b      	uxth	r3, r3
				   + sizeof(SequenceNumber_t) + sizeof(uint32_t) + bitMapSize; // SequenceNumberSet
 800e344:	331c      	adds	r3, #28
 800e346:	b29b      	uxth	r3, r3
    if(remainingSizeAtBeginning < SubmessageAckNack::getRawSize(msg.readerSNState)){
 800e348:	429c      	cmp	r4, r3
 800e34a:	d315      	bcc.n	800e378 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0xc2>
    if(msg.readerSNState.numBits != 0){
 800e34c:	b162      	cbz	r2, 800e368 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0xb2>
    	if(4*((msg.readerSNState.numBits / 32) + 1) > msg.readerSNState.bitMap.size()){
 800e34e:	0952      	lsrs	r2, r2, #5
 800e350:	3201      	adds	r2, #1
 800e352:	0092      	lsls	r2, r2, #2
 800e354:	2a08      	cmp	r2, #8
 800e356:	d902      	bls.n	800e35e <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0xa8>
 800e358:	e7fe      	b.n	800e358 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0xa2>
            uint16_t bitMapSize = 0;
 800e35a:	2300      	movs	r3, #0
 800e35c:	e7f2      	b.n	800e344 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0x8e>
    	doCopyAndMoveOn(reinterpret_cast<uint8_t*>(msg.readerSNState.bitMap.data()), currentPos, 4*((msg.readerSNState.numBits / 32) + 1));
 800e35e:	a901      	add	r1, sp, #4
 800e360:	f105 0018 	add.w	r0, r5, #24
 800e364:	f7ff feb9 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    doCopyAndMoveOn(reinterpret_cast<uint8_t*>(&msg.count.value), currentPos, sizeof(msg.count.value));
 800e368:	2204      	movs	r2, #4
 800e36a:	eb0d 0102 	add.w	r1, sp, r2
 800e36e:	f105 0038 	add.w	r0, r5, #56	; 0x38
 800e372:	f7ff feb2 	bl	800e0da <_Z15doCopyAndMoveOnPhRPKhj>
    return true;
 800e376:	e7a7      	b.n	800e2c8 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0x12>
        return false;
 800e378:	2700      	movs	r7, #0
 800e37a:	e7a5      	b.n	800e2c8 <_ZN4rtps18deserializeMessageERKNS_21MessageProcessingInfoERNS_17SubmessageAckNackE+0x12>

0800e37c <_ZN4rtps11PBufWrapperC1EP4pbuf>:

using rtps::PBufWrapper;

#define PBUF_WRAP_VERBOSE 0

PBufWrapper::PBufWrapper(pbuf* bufferToWrap) : firstElement(bufferToWrap){
 800e37c:	6001      	str	r1, [r0, #0]
 800e37e:	2200      	movs	r2, #0
 800e380:	8082      	strh	r2, [r0, #4]
    m_freeSpace = 0; // Assume it to be full
}
 800e382:	4770      	bx	lr

0800e384 <_ZN4rtps11PBufWrapper31copySimpleMembersAndResetBufferERKS0_>:
    }
    return *this;
}

void PBufWrapper::copySimpleMembersAndResetBuffer(const PBufWrapper& other){
    m_freeSpace = other.m_freeSpace;
 800e384:	888b      	ldrh	r3, [r1, #4]
 800e386:	8083      	strh	r3, [r0, #4]

    if(firstElement != nullptr){
 800e388:	6803      	ldr	r3, [r0, #0]
 800e38a:	b13b      	cbz	r3, 800e39c <_ZN4rtps11PBufWrapper31copySimpleMembersAndResetBufferERKS0_+0x18>
void PBufWrapper::copySimpleMembersAndResetBuffer(const PBufWrapper& other){
 800e38c:	b510      	push	{r4, lr}
 800e38e:	4604      	mov	r4, r0
        pbuf_free(firstElement);
 800e390:	4618      	mov	r0, r3
 800e392:	f7f8 f883 	bl	800649c <pbuf_free>
        firstElement = nullptr;
 800e396:	2300      	movs	r3, #0
 800e398:	6023      	str	r3, [r4, #0]
    }
}
 800e39a:	bd10      	pop	{r4, pc}
 800e39c:	4770      	bx	lr

0800e39e <_ZN4rtps11PBufWrapperaSERKS0_>:
PBufWrapper& PBufWrapper::operator=(const PBufWrapper &other) {
 800e39e:	b538      	push	{r3, r4, r5, lr}
 800e3a0:	4604      	mov	r4, r0
 800e3a2:	460d      	mov	r5, r1
    copySimpleMembersAndResetBuffer(other);
 800e3a4:	f7ff ffee 	bl	800e384 <_ZN4rtps11PBufWrapper31copySimpleMembersAndResetBufferERKS0_>
    if(other.firstElement!= nullptr){
 800e3a8:	6828      	ldr	r0, [r5, #0]
 800e3aa:	b108      	cbz	r0, 800e3b0 <_ZN4rtps11PBufWrapperaSERKS0_+0x12>
        pbuf_ref(other.firstElement);
 800e3ac:	f7f8 fa48 	bl	8006840 <pbuf_ref>
    firstElement = other.firstElement;
 800e3b0:	682b      	ldr	r3, [r5, #0]
 800e3b2:	6023      	str	r3, [r4, #0]
}
 800e3b4:	4620      	mov	r0, r4
 800e3b6:	bd38      	pop	{r3, r4, r5, pc}

0800e3b8 <_ZN4rtps11PBufWrapperC1ERKS0_>:
PBufWrapper::PBufWrapper(const PBufWrapper& other) {
 800e3b8:	b510      	push	{r4, lr}
 800e3ba:	4604      	mov	r4, r0
 800e3bc:	2300      	movs	r3, #0
 800e3be:	6003      	str	r3, [r0, #0]
 800e3c0:	8083      	strh	r3, [r0, #4]
    *this = other;
 800e3c2:	f7ff ffec 	bl	800e39e <_ZN4rtps11PBufWrapperaSERKS0_>
}
 800e3c6:	4620      	mov	r0, r4
 800e3c8:	bd10      	pop	{r4, pc}

0800e3ca <_ZN4rtps11PBufWrapperaSEOS0_>:
PBufWrapper& PBufWrapper::operator=(PBufWrapper&& other) noexcept{
 800e3ca:	b538      	push	{r3, r4, r5, lr}
 800e3cc:	4604      	mov	r4, r0
 800e3ce:	460d      	mov	r5, r1
    copySimpleMembersAndResetBuffer(other);
 800e3d0:	f7ff ffd8 	bl	800e384 <_ZN4rtps11PBufWrapper31copySimpleMembersAndResetBufferERKS0_>
    if(other.firstElement != nullptr){
 800e3d4:	682b      	ldr	r3, [r5, #0]
 800e3d6:	b113      	cbz	r3, 800e3de <_ZN4rtps11PBufWrapperaSEOS0_+0x14>
        firstElement = other.firstElement;
 800e3d8:	6023      	str	r3, [r4, #0]
        other.firstElement = nullptr;
 800e3da:	2300      	movs	r3, #0
 800e3dc:	602b      	str	r3, [r5, #0]
}
 800e3de:	4620      	mov	r0, r4
 800e3e0:	bd38      	pop	{r3, r4, r5, pc}

0800e3e2 <_ZN4rtps11PBufWrapperD1Ev>:

PBufWrapper::~PBufWrapper(){
 800e3e2:	b510      	push	{r4, lr}
 800e3e4:	4604      	mov	r4, r0
    if(firstElement != nullptr){
 800e3e6:	6800      	ldr	r0, [r0, #0]
 800e3e8:	b108      	cbz	r0, 800e3ee <_ZN4rtps11PBufWrapperD1Ev+0xc>
        pbuf_free(firstElement);
 800e3ea:	f7f8 f857 	bl	800649c <pbuf_free>
    }
}
 800e3ee:	4620      	mov	r0, r4
 800e3f0:	bd10      	pop	{r4, pc}

0800e3f2 <_ZNK4rtps11PBufWrapper7isValidEv>:
    }
    return clone;
}

bool PBufWrapper::isValid() const{
    return firstElement != nullptr;
 800e3f2:	6800      	ldr	r0, [r0, #0]
}
 800e3f4:	3000      	adds	r0, #0
 800e3f6:	bf18      	it	ne
 800e3f8:	2001      	movne	r0, #1
 800e3fa:	4770      	bx	lr

0800e3fc <_ZNK4rtps11PBufWrapper9spaceUsedEv>:
rtps::DataSize_t PBufWrapper::spaceLeft() const{
    return m_freeSpace;
}

rtps::DataSize_t PBufWrapper::spaceUsed() const{
    if(firstElement == nullptr){
 800e3fc:	6803      	ldr	r3, [r0, #0]
 800e3fe:	b123      	cbz	r3, 800e40a <_ZNK4rtps11PBufWrapper9spaceUsedEv+0xe>
        return 0;
    }

    return firstElement->tot_len - m_freeSpace;
 800e400:	891b      	ldrh	r3, [r3, #8]
 800e402:	8880      	ldrh	r0, [r0, #4]
 800e404:	1a18      	subs	r0, r3, r0
 800e406:	b280      	uxth	r0, r0
 800e408:	4770      	bx	lr
        return 0;
 800e40a:	2000      	movs	r0, #0
}
 800e40c:	4770      	bx	lr

0800e40e <_ZN4rtps11PBufWrapper6appendEPKht>:

bool PBufWrapper::append(const uint8_t* data, DataSize_t length){
    if(data == nullptr){
 800e40e:	b191      	cbz	r1, 800e436 <_ZN4rtps11PBufWrapper6appendEPKht+0x28>
bool PBufWrapper::append(const uint8_t* data, DataSize_t length){
 800e410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e412:	460e      	mov	r6, r1
 800e414:	4615      	mov	r5, r2
 800e416:	4604      	mov	r4, r0
        return false;
    }

    err_t err = pbuf_take_at(firstElement, data, length, spaceUsed());
 800e418:	6807      	ldr	r7, [r0, #0]
 800e41a:	f7ff ffef 	bl	800e3fc <_ZNK4rtps11PBufWrapper9spaceUsedEv>
 800e41e:	4603      	mov	r3, r0
 800e420:	462a      	mov	r2, r5
 800e422:	4631      	mov	r1, r6
 800e424:	4638      	mov	r0, r7
 800e426:	f7f8 fb75 	bl	8006b14 <pbuf_take_at>
    if(err != ERR_OK){
 800e42a:	b930      	cbnz	r0, 800e43a <_ZN4rtps11PBufWrapper6appendEPKht+0x2c>
        return false;
    }

    m_freeSpace -= length;
 800e42c:	88a2      	ldrh	r2, [r4, #4]
 800e42e:	1b52      	subs	r2, r2, r5
 800e430:	80a2      	strh	r2, [r4, #4]
    return true;
 800e432:	2001      	movs	r0, #1
}
 800e434:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return false;
 800e436:	2000      	movs	r0, #0
}
 800e438:	4770      	bx	lr
        return false;
 800e43a:	2000      	movs	r0, #0
 800e43c:	e7fa      	b.n	800e434 <_ZN4rtps11PBufWrapper6appendEPKht+0x26>

0800e43e <_ZN4rtps11PBufWrapper6appendEOS0_>:

void PBufWrapper::append(PBufWrapper&& other){
    if(this == &other){
 800e43e:	4288      	cmp	r0, r1
 800e440:	d00f      	beq.n	800e462 <_ZN4rtps11PBufWrapper6appendEOS0_+0x24>
void PBufWrapper::append(PBufWrapper&& other){
 800e442:	b510      	push	{r4, lr}
 800e444:	460c      	mov	r4, r1
        return;
    }
    if(this->firstElement == nullptr){
 800e446:	6803      	ldr	r3, [r0, #0]
 800e448:	b143      	cbz	r3, 800e45c <_ZN4rtps11PBufWrapper6appendEOS0_+0x1e>
        *this = std::move(other);
        return;
    }

    m_freeSpace = other.m_freeSpace;
 800e44a:	888a      	ldrh	r2, [r1, #4]
 800e44c:	8082      	strh	r2, [r0, #4]
    pbuf* const newElement = other.firstElement;
    pbuf_cat(this->firstElement, newElement);
 800e44e:	6809      	ldr	r1, [r1, #0]
 800e450:	4618      	mov	r0, r3
 800e452:	f7f8 fa11 	bl	8006878 <pbuf_cat>

    other.firstElement = nullptr;
 800e456:	2300      	movs	r3, #0
 800e458:	6023      	str	r3, [r4, #0]

}
 800e45a:	bd10      	pop	{r4, pc}
        *this = std::move(other);
 800e45c:	f7ff ffb5 	bl	800e3ca <_ZN4rtps11PBufWrapperaSEOS0_>
        return;
 800e460:	e7fb      	b.n	800e45a <_ZN4rtps11PBufWrapper6appendEOS0_+0x1c>
 800e462:	4770      	bx	lr

0800e464 <_ZN4rtps11PBufWrapper14increaseSizeByEt>:
    if(firstElement != nullptr){
        m_freeSpace = firstElement->tot_len;
    }
}

bool PBufWrapper::increaseSizeBy(uint16_t length){
 800e464:	b538      	push	{r3, r4, r5, lr}
 800e466:	4604      	mov	r4, r0
 800e468:	460d      	mov	r5, r1
    pbuf* allocation = pbuf_alloc(m_layer, length, m_type);
 800e46a:	2203      	movs	r2, #3
 800e46c:	2000      	movs	r0, #0
 800e46e:	f7f8 f87f 	bl	8006570 <pbuf_alloc>
    if(allocation == nullptr){
 800e472:	b160      	cbz	r0, 800e48e <_ZN4rtps11PBufWrapper14increaseSizeByEt+0x2a>
 800e474:	4601      	mov	r1, r0
        return false;
    }

    m_freeSpace += length;
 800e476:	88a3      	ldrh	r3, [r4, #4]
 800e478:	441d      	add	r5, r3
 800e47a:	80a5      	strh	r5, [r4, #4]

    if(firstElement == nullptr){
 800e47c:	6820      	ldr	r0, [r4, #0]
 800e47e:	b118      	cbz	r0, 800e488 <_ZN4rtps11PBufWrapper14increaseSizeByEt+0x24>
        firstElement = allocation;
    }else{
        pbuf_cat(firstElement, allocation);
 800e480:	f7f8 f9fa 	bl	8006878 <pbuf_cat>
    }

    return true;
 800e484:	2001      	movs	r0, #1
}
 800e486:	bd38      	pop	{r3, r4, r5, pc}
        firstElement = allocation;
 800e488:	6021      	str	r1, [r4, #0]
    return true;
 800e48a:	2001      	movs	r0, #1
 800e48c:	e7fb      	b.n	800e486 <_ZN4rtps11PBufWrapper14increaseSizeByEt+0x22>
        return false;
 800e48e:	2000      	movs	r0, #0
 800e490:	e7f9      	b.n	800e486 <_ZN4rtps11PBufWrapper14increaseSizeByEt+0x22>

0800e492 <_ZN4rtps11PBufWrapper7reserveEt>:
bool PBufWrapper::reserve(DataSize_t length) {
 800e492:	b508      	push	{r3, lr}
    auto additionalAllocation = length - m_freeSpace;
 800e494:	8883      	ldrh	r3, [r0, #4]
 800e496:	1aca      	subs	r2, r1, r3
    if(additionalAllocation <= 0){
 800e498:	2a00      	cmp	r2, #0
 800e49a:	dd03      	ble.n	800e4a4 <_ZN4rtps11PBufWrapper7reserveEt+0x12>
    return increaseSizeBy(additionalAllocation);
 800e49c:	b291      	uxth	r1, r2
 800e49e:	f7ff ffe1 	bl	800e464 <_ZN4rtps11PBufWrapper14increaseSizeByEt>
}
 800e4a2:	bd08      	pop	{r3, pc}
        return true;
 800e4a4:	2001      	movs	r0, #1
 800e4a6:	e7fc      	b.n	800e4a2 <_ZN4rtps11PBufWrapper7reserveEt+0x10>

0800e4a8 <_ZNK4rtps18SimpleHistoryCache6isFullEv>:
SimpleHistoryCache::SimpleHistoryCache(SequenceNumber_t lastUsed) : SimpleHistoryCache(){
    m_lastUsedSequenceNumber = lastUsed;
}

bool SimpleHistoryCache::isFull() const{
    uint16_t it = m_head;
 800e4a8:	f8b0 30dc 	ldrh.w	r3, [r0, #220]	; 0xdc
        incrementIterator(m_tail);
    }
}

void SimpleHistoryCache::incrementIterator(uint16_t& iterator) const{
    ++iterator;
 800e4ac:	3301      	adds	r3, #1
 800e4ae:	b29b      	uxth	r3, r3
    if(iterator >= m_buffer.size()){
 800e4b0:	2b0a      	cmp	r3, #10
 800e4b2:	d900      	bls.n	800e4b6 <_ZNK4rtps18SimpleHistoryCache6isFullEv+0xe>
        iterator = 0;
 800e4b4:	2300      	movs	r3, #0
    return it == m_tail;
 800e4b6:	f8b0 00de 	ldrh.w	r0, [r0, #222]	; 0xde
}
 800e4ba:	4298      	cmp	r0, r3
 800e4bc:	bf14      	ite	ne
 800e4be:	2000      	movne	r0, #0
 800e4c0:	2001      	moveq	r0, #1
 800e4c2:	4770      	bx	lr

0800e4c4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv>:
    if(m_head == m_tail){
 800e4c4:	f8b0 20dc 	ldrh.w	r2, [r0, #220]	; 0xdc
 800e4c8:	f8b0 30de 	ldrh.w	r3, [r0, #222]	; 0xde
 800e4cc:	429a      	cmp	r2, r3
 800e4ce:	d005      	beq.n	800e4dc <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv+0x18>
        return m_buffer[m_tail].sequenceNumber;
 800e4d0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800e4d4:	009a      	lsls	r2, r3, #2
 800e4d6:	4410      	add	r0, r2
 800e4d8:	3004      	adds	r0, #4
 800e4da:	4770      	bx	lr
        return SEQUENCENUMBER_UNKNOWN;
 800e4dc:	4800      	ldr	r0, [pc, #0]	; (800e4e0 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv+0x1c>)
}
 800e4de:	4770      	bx	lr
 800e4e0:	08010990 	.word	0x08010990

0800e4e4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMaxEv>:
    if(m_head == m_tail){
 800e4e4:	f8b0 20dc 	ldrh.w	r2, [r0, #220]	; 0xdc
 800e4e8:	f8b0 30de 	ldrh.w	r3, [r0, #222]	; 0xde
 800e4ec:	429a      	cmp	r2, r3
 800e4ee:	d001      	beq.n	800e4f4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMaxEv+0x10>
        return m_lastUsedSequenceNumber;
 800e4f0:	30e0      	adds	r0, #224	; 0xe0
 800e4f2:	4770      	bx	lr
        return SEQUENCENUMBER_UNKNOWN;
 800e4f4:	4800      	ldr	r0, [pc, #0]	; (800e4f8 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMaxEv+0x14>)
}
 800e4f6:	4770      	bx	lr
 800e4f8:	08010990 	.word	0x08010990

0800e4fc <_ZN4rtps18SimpleHistoryCache9addChangeEPKht>:
const rtps::CacheChange* SimpleHistoryCache::addChange(const uint8_t* data, DataSize_t size){
 800e4fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e4fe:	b087      	sub	sp, #28
 800e500:	4604      	mov	r4, r0
 800e502:	460e      	mov	r6, r1
 800e504:	4615      	mov	r5, r2
 800e506:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800e50a:	9302      	str	r3, [sp, #8]
 800e50c:	2300      	movs	r3, #0
 800e50e:	9303      	str	r3, [sp, #12]
 800e510:	9304      	str	r3, [sp, #16]
 800e512:	f8ad 3014 	strh.w	r3, [sp, #20]
    change.kind = ChangeKind_t::ALIVE;
 800e516:	2301      	movs	r3, #1
 800e518:	f88d 3004 	strb.w	r3, [sp, #4]
    change.data.reserve(size);
 800e51c:	4611      	mov	r1, r2
 800e51e:	a804      	add	r0, sp, #16
 800e520:	f7ff ffb7 	bl	800e492 <_ZN4rtps11PBufWrapper7reserveEt>
    change.data.append(data, size);
 800e524:	462a      	mov	r2, r5
 800e526:	4631      	mov	r1, r6
 800e528:	a804      	add	r0, sp, #16
 800e52a:	f7ff ff70 	bl	800e40e <_ZN4rtps11PBufWrapper6appendEPKht>
            ++low;
 800e52e:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 800e532:	3301      	adds	r3, #1
 800e534:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
            if(low == 0){
 800e538:	b923      	cbnz	r3, 800e544 <_ZN4rtps18SimpleHistoryCache9addChangeEPKht+0x48>
                ++high;
 800e53a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800e53e:	3301      	adds	r3, #1
 800e540:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
    change.sequenceNumber = ++m_lastUsedSequenceNumber;
 800e544:	ab02      	add	r3, sp, #8
 800e546:	f104 02e0 	add.w	r2, r4, #224	; 0xe0
 800e54a:	e892 0003 	ldmia.w	r2, {r0, r1}
 800e54e:	e883 0003 	stmia.w	r3, {r0, r1}
    CacheChange* place = &m_buffer[m_head];
 800e552:	f8b4 30dc 	ldrh.w	r3, [r4, #220]	; 0xdc
      { return const_cast<_Tp&>(__t[__n]); }
 800e556:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800e55a:	0095      	lsls	r5, r2, #2
 800e55c:	4425      	add	r5, r4
    ++iterator;
 800e55e:	1c5a      	adds	r2, r3, #1
 800e560:	b292      	uxth	r2, r2
 800e562:	f8a4 20dc 	strh.w	r2, [r4, #220]	; 0xdc
    if(iterator >= m_buffer.size()){
 800e566:	2a0a      	cmp	r2, #10
 800e568:	d902      	bls.n	800e570 <_ZN4rtps18SimpleHistoryCache9addChangeEPKht+0x74>
        iterator = 0;
 800e56a:	2200      	movs	r2, #0
 800e56c:	f8a4 20dc 	strh.w	r2, [r4, #220]	; 0xdc
    if(m_head == m_tail){
 800e570:	f8b4 10dc 	ldrh.w	r1, [r4, #220]	; 0xdc
 800e574:	f8b4 20de 	ldrh.w	r2, [r4, #222]	; 0xde
 800e578:	4291      	cmp	r1, r2
 800e57a:	d019      	beq.n	800e5b0 <_ZN4rtps18SimpleHistoryCache9addChangeEPKht+0xb4>
    struct CacheChange{
 800e57c:	f89d 7004 	ldrb.w	r7, [sp, #4]
 800e580:	009a      	lsls	r2, r3, #2
 800e582:	18d0      	adds	r0, r2, r3
 800e584:	0081      	lsls	r1, r0, #2
 800e586:	1866      	adds	r6, r4, r1
 800e588:	5467      	strb	r7, [r4, r1]
 800e58a:	3604      	adds	r6, #4
 800e58c:	a902      	add	r1, sp, #8
 800e58e:	c903      	ldmia	r1, {r0, r1}
 800e590:	e886 0003 	stmia.w	r6, {r0, r1}
 800e594:	4413      	add	r3, r2
 800e596:	0098      	lsls	r0, r3, #2
 800e598:	3008      	adds	r0, #8
 800e59a:	4420      	add	r0, r4
 800e59c:	a904      	add	r1, sp, #16
 800e59e:	3004      	adds	r0, #4
 800e5a0:	f7ff ff13 	bl	800e3ca <_ZN4rtps11PBufWrapperaSEOS0_>
 800e5a4:	a804      	add	r0, sp, #16
 800e5a6:	f7ff ff1c 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
}
 800e5aa:	4628      	mov	r0, r5
 800e5ac:	b007      	add	sp, #28
 800e5ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ++iterator;
 800e5b0:	3201      	adds	r2, #1
 800e5b2:	b292      	uxth	r2, r2
 800e5b4:	f8a4 20de 	strh.w	r2, [r4, #222]	; 0xde
    if(iterator >= m_buffer.size()){
 800e5b8:	2a0a      	cmp	r2, #10
 800e5ba:	d9df      	bls.n	800e57c <_ZN4rtps18SimpleHistoryCache9addChangeEPKht+0x80>
        iterator = 0;
 800e5bc:	2200      	movs	r2, #0
 800e5be:	f8a4 20de 	strh.w	r2, [r4, #222]	; 0xde
 800e5c2:	e7db      	b.n	800e57c <_ZN4rtps18SimpleHistoryCache9addChangeEPKht+0x80>
 800e5c4:	a804      	add	r0, sp, #16
 800e5c6:	f7ff ff0c 	bl	800e3e2 <_ZN4rtps11PBufWrapperD1Ev>
 800e5ca:	f000 fa06 	bl	800e9da <__cxa_end_cleanup>

0800e5ce <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE>:
const rtps::CacheChange* SimpleHistoryCache::getChangeBySN(SequenceNumber_t sn) const{
 800e5ce:	b530      	push	{r4, r5, lr}
 800e5d0:	b085      	sub	sp, #20
 800e5d2:	4604      	mov	r4, r0
 800e5d4:	466b      	mov	r3, sp
 800e5d6:	e883 0006 	stmia.w	r3, {r1, r2}
    SequenceNumber_t minSN = getSeqNumMin();
 800e5da:	f7ff ff73 	bl	800e4c4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMinEv>
 800e5de:	c803      	ldmia	r0, {r0, r1}
 800e5e0:	ab04      	add	r3, sp, #16
 800e5e2:	e903 0003 	stmdb	r3, {r0, r1}
            return high < other.high || (high == other.high && low < other.low);
 800e5e6:	9d00      	ldr	r5, [sp, #0]
 800e5e8:	9b02      	ldr	r3, [sp, #8]
 800e5ea:	42ab      	cmp	r3, r5
 800e5ec:	dc25      	bgt.n	800e63a <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x6c>
 800e5ee:	d018      	beq.n	800e622 <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x54>
    if(sn < minSN || getSeqNumMax() < sn){
 800e5f0:	4620      	mov	r0, r4
 800e5f2:	f7ff ff77 	bl	800e4e4 <_ZNK4rtps18SimpleHistoryCache12getSeqNumMaxEv>
 800e5f6:	6803      	ldr	r3, [r0, #0]
 800e5f8:	42ab      	cmp	r3, r5
 800e5fa:	db20      	blt.n	800e63e <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x70>
 800e5fc:	d017      	beq.n	800e62e <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x60>
    uint16_t pos = m_tail + static_cast<uint16_t>(sn.low - minSN.low);
 800e5fe:	f8b4 10de 	ldrh.w	r1, [r4, #222]	; 0xde
 800e602:	9a01      	ldr	r2, [sp, #4]
 800e604:	9b03      	ldr	r3, [sp, #12]
 800e606:	1ad3      	subs	r3, r2, r3
 800e608:	fa11 f383 	uxtah	r3, r1, r3
 800e60c:	b29b      	uxth	r3, r3
    if(pos >= m_buffer.size()){
 800e60e:	2b0a      	cmp	r3, #10
 800e610:	d901      	bls.n	800e616 <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x48>
        pos -= m_buffer.size();
 800e612:	3b0b      	subs	r3, #11
 800e614:	b29b      	uxth	r3, r3
 800e616:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800e61a:	0098      	lsls	r0, r3, #2
 800e61c:	4420      	add	r0, r4
}
 800e61e:	b005      	add	sp, #20
 800e620:	bd30      	pop	{r4, r5, pc}
 800e622:	9a03      	ldr	r2, [sp, #12]
 800e624:	9b01      	ldr	r3, [sp, #4]
 800e626:	429a      	cmp	r2, r3
 800e628:	d9e2      	bls.n	800e5f0 <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x22>
        return nullptr;
 800e62a:	2000      	movs	r0, #0
 800e62c:	e7f7      	b.n	800e61e <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x50>
 800e62e:	6842      	ldr	r2, [r0, #4]
 800e630:	9b01      	ldr	r3, [sp, #4]
 800e632:	429a      	cmp	r2, r3
 800e634:	d2e3      	bcs.n	800e5fe <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x30>
 800e636:	2000      	movs	r0, #0
 800e638:	e7f1      	b.n	800e61e <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x50>
 800e63a:	2000      	movs	r0, #0
 800e63c:	e7ef      	b.n	800e61e <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x50>
 800e63e:	2000      	movs	r0, #0
 800e640:	e7ed      	b.n	800e61e <_ZNK4rtps18SimpleHistoryCache13getChangeBySNENS_16SequenceNumber_tE+0x50>

0800e642 <ucdr_check_buffer>:
// -------------------------------------------------------------------
//                   INTERNAL UTIL IMPLEMENTATIONS
// -------------------------------------------------------------------
bool ucdr_check_buffer(ucdrBuffer* mb, const uint32_t bytes)
{
    if(!mb->error)
 800e642:	7d02      	ldrb	r2, [r0, #20]
 800e644:	b932      	cbnz	r2, 800e654 <ucdr_check_buffer+0x12>
    {
        bool fit = mb->iterator + bytes <= mb->final;
 800e646:	6883      	ldr	r3, [r0, #8]
 800e648:	440b      	add	r3, r1
 800e64a:	6842      	ldr	r2, [r0, #4]
        if(!fit)
 800e64c:	4293      	cmp	r3, r2
 800e64e:	d901      	bls.n	800e654 <ucdr_check_buffer+0x12>
        {
            mb->error = true;
 800e650:	2301      	movs	r3, #1
 800e652:	7503      	strb	r3, [r0, #20]
        }
    }

    return !mb->error;
 800e654:	7d00      	ldrb	r0, [r0, #20]
}
 800e656:	f080 0001 	eor.w	r0, r0, #1
 800e65a:	4770      	bx	lr

0800e65c <ucdr_init_buffer_offset_endian>:
    ucdr_init_buffer_offset_endian(mb, data, size, offset, UCDR_MACHINE_ENDIANNESS);
}

void ucdr_init_buffer_offset_endian(ucdrBuffer* mb, const uint8_t* data, const uint32_t size, uint32_t offset, ucdrEndianness endianness)
{
    mb->init = data;
 800e65c:	6001      	str	r1, [r0, #0]
    mb->final = mb->init + size;
 800e65e:	440a      	add	r2, r1
 800e660:	6042      	str	r2, [r0, #4]
    mb->iterator = (uint8_t*)mb->init + offset;
 800e662:	440b      	add	r3, r1
 800e664:	6083      	str	r3, [r0, #8]
    mb->last_data_size = 0U;
 800e666:	2300      	movs	r3, #0
 800e668:	6103      	str	r3, [r0, #16]
    mb->endianness = endianness;
 800e66a:	f89d 2000 	ldrb.w	r2, [sp]
 800e66e:	7302      	strb	r2, [r0, #12]
    mb->error = false;
 800e670:	7503      	strb	r3, [r0, #20]
}
 800e672:	4770      	bx	lr

0800e674 <ucdr_init_buffer_offset>:
{
 800e674:	b510      	push	{r4, lr}
 800e676:	b082      	sub	sp, #8
    ucdr_init_buffer_offset_endian(mb, data, size, offset, UCDR_MACHINE_ENDIANNESS);
 800e678:	2401      	movs	r4, #1
 800e67a:	9400      	str	r4, [sp, #0]
 800e67c:	f7ff ffee 	bl	800e65c <ucdr_init_buffer_offset_endian>
}
 800e680:	b002      	add	sp, #8
 800e682:	bd10      	pop	{r4, pc}

0800e684 <ucdr_init_buffer>:
{
 800e684:	b508      	push	{r3, lr}
    ucdr_init_buffer_offset(mb, data, size, 0U);
 800e686:	2300      	movs	r3, #0
 800e688:	f7ff fff4 	bl	800e674 <ucdr_init_buffer_offset>
}
 800e68c:	bd08      	pop	{r3, pc}

0800e68e <ucdr_buffer_alignment>:
    return ((data_size - (current_alignment % data_size)) & (data_size - 1));
}

uint32_t ucdr_buffer_alignment(const ucdrBuffer* mb, const uint32_t data_size)
{
    if(data_size > mb->last_data_size)
 800e68e:	6903      	ldr	r3, [r0, #16]
 800e690:	428b      	cmp	r3, r1
 800e692:	d20a      	bcs.n	800e6aa <ucdr_buffer_alignment+0x1c>
    {
        return (data_size - ((uint32_t)(mb->iterator - mb->init) % data_size)) & (data_size - 1);
 800e694:	6883      	ldr	r3, [r0, #8]
 800e696:	6800      	ldr	r0, [r0, #0]
 800e698:	1a1b      	subs	r3, r3, r0
 800e69a:	fbb3 f0f1 	udiv	r0, r3, r1
 800e69e:	fb01 3010 	mls	r0, r1, r0, r3
 800e6a2:	1a08      	subs	r0, r1, r0
 800e6a4:	3901      	subs	r1, #1
 800e6a6:	4008      	ands	r0, r1
 800e6a8:	4770      	bx	lr
    }

    return 0;
 800e6aa:	2000      	movs	r0, #0
}
 800e6ac:	4770      	bx	lr

0800e6ae <ucdr_align_to>:
{
 800e6ae:	b538      	push	{r3, r4, r5, lr}
 800e6b0:	4604      	mov	r4, r0
 800e6b2:	460d      	mov	r5, r1
    uint32_t offset = ucdr_buffer_alignment(mb, size);
 800e6b4:	f7ff ffeb 	bl	800e68e <ucdr_buffer_alignment>
    mb->iterator += offset;
 800e6b8:	68a3      	ldr	r3, [r4, #8]
 800e6ba:	4418      	add	r0, r3
 800e6bc:	60a0      	str	r0, [r4, #8]
    if(mb->iterator > mb->final)
 800e6be:	6863      	ldr	r3, [r4, #4]
 800e6c0:	4298      	cmp	r0, r3
 800e6c2:	d900      	bls.n	800e6c6 <ucdr_align_to+0x18>
        mb->iterator = (uint8_t*)mb->final;
 800e6c4:	60a3      	str	r3, [r4, #8]
    mb->last_data_size = size;
 800e6c6:	6125      	str	r5, [r4, #16]
}
 800e6c8:	bd38      	pop	{r3, r4, r5, pc}

0800e6ca <ucdr_buffer_length>:
    return (size_t)(mb->final - mb->init);
}

size_t ucdr_buffer_length(const ucdrBuffer* mb)
{
    return (size_t)(mb->iterator - mb->init);
 800e6ca:	6882      	ldr	r2, [r0, #8]
 800e6cc:	6800      	ldr	r0, [r0, #0]
}
 800e6ce:	1a10      	subs	r0, r2, r0
 800e6d0:	4770      	bx	lr

0800e6d2 <ucdr_buffer_remaining>:

size_t ucdr_buffer_remaining(const ucdrBuffer* mb)
{
    return (size_t)(mb->final - mb->iterator);
 800e6d2:	6842      	ldr	r2, [r0, #4]
 800e6d4:	6880      	ldr	r0, [r0, #8]
}
 800e6d6:	1a10      	subs	r0, r2, r0
 800e6d8:	4770      	bx	lr

0800e6da <ucdr_serialize_array_byte_1>:
// -------------------------------------------------------------------
//                INTERNAL SERIALIZATION IMPLEMENTATION
// -------------------------------------------------------------------

bool ucdr_serialize_array_byte_1(ucdrBuffer* mb, const uint8_t* array, const uint32_t size)
{
 800e6da:	b570      	push	{r4, r5, r6, lr}
 800e6dc:	4604      	mov	r4, r0
 800e6de:	460e      	mov	r6, r1
 800e6e0:	4615      	mov	r5, r2
    uint32_t data_size = sizeof(uint8_t);
    if(ucdr_check_buffer(mb, size))
 800e6e2:	4611      	mov	r1, r2
 800e6e4:	f7ff ffad 	bl	800e642 <ucdr_check_buffer>
 800e6e8:	b918      	cbnz	r0, 800e6f2 <ucdr_serialize_array_byte_1+0x18>
        memcpy(mb->iterator, array, size);

        mb->iterator += size;
        mb->last_data_size = data_size;
    }
    return !mb->error;
 800e6ea:	7d20      	ldrb	r0, [r4, #20]
}
 800e6ec:	f080 0001 	eor.w	r0, r0, #1
 800e6f0:	bd70      	pop	{r4, r5, r6, pc}
        memcpy(mb->iterator, array, size);
 800e6f2:	462a      	mov	r2, r5
 800e6f4:	4631      	mov	r1, r6
 800e6f6:	68a0      	ldr	r0, [r4, #8]
 800e6f8:	f000 fec5 	bl	800f486 <memcpy>
        mb->iterator += size;
 800e6fc:	68a3      	ldr	r3, [r4, #8]
 800e6fe:	441d      	add	r5, r3
 800e700:	60a5      	str	r5, [r4, #8]
        mb->last_data_size = data_size;
 800e702:	2301      	movs	r3, #1
 800e704:	6123      	str	r3, [r4, #16]
 800e706:	e7f0      	b.n	800e6ea <ucdr_serialize_array_byte_1+0x10>

0800e708 <ucdr_deserialize_array_byte_1>:
    }
    return !mb->error;
}

bool ucdr_deserialize_array_byte_1(ucdrBuffer* mb, uint8_t* array, const uint32_t size)
{
 800e708:	b570      	push	{r4, r5, r6, lr}
 800e70a:	4604      	mov	r4, r0
 800e70c:	460e      	mov	r6, r1
 800e70e:	4615      	mov	r5, r2
    uint32_t data_size = sizeof(uint8_t);
    if(ucdr_check_buffer(mb, size))
 800e710:	4611      	mov	r1, r2
 800e712:	f7ff ff96 	bl	800e642 <ucdr_check_buffer>
 800e716:	b918      	cbnz	r0, 800e720 <ucdr_deserialize_array_byte_1+0x18>
        memcpy(array, mb->iterator, size);

        mb->iterator += size;
        mb->last_data_size = data_size;
    }
    return !mb->error;
 800e718:	7d20      	ldrb	r0, [r4, #20]
}
 800e71a:	f080 0001 	eor.w	r0, r0, #1
 800e71e:	bd70      	pop	{r4, r5, r6, pc}
        memcpy(array, mb->iterator, size);
 800e720:	462a      	mov	r2, r5
 800e722:	68a1      	ldr	r1, [r4, #8]
 800e724:	4630      	mov	r0, r6
 800e726:	f000 feae 	bl	800f486 <memcpy>
        mb->iterator += size;
 800e72a:	68a3      	ldr	r3, [r4, #8]
 800e72c:	441d      	add	r5, r3
 800e72e:	60a5      	str	r5, [r4, #8]
        mb->last_data_size = data_size;
 800e730:	2301      	movs	r3, #1
 800e732:	6123      	str	r3, [r4, #16]
 800e734:	e7f0      	b.n	800e718 <ucdr_deserialize_array_byte_1+0x10>

0800e736 <ucdr_serialize_array_char>:
// -------------------------------------------------------------------
//              PUBLIC SERIALIZATION IMPLEMENTATIONS
// -------------------------------------------------------------------

bool ucdr_serialize_array_char(ucdrBuffer* mb, const char* array, const uint32_t size)
{
 800e736:	b508      	push	{r3, lr}
    return ucdr_serialize_array_byte_1(mb, (uint8_t*)array, size);
 800e738:	f7ff ffcf 	bl	800e6da <ucdr_serialize_array_byte_1>
}
 800e73c:	bd08      	pop	{r3, pc}

0800e73e <ucdr_serialize_array_uint8_t>:
{
    return ucdr_serialize_array_byte_1(mb, (uint8_t*)array, size);
}

bool ucdr_serialize_array_uint8_t(ucdrBuffer* mb, const uint8_t* array, const uint32_t size)
{
 800e73e:	b508      	push	{r3, lr}
    return ucdr_serialize_array_byte_1(mb, array, size);
 800e740:	f7ff ffcb 	bl	800e6da <ucdr_serialize_array_byte_1>
}
 800e744:	bd08      	pop	{r3, pc}

0800e746 <ucdr_deserialize_array_char>:
{
    return ucdr_serialize_array_byte_8(mb, mb->endianness, (uint64_t*)array, size);
}

bool ucdr_deserialize_array_char(ucdrBuffer* mb, char* array, const uint32_t size)
{
 800e746:	b508      	push	{r3, lr}
    return ucdr_deserialize_array_byte_1(mb, (uint8_t*)array, size);
 800e748:	f7ff ffde 	bl	800e708 <ucdr_deserialize_array_byte_1>
}
 800e74c:	bd08      	pop	{r3, pc}

0800e74e <ucdr_deserialize_array_uint8_t>:
{
    return ucdr_deserialize_array_byte_1(mb, (uint8_t*)array, size);
}

bool ucdr_deserialize_array_uint8_t(ucdrBuffer* mb, uint8_t* array, const uint32_t size)
{
 800e74e:	b508      	push	{r3, lr}
    return ucdr_deserialize_array_byte_1(mb, array, size);
 800e750:	f7ff ffda 	bl	800e708 <ucdr_deserialize_array_byte_1>
}
 800e754:	bd08      	pop	{r3, pc}

0800e756 <ucdr_serialize_byte_1>:
// -------------------------------------------------------------------
//                INTERNAL SERIALIZATION IMPLEMENTATION
// -------------------------------------------------------------------

bool ucdr_serialize_byte_1(ucdrBuffer* mb, const uint8_t* byte)
{
 800e756:	b538      	push	{r3, r4, r5, lr}
 800e758:	4604      	mov	r4, r0
 800e75a:	460d      	mov	r5, r1
    uint32_t data_size = sizeof(uint8_t);
    if(ucdr_check_buffer(mb, data_size))
 800e75c:	2101      	movs	r1, #1
 800e75e:	f7ff ff70 	bl	800e642 <ucdr_check_buffer>
 800e762:	b138      	cbz	r0, 800e774 <ucdr_serialize_byte_1+0x1e>
    {
        *mb->iterator = *byte;
 800e764:	68a3      	ldr	r3, [r4, #8]
 800e766:	782a      	ldrb	r2, [r5, #0]
 800e768:	701a      	strb	r2, [r3, #0]

        mb->iterator += data_size;
 800e76a:	68a3      	ldr	r3, [r4, #8]
 800e76c:	3301      	adds	r3, #1
 800e76e:	60a3      	str	r3, [r4, #8]
        mb->last_data_size = data_size;
 800e770:	2301      	movs	r3, #1
 800e772:	6123      	str	r3, [r4, #16]
    }
    return !mb->error;
 800e774:	7d20      	ldrb	r0, [r4, #20]
}
 800e776:	f080 0001 	eor.w	r0, r0, #1
 800e77a:	bd38      	pop	{r3, r4, r5, pc}

0800e77c <ucdr_serialize_byte_2>:

bool ucdr_serialize_byte_2(ucdrBuffer* mb, const ucdrEndianness endianness, const uint16_t* bytes)
{
 800e77c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e77e:	4604      	mov	r4, r0
 800e780:	460f      	mov	r7, r1
 800e782:	4616      	mov	r6, r2
    uint32_t data_size = sizeof(uint16_t);
    uint32_t alignment = ucdr_buffer_alignment(mb, data_size);
 800e784:	2102      	movs	r1, #2
 800e786:	f7ff ff82 	bl	800e68e <ucdr_buffer_alignment>
 800e78a:	4605      	mov	r5, r0

    if(ucdr_check_buffer(mb, alignment + data_size))
 800e78c:	1c81      	adds	r1, r0, #2
 800e78e:	4620      	mov	r0, r4
 800e790:	f7ff ff57 	bl	800e642 <ucdr_check_buffer>
 800e794:	b180      	cbz	r0, 800e7b8 <ucdr_serialize_byte_2+0x3c>
    {
        mb->iterator += alignment;
 800e796:	68a3      	ldr	r3, [r4, #8]
 800e798:	195a      	adds	r2, r3, r5
 800e79a:	60a2      	str	r2, [r4, #8]

        if(UCDR_MACHINE_ENDIANNESS == endianness)
 800e79c:	4a0a      	ldr	r2, [pc, #40]	; (800e7c8 <ucdr_serialize_byte_2+0x4c>)
 800e79e:	7812      	ldrb	r2, [r2, #0]
 800e7a0:	42ba      	cmp	r2, r7
 800e7a2:	d00d      	beq.n	800e7c0 <ucdr_serialize_byte_2+0x44>
            memcpy(mb->iterator, bytes, data_size);
        }
        else
        {
            uint8_t* bytes_pointer = (uint8_t*)bytes;
            *mb->iterator = *(bytes_pointer + 1);
 800e7a4:	7872      	ldrb	r2, [r6, #1]
 800e7a6:	555a      	strb	r2, [r3, r5]
            *(mb->iterator + 1) = *bytes_pointer;
 800e7a8:	68a3      	ldr	r3, [r4, #8]
 800e7aa:	7832      	ldrb	r2, [r6, #0]
 800e7ac:	705a      	strb	r2, [r3, #1]
        }

        mb->iterator += data_size;
 800e7ae:	68a3      	ldr	r3, [r4, #8]
 800e7b0:	3302      	adds	r3, #2
 800e7b2:	60a3      	str	r3, [r4, #8]
        mb->last_data_size = data_size;
 800e7b4:	2302      	movs	r3, #2
 800e7b6:	6123      	str	r3, [r4, #16]
    }
    return !mb->error;
 800e7b8:	7d20      	ldrb	r0, [r4, #20]
}
 800e7ba:	f080 0001 	eor.w	r0, r0, #1
 800e7be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e7c0:	8832      	ldrh	r2, [r6, #0]
            memcpy(mb->iterator, bytes, data_size);
 800e7c2:	535a      	strh	r2, [r3, r5]
 800e7c4:	e7f3      	b.n	800e7ae <ucdr_serialize_byte_2+0x32>
 800e7c6:	bf00      	nop
 800e7c8:	08010998 	.word	0x08010998

0800e7cc <ucdr_serialize_byte_4>:

bool ucdr_serialize_byte_4(ucdrBuffer* mb, const ucdrEndianness endianness, const uint32_t* bytes)
{
 800e7cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e7ce:	4604      	mov	r4, r0
 800e7d0:	460f      	mov	r7, r1
 800e7d2:	4616      	mov	r6, r2
    uint32_t data_size = sizeof(uint32_t);
    uint32_t alignment = ucdr_buffer_alignment(mb, data_size);
 800e7d4:	2104      	movs	r1, #4
 800e7d6:	f7ff ff5a 	bl	800e68e <ucdr_buffer_alignment>
 800e7da:	4605      	mov	r5, r0

    if(ucdr_check_buffer(mb, alignment + data_size))
 800e7dc:	1d01      	adds	r1, r0, #4
 800e7de:	4620      	mov	r0, r4
 800e7e0:	f7ff ff2f 	bl	800e642 <ucdr_check_buffer>
 800e7e4:	b1b0      	cbz	r0, 800e814 <ucdr_serialize_byte_4+0x48>
    {
        mb->iterator += alignment;
 800e7e6:	68a3      	ldr	r3, [r4, #8]
 800e7e8:	195a      	adds	r2, r3, r5
 800e7ea:	60a2      	str	r2, [r4, #8]

        if(UCDR_MACHINE_ENDIANNESS == endianness)
 800e7ec:	4a0d      	ldr	r2, [pc, #52]	; (800e824 <ucdr_serialize_byte_4+0x58>)
 800e7ee:	7812      	ldrb	r2, [r2, #0]
 800e7f0:	42ba      	cmp	r2, r7
 800e7f2:	d013      	beq.n	800e81c <ucdr_serialize_byte_4+0x50>
            memcpy(mb->iterator, bytes, data_size);
        }
        else
        {
            uint8_t* bytes_pointer = (uint8_t*)bytes;
            *mb->iterator = *(bytes_pointer + 3);
 800e7f4:	78f2      	ldrb	r2, [r6, #3]
 800e7f6:	555a      	strb	r2, [r3, r5]
            *(mb->iterator + 1) = *(bytes_pointer + 2);
 800e7f8:	68a3      	ldr	r3, [r4, #8]
 800e7fa:	78b2      	ldrb	r2, [r6, #2]
 800e7fc:	705a      	strb	r2, [r3, #1]
            *(mb->iterator + 2) = *(bytes_pointer + 1);
 800e7fe:	68a3      	ldr	r3, [r4, #8]
 800e800:	7872      	ldrb	r2, [r6, #1]
 800e802:	709a      	strb	r2, [r3, #2]
            *(mb->iterator + 3) = *bytes_pointer;
 800e804:	68a3      	ldr	r3, [r4, #8]
 800e806:	7832      	ldrb	r2, [r6, #0]
 800e808:	70da      	strb	r2, [r3, #3]
        }

        mb->iterator += data_size;
 800e80a:	68a3      	ldr	r3, [r4, #8]
 800e80c:	3304      	adds	r3, #4
 800e80e:	60a3      	str	r3, [r4, #8]
        mb->last_data_size = data_size;
 800e810:	2304      	movs	r3, #4
 800e812:	6123      	str	r3, [r4, #16]
    }
    return !mb->error;
 800e814:	7d20      	ldrb	r0, [r4, #20]
}
 800e816:	f080 0001 	eor.w	r0, r0, #1
 800e81a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e81c:	6832      	ldr	r2, [r6, #0]
            memcpy(mb->iterator, bytes, data_size);
 800e81e:	515a      	str	r2, [r3, r5]
 800e820:	e7f3      	b.n	800e80a <ucdr_serialize_byte_4+0x3e>
 800e822:	bf00      	nop
 800e824:	08010998 	.word	0x08010998

0800e828 <ucdr_deserialize_byte_1>:
    }
    return !mb->error;
}

bool ucdr_deserialize_byte_1(ucdrBuffer* mb, uint8_t* byte)
{
 800e828:	b538      	push	{r3, r4, r5, lr}
 800e82a:	4604      	mov	r4, r0
 800e82c:	460d      	mov	r5, r1
    uint32_t data_size = sizeof(uint8_t);
    if(ucdr_check_buffer(mb, data_size))
 800e82e:	2101      	movs	r1, #1
 800e830:	f7ff ff07 	bl	800e642 <ucdr_check_buffer>
 800e834:	b138      	cbz	r0, 800e846 <ucdr_deserialize_byte_1+0x1e>
    {
        *byte = *mb->iterator;
 800e836:	68a3      	ldr	r3, [r4, #8]
 800e838:	781b      	ldrb	r3, [r3, #0]
 800e83a:	702b      	strb	r3, [r5, #0]

        mb->iterator += data_size;
 800e83c:	68a3      	ldr	r3, [r4, #8]
 800e83e:	3301      	adds	r3, #1
 800e840:	60a3      	str	r3, [r4, #8]
        mb->last_data_size = data_size;
 800e842:	2301      	movs	r3, #1
 800e844:	6123      	str	r3, [r4, #16]
    }
    return !mb->error;
 800e846:	7d20      	ldrb	r0, [r4, #20]
}
 800e848:	f080 0001 	eor.w	r0, r0, #1
 800e84c:	bd38      	pop	{r3, r4, r5, pc}
	...

0800e850 <ucdr_deserialize_byte_2>:

bool ucdr_deserialize_byte_2(ucdrBuffer* mb, const ucdrEndianness endianness, uint16_t* bytes)
{
 800e850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e852:	4604      	mov	r4, r0
 800e854:	460f      	mov	r7, r1
 800e856:	4616      	mov	r6, r2
    uint32_t data_size = sizeof(uint16_t);
    uint32_t alignment = ucdr_buffer_alignment(mb, data_size);
 800e858:	2102      	movs	r1, #2
 800e85a:	f7ff ff18 	bl	800e68e <ucdr_buffer_alignment>
 800e85e:	4605      	mov	r5, r0

    if(ucdr_check_buffer(mb, alignment + data_size))
 800e860:	1c81      	adds	r1, r0, #2
 800e862:	4620      	mov	r0, r4
 800e864:	f7ff feed 	bl	800e642 <ucdr_check_buffer>
 800e868:	b180      	cbz	r0, 800e88c <ucdr_deserialize_byte_2+0x3c>
    {
        mb->iterator += alignment;
 800e86a:	68a0      	ldr	r0, [r4, #8]
 800e86c:	4428      	add	r0, r5
 800e86e:	60a0      	str	r0, [r4, #8]

        if(UCDR_MACHINE_ENDIANNESS == endianness)
 800e870:	4b0a      	ldr	r3, [pc, #40]	; (800e89c <ucdr_deserialize_byte_2+0x4c>)
 800e872:	781b      	ldrb	r3, [r3, #0]
 800e874:	42bb      	cmp	r3, r7
 800e876:	d00d      	beq.n	800e894 <ucdr_deserialize_byte_2+0x44>
            memcpy(bytes, mb->iterator, data_size);
        }
        else
        {
            uint8_t* bytes_pointer = (uint8_t*)bytes;
            *bytes_pointer = *(mb->iterator + 1);
 800e878:	7843      	ldrb	r3, [r0, #1]
 800e87a:	7033      	strb	r3, [r6, #0]
            *(bytes_pointer + 1) = *mb->iterator ;
 800e87c:	68a3      	ldr	r3, [r4, #8]
 800e87e:	781b      	ldrb	r3, [r3, #0]
 800e880:	7073      	strb	r3, [r6, #1]
        }

        mb->iterator += data_size;
 800e882:	68a3      	ldr	r3, [r4, #8]
 800e884:	3302      	adds	r3, #2
 800e886:	60a3      	str	r3, [r4, #8]
        mb->last_data_size = data_size;
 800e888:	2302      	movs	r3, #2
 800e88a:	6123      	str	r3, [r4, #16]
    }
    return !mb->error;
 800e88c:	7d20      	ldrb	r0, [r4, #20]
}
 800e88e:	f080 0001 	eor.w	r0, r0, #1
 800e892:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e894:	8803      	ldrh	r3, [r0, #0]
            memcpy(bytes, mb->iterator, data_size);
 800e896:	8033      	strh	r3, [r6, #0]
 800e898:	e7f3      	b.n	800e882 <ucdr_deserialize_byte_2+0x32>
 800e89a:	bf00      	nop
 800e89c:	08010998 	.word	0x08010998

0800e8a0 <ucdr_deserialize_byte_4>:

bool ucdr_deserialize_byte_4(ucdrBuffer* mb, const ucdrEndianness endianness, uint32_t* bytes)
{
 800e8a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e8a2:	4604      	mov	r4, r0
 800e8a4:	460f      	mov	r7, r1
 800e8a6:	4615      	mov	r5, r2
    uint32_t data_size = sizeof(uint32_t);
    uint32_t alignment = ucdr_buffer_alignment(mb, data_size);
 800e8a8:	2104      	movs	r1, #4
 800e8aa:	f7ff fef0 	bl	800e68e <ucdr_buffer_alignment>
 800e8ae:	4606      	mov	r6, r0

    if(ucdr_check_buffer(mb, alignment + data_size))
 800e8b0:	1d01      	adds	r1, r0, #4
 800e8b2:	4620      	mov	r0, r4
 800e8b4:	f7ff fec5 	bl	800e642 <ucdr_check_buffer>
 800e8b8:	b1b0      	cbz	r0, 800e8e8 <ucdr_deserialize_byte_4+0x48>
    {
        mb->iterator += alignment;
 800e8ba:	68a0      	ldr	r0, [r4, #8]
 800e8bc:	4430      	add	r0, r6
 800e8be:	60a0      	str	r0, [r4, #8]

        if(UCDR_MACHINE_ENDIANNESS == endianness)
 800e8c0:	4b0d      	ldr	r3, [pc, #52]	; (800e8f8 <ucdr_deserialize_byte_4+0x58>)
 800e8c2:	781b      	ldrb	r3, [r3, #0]
 800e8c4:	42bb      	cmp	r3, r7
 800e8c6:	d013      	beq.n	800e8f0 <ucdr_deserialize_byte_4+0x50>
            memcpy(bytes, mb->iterator, data_size);
        }
        else
        {
            uint8_t* bytes_pointer = (uint8_t*)bytes;
            *bytes_pointer = *(mb->iterator + 3);
 800e8c8:	78c3      	ldrb	r3, [r0, #3]
 800e8ca:	702b      	strb	r3, [r5, #0]
            *(bytes_pointer + 1) = *(mb->iterator + 2);
 800e8cc:	68a3      	ldr	r3, [r4, #8]
 800e8ce:	789b      	ldrb	r3, [r3, #2]
 800e8d0:	706b      	strb	r3, [r5, #1]
            *(bytes_pointer + 2) = *(mb->iterator + 1);
 800e8d2:	68a3      	ldr	r3, [r4, #8]
 800e8d4:	785b      	ldrb	r3, [r3, #1]
 800e8d6:	70ab      	strb	r3, [r5, #2]
            *(bytes_pointer + 3) = *mb->iterator;
 800e8d8:	68a3      	ldr	r3, [r4, #8]
 800e8da:	781b      	ldrb	r3, [r3, #0]
 800e8dc:	70eb      	strb	r3, [r5, #3]
        }

        mb->iterator += data_size;
 800e8de:	68a3      	ldr	r3, [r4, #8]
 800e8e0:	3304      	adds	r3, #4
 800e8e2:	60a3      	str	r3, [r4, #8]
        mb->last_data_size = data_size;
 800e8e4:	2304      	movs	r3, #4
 800e8e6:	6123      	str	r3, [r4, #16]
    }
    return !mb->error;
 800e8e8:	7d20      	ldrb	r0, [r4, #20]
}
 800e8ea:	f080 0001 	eor.w	r0, r0, #1
 800e8ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e8f0:	6803      	ldr	r3, [r0, #0]
            memcpy(bytes, mb->iterator, data_size);
 800e8f2:	602b      	str	r3, [r5, #0]
 800e8f4:	e7f3      	b.n	800e8de <ucdr_deserialize_byte_4+0x3e>
 800e8f6:	bf00      	nop
 800e8f8:	08010998 	.word	0x08010998

0800e8fc <ucdr_serialize_uint8_t>:
{
    return ucdr_serialize_byte_1(mb, (uint8_t*)&value);
}

bool ucdr_serialize_uint8_t(ucdrBuffer* mb, const uint8_t value)
{
 800e8fc:	b500      	push	{lr}
 800e8fe:	b083      	sub	sp, #12
 800e900:	ab02      	add	r3, sp, #8
 800e902:	f803 1d01 	strb.w	r1, [r3, #-1]!
    return ucdr_serialize_byte_1(mb, &value);
 800e906:	4619      	mov	r1, r3
 800e908:	f7ff ff25 	bl	800e756 <ucdr_serialize_byte_1>
}
 800e90c:	b003      	add	sp, #12
 800e90e:	f85d fb04 	ldr.w	pc, [sp], #4

0800e912 <ucdr_serialize_uint16_t>:

bool ucdr_serialize_uint16_t(ucdrBuffer* mb, const uint16_t value)
{
 800e912:	b500      	push	{lr}
 800e914:	b083      	sub	sp, #12
 800e916:	aa02      	add	r2, sp, #8
 800e918:	f822 1d02 	strh.w	r1, [r2, #-2]!
    return ucdr_serialize_byte_2(mb, mb->endianness, &value);
 800e91c:	7b01      	ldrb	r1, [r0, #12]
 800e91e:	f7ff ff2d 	bl	800e77c <ucdr_serialize_byte_2>
}
 800e922:	b003      	add	sp, #12
 800e924:	f85d fb04 	ldr.w	pc, [sp], #4

0800e928 <ucdr_serialize_uint32_t>:

bool ucdr_serialize_uint32_t(ucdrBuffer* mb, const uint32_t value)
{
 800e928:	b500      	push	{lr}
 800e92a:	b083      	sub	sp, #12
 800e92c:	aa02      	add	r2, sp, #8
 800e92e:	f842 1d04 	str.w	r1, [r2, #-4]!
    return ucdr_serialize_byte_4(mb, mb->endianness, &value);
 800e932:	7b01      	ldrb	r1, [r0, #12]
 800e934:	f7ff ff4a 	bl	800e7cc <ucdr_serialize_byte_4>
}
 800e938:	b003      	add	sp, #12
 800e93a:	f85d fb04 	ldr.w	pc, [sp], #4

0800e93e <ucdr_serialize_int32_t>:
{
    return ucdr_serialize_byte_2(mb, mb->endianness, (uint16_t*)&value);
}

bool ucdr_serialize_int32_t(ucdrBuffer* mb, const int32_t value)
{
 800e93e:	b500      	push	{lr}
 800e940:	b083      	sub	sp, #12
 800e942:	aa02      	add	r2, sp, #8
 800e944:	f842 1d04 	str.w	r1, [r2, #-4]!
    return ucdr_serialize_byte_4(mb, mb->endianness, (uint32_t*)&value);
 800e948:	7b01      	ldrb	r1, [r0, #12]
 800e94a:	f7ff ff3f 	bl	800e7cc <ucdr_serialize_byte_4>
}
 800e94e:	b003      	add	sp, #12
 800e950:	f85d fb04 	ldr.w	pc, [sp], #4

0800e954 <ucdr_deserialize_bool>:
{
    return ucdr_deserialize_byte_1(mb, (uint8_t*)value);
}

bool ucdr_deserialize_bool(ucdrBuffer* mb, bool* value)
{
 800e954:	b508      	push	{r3, lr}
    return ucdr_deserialize_byte_1(mb, (uint8_t*)value);
 800e956:	f7ff ff67 	bl	800e828 <ucdr_deserialize_byte_1>
}
 800e95a:	bd08      	pop	{r3, pc}

0800e95c <ucdr_deserialize_uint8_t>:

bool ucdr_deserialize_uint8_t(ucdrBuffer* mb, uint8_t* value)
{
 800e95c:	b508      	push	{r3, lr}
    return ucdr_deserialize_byte_1(mb, value);
 800e95e:	f7ff ff63 	bl	800e828 <ucdr_deserialize_byte_1>
}
 800e962:	bd08      	pop	{r3, pc}

0800e964 <ucdr_deserialize_uint16_t>:

bool ucdr_deserialize_uint16_t(ucdrBuffer* mb, uint16_t* value)
{
 800e964:	b508      	push	{r3, lr}
    return ucdr_deserialize_byte_2(mb, mb->endianness, value);
 800e966:	460a      	mov	r2, r1
 800e968:	7b01      	ldrb	r1, [r0, #12]
 800e96a:	f7ff ff71 	bl	800e850 <ucdr_deserialize_byte_2>
}
 800e96e:	bd08      	pop	{r3, pc}

0800e970 <ucdr_deserialize_uint32_t>:

bool ucdr_deserialize_uint32_t(ucdrBuffer* mb, uint32_t* value)
{
 800e970:	b508      	push	{r3, lr}
    return ucdr_deserialize_byte_4(mb, mb->endianness, value);
 800e972:	460a      	mov	r2, r1
 800e974:	7b01      	ldrb	r1, [r0, #12]
 800e976:	f7ff ff93 	bl	800e8a0 <ucdr_deserialize_byte_4>
}
 800e97a:	bd08      	pop	{r3, pc}

0800e97c <ucdr_deserialize_int32_t>:
{
    return ucdr_deserialize_byte_2(mb, mb->endianness, (uint16_t*)value);
}

bool ucdr_deserialize_int32_t(ucdrBuffer* mb, int32_t* value)
{
 800e97c:	b508      	push	{r3, lr}
    return ucdr_deserialize_byte_4(mb, mb->endianness, (uint32_t*)value);
 800e97e:	460a      	mov	r2, r1
 800e980:	7b01      	ldrb	r1, [r0, #12]
 800e982:	f7ff ff8d 	bl	800e8a0 <ucdr_deserialize_byte_4>
}
 800e986:	bd08      	pop	{r3, pc}

0800e988 <Reset_Handler>:
*/

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:   ldr   sp, =_estack      /* set stack pointer */
 800e988:	f8df d034 	ldr.w	sp, [pc, #52]	; 800e9c0 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800e98c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800e98e:	e003      	b.n	800e998 <LoopCopyDataInit>

0800e990 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800e990:	4b0c      	ldr	r3, [pc, #48]	; (800e9c4 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800e992:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800e994:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800e996:	3104      	adds	r1, #4

0800e998 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800e998:	480b      	ldr	r0, [pc, #44]	; (800e9c8 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800e99a:	4b0c      	ldr	r3, [pc, #48]	; (800e9cc <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800e99c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800e99e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800e9a0:	d3f6      	bcc.n	800e990 <CopyDataInit>
  ldr  r2, =_sbss
 800e9a2:	4a0b      	ldr	r2, [pc, #44]	; (800e9d0 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800e9a4:	e002      	b.n	800e9ac <LoopFillZerobss>

0800e9a6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800e9a6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800e9a8:	f842 3b04 	str.w	r3, [r2], #4

0800e9ac <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800e9ac:	4b09      	ldr	r3, [pc, #36]	; (800e9d4 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800e9ae:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800e9b0:	d3f9      	bcc.n	800e9a6 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800e9b2:	f7fc f9e5 	bl	800ad80 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800e9b6:	f000 fd33 	bl	800f420 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800e9ba:	f7fb fadf 	bl	8009f7c <main>
  bx  lr    
 800e9be:	4770      	bx	lr
Reset_Handler:   ldr   sp, =_estack      /* set stack pointer */
 800e9c0:	20080000 	.word	0x20080000
  ldr  r3, =_sidata
 800e9c4:	08012820 	.word	0x08012820
  ldr  r0, =_sdata
 800e9c8:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800e9cc:	20000080 	.word	0x20000080
  ldr  r2, =_sbss
 800e9d0:	20000080 	.word	0x20000080
  ldr  r3, = _ebss
 800e9d4:	2000b79c 	.word	0x2000b79c

0800e9d8 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800e9d8:	e7fe      	b.n	800e9d8 <ADC_IRQHandler>

0800e9da <__cxa_end_cleanup>:
 800e9da:	b41e      	push	{r1, r2, r3, r4}
 800e9dc:	f000 f89b 	bl	800eb16 <__gnu_end_cleanup>
 800e9e0:	bc1e      	pop	{r1, r2, r3, r4}
 800e9e2:	f7f2 fb97 	bl	8001114 <_Unwind_Resume>

0800e9e6 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 800e9e6:	7803      	ldrb	r3, [r0, #0]
 800e9e8:	2b47      	cmp	r3, #71	; 0x47
 800e9ea:	d117      	bne.n	800ea1c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800e9ec:	7843      	ldrb	r3, [r0, #1]
 800e9ee:	2b4e      	cmp	r3, #78	; 0x4e
 800e9f0:	d114      	bne.n	800ea1c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800e9f2:	7883      	ldrb	r3, [r0, #2]
 800e9f4:	2b55      	cmp	r3, #85	; 0x55
 800e9f6:	d111      	bne.n	800ea1c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800e9f8:	78c3      	ldrb	r3, [r0, #3]
 800e9fa:	2b43      	cmp	r3, #67	; 0x43
 800e9fc:	d10e      	bne.n	800ea1c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800e9fe:	7903      	ldrb	r3, [r0, #4]
 800ea00:	2b43      	cmp	r3, #67	; 0x43
 800ea02:	d10b      	bne.n	800ea1c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800ea04:	7943      	ldrb	r3, [r0, #5]
 800ea06:	2b2b      	cmp	r3, #43	; 0x2b
 800ea08:	d108      	bne.n	800ea1c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800ea0a:	7983      	ldrb	r3, [r0, #6]
 800ea0c:	2b2b      	cmp	r3, #43	; 0x2b
 800ea0e:	d105      	bne.n	800ea1c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800ea10:	79c0      	ldrb	r0, [r0, #7]
 800ea12:	2801      	cmp	r0, #1
 800ea14:	bf8c      	ite	hi
 800ea16:	2000      	movhi	r0, #0
 800ea18:	2001      	movls	r0, #1
 800ea1a:	4770      	bx	lr
 800ea1c:	2000      	movs	r0, #0
 800ea1e:	4770      	bx	lr

0800ea20 <__cxa_type_match>:
 800ea20:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800ea24:	461e      	mov	r6, r3
 800ea26:	7803      	ldrb	r3, [r0, #0]
 800ea28:	2b47      	cmp	r3, #71	; 0x47
 800ea2a:	460d      	mov	r5, r1
 800ea2c:	4602      	mov	r2, r0
 800ea2e:	79c1      	ldrb	r1, [r0, #7]
 800ea30:	d113      	bne.n	800ea5a <__cxa_type_match+0x3a>
 800ea32:	7843      	ldrb	r3, [r0, #1]
 800ea34:	2b4e      	cmp	r3, #78	; 0x4e
 800ea36:	d110      	bne.n	800ea5a <__cxa_type_match+0x3a>
 800ea38:	7883      	ldrb	r3, [r0, #2]
 800ea3a:	2b55      	cmp	r3, #85	; 0x55
 800ea3c:	d10d      	bne.n	800ea5a <__cxa_type_match+0x3a>
 800ea3e:	78c3      	ldrb	r3, [r0, #3]
 800ea40:	2b43      	cmp	r3, #67	; 0x43
 800ea42:	d10a      	bne.n	800ea5a <__cxa_type_match+0x3a>
 800ea44:	7903      	ldrb	r3, [r0, #4]
 800ea46:	2b46      	cmp	r3, #70	; 0x46
 800ea48:	d107      	bne.n	800ea5a <__cxa_type_match+0x3a>
 800ea4a:	7943      	ldrb	r3, [r0, #5]
 800ea4c:	2b4f      	cmp	r3, #79	; 0x4f
 800ea4e:	d104      	bne.n	800ea5a <__cxa_type_match+0x3a>
 800ea50:	7983      	ldrb	r3, [r0, #6]
 800ea52:	2b52      	cmp	r3, #82	; 0x52
 800ea54:	d101      	bne.n	800ea5a <__cxa_type_match+0x3a>
 800ea56:	2900      	cmp	r1, #0
 800ea58:	d031      	beq.n	800eabe <__cxa_type_match+0x9e>
 800ea5a:	4610      	mov	r0, r2
 800ea5c:	f7ff ffc3 	bl	800e9e6 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800ea60:	f080 0001 	eor.w	r0, r0, #1
 800ea64:	b2c0      	uxtb	r0, r0
 800ea66:	2300      	movs	r3, #0
 800ea68:	2400      	movs	r4, #0
 800ea6a:	9401      	str	r4, [sp, #4]
 800ea6c:	bb53      	cbnz	r3, 800eac4 <__cxa_type_match+0xa4>
 800ea6e:	bb58      	cbnz	r0, 800eac8 <__cxa_type_match+0xa8>
 800ea70:	2901      	cmp	r1, #1
 800ea72:	bf0a      	itet	eq
 800ea74:	f852 3c20 	ldreq.w	r3, [r2, #-32]
 800ea78:	f1a2 0320 	subne.w	r3, r2, #32
 800ea7c:	3b78      	subeq	r3, #120	; 0x78
 800ea7e:	2901      	cmp	r1, #1
 800ea80:	bf08      	it	eq
 800ea82:	f852 2c20 	ldreq.w	r2, [r2, #-32]
 800ea86:	681c      	ldr	r4, [r3, #0]
 800ea88:	bf18      	it	ne
 800ea8a:	3258      	addne	r2, #88	; 0x58
 800ea8c:	9201      	str	r2, [sp, #4]
 800ea8e:	6823      	ldr	r3, [r4, #0]
 800ea90:	4620      	mov	r0, r4
 800ea92:	689b      	ldr	r3, [r3, #8]
 800ea94:	4798      	blx	r3
 800ea96:	b1c8      	cbz	r0, 800eacc <__cxa_type_match+0xac>
 800ea98:	9b01      	ldr	r3, [sp, #4]
 800ea9a:	681b      	ldr	r3, [r3, #0]
 800ea9c:	9301      	str	r3, [sp, #4]
 800ea9e:	2702      	movs	r7, #2
 800eaa0:	682b      	ldr	r3, [r5, #0]
 800eaa2:	aa01      	add	r2, sp, #4
 800eaa4:	f8d3 8010 	ldr.w	r8, [r3, #16]
 800eaa8:	4621      	mov	r1, r4
 800eaaa:	2301      	movs	r3, #1
 800eaac:	4628      	mov	r0, r5
 800eaae:	47c0      	blx	r8
 800eab0:	b170      	cbz	r0, 800ead0 <__cxa_type_match+0xb0>
 800eab2:	9b01      	ldr	r3, [sp, #4]
 800eab4:	6033      	str	r3, [r6, #0]
 800eab6:	4638      	mov	r0, r7
 800eab8:	b002      	add	sp, #8
 800eaba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800eabe:	2301      	movs	r3, #1
 800eac0:	4608      	mov	r0, r1
 800eac2:	e7d1      	b.n	800ea68 <__cxa_type_match+0x48>
 800eac4:	4c03      	ldr	r4, [pc, #12]	; (800ead4 <__cxa_type_match+0xb4>)
 800eac6:	e7e2      	b.n	800ea8e <__cxa_type_match+0x6e>
 800eac8:	4c03      	ldr	r4, [pc, #12]	; (800ead8 <__cxa_type_match+0xb8>)
 800eaca:	e7e0      	b.n	800ea8e <__cxa_type_match+0x6e>
 800eacc:	2701      	movs	r7, #1
 800eace:	e7e7      	b.n	800eaa0 <__cxa_type_match+0x80>
 800ead0:	4607      	mov	r7, r0
 800ead2:	e7f0      	b.n	800eab6 <__cxa_type_match+0x96>
 800ead4:	08011cac 	.word	0x08011cac
 800ead8:	08011cb4 	.word	0x08011cb4

0800eadc <__cxa_begin_cleanup>:
 800eadc:	b510      	push	{r4, lr}
 800eade:	4604      	mov	r4, r0
 800eae0:	f000 f832 	bl	800eb48 <__cxa_get_globals>
 800eae4:	4602      	mov	r2, r0
 800eae6:	4620      	mov	r0, r4
 800eae8:	f1a4 0120 	sub.w	r1, r4, #32
 800eaec:	f7ff ff7b 	bl	800e9e6 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800eaf0:	b160      	cbz	r0, 800eb0c <__cxa_begin_cleanup+0x30>
 800eaf2:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800eaf6:	3301      	adds	r3, #1
 800eaf8:	2b01      	cmp	r3, #1
 800eafa:	f844 3c04 	str.w	r3, [r4, #-4]
 800eafe:	d103      	bne.n	800eb08 <__cxa_begin_cleanup+0x2c>
 800eb00:	6893      	ldr	r3, [r2, #8]
 800eb02:	f844 3c08 	str.w	r3, [r4, #-8]
 800eb06:	6091      	str	r1, [r2, #8]
 800eb08:	2001      	movs	r0, #1
 800eb0a:	bd10      	pop	{r4, pc}
 800eb0c:	6893      	ldr	r3, [r2, #8]
 800eb0e:	2b00      	cmp	r3, #0
 800eb10:	d0f9      	beq.n	800eb06 <__cxa_begin_cleanup+0x2a>
 800eb12:	f000 fac7 	bl	800f0a4 <_ZSt9terminatev>

0800eb16 <__gnu_end_cleanup>:
 800eb16:	b510      	push	{r4, lr}
 800eb18:	f000 f816 	bl	800eb48 <__cxa_get_globals>
 800eb1c:	6882      	ldr	r2, [r0, #8]
 800eb1e:	4601      	mov	r1, r0
 800eb20:	b90a      	cbnz	r2, 800eb26 <__gnu_end_cleanup+0x10>
 800eb22:	f000 fabf 	bl	800f0a4 <_ZSt9terminatev>
 800eb26:	f102 0420 	add.w	r4, r2, #32
 800eb2a:	4620      	mov	r0, r4
 800eb2c:	f7ff ff5b 	bl	800e9e6 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800eb30:	b140      	cbz	r0, 800eb44 <__gnu_end_cleanup+0x2e>
 800eb32:	69d3      	ldr	r3, [r2, #28]
 800eb34:	3b01      	subs	r3, #1
 800eb36:	61d3      	str	r3, [r2, #28]
 800eb38:	b913      	cbnz	r3, 800eb40 <__gnu_end_cleanup+0x2a>
 800eb3a:	6990      	ldr	r0, [r2, #24]
 800eb3c:	6088      	str	r0, [r1, #8]
 800eb3e:	6193      	str	r3, [r2, #24]
 800eb40:	4620      	mov	r0, r4
 800eb42:	bd10      	pop	{r4, pc}
 800eb44:	6088      	str	r0, [r1, #8]
 800eb46:	e7fb      	b.n	800eb40 <__gnu_end_cleanup+0x2a>

0800eb48 <__cxa_get_globals>:
 800eb48:	4800      	ldr	r0, [pc, #0]	; (800eb4c <__cxa_get_globals+0x4>)
 800eb4a:	4770      	bx	lr
 800eb4c:	20005944 	.word	0x20005944

0800eb50 <_ZL12read_uleb128PKhPm>:
 800eb50:	b570      	push	{r4, r5, r6, lr}
 800eb52:	2300      	movs	r3, #0
 800eb54:	eba0 06c0 	sub.w	r6, r0, r0, lsl #3
 800eb58:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
 800eb5c:	f810 5b01 	ldrb.w	r5, [r0], #1
 800eb60:	1994      	adds	r4, r2, r6
 800eb62:	f005 027f 	and.w	r2, r5, #127	; 0x7f
 800eb66:	40a2      	lsls	r2, r4
 800eb68:	4313      	orrs	r3, r2
 800eb6a:	062a      	lsls	r2, r5, #24
 800eb6c:	d4f4      	bmi.n	800eb58 <_ZL12read_uleb128PKhPm+0x8>
 800eb6e:	600b      	str	r3, [r1, #0]
 800eb70:	bd70      	pop	{r4, r5, r6, pc}

0800eb72 <_ZL12read_sleb128PKhPl>:
 800eb72:	b530      	push	{r4, r5, lr}
 800eb74:	2300      	movs	r3, #0
 800eb76:	461a      	mov	r2, r3
 800eb78:	f810 4b01 	ldrb.w	r4, [r0], #1
 800eb7c:	f004 057f 	and.w	r5, r4, #127	; 0x7f
 800eb80:	4095      	lsls	r5, r2
 800eb82:	432b      	orrs	r3, r5
 800eb84:	0625      	lsls	r5, r4, #24
 800eb86:	f102 0207 	add.w	r2, r2, #7
 800eb8a:	d4f5      	bmi.n	800eb78 <_ZL12read_sleb128PKhPl+0x6>
 800eb8c:	2a1f      	cmp	r2, #31
 800eb8e:	d806      	bhi.n	800eb9e <_ZL12read_sleb128PKhPl+0x2c>
 800eb90:	0664      	lsls	r4, r4, #25
 800eb92:	bf42      	ittt	mi
 800eb94:	f04f 34ff 	movmi.w	r4, #4294967295	; 0xffffffff
 800eb98:	fa04 f202 	lslmi.w	r2, r4, r2
 800eb9c:	4313      	orrmi	r3, r2
 800eb9e:	600b      	str	r3, [r1, #0]
 800eba0:	bd30      	pop	{r4, r5, pc}

0800eba2 <_ZL28read_encoded_value_with_basehjPKhPj>:
 800eba2:	2850      	cmp	r0, #80	; 0x50
 800eba4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800eba6:	4605      	mov	r5, r0
 800eba8:	460e      	mov	r6, r1
 800ebaa:	4614      	mov	r4, r2
 800ebac:	461f      	mov	r7, r3
 800ebae:	d107      	bne.n	800ebc0 <_ZL28read_encoded_value_with_basehjPKhPj+0x1e>
 800ebb0:	1cd0      	adds	r0, r2, #3
 800ebb2:	f020 0003 	bic.w	r0, r0, #3
 800ebb6:	f850 3b04 	ldr.w	r3, [r0], #4
 800ebba:	603b      	str	r3, [r7, #0]
 800ebbc:	b003      	add	sp, #12
 800ebbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ebc0:	f000 030f 	and.w	r3, r0, #15
 800ebc4:	2b0c      	cmp	r3, #12
 800ebc6:	d82e      	bhi.n	800ec26 <_ZL28read_encoded_value_with_basehjPKhPj+0x84>
 800ebc8:	e8df f003 	tbb	[pc, r3]
 800ebcc:	251d0725 	.word	0x251d0725
 800ebd0:	2d2d2d29 	.word	0x2d2d2d29
 800ebd4:	2521182d 	.word	0x2521182d
 800ebd8:	29          	.byte	0x29
 800ebd9:	00          	.byte	0x00
 800ebda:	a901      	add	r1, sp, #4
 800ebdc:	4620      	mov	r0, r4
 800ebde:	f7ff ffb7 	bl	800eb50 <_ZL12read_uleb128PKhPm>
 800ebe2:	9b01      	ldr	r3, [sp, #4]
 800ebe4:	2b00      	cmp	r3, #0
 800ebe6:	d0e8      	beq.n	800ebba <_ZL28read_encoded_value_with_basehjPKhPj+0x18>
 800ebe8:	f005 0270 	and.w	r2, r5, #112	; 0x70
 800ebec:	2a10      	cmp	r2, #16
 800ebee:	bf08      	it	eq
 800ebf0:	4626      	moveq	r6, r4
 800ebf2:	4433      	add	r3, r6
 800ebf4:	062a      	lsls	r2, r5, #24
 800ebf6:	bf48      	it	mi
 800ebf8:	681b      	ldrmi	r3, [r3, #0]
 800ebfa:	e7de      	b.n	800ebba <_ZL28read_encoded_value_with_basehjPKhPj+0x18>
 800ebfc:	a901      	add	r1, sp, #4
 800ebfe:	4620      	mov	r0, r4
 800ec00:	f7ff ffb7 	bl	800eb72 <_ZL12read_sleb128PKhPl>
 800ec04:	e7ed      	b.n	800ebe2 <_ZL28read_encoded_value_with_basehjPKhPj+0x40>
 800ec06:	4620      	mov	r0, r4
 800ec08:	f830 3b02 	ldrh.w	r3, [r0], #2
 800ec0c:	e7ea      	b.n	800ebe4 <_ZL28read_encoded_value_with_basehjPKhPj+0x42>
 800ec0e:	4620      	mov	r0, r4
 800ec10:	f930 3b02 	ldrsh.w	r3, [r0], #2
 800ec14:	e7e6      	b.n	800ebe4 <_ZL28read_encoded_value_with_basehjPKhPj+0x42>
 800ec16:	4620      	mov	r0, r4
 800ec18:	f850 3b04 	ldr.w	r3, [r0], #4
 800ec1c:	e7e2      	b.n	800ebe4 <_ZL28read_encoded_value_with_basehjPKhPj+0x42>
 800ec1e:	4620      	mov	r0, r4
 800ec20:	f850 3b08 	ldr.w	r3, [r0], #8
 800ec24:	e7de      	b.n	800ebe4 <_ZL28read_encoded_value_with_basehjPKhPj+0x42>
 800ec26:	f000 fbe8 	bl	800f3fa <abort>

0800ec2a <_Unwind_GetGR>:
 800ec2a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800ec2c:	ab03      	add	r3, sp, #12
 800ec2e:	9300      	str	r3, [sp, #0]
 800ec30:	2300      	movs	r3, #0
 800ec32:	460a      	mov	r2, r1
 800ec34:	4619      	mov	r1, r3
 800ec36:	f7f1 feb1 	bl	800099c <_Unwind_VRS_Get>
 800ec3a:	9803      	ldr	r0, [sp, #12]
 800ec3c:	b005      	add	sp, #20
 800ec3e:	f85d fb04 	ldr.w	pc, [sp], #4

0800ec42 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3>:
 800ec42:	f000 0070 	and.w	r0, r0, #112	; 0x70
 800ec46:	2820      	cmp	r0, #32
 800ec48:	b508      	push	{r3, lr}
 800ec4a:	d010      	beq.n	800ec6e <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3+0x2c>
 800ec4c:	d804      	bhi.n	800ec58 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3+0x16>
 800ec4e:	b1c0      	cbz	r0, 800ec82 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3+0x40>
 800ec50:	2810      	cmp	r0, #16
 800ec52:	d016      	beq.n	800ec82 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3+0x40>
 800ec54:	f000 fbd1 	bl	800f3fa <abort>
 800ec58:	2840      	cmp	r0, #64	; 0x40
 800ec5a:	d00d      	beq.n	800ec78 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3+0x36>
 800ec5c:	2850      	cmp	r0, #80	; 0x50
 800ec5e:	d010      	beq.n	800ec82 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3+0x40>
 800ec60:	2830      	cmp	r0, #48	; 0x30
 800ec62:	d1f7      	bne.n	800ec54 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3+0x12>
 800ec64:	4608      	mov	r0, r1
 800ec66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800ec6a:	f7f2 bc4d 	b.w	8001508 <_Unwind_GetDataRelBase>
 800ec6e:	4608      	mov	r0, r1
 800ec70:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800ec74:	f7f2 bc4c 	b.w	8001510 <_Unwind_GetTextRelBase>
 800ec78:	4608      	mov	r0, r1
 800ec7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800ec7e:	f7f2 bc33 	b.w	80014e8 <_Unwind_GetRegionStart>
 800ec82:	2000      	movs	r0, #0
 800ec84:	bd08      	pop	{r3, pc}

0800ec86 <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>:
 800ec86:	29ff      	cmp	r1, #255	; 0xff
 800ec88:	b570      	push	{r4, r5, r6, lr}
 800ec8a:	460c      	mov	r4, r1
 800ec8c:	4615      	mov	r5, r2
 800ec8e:	461e      	mov	r6, r3
 800ec90:	d00b      	beq.n	800ecaa <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj+0x24>
 800ec92:	4601      	mov	r1, r0
 800ec94:	4620      	mov	r0, r4
 800ec96:	f7ff ffd4 	bl	800ec42 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3>
 800ec9a:	4601      	mov	r1, r0
 800ec9c:	4633      	mov	r3, r6
 800ec9e:	462a      	mov	r2, r5
 800eca0:	4620      	mov	r0, r4
 800eca2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800eca6:	f7ff bf7c 	b.w	800eba2 <_ZL28read_encoded_value_with_basehjPKhPj>
 800ecaa:	2100      	movs	r1, #0
 800ecac:	e7f6      	b.n	800ec9c <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj+0x16>

0800ecae <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>:
 800ecae:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800ecb0:	460e      	mov	r6, r1
 800ecb2:	4614      	mov	r4, r2
 800ecb4:	4605      	mov	r5, r0
 800ecb6:	b108      	cbz	r0, 800ecbc <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0xe>
 800ecb8:	f7f2 fc16 	bl	80014e8 <_Unwind_GetRegionStart>
 800ecbc:	6020      	str	r0, [r4, #0]
 800ecbe:	7831      	ldrb	r1, [r6, #0]
 800ecc0:	29ff      	cmp	r1, #255	; 0xff
 800ecc2:	f106 0201 	add.w	r2, r6, #1
 800ecc6:	d01d      	beq.n	800ed04 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x56>
 800ecc8:	1d23      	adds	r3, r4, #4
 800ecca:	4628      	mov	r0, r5
 800eccc:	f7ff ffdb 	bl	800ec86 <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 800ecd0:	4602      	mov	r2, r0
 800ecd2:	7813      	ldrb	r3, [r2, #0]
 800ecd4:	7523      	strb	r3, [r4, #20]
 800ecd6:	2bff      	cmp	r3, #255	; 0xff
 800ecd8:	f102 0001 	add.w	r0, r2, #1
 800ecdc:	d014      	beq.n	800ed08 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x5a>
 800ecde:	2310      	movs	r3, #16
 800ece0:	7523      	strb	r3, [r4, #20]
 800ece2:	a901      	add	r1, sp, #4
 800ece4:	f7ff ff34 	bl	800eb50 <_ZL12read_uleb128PKhPm>
 800ece8:	9b01      	ldr	r3, [sp, #4]
 800ecea:	4403      	add	r3, r0
 800ecec:	60e3      	str	r3, [r4, #12]
 800ecee:	7803      	ldrb	r3, [r0, #0]
 800ecf0:	7563      	strb	r3, [r4, #21]
 800ecf2:	a901      	add	r1, sp, #4
 800ecf4:	3001      	adds	r0, #1
 800ecf6:	f7ff ff2b 	bl	800eb50 <_ZL12read_uleb128PKhPm>
 800ecfa:	9b01      	ldr	r3, [sp, #4]
 800ecfc:	4403      	add	r3, r0
 800ecfe:	6123      	str	r3, [r4, #16]
 800ed00:	b002      	add	sp, #8
 800ed02:	bd70      	pop	{r4, r5, r6, pc}
 800ed04:	6060      	str	r0, [r4, #4]
 800ed06:	e7e4      	b.n	800ecd2 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x24>
 800ed08:	2300      	movs	r3, #0
 800ed0a:	e7ef      	b.n	800ecec <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x3e>

0800ed0c <__gxx_personality_v0>:
 800ed0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ed10:	b091      	sub	sp, #68	; 0x44
 800ed12:	2300      	movs	r3, #0
 800ed14:	9304      	str	r3, [sp, #16]
 800ed16:	f000 0303 	and.w	r3, r0, #3
 800ed1a:	2b01      	cmp	r3, #1
 800ed1c:	4607      	mov	r7, r0
 800ed1e:	460c      	mov	r4, r1
 800ed20:	4616      	mov	r6, r2
 800ed22:	d011      	beq.n	800ed48 <__gxx_personality_v0+0x3c>
 800ed24:	d303      	bcc.n	800ed2e <__gxx_personality_v0+0x22>
 800ed26:	2b02      	cmp	r3, #2
 800ed28:	d003      	beq.n	800ed32 <__gxx_personality_v0+0x26>
 800ed2a:	f000 fb66 	bl	800f3fa <abort>
 800ed2e:	0702      	lsls	r2, r0, #28
 800ed30:	d51a      	bpl.n	800ed68 <__gxx_personality_v0+0x5c>
 800ed32:	4631      	mov	r1, r6
 800ed34:	4620      	mov	r0, r4
 800ed36:	f7f2 fbc3 	bl	80014c0 <__gnu_unwind_frame>
 800ed3a:	b118      	cbz	r0, 800ed44 <__gxx_personality_v0+0x38>
 800ed3c:	2009      	movs	r0, #9
 800ed3e:	b011      	add	sp, #68	; 0x44
 800ed40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ed44:	2008      	movs	r0, #8
 800ed46:	e7fa      	b.n	800ed3e <__gxx_personality_v0+0x32>
 800ed48:	f000 0508 	and.w	r5, r0, #8
 800ed4c:	f005 08ff 	and.w	r8, r5, #255	; 0xff
 800ed50:	bb75      	cbnz	r5, 800edb0 <__gxx_personality_v0+0xa4>
 800ed52:	f8d1 9020 	ldr.w	r9, [r1, #32]
 800ed56:	4610      	mov	r0, r2
 800ed58:	210d      	movs	r1, #13
 800ed5a:	f7ff ff66 	bl	800ec2a <_Unwind_GetGR>
 800ed5e:	4581      	cmp	r9, r0
 800ed60:	f040 8145 	bne.w	800efee <__gxx_personality_v0+0x2e2>
 800ed64:	2506      	movs	r5, #6
 800ed66:	e000      	b.n	800ed6a <__gxx_personality_v0+0x5e>
 800ed68:	2501      	movs	r5, #1
 800ed6a:	ab10      	add	r3, sp, #64	; 0x40
 800ed6c:	f007 0708 	and.w	r7, r7, #8
 800ed70:	f843 4d2c 	str.w	r4, [r3, #-44]!
 800ed74:	9300      	str	r3, [sp, #0]
 800ed76:	2300      	movs	r3, #0
 800ed78:	433d      	orrs	r5, r7
 800ed7a:	220c      	movs	r2, #12
 800ed7c:	4619      	mov	r1, r3
 800ed7e:	4630      	mov	r0, r6
 800ed80:	f7f1 fe2e 	bl	80009e0 <_Unwind_VRS_Set>
 800ed84:	2d06      	cmp	r5, #6
 800ed86:	f040 813e 	bne.w	800f006 <__gxx_personality_v0+0x2fa>
 800ed8a:	6b27      	ldr	r7, [r4, #48]	; 0x30
 800ed8c:	e9d4 980a 	ldrd	r9, r8, [r4, #40]	; 0x28
 800ed90:	2f00      	cmp	r7, #0
 800ed92:	bf0c      	ite	eq
 800ed94:	f04f 0a01 	moveq.w	sl, #1
 800ed98:	f04f 0a03 	movne.w	sl, #3
 800ed9c:	f015 0508 	ands.w	r5, r5, #8
 800eda0:	f000 80c7 	beq.w	800ef32 <__gxx_personality_v0+0x226>
 800eda4:	f1ba 0f01 	cmp.w	sl, #1
 800eda8:	f040 80be 	bne.w	800ef28 <__gxx_personality_v0+0x21c>
 800edac:	f000 f97a 	bl	800f0a4 <_ZSt9terminatev>
 800edb0:	2502      	movs	r5, #2
 800edb2:	e7da      	b.n	800ed6a <__gxx_personality_v0+0x5e>
 800edb4:	2000      	movs	r0, #0
 800edb6:	e13b      	b.n	800f030 <__gxx_personality_v0+0x324>
 800edb8:	9a07      	ldr	r2, [sp, #28]
 800edba:	4413      	add	r3, r2
 800edbc:	42bb      	cmp	r3, r7
 800edbe:	f240 813f 	bls.w	800f040 <__gxx_personality_v0+0x334>
 800edc2:	9f08      	ldr	r7, [sp, #32]
 800edc4:	b10f      	cbz	r7, 800edca <__gxx_personality_v0+0xbe>
 800edc6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800edc8:	441f      	add	r7, r3
 800edca:	9809      	ldr	r0, [sp, #36]	; 0x24
 800edcc:	b110      	cbz	r0, 800edd4 <__gxx_personality_v0+0xc8>
 800edce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800edd0:	3801      	subs	r0, #1
 800edd2:	4418      	add	r0, r3
 800edd4:	2f00      	cmp	r7, #0
 800edd6:	d0ac      	beq.n	800ed32 <__gxx_personality_v0+0x26>
 800edd8:	2800      	cmp	r0, #0
 800edda:	f000 8104 	beq.w	800efe6 <__gxx_personality_v0+0x2da>
 800edde:	f015 0308 	ands.w	r3, r5, #8
 800ede2:	9302      	str	r3, [sp, #8]
 800ede4:	d034      	beq.n	800ee50 <__gxx_personality_v0+0x144>
 800ede6:	2347      	movs	r3, #71	; 0x47
 800ede8:	7023      	strb	r3, [r4, #0]
 800edea:	234e      	movs	r3, #78	; 0x4e
 800edec:	7063      	strb	r3, [r4, #1]
 800edee:	2355      	movs	r3, #85	; 0x55
 800edf0:	70a3      	strb	r3, [r4, #2]
 800edf2:	2343      	movs	r3, #67	; 0x43
 800edf4:	70e3      	strb	r3, [r4, #3]
 800edf6:	2346      	movs	r3, #70	; 0x46
 800edf8:	7123      	strb	r3, [r4, #4]
 800edfa:	234f      	movs	r3, #79	; 0x4f
 800edfc:	7163      	strb	r3, [r4, #5]
 800edfe:	2352      	movs	r3, #82	; 0x52
 800ee00:	71a3      	strb	r3, [r4, #6]
 800ee02:	2300      	movs	r3, #0
 800ee04:	71e3      	strb	r3, [r4, #7]
 800ee06:	f04f 0a00 	mov.w	sl, #0
 800ee0a:	f06f 0b03 	mvn.w	fp, #3
 800ee0e:	a907      	add	r1, sp, #28
 800ee10:	f7ff feaf 	bl	800eb72 <_ZL12read_sleb128PKhPl>
 800ee14:	a908      	add	r1, sp, #32
 800ee16:	9003      	str	r0, [sp, #12]
 800ee18:	f7ff feab 	bl	800eb72 <_ZL12read_sleb128PKhPl>
 800ee1c:	9907      	ldr	r1, [sp, #28]
 800ee1e:	2900      	cmp	r1, #0
 800ee20:	d067      	beq.n	800eef2 <__gxx_personality_v0+0x1e6>
 800ee22:	dd3e      	ble.n	800eea2 <__gxx_personality_v0+0x196>
 800ee24:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 800ee28:	28ff      	cmp	r0, #255	; 0xff
 800ee2a:	d034      	beq.n	800ee96 <__gxx_personality_v0+0x18a>
 800ee2c:	f000 0307 	and.w	r3, r0, #7
 800ee30:	2b04      	cmp	r3, #4
 800ee32:	f63f af7a 	bhi.w	800ed2a <__gxx_personality_v0+0x1e>
 800ee36:	a201      	add	r2, pc, #4	; (adr r2, 800ee3c <__gxx_personality_v0+0x130>)
 800ee38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ee3c:	0800ee63 	.word	0x0800ee63
 800ee40:	0800ed2b 	.word	0x0800ed2b
 800ee44:	0800ee9d 	.word	0x0800ee9d
 800ee48:	0800ee63 	.word	0x0800ee63
 800ee4c:	0800ee91 	.word	0x0800ee91
 800ee50:	79e3      	ldrb	r3, [r4, #7]
 800ee52:	2b01      	cmp	r3, #1
 800ee54:	bf0c      	ite	eq
 800ee56:	f854 3c20 	ldreq.w	r3, [r4, #-32]
 800ee5a:	f104 0358 	addne.w	r3, r4, #88	; 0x58
 800ee5e:	9304      	str	r3, [sp, #16]
 800ee60:	e7d1      	b.n	800ee06 <__gxx_personality_v0+0xfa>
 800ee62:	f04f 0c04 	mov.w	ip, #4
 800ee66:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800ee68:	ab09      	add	r3, sp, #36	; 0x24
 800ee6a:	fb0c 2211 	mls	r2, ip, r1, r2
 800ee6e:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ee70:	f7ff fe97 	bl	800eba2 <_ZL28read_encoded_value_with_basehjPKhPj>
 800ee74:	9909      	ldr	r1, [sp, #36]	; 0x24
 800ee76:	b131      	cbz	r1, 800ee86 <__gxx_personality_v0+0x17a>
 800ee78:	b37c      	cbz	r4, 800eeda <__gxx_personality_v0+0x1ce>
 800ee7a:	ab04      	add	r3, sp, #16
 800ee7c:	2200      	movs	r2, #0
 800ee7e:	4620      	mov	r0, r4
 800ee80:	f7ff fdce 	bl	800ea20 <__cxa_type_match>
 800ee84:	b348      	cbz	r0, 800eeda <__gxx_personality_v0+0x1ce>
 800ee86:	f8dd 901c 	ldr.w	r9, [sp, #28]
 800ee8a:	f04f 0a03 	mov.w	sl, #3
 800ee8e:	e038      	b.n	800ef02 <__gxx_personality_v0+0x1f6>
 800ee90:	f04f 0c08 	mov.w	ip, #8
 800ee94:	e7e7      	b.n	800ee66 <__gxx_personality_v0+0x15a>
 800ee96:	f04f 0c00 	mov.w	ip, #0
 800ee9a:	e7e4      	b.n	800ee66 <__gxx_personality_v0+0x15a>
 800ee9c:	f04f 0c02 	mov.w	ip, #2
 800eea0:	e7e1      	b.n	800ee66 <__gxx_personality_v0+0x15a>
 800eea2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800eea4:	fb01 b10b 	mla	r1, r1, fp, fp
 800eea8:	eb03 0901 	add.w	r9, r3, r1
 800eeac:	b1e4      	cbz	r4, 800eee8 <__gxx_personality_v0+0x1dc>
 800eeae:	9a02      	ldr	r2, [sp, #8]
 800eeb0:	b9d2      	cbnz	r2, 800eee8 <__gxx_personality_v0+0x1dc>
 800eeb2:	9b04      	ldr	r3, [sp, #16]
 800eeb4:	9306      	str	r3, [sp, #24]
 800eeb6:	f1a9 0904 	sub.w	r9, r9, #4
 800eeba:	f859 1f04 	ldr.w	r1, [r9, #4]!
 800eebe:	b141      	cbz	r1, 800eed2 <__gxx_personality_v0+0x1c6>
 800eec0:	ab06      	add	r3, sp, #24
 800eec2:	2200      	movs	r2, #0
 800eec4:	4449      	add	r1, r9
 800eec6:	4620      	mov	r0, r4
 800eec8:	f7ff fdaa 	bl	800ea20 <__cxa_type_match>
 800eecc:	2800      	cmp	r0, #0
 800eece:	d0f4      	beq.n	800eeba <__gxx_personality_v0+0x1ae>
 800eed0:	2101      	movs	r1, #1
 800eed2:	f081 0101 	eor.w	r1, r1, #1
 800eed6:	2900      	cmp	r1, #0
 800eed8:	d1d5      	bne.n	800ee86 <__gxx_personality_v0+0x17a>
 800eeda:	9808      	ldr	r0, [sp, #32]
 800eedc:	2800      	cmp	r0, #0
 800eede:	d07e      	beq.n	800efde <__gxx_personality_v0+0x2d2>
 800eee0:	9b03      	ldr	r3, [sp, #12]
 800eee2:	4403      	add	r3, r0
 800eee4:	4618      	mov	r0, r3
 800eee6:	e792      	b.n	800ee0e <__gxx_personality_v0+0x102>
 800eee8:	5859      	ldr	r1, [r3, r1]
 800eeea:	fab1 f181 	clz	r1, r1
 800eeee:	0949      	lsrs	r1, r1, #5
 800eef0:	e7f1      	b.n	800eed6 <__gxx_personality_v0+0x1ca>
 800eef2:	f04f 0a01 	mov.w	sl, #1
 800eef6:	e7f0      	b.n	800eeda <__gxx_personality_v0+0x1ce>
 800eef8:	f04f 0900 	mov.w	r9, #0
 800eefc:	464f      	mov	r7, r9
 800eefe:	f04f 0a01 	mov.w	sl, #1
 800ef02:	07eb      	lsls	r3, r5, #31
 800ef04:	f57f af4a 	bpl.w	800ed9c <__gxx_personality_v0+0x90>
 800ef08:	f1ba 0f02 	cmp.w	sl, #2
 800ef0c:	f43f af11 	beq.w	800ed32 <__gxx_personality_v0+0x26>
 800ef10:	210d      	movs	r1, #13
 800ef12:	4630      	mov	r0, r6
 800ef14:	9d04      	ldr	r5, [sp, #16]
 800ef16:	f7ff fe88 	bl	800ec2a <_Unwind_GetGR>
 800ef1a:	e9c4 980a 	strd	r9, r8, [r4, #40]	; 0x28
 800ef1e:	e9c4 0508 	strd	r0, r5, [r4, #32]
 800ef22:	6327      	str	r7, [r4, #48]	; 0x30
 800ef24:	2006      	movs	r0, #6
 800ef26:	e70a      	b.n	800ed3e <__gxx_personality_v0+0x32>
 800ef28:	f1b9 0f00 	cmp.w	r9, #0
 800ef2c:	da2a      	bge.n	800ef84 <__gxx_personality_v0+0x278>
 800ef2e:	f000 f8cb 	bl	800f0c8 <_ZSt10unexpectedv>
 800ef32:	f1ba 0f01 	cmp.w	sl, #1
 800ef36:	d102      	bne.n	800ef3e <__gxx_personality_v0+0x232>
 800ef38:	4620      	mov	r0, r4
 800ef3a:	f000 f9f4 	bl	800f326 <__cxa_call_terminate>
 800ef3e:	f1b9 0f00 	cmp.w	r9, #0
 800ef42:	da1f      	bge.n	800ef84 <__gxx_personality_v0+0x278>
 800ef44:	aa0a      	add	r2, sp, #40	; 0x28
 800ef46:	4641      	mov	r1, r8
 800ef48:	4630      	mov	r0, r6
 800ef4a:	f7ff feb0 	bl	800ecae <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 800ef4e:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 800ef52:	28ff      	cmp	r0, #255	; 0xff
 800ef54:	d00f      	beq.n	800ef76 <__gxx_personality_v0+0x26a>
 800ef56:	4631      	mov	r1, r6
 800ef58:	f7ff fe73 	bl	800ec42 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3>
 800ef5c:	f06f 0303 	mvn.w	r3, #3
 800ef60:	fb09 3203 	mla	r2, r9, r3, r3
 800ef64:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ef66:	900c      	str	r0, [sp, #48]	; 0x30
 800ef68:	4413      	add	r3, r2
 800ef6a:	2200      	movs	r2, #0
 800ef6c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800ef70:	b119      	cbz	r1, 800ef7a <__gxx_personality_v0+0x26e>
 800ef72:	3201      	adds	r2, #1
 800ef74:	e7fa      	b.n	800ef6c <__gxx_personality_v0+0x260>
 800ef76:	4628      	mov	r0, r5
 800ef78:	e7f0      	b.n	800ef5c <__gxx_personality_v0+0x250>
 800ef7a:	e9c4 200a 	strd	r2, r0, [r4, #40]	; 0x28
 800ef7e:	2204      	movs	r2, #4
 800ef80:	e9c4 230c 	strd	r2, r3, [r4, #48]	; 0x30
 800ef84:	ab10      	add	r3, sp, #64	; 0x40
 800ef86:	4630      	mov	r0, r6
 800ef88:	f843 4d1c 	str.w	r4, [r3, #-28]!
 800ef8c:	9300      	str	r3, [sp, #0]
 800ef8e:	2300      	movs	r3, #0
 800ef90:	461a      	mov	r2, r3
 800ef92:	4619      	mov	r1, r3
 800ef94:	f7f1 fd24 	bl	80009e0 <_Unwind_VRS_Set>
 800ef98:	ab10      	add	r3, sp, #64	; 0x40
 800ef9a:	2201      	movs	r2, #1
 800ef9c:	f843 9d20 	str.w	r9, [r3, #-32]!
 800efa0:	9300      	str	r3, [sp, #0]
 800efa2:	2300      	movs	r3, #0
 800efa4:	4619      	mov	r1, r3
 800efa6:	4630      	mov	r0, r6
 800efa8:	f7f1 fd1a 	bl	80009e0 <_Unwind_VRS_Set>
 800efac:	210f      	movs	r1, #15
 800efae:	4630      	mov	r0, r6
 800efb0:	f7ff fe3b 	bl	800ec2a <_Unwind_GetGR>
 800efb4:	ab10      	add	r3, sp, #64	; 0x40
 800efb6:	f000 0001 	and.w	r0, r0, #1
 800efba:	4307      	orrs	r7, r0
 800efbc:	f843 7d24 	str.w	r7, [r3, #-36]!
 800efc0:	9300      	str	r3, [sp, #0]
 800efc2:	2300      	movs	r3, #0
 800efc4:	220f      	movs	r2, #15
 800efc6:	4619      	mov	r1, r3
 800efc8:	4630      	mov	r0, r6
 800efca:	f7f1 fd09 	bl	80009e0 <_Unwind_VRS_Set>
 800efce:	f1ba 0f02 	cmp.w	sl, #2
 800efd2:	d102      	bne.n	800efda <__gxx_personality_v0+0x2ce>
 800efd4:	4620      	mov	r0, r4
 800efd6:	f7ff fd81 	bl	800eadc <__cxa_begin_cleanup>
 800efda:	2007      	movs	r0, #7
 800efdc:	e6af      	b.n	800ed3e <__gxx_personality_v0+0x32>
 800efde:	f1ba 0f00 	cmp.w	sl, #0
 800efe2:	f43f aea6 	beq.w	800ed32 <__gxx_personality_v0+0x26>
 800efe6:	4681      	mov	r9, r0
 800efe8:	f04f 0a02 	mov.w	sl, #2
 800efec:	e789      	b.n	800ef02 <__gxx_personality_v0+0x1f6>
 800efee:	aa10      	add	r2, sp, #64	; 0x40
 800eff0:	4643      	mov	r3, r8
 800eff2:	f842 4d2c 	str.w	r4, [r2, #-44]!
 800eff6:	4641      	mov	r1, r8
 800eff8:	9200      	str	r2, [sp, #0]
 800effa:	4630      	mov	r0, r6
 800effc:	220c      	movs	r2, #12
 800effe:	f045 0502 	orr.w	r5, r5, #2
 800f002:	f7f1 fced 	bl	80009e0 <_Unwind_VRS_Set>
 800f006:	4630      	mov	r0, r6
 800f008:	f7f2 fa74 	bl	80014f4 <_Unwind_GetLanguageSpecificData>
 800f00c:	4680      	mov	r8, r0
 800f00e:	2800      	cmp	r0, #0
 800f010:	f43f ae8f 	beq.w	800ed32 <__gxx_personality_v0+0x26>
 800f014:	4601      	mov	r1, r0
 800f016:	aa0a      	add	r2, sp, #40	; 0x28
 800f018:	4630      	mov	r0, r6
 800f01a:	f7ff fe48 	bl	800ecae <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 800f01e:	4681      	mov	r9, r0
 800f020:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 800f024:	28ff      	cmp	r0, #255	; 0xff
 800f026:	f43f aec5 	beq.w	800edb4 <__gxx_personality_v0+0xa8>
 800f02a:	4631      	mov	r1, r6
 800f02c:	f7ff fe09 	bl	800ec42 <_ZL21base_of_encoded_valuehP15_Unwind_Context.part.3>
 800f030:	900c      	str	r0, [sp, #48]	; 0x30
 800f032:	210f      	movs	r1, #15
 800f034:	4630      	mov	r0, r6
 800f036:	f7ff fdf8 	bl	800ec2a <_Unwind_GetGR>
 800f03a:	f020 0001 	bic.w	r0, r0, #1
 800f03e:	1e47      	subs	r7, r0, #1
 800f040:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f042:	454b      	cmp	r3, r9
 800f044:	f67f af58 	bls.w	800eef8 <__gxx_personality_v0+0x1ec>
 800f048:	464a      	mov	r2, r9
 800f04a:	ab06      	add	r3, sp, #24
 800f04c:	f89d 103d 	ldrb.w	r1, [sp, #61]	; 0x3d
 800f050:	2000      	movs	r0, #0
 800f052:	f7ff fe18 	bl	800ec86 <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 800f056:	ab07      	add	r3, sp, #28
 800f058:	4602      	mov	r2, r0
 800f05a:	f89d 103d 	ldrb.w	r1, [sp, #61]	; 0x3d
 800f05e:	2000      	movs	r0, #0
 800f060:	f7ff fe11 	bl	800ec86 <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 800f064:	ab08      	add	r3, sp, #32
 800f066:	4602      	mov	r2, r0
 800f068:	f89d 103d 	ldrb.w	r1, [sp, #61]	; 0x3d
 800f06c:	2000      	movs	r0, #0
 800f06e:	f7ff fe0a 	bl	800ec86 <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 800f072:	a909      	add	r1, sp, #36	; 0x24
 800f074:	f7ff fd6c 	bl	800eb50 <_ZL12read_uleb128PKhPm>
 800f078:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f07a:	9a06      	ldr	r2, [sp, #24]
 800f07c:	4413      	add	r3, r2
 800f07e:	42bb      	cmp	r3, r7
 800f080:	4681      	mov	r9, r0
 800f082:	f67f ae99 	bls.w	800edb8 <__gxx_personality_v0+0xac>
 800f086:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
 800f08a:	e7d9      	b.n	800f040 <__gxx_personality_v0+0x334>

0800f08c <_ZN10__cxxabiv111__terminateEPFvvE>:
 800f08c:	b508      	push	{r3, lr}
 800f08e:	4780      	blx	r0
 800f090:	f000 f9b3 	bl	800f3fa <abort>

0800f094 <_ZSt13get_terminatev>:
 800f094:	4b02      	ldr	r3, [pc, #8]	; (800f0a0 <_ZSt13get_terminatev+0xc>)
 800f096:	6818      	ldr	r0, [r3, #0]
 800f098:	f3bf 8f5b 	dmb	ish
 800f09c:	4770      	bx	lr
 800f09e:	bf00      	nop
 800f0a0:	20000018 	.word	0x20000018

0800f0a4 <_ZSt9terminatev>:
 800f0a4:	b508      	push	{r3, lr}
 800f0a6:	f7ff fff5 	bl	800f094 <_ZSt13get_terminatev>
 800f0aa:	f7ff ffef 	bl	800f08c <_ZN10__cxxabiv111__terminateEPFvvE>

0800f0ae <_ZN10__cxxabiv112__unexpectedEPFvvE>:
 800f0ae:	b508      	push	{r3, lr}
 800f0b0:	4780      	blx	r0
 800f0b2:	f7ff fff7 	bl	800f0a4 <_ZSt9terminatev>
	...

0800f0b8 <_ZSt14get_unexpectedv>:
 800f0b8:	4b02      	ldr	r3, [pc, #8]	; (800f0c4 <_ZSt14get_unexpectedv+0xc>)
 800f0ba:	6818      	ldr	r0, [r3, #0]
 800f0bc:	f3bf 8f5b 	dmb	ish
 800f0c0:	4770      	bx	lr
 800f0c2:	bf00      	nop
 800f0c4:	20000014 	.word	0x20000014

0800f0c8 <_ZSt10unexpectedv>:
 800f0c8:	b508      	push	{r3, lr}
 800f0ca:	f7ff fff5 	bl	800f0b8 <_ZSt14get_unexpectedv>
 800f0ce:	f7ff ffee 	bl	800f0ae <_ZN10__cxxabiv112__unexpectedEPFvvE>
	...

0800f0d4 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>:
 800f0d4:	b510      	push	{r4, lr}
 800f0d6:	4b03      	ldr	r3, [pc, #12]	; (800f0e4 <_ZN10__cxxabiv120__si_class_type_infoD1Ev+0x10>)
 800f0d8:	6003      	str	r3, [r0, #0]
 800f0da:	4604      	mov	r4, r0
 800f0dc:	f000 f8b2 	bl	800f244 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 800f0e0:	4620      	mov	r0, r4
 800f0e2:	bd10      	pop	{r4, pc}
 800f0e4:	08011d3c 	.word	0x08011d3c

0800f0e8 <_ZN10__cxxabiv120__si_class_type_infoD0Ev>:
 800f0e8:	b510      	push	{r4, lr}
 800f0ea:	4604      	mov	r4, r0
 800f0ec:	f7ff fff2 	bl	800f0d4 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>
 800f0f0:	4620      	mov	r0, r4
 800f0f2:	210c      	movs	r1, #12
 800f0f4:	f000 f8f8 	bl	800f2e8 <_ZdlPvj>
 800f0f8:	4620      	mov	r0, r4
 800f0fa:	bd10      	pop	{r4, pc}

0800f0fc <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_>:
 800f0fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f100:	9e06      	ldr	r6, [sp, #24]
 800f102:	4296      	cmp	r6, r2
 800f104:	4607      	mov	r7, r0
 800f106:	4688      	mov	r8, r1
 800f108:	4615      	mov	r5, r2
 800f10a:	461c      	mov	r4, r3
 800f10c:	d00a      	beq.n	800f124 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x28>
 800f10e:	68b8      	ldr	r0, [r7, #8]
 800f110:	6803      	ldr	r3, [r0, #0]
 800f112:	9606      	str	r6, [sp, #24]
 800f114:	6a1e      	ldr	r6, [r3, #32]
 800f116:	462a      	mov	r2, r5
 800f118:	4623      	mov	r3, r4
 800f11a:	4641      	mov	r1, r8
 800f11c:	46b4      	mov	ip, r6
 800f11e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800f122:	4760      	bx	ip
 800f124:	4619      	mov	r1, r3
 800f126:	f000 f857 	bl	800f1d8 <_ZNKSt9type_infoeqERKS_>
 800f12a:	2800      	cmp	r0, #0
 800f12c:	d0ef      	beq.n	800f10e <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x12>
 800f12e:	2006      	movs	r0, #6
 800f130:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800f134 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE>:
 800f134:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f138:	460e      	mov	r6, r1
 800f13a:	4619      	mov	r1, r3
 800f13c:	4683      	mov	fp, r0
 800f13e:	4617      	mov	r7, r2
 800f140:	4699      	mov	r9, r3
 800f142:	e9dd 4a0a 	ldrd	r4, sl, [sp, #40]	; 0x28
 800f146:	e9dd 850c 	ldrd	r8, r5, [sp, #48]	; 0x30
 800f14a:	f000 f845 	bl	800f1d8 <_ZNKSt9type_infoeqERKS_>
 800f14e:	b190      	cbz	r0, 800f176 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x42>
 800f150:	2e00      	cmp	r6, #0
 800f152:	602c      	str	r4, [r5, #0]
 800f154:	712f      	strb	r7, [r5, #4]
 800f156:	db09      	blt.n	800f16c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x38>
 800f158:	4434      	add	r4, r6
 800f15a:	45a0      	cmp	r8, r4
 800f15c:	bf0c      	ite	eq
 800f15e:	2406      	moveq	r4, #6
 800f160:	2401      	movne	r4, #1
 800f162:	71ac      	strb	r4, [r5, #6]
 800f164:	2000      	movs	r0, #0
 800f166:	b001      	add	sp, #4
 800f168:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f16c:	3602      	adds	r6, #2
 800f16e:	d1f9      	bne.n	800f164 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x30>
 800f170:	2301      	movs	r3, #1
 800f172:	71ab      	strb	r3, [r5, #6]
 800f174:	e7f6      	b.n	800f164 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x30>
 800f176:	4544      	cmp	r4, r8
 800f178:	d106      	bne.n	800f188 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x54>
 800f17a:	4651      	mov	r1, sl
 800f17c:	4658      	mov	r0, fp
 800f17e:	f000 f82b 	bl	800f1d8 <_ZNKSt9type_infoeqERKS_>
 800f182:	b108      	cbz	r0, 800f188 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x54>
 800f184:	716f      	strb	r7, [r5, #5]
 800f186:	e7ed      	b.n	800f164 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x30>
 800f188:	f8db 0008 	ldr.w	r0, [fp, #8]
 800f18c:	6803      	ldr	r3, [r0, #0]
 800f18e:	e9cd 850c 	strd	r8, r5, [sp, #48]	; 0x30
 800f192:	e9cd 4a0a 	strd	r4, sl, [sp, #40]	; 0x28
 800f196:	69dc      	ldr	r4, [r3, #28]
 800f198:	463a      	mov	r2, r7
 800f19a:	464b      	mov	r3, r9
 800f19c:	4631      	mov	r1, r6
 800f19e:	46a4      	mov	ip, r4
 800f1a0:	b001      	add	sp, #4
 800f1a2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f1a6:	4760      	bx	ip

0800f1a8 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE>:
 800f1a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f1ac:	4604      	mov	r4, r0
 800f1ae:	460d      	mov	r5, r1
 800f1b0:	4616      	mov	r6, r2
 800f1b2:	461f      	mov	r7, r3
 800f1b4:	f000 f877 	bl	800f2a6 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>
 800f1b8:	b948      	cbnz	r0, 800f1ce <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x26>
 800f1ba:	68a0      	ldr	r0, [r4, #8]
 800f1bc:	6803      	ldr	r3, [r0, #0]
 800f1be:	699c      	ldr	r4, [r3, #24]
 800f1c0:	4632      	mov	r2, r6
 800f1c2:	463b      	mov	r3, r7
 800f1c4:	4629      	mov	r1, r5
 800f1c6:	46a4      	mov	ip, r4
 800f1c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800f1cc:	4760      	bx	ip
 800f1ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800f1d2 <_ZNSt9type_infoD1Ev>:
 800f1d2:	4770      	bx	lr

0800f1d4 <_ZNKSt9type_info14__is_pointer_pEv>:
 800f1d4:	2000      	movs	r0, #0
 800f1d6:	4770      	bx	lr

0800f1d8 <_ZNKSt9type_infoeqERKS_>:
 800f1d8:	4281      	cmp	r1, r0
 800f1da:	b508      	push	{r3, lr}
 800f1dc:	d00e      	beq.n	800f1fc <_ZNKSt9type_infoeqERKS_+0x24>
 800f1de:	6840      	ldr	r0, [r0, #4]
 800f1e0:	7803      	ldrb	r3, [r0, #0]
 800f1e2:	2b2a      	cmp	r3, #42	; 0x2a
 800f1e4:	d00c      	beq.n	800f200 <_ZNKSt9type_infoeqERKS_+0x28>
 800f1e6:	6849      	ldr	r1, [r1, #4]
 800f1e8:	780b      	ldrb	r3, [r1, #0]
 800f1ea:	2b2a      	cmp	r3, #42	; 0x2a
 800f1ec:	bf08      	it	eq
 800f1ee:	3101      	addeq	r1, #1
 800f1f0:	f7f1 f826 	bl	8000240 <strcmp>
 800f1f4:	fab0 f080 	clz	r0, r0
 800f1f8:	0940      	lsrs	r0, r0, #5
 800f1fa:	bd08      	pop	{r3, pc}
 800f1fc:	2001      	movs	r0, #1
 800f1fe:	e7fc      	b.n	800f1fa <_ZNKSt9type_infoeqERKS_+0x22>
 800f200:	2000      	movs	r0, #0
 800f202:	e7fa      	b.n	800f1fa <_ZNKSt9type_infoeqERKS_+0x22>

0800f204 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv>:
 800f204:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800f206:	2400      	movs	r4, #0
 800f208:	2310      	movs	r3, #16
 800f20a:	e9cd 3402 	strd	r3, r4, [sp, #8]
 800f20e:	6803      	ldr	r3, [r0, #0]
 800f210:	9400      	str	r4, [sp, #0]
 800f212:	4615      	mov	r5, r2
 800f214:	699e      	ldr	r6, [r3, #24]
 800f216:	f88d 4004 	strb.w	r4, [sp, #4]
 800f21a:	466b      	mov	r3, sp
 800f21c:	6812      	ldr	r2, [r2, #0]
 800f21e:	47b0      	blx	r6
 800f220:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800f224:	f003 0306 	and.w	r3, r3, #6
 800f228:	2b06      	cmp	r3, #6
 800f22a:	bf03      	ittte	eq
 800f22c:	9b00      	ldreq	r3, [sp, #0]
 800f22e:	602b      	streq	r3, [r5, #0]
 800f230:	2001      	moveq	r0, #1
 800f232:	4620      	movne	r0, r4
 800f234:	b004      	add	sp, #16
 800f236:	bd70      	pop	{r4, r5, r6, pc}

0800f238 <_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_>:
 800f238:	9800      	ldr	r0, [sp, #0]
 800f23a:	4290      	cmp	r0, r2
 800f23c:	bf0c      	ite	eq
 800f23e:	2006      	moveq	r0, #6
 800f240:	2001      	movne	r0, #1
 800f242:	4770      	bx	lr

0800f244 <_ZN10__cxxabiv117__class_type_infoD1Ev>:
 800f244:	b510      	push	{r4, lr}
 800f246:	4b03      	ldr	r3, [pc, #12]	; (800f254 <_ZN10__cxxabiv117__class_type_infoD1Ev+0x10>)
 800f248:	6003      	str	r3, [r0, #0]
 800f24a:	4604      	mov	r4, r0
 800f24c:	f7ff ffc1 	bl	800f1d2 <_ZNSt9type_infoD1Ev>
 800f250:	4620      	mov	r0, r4
 800f252:	bd10      	pop	{r4, pc}
 800f254:	08011db0 	.word	0x08011db0

0800f258 <_ZN10__cxxabiv117__class_type_infoD0Ev>:
 800f258:	b510      	push	{r4, lr}
 800f25a:	4604      	mov	r4, r0
 800f25c:	f7ff fff2 	bl	800f244 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 800f260:	4620      	mov	r0, r4
 800f262:	2108      	movs	r1, #8
 800f264:	f000 f840 	bl	800f2e8 <_ZdlPvj>
 800f268:	4620      	mov	r0, r4
 800f26a:	bd10      	pop	{r4, pc}

0800f26c <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE>:
 800f26c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f270:	4698      	mov	r8, r3
 800f272:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
 800f276:	9e06      	ldr	r6, [sp, #24]
 800f278:	429e      	cmp	r6, r3
 800f27a:	4607      	mov	r7, r0
 800f27c:	4615      	mov	r5, r2
 800f27e:	d107      	bne.n	800f290 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x24>
 800f280:	9907      	ldr	r1, [sp, #28]
 800f282:	f7ff ffa9 	bl	800f1d8 <_ZNKSt9type_infoeqERKS_>
 800f286:	b118      	cbz	r0, 800f290 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x24>
 800f288:	7165      	strb	r5, [r4, #5]
 800f28a:	2000      	movs	r0, #0
 800f28c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f290:	4641      	mov	r1, r8
 800f292:	4638      	mov	r0, r7
 800f294:	f7ff ffa0 	bl	800f1d8 <_ZNKSt9type_infoeqERKS_>
 800f298:	2800      	cmp	r0, #0
 800f29a:	d0f6      	beq.n	800f28a <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x1e>
 800f29c:	2301      	movs	r3, #1
 800f29e:	6026      	str	r6, [r4, #0]
 800f2a0:	7125      	strb	r5, [r4, #4]
 800f2a2:	71a3      	strb	r3, [r4, #6]
 800f2a4:	e7f1      	b.n	800f28a <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x1e>

0800f2a6 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>:
 800f2a6:	b538      	push	{r3, r4, r5, lr}
 800f2a8:	4615      	mov	r5, r2
 800f2aa:	461c      	mov	r4, r3
 800f2ac:	f7ff ff94 	bl	800f1d8 <_ZNKSt9type_infoeqERKS_>
 800f2b0:	b120      	cbz	r0, 800f2bc <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE+0x16>
 800f2b2:	2308      	movs	r3, #8
 800f2b4:	60e3      	str	r3, [r4, #12]
 800f2b6:	2306      	movs	r3, #6
 800f2b8:	6025      	str	r5, [r4, #0]
 800f2ba:	7123      	strb	r3, [r4, #4]
 800f2bc:	bd38      	pop	{r3, r4, r5, pc}

0800f2be <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj>:
 800f2be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f2c2:	4605      	mov	r5, r0
 800f2c4:	460c      	mov	r4, r1
 800f2c6:	4616      	mov	r6, r2
 800f2c8:	461f      	mov	r7, r3
 800f2ca:	f7ff ff85 	bl	800f1d8 <_ZNKSt9type_infoeqERKS_>
 800f2ce:	b948      	cbnz	r0, 800f2e4 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
 800f2d0:	2f03      	cmp	r7, #3
 800f2d2:	d807      	bhi.n	800f2e4 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
 800f2d4:	6823      	ldr	r3, [r4, #0]
 800f2d6:	4632      	mov	r2, r6
 800f2d8:	4629      	mov	r1, r5
 800f2da:	4620      	mov	r0, r4
 800f2dc:	695b      	ldr	r3, [r3, #20]
 800f2de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800f2e2:	4718      	bx	r3
 800f2e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800f2e8 <_ZdlPvj>:
 800f2e8:	f7fa bdc6 	b.w	8009e78 <_ZdlPv>

0800f2ec <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 800f2ec:	7803      	ldrb	r3, [r0, #0]
 800f2ee:	2b47      	cmp	r3, #71	; 0x47
 800f2f0:	d117      	bne.n	800f322 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f2f2:	7843      	ldrb	r3, [r0, #1]
 800f2f4:	2b4e      	cmp	r3, #78	; 0x4e
 800f2f6:	d114      	bne.n	800f322 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f2f8:	7883      	ldrb	r3, [r0, #2]
 800f2fa:	2b55      	cmp	r3, #85	; 0x55
 800f2fc:	d111      	bne.n	800f322 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f2fe:	78c3      	ldrb	r3, [r0, #3]
 800f300:	2b43      	cmp	r3, #67	; 0x43
 800f302:	d10e      	bne.n	800f322 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f304:	7903      	ldrb	r3, [r0, #4]
 800f306:	2b43      	cmp	r3, #67	; 0x43
 800f308:	d10b      	bne.n	800f322 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f30a:	7943      	ldrb	r3, [r0, #5]
 800f30c:	2b2b      	cmp	r3, #43	; 0x2b
 800f30e:	d108      	bne.n	800f322 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f310:	7983      	ldrb	r3, [r0, #6]
 800f312:	2b2b      	cmp	r3, #43	; 0x2b
 800f314:	d105      	bne.n	800f322 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f316:	79c0      	ldrb	r0, [r0, #7]
 800f318:	2801      	cmp	r0, #1
 800f31a:	bf8c      	ite	hi
 800f31c:	2000      	movhi	r0, #0
 800f31e:	2001      	movls	r0, #1
 800f320:	4770      	bx	lr
 800f322:	2000      	movs	r0, #0
 800f324:	4770      	bx	lr

0800f326 <__cxa_call_terminate>:
 800f326:	b510      	push	{r4, lr}
 800f328:	4604      	mov	r4, r0
 800f32a:	b148      	cbz	r0, 800f340 <__cxa_call_terminate+0x1a>
 800f32c:	f000 f83b 	bl	800f3a6 <__cxa_begin_catch>
 800f330:	4620      	mov	r0, r4
 800f332:	f7ff ffdb 	bl	800f2ec <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800f336:	b118      	cbz	r0, 800f340 <__cxa_call_terminate+0x1a>
 800f338:	f854 0c14 	ldr.w	r0, [r4, #-20]
 800f33c:	f7ff fea6 	bl	800f08c <_ZN10__cxxabiv111__terminateEPFvvE>
 800f340:	f7ff feb0 	bl	800f0a4 <_ZSt9terminatev>

0800f344 <__cxa_call_unexpected>:
 800f344:	b538      	push	{r3, r4, r5, lr}
 800f346:	4602      	mov	r2, r0
 800f348:	f7ff ffd0 	bl	800f2ec <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800f34c:	b140      	cbz	r0, 800f360 <__cxa_call_unexpected+0x1c>
 800f34e:	f852 4c18 	ldr.w	r4, [r2, #-24]
 800f352:	2500      	movs	r5, #0
 800f354:	4610      	mov	r0, r2
 800f356:	f000 f826 	bl	800f3a6 <__cxa_begin_catch>
 800f35a:	b125      	cbz	r5, 800f366 <__cxa_call_unexpected+0x22>
 800f35c:	f7ff feb4 	bl	800f0c8 <_ZSt10unexpectedv>
 800f360:	4604      	mov	r4, r0
 800f362:	2501      	movs	r5, #1
 800f364:	e7f6      	b.n	800f354 <__cxa_call_unexpected+0x10>
 800f366:	4620      	mov	r0, r4
 800f368:	f7ff fea1 	bl	800f0ae <_ZN10__cxxabiv112__unexpectedEPFvvE>

0800f36c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 800f36c:	7803      	ldrb	r3, [r0, #0]
 800f36e:	2b47      	cmp	r3, #71	; 0x47
 800f370:	d117      	bne.n	800f3a2 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f372:	7843      	ldrb	r3, [r0, #1]
 800f374:	2b4e      	cmp	r3, #78	; 0x4e
 800f376:	d114      	bne.n	800f3a2 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f378:	7883      	ldrb	r3, [r0, #2]
 800f37a:	2b55      	cmp	r3, #85	; 0x55
 800f37c:	d111      	bne.n	800f3a2 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f37e:	78c3      	ldrb	r3, [r0, #3]
 800f380:	2b43      	cmp	r3, #67	; 0x43
 800f382:	d10e      	bne.n	800f3a2 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f384:	7903      	ldrb	r3, [r0, #4]
 800f386:	2b43      	cmp	r3, #67	; 0x43
 800f388:	d10b      	bne.n	800f3a2 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f38a:	7943      	ldrb	r3, [r0, #5]
 800f38c:	2b2b      	cmp	r3, #43	; 0x2b
 800f38e:	d108      	bne.n	800f3a2 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f390:	7983      	ldrb	r3, [r0, #6]
 800f392:	2b2b      	cmp	r3, #43	; 0x2b
 800f394:	d105      	bne.n	800f3a2 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800f396:	79c0      	ldrb	r0, [r0, #7]
 800f398:	2801      	cmp	r0, #1
 800f39a:	bf8c      	ite	hi
 800f39c:	2000      	movhi	r0, #0
 800f39e:	2001      	movls	r0, #1
 800f3a0:	4770      	bx	lr
 800f3a2:	2000      	movs	r0, #0
 800f3a4:	4770      	bx	lr

0800f3a6 <__cxa_begin_catch>:
 800f3a6:	b538      	push	{r3, r4, r5, lr}
 800f3a8:	4605      	mov	r5, r0
 800f3aa:	f7ff fbcd 	bl	800eb48 <__cxa_get_globals>
 800f3ae:	4601      	mov	r1, r0
 800f3b0:	6802      	ldr	r2, [r0, #0]
 800f3b2:	4628      	mov	r0, r5
 800f3b4:	f1a5 0420 	sub.w	r4, r5, #32
 800f3b8:	f7ff ffd8 	bl	800f36c <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800f3bc:	b930      	cbnz	r0, 800f3cc <__cxa_begin_catch+0x26>
 800f3be:	b10a      	cbz	r2, 800f3c4 <__cxa_begin_catch+0x1e>
 800f3c0:	f7ff fe70 	bl	800f0a4 <_ZSt9terminatev>
 800f3c4:	600c      	str	r4, [r1, #0]
 800f3c6:	4614      	mov	r4, r2
 800f3c8:	4620      	mov	r0, r4
 800f3ca:	bd38      	pop	{r3, r4, r5, pc}
 800f3cc:	f855 3c0c 	ldr.w	r3, [r5, #-12]
 800f3d0:	2b00      	cmp	r3, #0
 800f3d2:	bfb4      	ite	lt
 800f3d4:	f1c3 0301 	rsblt	r3, r3, #1
 800f3d8:	3301      	addge	r3, #1
 800f3da:	f845 3c0c 	str.w	r3, [r5, #-12]
 800f3de:	684b      	ldr	r3, [r1, #4]
 800f3e0:	42a2      	cmp	r2, r4
 800f3e2:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 800f3e6:	604b      	str	r3, [r1, #4]
 800f3e8:	4628      	mov	r0, r5
 800f3ea:	bf1c      	itt	ne
 800f3ec:	f845 2c10 	strne.w	r2, [r5, #-16]
 800f3f0:	600c      	strne	r4, [r1, #0]
 800f3f2:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 800f3f4:	f7f1 faca 	bl	800098c <_Unwind_Complete>
 800f3f8:	e7e6      	b.n	800f3c8 <__cxa_begin_catch+0x22>

0800f3fa <abort>:
 800f3fa:	b508      	push	{r3, lr}
 800f3fc:	2006      	movs	r0, #6
 800f3fe:	f000 f8c9 	bl	800f594 <raise>
 800f402:	2001      	movs	r0, #1
 800f404:	f7fb fc70 	bl	800ace8 <_exit>

0800f408 <atexit>:
 800f408:	2300      	movs	r3, #0
 800f40a:	4601      	mov	r1, r0
 800f40c:	461a      	mov	r2, r3
 800f40e:	4618      	mov	r0, r3
 800f410:	f000 b918 	b.w	800f644 <__register_exitproc>

0800f414 <__errno>:
 800f414:	4b01      	ldr	r3, [pc, #4]	; (800f41c <__errno+0x8>)
 800f416:	6818      	ldr	r0, [r3, #0]
 800f418:	4770      	bx	lr
 800f41a:	bf00      	nop
 800f41c:	2000001c 	.word	0x2000001c

0800f420 <__libc_init_array>:
 800f420:	b570      	push	{r4, r5, r6, lr}
 800f422:	4e0d      	ldr	r6, [pc, #52]	; (800f458 <__libc_init_array+0x38>)
 800f424:	4c0d      	ldr	r4, [pc, #52]	; (800f45c <__libc_init_array+0x3c>)
 800f426:	1ba4      	subs	r4, r4, r6
 800f428:	10a4      	asrs	r4, r4, #2
 800f42a:	2500      	movs	r5, #0
 800f42c:	42a5      	cmp	r5, r4
 800f42e:	d109      	bne.n	800f444 <__libc_init_array+0x24>
 800f430:	4e0b      	ldr	r6, [pc, #44]	; (800f460 <__libc_init_array+0x40>)
 800f432:	4c0c      	ldr	r4, [pc, #48]	; (800f464 <__libc_init_array+0x44>)
 800f434:	f001 f9d8 	bl	80107e8 <_init>
 800f438:	1ba4      	subs	r4, r4, r6
 800f43a:	10a4      	asrs	r4, r4, #2
 800f43c:	2500      	movs	r5, #0
 800f43e:	42a5      	cmp	r5, r4
 800f440:	d105      	bne.n	800f44e <__libc_init_array+0x2e>
 800f442:	bd70      	pop	{r4, r5, r6, pc}
 800f444:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800f448:	4798      	blx	r3
 800f44a:	3501      	adds	r5, #1
 800f44c:	e7ee      	b.n	800f42c <__libc_init_array+0xc>
 800f44e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800f452:	4798      	blx	r3
 800f454:	3501      	adds	r5, #1
 800f456:	e7f2      	b.n	800f43e <__libc_init_array+0x1e>
 800f458:	08012818 	.word	0x08012818
 800f45c:	08012818 	.word	0x08012818
 800f460:	08012818 	.word	0x08012818
 800f464:	0801281c 	.word	0x0801281c

0800f468 <memcmp>:
 800f468:	b530      	push	{r4, r5, lr}
 800f46a:	2400      	movs	r4, #0
 800f46c:	42a2      	cmp	r2, r4
 800f46e:	d101      	bne.n	800f474 <memcmp+0xc>
 800f470:	2000      	movs	r0, #0
 800f472:	e007      	b.n	800f484 <memcmp+0x1c>
 800f474:	5d03      	ldrb	r3, [r0, r4]
 800f476:	3401      	adds	r4, #1
 800f478:	190d      	adds	r5, r1, r4
 800f47a:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 800f47e:	42ab      	cmp	r3, r5
 800f480:	d0f4      	beq.n	800f46c <memcmp+0x4>
 800f482:	1b58      	subs	r0, r3, r5
 800f484:	bd30      	pop	{r4, r5, pc}

0800f486 <memcpy>:
 800f486:	b510      	push	{r4, lr}
 800f488:	1e43      	subs	r3, r0, #1
 800f48a:	440a      	add	r2, r1
 800f48c:	4291      	cmp	r1, r2
 800f48e:	d100      	bne.n	800f492 <memcpy+0xc>
 800f490:	bd10      	pop	{r4, pc}
 800f492:	f811 4b01 	ldrb.w	r4, [r1], #1
 800f496:	f803 4f01 	strb.w	r4, [r3, #1]!
 800f49a:	e7f7      	b.n	800f48c <memcpy+0x6>

0800f49c <memset>:
 800f49c:	4402      	add	r2, r0
 800f49e:	4603      	mov	r3, r0
 800f4a0:	4293      	cmp	r3, r2
 800f4a2:	d100      	bne.n	800f4a6 <memset+0xa>
 800f4a4:	4770      	bx	lr
 800f4a6:	f803 1b01 	strb.w	r1, [r3], #1
 800f4aa:	e7f9      	b.n	800f4a0 <memset+0x4>

0800f4ac <iprintf>:
 800f4ac:	b40f      	push	{r0, r1, r2, r3}
 800f4ae:	4b0a      	ldr	r3, [pc, #40]	; (800f4d8 <iprintf+0x2c>)
 800f4b0:	b513      	push	{r0, r1, r4, lr}
 800f4b2:	681c      	ldr	r4, [r3, #0]
 800f4b4:	b124      	cbz	r4, 800f4c0 <iprintf+0x14>
 800f4b6:	69a3      	ldr	r3, [r4, #24]
 800f4b8:	b913      	cbnz	r3, 800f4c0 <iprintf+0x14>
 800f4ba:	4620      	mov	r0, r4
 800f4bc:	f000 f966 	bl	800f78c <__sinit>
 800f4c0:	ab05      	add	r3, sp, #20
 800f4c2:	9a04      	ldr	r2, [sp, #16]
 800f4c4:	68a1      	ldr	r1, [r4, #8]
 800f4c6:	9301      	str	r3, [sp, #4]
 800f4c8:	4620      	mov	r0, r4
 800f4ca:	f000 fc15 	bl	800fcf8 <_vfiprintf_r>
 800f4ce:	b002      	add	sp, #8
 800f4d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800f4d4:	b004      	add	sp, #16
 800f4d6:	4770      	bx	lr
 800f4d8:	2000001c 	.word	0x2000001c

0800f4dc <rand>:
 800f4dc:	b538      	push	{r3, r4, r5, lr}
 800f4de:	4b13      	ldr	r3, [pc, #76]	; (800f52c <rand+0x50>)
 800f4e0:	681c      	ldr	r4, [r3, #0]
 800f4e2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800f4e4:	b97b      	cbnz	r3, 800f506 <rand+0x2a>
 800f4e6:	2018      	movs	r0, #24
 800f4e8:	f000 f9da 	bl	800f8a0 <malloc>
 800f4ec:	4a10      	ldr	r2, [pc, #64]	; (800f530 <rand+0x54>)
 800f4ee:	4b11      	ldr	r3, [pc, #68]	; (800f534 <rand+0x58>)
 800f4f0:	63a0      	str	r0, [r4, #56]	; 0x38
 800f4f2:	e9c0 2300 	strd	r2, r3, [r0]
 800f4f6:	4b10      	ldr	r3, [pc, #64]	; (800f538 <rand+0x5c>)
 800f4f8:	6083      	str	r3, [r0, #8]
 800f4fa:	230b      	movs	r3, #11
 800f4fc:	8183      	strh	r3, [r0, #12]
 800f4fe:	2201      	movs	r2, #1
 800f500:	2300      	movs	r3, #0
 800f502:	e9c0 2304 	strd	r2, r3, [r0, #16]
 800f506:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800f508:	480c      	ldr	r0, [pc, #48]	; (800f53c <rand+0x60>)
 800f50a:	690a      	ldr	r2, [r1, #16]
 800f50c:	694b      	ldr	r3, [r1, #20]
 800f50e:	4c0c      	ldr	r4, [pc, #48]	; (800f540 <rand+0x64>)
 800f510:	4350      	muls	r0, r2
 800f512:	fb04 0003 	mla	r0, r4, r3, r0
 800f516:	fba2 2304 	umull	r2, r3, r2, r4
 800f51a:	4403      	add	r3, r0
 800f51c:	1c54      	adds	r4, r2, #1
 800f51e:	f143 0500 	adc.w	r5, r3, #0
 800f522:	e9c1 4504 	strd	r4, r5, [r1, #16]
 800f526:	f025 4000 	bic.w	r0, r5, #2147483648	; 0x80000000
 800f52a:	bd38      	pop	{r3, r4, r5, pc}
 800f52c:	2000001c 	.word	0x2000001c
 800f530:	abcd330e 	.word	0xabcd330e
 800f534:	e66d1234 	.word	0xe66d1234
 800f538:	0005deec 	.word	0x0005deec
 800f53c:	5851f42d 	.word	0x5851f42d
 800f540:	4c957f2d 	.word	0x4c957f2d

0800f544 <_raise_r>:
 800f544:	291f      	cmp	r1, #31
 800f546:	b538      	push	{r3, r4, r5, lr}
 800f548:	4604      	mov	r4, r0
 800f54a:	460d      	mov	r5, r1
 800f54c:	d904      	bls.n	800f558 <_raise_r+0x14>
 800f54e:	2316      	movs	r3, #22
 800f550:	6003      	str	r3, [r0, #0]
 800f552:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800f556:	bd38      	pop	{r3, r4, r5, pc}
 800f558:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800f55a:	b112      	cbz	r2, 800f562 <_raise_r+0x1e>
 800f55c:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 800f560:	b94b      	cbnz	r3, 800f576 <_raise_r+0x32>
 800f562:	4620      	mov	r0, r4
 800f564:	f000 f830 	bl	800f5c8 <_getpid_r>
 800f568:	462a      	mov	r2, r5
 800f56a:	4601      	mov	r1, r0
 800f56c:	4620      	mov	r0, r4
 800f56e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800f572:	f000 b817 	b.w	800f5a4 <_kill_r>
 800f576:	2b01      	cmp	r3, #1
 800f578:	d00a      	beq.n	800f590 <_raise_r+0x4c>
 800f57a:	1c59      	adds	r1, r3, #1
 800f57c:	d103      	bne.n	800f586 <_raise_r+0x42>
 800f57e:	2316      	movs	r3, #22
 800f580:	6003      	str	r3, [r0, #0]
 800f582:	2001      	movs	r0, #1
 800f584:	e7e7      	b.n	800f556 <_raise_r+0x12>
 800f586:	2400      	movs	r4, #0
 800f588:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 800f58c:	4628      	mov	r0, r5
 800f58e:	4798      	blx	r3
 800f590:	2000      	movs	r0, #0
 800f592:	e7e0      	b.n	800f556 <_raise_r+0x12>

0800f594 <raise>:
 800f594:	4b02      	ldr	r3, [pc, #8]	; (800f5a0 <raise+0xc>)
 800f596:	4601      	mov	r1, r0
 800f598:	6818      	ldr	r0, [r3, #0]
 800f59a:	f7ff bfd3 	b.w	800f544 <_raise_r>
 800f59e:	bf00      	nop
 800f5a0:	2000001c 	.word	0x2000001c

0800f5a4 <_kill_r>:
 800f5a4:	b538      	push	{r3, r4, r5, lr}
 800f5a6:	4c07      	ldr	r4, [pc, #28]	; (800f5c4 <_kill_r+0x20>)
 800f5a8:	2300      	movs	r3, #0
 800f5aa:	4605      	mov	r5, r0
 800f5ac:	4608      	mov	r0, r1
 800f5ae:	4611      	mov	r1, r2
 800f5b0:	6023      	str	r3, [r4, #0]
 800f5b2:	f7fb fb91 	bl	800acd8 <_kill>
 800f5b6:	1c43      	adds	r3, r0, #1
 800f5b8:	d102      	bne.n	800f5c0 <_kill_r+0x1c>
 800f5ba:	6823      	ldr	r3, [r4, #0]
 800f5bc:	b103      	cbz	r3, 800f5c0 <_kill_r+0x1c>
 800f5be:	602b      	str	r3, [r5, #0]
 800f5c0:	bd38      	pop	{r3, r4, r5, pc}
 800f5c2:	bf00      	nop
 800f5c4:	2000b798 	.word	0x2000b798

0800f5c8 <_getpid_r>:
 800f5c8:	f7fb bb84 	b.w	800acd4 <_getpid>

0800f5cc <sniprintf>:
 800f5cc:	b40c      	push	{r2, r3}
 800f5ce:	b530      	push	{r4, r5, lr}
 800f5d0:	4b17      	ldr	r3, [pc, #92]	; (800f630 <sniprintf+0x64>)
 800f5d2:	1e0c      	subs	r4, r1, #0
 800f5d4:	b09d      	sub	sp, #116	; 0x74
 800f5d6:	681d      	ldr	r5, [r3, #0]
 800f5d8:	da08      	bge.n	800f5ec <sniprintf+0x20>
 800f5da:	238b      	movs	r3, #139	; 0x8b
 800f5dc:	602b      	str	r3, [r5, #0]
 800f5de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800f5e2:	b01d      	add	sp, #116	; 0x74
 800f5e4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800f5e8:	b002      	add	sp, #8
 800f5ea:	4770      	bx	lr
 800f5ec:	f44f 7302 	mov.w	r3, #520	; 0x208
 800f5f0:	f8ad 3014 	strh.w	r3, [sp, #20]
 800f5f4:	bf14      	ite	ne
 800f5f6:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
 800f5fa:	4623      	moveq	r3, r4
 800f5fc:	9304      	str	r3, [sp, #16]
 800f5fe:	9307      	str	r3, [sp, #28]
 800f600:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800f604:	9002      	str	r0, [sp, #8]
 800f606:	9006      	str	r0, [sp, #24]
 800f608:	f8ad 3016 	strh.w	r3, [sp, #22]
 800f60c:	9a20      	ldr	r2, [sp, #128]	; 0x80
 800f60e:	ab21      	add	r3, sp, #132	; 0x84
 800f610:	a902      	add	r1, sp, #8
 800f612:	4628      	mov	r0, r5
 800f614:	9301      	str	r3, [sp, #4]
 800f616:	f000 fa4d 	bl	800fab4 <_svfiprintf_r>
 800f61a:	1c43      	adds	r3, r0, #1
 800f61c:	bfbc      	itt	lt
 800f61e:	238b      	movlt	r3, #139	; 0x8b
 800f620:	602b      	strlt	r3, [r5, #0]
 800f622:	2c00      	cmp	r4, #0
 800f624:	d0dd      	beq.n	800f5e2 <sniprintf+0x16>
 800f626:	9b02      	ldr	r3, [sp, #8]
 800f628:	2200      	movs	r2, #0
 800f62a:	701a      	strb	r2, [r3, #0]
 800f62c:	e7d9      	b.n	800f5e2 <sniprintf+0x16>
 800f62e:	bf00      	nop
 800f630:	2000001c 	.word	0x2000001c

0800f634 <strcpy>:
 800f634:	4603      	mov	r3, r0
 800f636:	f811 2b01 	ldrb.w	r2, [r1], #1
 800f63a:	f803 2b01 	strb.w	r2, [r3], #1
 800f63e:	2a00      	cmp	r2, #0
 800f640:	d1f9      	bne.n	800f636 <strcpy+0x2>
 800f642:	4770      	bx	lr

0800f644 <__register_exitproc>:
 800f644:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800f648:	4d2c      	ldr	r5, [pc, #176]	; (800f6fc <__register_exitproc+0xb8>)
 800f64a:	682c      	ldr	r4, [r5, #0]
 800f64c:	4607      	mov	r7, r0
 800f64e:	460e      	mov	r6, r1
 800f650:	4691      	mov	r9, r2
 800f652:	4698      	mov	r8, r3
 800f654:	b934      	cbnz	r4, 800f664 <__register_exitproc+0x20>
 800f656:	4b2a      	ldr	r3, [pc, #168]	; (800f700 <__register_exitproc+0xbc>)
 800f658:	4c2a      	ldr	r4, [pc, #168]	; (800f704 <__register_exitproc+0xc0>)
 800f65a:	602c      	str	r4, [r5, #0]
 800f65c:	b113      	cbz	r3, 800f664 <__register_exitproc+0x20>
 800f65e:	681b      	ldr	r3, [r3, #0]
 800f660:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 800f664:	6863      	ldr	r3, [r4, #4]
 800f666:	2b1f      	cmp	r3, #31
 800f668:	dd3d      	ble.n	800f6e6 <__register_exitproc+0xa2>
 800f66a:	4b27      	ldr	r3, [pc, #156]	; (800f708 <__register_exitproc+0xc4>)
 800f66c:	b91b      	cbnz	r3, 800f676 <__register_exitproc+0x32>
 800f66e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800f672:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800f676:	208c      	movs	r0, #140	; 0x8c
 800f678:	f000 f912 	bl	800f8a0 <malloc>
 800f67c:	4604      	mov	r4, r0
 800f67e:	2800      	cmp	r0, #0
 800f680:	d0f5      	beq.n	800f66e <__register_exitproc+0x2a>
 800f682:	2300      	movs	r3, #0
 800f684:	682a      	ldr	r2, [r5, #0]
 800f686:	6002      	str	r2, [r0, #0]
 800f688:	6043      	str	r3, [r0, #4]
 800f68a:	6028      	str	r0, [r5, #0]
 800f68c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
 800f690:	b30f      	cbz	r7, 800f6d6 <__register_exitproc+0x92>
 800f692:	f44f 7084 	mov.w	r0, #264	; 0x108
 800f696:	f000 f903 	bl	800f8a0 <malloc>
 800f69a:	2800      	cmp	r0, #0
 800f69c:	d0e7      	beq.n	800f66e <__register_exitproc+0x2a>
 800f69e:	2300      	movs	r3, #0
 800f6a0:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
 800f6a4:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 800f6a8:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 800f6ac:	6862      	ldr	r2, [r4, #4]
 800f6ae:	f840 9022 	str.w	r9, [r0, r2, lsl #2]
 800f6b2:	2301      	movs	r3, #1
 800f6b4:	4093      	lsls	r3, r2
 800f6b6:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 800f6ba:	f8d0 2100 	ldr.w	r2, [r0, #256]	; 0x100
 800f6be:	431a      	orrs	r2, r3
 800f6c0:	2f02      	cmp	r7, #2
 800f6c2:	f8c0 2100 	str.w	r2, [r0, #256]	; 0x100
 800f6c6:	f8c1 8080 	str.w	r8, [r1, #128]	; 0x80
 800f6ca:	bf02      	ittt	eq
 800f6cc:	f8d0 2104 	ldreq.w	r2, [r0, #260]	; 0x104
 800f6d0:	4313      	orreq	r3, r2
 800f6d2:	f8c0 3104 	streq.w	r3, [r0, #260]	; 0x104
 800f6d6:	6863      	ldr	r3, [r4, #4]
 800f6d8:	1c5a      	adds	r2, r3, #1
 800f6da:	3302      	adds	r3, #2
 800f6dc:	6062      	str	r2, [r4, #4]
 800f6de:	2000      	movs	r0, #0
 800f6e0:	f844 6023 	str.w	r6, [r4, r3, lsl #2]
 800f6e4:	e7c5      	b.n	800f672 <__register_exitproc+0x2e>
 800f6e6:	2f00      	cmp	r7, #0
 800f6e8:	d0f5      	beq.n	800f6d6 <__register_exitproc+0x92>
 800f6ea:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 800f6ee:	2800      	cmp	r0, #0
 800f6f0:	d1dc      	bne.n	800f6ac <__register_exitproc+0x68>
 800f6f2:	4b05      	ldr	r3, [pc, #20]	; (800f708 <__register_exitproc+0xc4>)
 800f6f4:	2b00      	cmp	r3, #0
 800f6f6:	d0ba      	beq.n	800f66e <__register_exitproc+0x2a>
 800f6f8:	e7cb      	b.n	800f692 <__register_exitproc+0x4e>
 800f6fa:	bf00      	nop
 800f6fc:	200059dc 	.word	0x200059dc
 800f700:	00000000 	.word	0x00000000
 800f704:	20005950 	.word	0x20005950
 800f708:	0800f8a1 	.word	0x0800f8a1

0800f70c <std>:
 800f70c:	2300      	movs	r3, #0
 800f70e:	b510      	push	{r4, lr}
 800f710:	4604      	mov	r4, r0
 800f712:	e9c0 3300 	strd	r3, r3, [r0]
 800f716:	6083      	str	r3, [r0, #8]
 800f718:	8181      	strh	r1, [r0, #12]
 800f71a:	6643      	str	r3, [r0, #100]	; 0x64
 800f71c:	81c2      	strh	r2, [r0, #14]
 800f71e:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800f722:	6183      	str	r3, [r0, #24]
 800f724:	4619      	mov	r1, r3
 800f726:	2208      	movs	r2, #8
 800f728:	305c      	adds	r0, #92	; 0x5c
 800f72a:	f7ff feb7 	bl	800f49c <memset>
 800f72e:	4b05      	ldr	r3, [pc, #20]	; (800f744 <std+0x38>)
 800f730:	6263      	str	r3, [r4, #36]	; 0x24
 800f732:	4b05      	ldr	r3, [pc, #20]	; (800f748 <std+0x3c>)
 800f734:	62a3      	str	r3, [r4, #40]	; 0x28
 800f736:	4b05      	ldr	r3, [pc, #20]	; (800f74c <std+0x40>)
 800f738:	62e3      	str	r3, [r4, #44]	; 0x2c
 800f73a:	4b05      	ldr	r3, [pc, #20]	; (800f750 <std+0x44>)
 800f73c:	6224      	str	r4, [r4, #32]
 800f73e:	6323      	str	r3, [r4, #48]	; 0x30
 800f740:	bd10      	pop	{r4, pc}
 800f742:	bf00      	nop
 800f744:	08010255 	.word	0x08010255
 800f748:	08010277 	.word	0x08010277
 800f74c:	080102af 	.word	0x080102af
 800f750:	080102d3 	.word	0x080102d3

0800f754 <_cleanup_r>:
 800f754:	4901      	ldr	r1, [pc, #4]	; (800f75c <_cleanup_r+0x8>)
 800f756:	f000 b885 	b.w	800f864 <_fwalk_reent>
 800f75a:	bf00      	nop
 800f75c:	080105ad 	.word	0x080105ad

0800f760 <__sfmoreglue>:
 800f760:	b570      	push	{r4, r5, r6, lr}
 800f762:	1e4a      	subs	r2, r1, #1
 800f764:	2568      	movs	r5, #104	; 0x68
 800f766:	4355      	muls	r5, r2
 800f768:	460e      	mov	r6, r1
 800f76a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 800f76e:	f000 f8ed 	bl	800f94c <_malloc_r>
 800f772:	4604      	mov	r4, r0
 800f774:	b140      	cbz	r0, 800f788 <__sfmoreglue+0x28>
 800f776:	2100      	movs	r1, #0
 800f778:	e9c0 1600 	strd	r1, r6, [r0]
 800f77c:	300c      	adds	r0, #12
 800f77e:	60a0      	str	r0, [r4, #8]
 800f780:	f105 0268 	add.w	r2, r5, #104	; 0x68
 800f784:	f7ff fe8a 	bl	800f49c <memset>
 800f788:	4620      	mov	r0, r4
 800f78a:	bd70      	pop	{r4, r5, r6, pc}

0800f78c <__sinit>:
 800f78c:	6983      	ldr	r3, [r0, #24]
 800f78e:	b510      	push	{r4, lr}
 800f790:	4604      	mov	r4, r0
 800f792:	bb33      	cbnz	r3, 800f7e2 <__sinit+0x56>
 800f794:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 800f798:	6503      	str	r3, [r0, #80]	; 0x50
 800f79a:	4b12      	ldr	r3, [pc, #72]	; (800f7e4 <__sinit+0x58>)
 800f79c:	4a12      	ldr	r2, [pc, #72]	; (800f7e8 <__sinit+0x5c>)
 800f79e:	681b      	ldr	r3, [r3, #0]
 800f7a0:	6282      	str	r2, [r0, #40]	; 0x28
 800f7a2:	4298      	cmp	r0, r3
 800f7a4:	bf04      	itt	eq
 800f7a6:	2301      	moveq	r3, #1
 800f7a8:	6183      	streq	r3, [r0, #24]
 800f7aa:	f000 f81f 	bl	800f7ec <__sfp>
 800f7ae:	6060      	str	r0, [r4, #4]
 800f7b0:	4620      	mov	r0, r4
 800f7b2:	f000 f81b 	bl	800f7ec <__sfp>
 800f7b6:	60a0      	str	r0, [r4, #8]
 800f7b8:	4620      	mov	r0, r4
 800f7ba:	f000 f817 	bl	800f7ec <__sfp>
 800f7be:	2200      	movs	r2, #0
 800f7c0:	60e0      	str	r0, [r4, #12]
 800f7c2:	2104      	movs	r1, #4
 800f7c4:	6860      	ldr	r0, [r4, #4]
 800f7c6:	f7ff ffa1 	bl	800f70c <std>
 800f7ca:	2201      	movs	r2, #1
 800f7cc:	2109      	movs	r1, #9
 800f7ce:	68a0      	ldr	r0, [r4, #8]
 800f7d0:	f7ff ff9c 	bl	800f70c <std>
 800f7d4:	2202      	movs	r2, #2
 800f7d6:	2112      	movs	r1, #18
 800f7d8:	68e0      	ldr	r0, [r4, #12]
 800f7da:	f7ff ff97 	bl	800f70c <std>
 800f7de:	2301      	movs	r3, #1
 800f7e0:	61a3      	str	r3, [r4, #24]
 800f7e2:	bd10      	pop	{r4, pc}
 800f7e4:	08011dd4 	.word	0x08011dd4
 800f7e8:	0800f755 	.word	0x0800f755

0800f7ec <__sfp>:
 800f7ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f7ee:	4b1b      	ldr	r3, [pc, #108]	; (800f85c <__sfp+0x70>)
 800f7f0:	681e      	ldr	r6, [r3, #0]
 800f7f2:	69b3      	ldr	r3, [r6, #24]
 800f7f4:	4607      	mov	r7, r0
 800f7f6:	b913      	cbnz	r3, 800f7fe <__sfp+0x12>
 800f7f8:	4630      	mov	r0, r6
 800f7fa:	f7ff ffc7 	bl	800f78c <__sinit>
 800f7fe:	3648      	adds	r6, #72	; 0x48
 800f800:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 800f804:	3b01      	subs	r3, #1
 800f806:	d503      	bpl.n	800f810 <__sfp+0x24>
 800f808:	6833      	ldr	r3, [r6, #0]
 800f80a:	b133      	cbz	r3, 800f81a <__sfp+0x2e>
 800f80c:	6836      	ldr	r6, [r6, #0]
 800f80e:	e7f7      	b.n	800f800 <__sfp+0x14>
 800f810:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 800f814:	b16d      	cbz	r5, 800f832 <__sfp+0x46>
 800f816:	3468      	adds	r4, #104	; 0x68
 800f818:	e7f4      	b.n	800f804 <__sfp+0x18>
 800f81a:	2104      	movs	r1, #4
 800f81c:	4638      	mov	r0, r7
 800f81e:	f7ff ff9f 	bl	800f760 <__sfmoreglue>
 800f822:	6030      	str	r0, [r6, #0]
 800f824:	2800      	cmp	r0, #0
 800f826:	d1f1      	bne.n	800f80c <__sfp+0x20>
 800f828:	230c      	movs	r3, #12
 800f82a:	603b      	str	r3, [r7, #0]
 800f82c:	4604      	mov	r4, r0
 800f82e:	4620      	mov	r0, r4
 800f830:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f832:	4b0b      	ldr	r3, [pc, #44]	; (800f860 <__sfp+0x74>)
 800f834:	6665      	str	r5, [r4, #100]	; 0x64
 800f836:	e9c4 5500 	strd	r5, r5, [r4]
 800f83a:	60a5      	str	r5, [r4, #8]
 800f83c:	e9c4 3503 	strd	r3, r5, [r4, #12]
 800f840:	e9c4 5505 	strd	r5, r5, [r4, #20]
 800f844:	2208      	movs	r2, #8
 800f846:	4629      	mov	r1, r5
 800f848:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800f84c:	f7ff fe26 	bl	800f49c <memset>
 800f850:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 800f854:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 800f858:	e7e9      	b.n	800f82e <__sfp+0x42>
 800f85a:	bf00      	nop
 800f85c:	08011dd4 	.word	0x08011dd4
 800f860:	ffff0001 	.word	0xffff0001

0800f864 <_fwalk_reent>:
 800f864:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800f868:	4680      	mov	r8, r0
 800f86a:	4689      	mov	r9, r1
 800f86c:	f100 0448 	add.w	r4, r0, #72	; 0x48
 800f870:	2600      	movs	r6, #0
 800f872:	b914      	cbnz	r4, 800f87a <_fwalk_reent+0x16>
 800f874:	4630      	mov	r0, r6
 800f876:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800f87a:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 800f87e:	3f01      	subs	r7, #1
 800f880:	d501      	bpl.n	800f886 <_fwalk_reent+0x22>
 800f882:	6824      	ldr	r4, [r4, #0]
 800f884:	e7f5      	b.n	800f872 <_fwalk_reent+0xe>
 800f886:	89ab      	ldrh	r3, [r5, #12]
 800f888:	2b01      	cmp	r3, #1
 800f88a:	d907      	bls.n	800f89c <_fwalk_reent+0x38>
 800f88c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800f890:	3301      	adds	r3, #1
 800f892:	d003      	beq.n	800f89c <_fwalk_reent+0x38>
 800f894:	4629      	mov	r1, r5
 800f896:	4640      	mov	r0, r8
 800f898:	47c8      	blx	r9
 800f89a:	4306      	orrs	r6, r0
 800f89c:	3568      	adds	r5, #104	; 0x68
 800f89e:	e7ee      	b.n	800f87e <_fwalk_reent+0x1a>

0800f8a0 <malloc>:
 800f8a0:	4b02      	ldr	r3, [pc, #8]	; (800f8ac <malloc+0xc>)
 800f8a2:	4601      	mov	r1, r0
 800f8a4:	6818      	ldr	r0, [r3, #0]
 800f8a6:	f000 b851 	b.w	800f94c <_malloc_r>
 800f8aa:	bf00      	nop
 800f8ac:	2000001c 	.word	0x2000001c

0800f8b0 <_free_r>:
 800f8b0:	b538      	push	{r3, r4, r5, lr}
 800f8b2:	4605      	mov	r5, r0
 800f8b4:	2900      	cmp	r1, #0
 800f8b6:	d045      	beq.n	800f944 <_free_r+0x94>
 800f8b8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800f8bc:	1f0c      	subs	r4, r1, #4
 800f8be:	2b00      	cmp	r3, #0
 800f8c0:	bfb8      	it	lt
 800f8c2:	18e4      	addlt	r4, r4, r3
 800f8c4:	f000 ff2b 	bl	801071e <__malloc_lock>
 800f8c8:	4a1f      	ldr	r2, [pc, #124]	; (800f948 <_free_r+0x98>)
 800f8ca:	6813      	ldr	r3, [r2, #0]
 800f8cc:	4610      	mov	r0, r2
 800f8ce:	b933      	cbnz	r3, 800f8de <_free_r+0x2e>
 800f8d0:	6063      	str	r3, [r4, #4]
 800f8d2:	6014      	str	r4, [r2, #0]
 800f8d4:	4628      	mov	r0, r5
 800f8d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800f8da:	f000 bf21 	b.w	8010720 <__malloc_unlock>
 800f8de:	42a3      	cmp	r3, r4
 800f8e0:	d90c      	bls.n	800f8fc <_free_r+0x4c>
 800f8e2:	6821      	ldr	r1, [r4, #0]
 800f8e4:	1862      	adds	r2, r4, r1
 800f8e6:	4293      	cmp	r3, r2
 800f8e8:	bf04      	itt	eq
 800f8ea:	681a      	ldreq	r2, [r3, #0]
 800f8ec:	685b      	ldreq	r3, [r3, #4]
 800f8ee:	6063      	str	r3, [r4, #4]
 800f8f0:	bf04      	itt	eq
 800f8f2:	1852      	addeq	r2, r2, r1
 800f8f4:	6022      	streq	r2, [r4, #0]
 800f8f6:	6004      	str	r4, [r0, #0]
 800f8f8:	e7ec      	b.n	800f8d4 <_free_r+0x24>
 800f8fa:	4613      	mov	r3, r2
 800f8fc:	685a      	ldr	r2, [r3, #4]
 800f8fe:	b10a      	cbz	r2, 800f904 <_free_r+0x54>
 800f900:	42a2      	cmp	r2, r4
 800f902:	d9fa      	bls.n	800f8fa <_free_r+0x4a>
 800f904:	6819      	ldr	r1, [r3, #0]
 800f906:	1858      	adds	r0, r3, r1
 800f908:	42a0      	cmp	r0, r4
 800f90a:	d10b      	bne.n	800f924 <_free_r+0x74>
 800f90c:	6820      	ldr	r0, [r4, #0]
 800f90e:	4401      	add	r1, r0
 800f910:	1858      	adds	r0, r3, r1
 800f912:	4282      	cmp	r2, r0
 800f914:	6019      	str	r1, [r3, #0]
 800f916:	d1dd      	bne.n	800f8d4 <_free_r+0x24>
 800f918:	6810      	ldr	r0, [r2, #0]
 800f91a:	6852      	ldr	r2, [r2, #4]
 800f91c:	605a      	str	r2, [r3, #4]
 800f91e:	4401      	add	r1, r0
 800f920:	6019      	str	r1, [r3, #0]
 800f922:	e7d7      	b.n	800f8d4 <_free_r+0x24>
 800f924:	d902      	bls.n	800f92c <_free_r+0x7c>
 800f926:	230c      	movs	r3, #12
 800f928:	602b      	str	r3, [r5, #0]
 800f92a:	e7d3      	b.n	800f8d4 <_free_r+0x24>
 800f92c:	6820      	ldr	r0, [r4, #0]
 800f92e:	1821      	adds	r1, r4, r0
 800f930:	428a      	cmp	r2, r1
 800f932:	bf04      	itt	eq
 800f934:	6811      	ldreq	r1, [r2, #0]
 800f936:	6852      	ldreq	r2, [r2, #4]
 800f938:	6062      	str	r2, [r4, #4]
 800f93a:	bf04      	itt	eq
 800f93c:	1809      	addeq	r1, r1, r0
 800f93e:	6021      	streq	r1, [r4, #0]
 800f940:	605c      	str	r4, [r3, #4]
 800f942:	e7c7      	b.n	800f8d4 <_free_r+0x24>
 800f944:	bd38      	pop	{r3, r4, r5, pc}
 800f946:	bf00      	nop
 800f948:	200059e0 	.word	0x200059e0

0800f94c <_malloc_r>:
 800f94c:	b570      	push	{r4, r5, r6, lr}
 800f94e:	1ccd      	adds	r5, r1, #3
 800f950:	f025 0503 	bic.w	r5, r5, #3
 800f954:	3508      	adds	r5, #8
 800f956:	2d0c      	cmp	r5, #12
 800f958:	bf38      	it	cc
 800f95a:	250c      	movcc	r5, #12
 800f95c:	2d00      	cmp	r5, #0
 800f95e:	4606      	mov	r6, r0
 800f960:	db01      	blt.n	800f966 <_malloc_r+0x1a>
 800f962:	42a9      	cmp	r1, r5
 800f964:	d903      	bls.n	800f96e <_malloc_r+0x22>
 800f966:	230c      	movs	r3, #12
 800f968:	6033      	str	r3, [r6, #0]
 800f96a:	2000      	movs	r0, #0
 800f96c:	bd70      	pop	{r4, r5, r6, pc}
 800f96e:	f000 fed6 	bl	801071e <__malloc_lock>
 800f972:	4a21      	ldr	r2, [pc, #132]	; (800f9f8 <_malloc_r+0xac>)
 800f974:	6814      	ldr	r4, [r2, #0]
 800f976:	4621      	mov	r1, r4
 800f978:	b991      	cbnz	r1, 800f9a0 <_malloc_r+0x54>
 800f97a:	4c20      	ldr	r4, [pc, #128]	; (800f9fc <_malloc_r+0xb0>)
 800f97c:	6823      	ldr	r3, [r4, #0]
 800f97e:	b91b      	cbnz	r3, 800f988 <_malloc_r+0x3c>
 800f980:	4630      	mov	r0, r6
 800f982:	f000 fc57 	bl	8010234 <_sbrk_r>
 800f986:	6020      	str	r0, [r4, #0]
 800f988:	4629      	mov	r1, r5
 800f98a:	4630      	mov	r0, r6
 800f98c:	f000 fc52 	bl	8010234 <_sbrk_r>
 800f990:	1c43      	adds	r3, r0, #1
 800f992:	d124      	bne.n	800f9de <_malloc_r+0x92>
 800f994:	230c      	movs	r3, #12
 800f996:	6033      	str	r3, [r6, #0]
 800f998:	4630      	mov	r0, r6
 800f99a:	f000 fec1 	bl	8010720 <__malloc_unlock>
 800f99e:	e7e4      	b.n	800f96a <_malloc_r+0x1e>
 800f9a0:	680b      	ldr	r3, [r1, #0]
 800f9a2:	1b5b      	subs	r3, r3, r5
 800f9a4:	d418      	bmi.n	800f9d8 <_malloc_r+0x8c>
 800f9a6:	2b0b      	cmp	r3, #11
 800f9a8:	d90f      	bls.n	800f9ca <_malloc_r+0x7e>
 800f9aa:	600b      	str	r3, [r1, #0]
 800f9ac:	50cd      	str	r5, [r1, r3]
 800f9ae:	18cc      	adds	r4, r1, r3
 800f9b0:	4630      	mov	r0, r6
 800f9b2:	f000 feb5 	bl	8010720 <__malloc_unlock>
 800f9b6:	f104 000b 	add.w	r0, r4, #11
 800f9ba:	1d23      	adds	r3, r4, #4
 800f9bc:	f020 0007 	bic.w	r0, r0, #7
 800f9c0:	1ac3      	subs	r3, r0, r3
 800f9c2:	d0d3      	beq.n	800f96c <_malloc_r+0x20>
 800f9c4:	425a      	negs	r2, r3
 800f9c6:	50e2      	str	r2, [r4, r3]
 800f9c8:	e7d0      	b.n	800f96c <_malloc_r+0x20>
 800f9ca:	428c      	cmp	r4, r1
 800f9cc:	684b      	ldr	r3, [r1, #4]
 800f9ce:	bf16      	itet	ne
 800f9d0:	6063      	strne	r3, [r4, #4]
 800f9d2:	6013      	streq	r3, [r2, #0]
 800f9d4:	460c      	movne	r4, r1
 800f9d6:	e7eb      	b.n	800f9b0 <_malloc_r+0x64>
 800f9d8:	460c      	mov	r4, r1
 800f9da:	6849      	ldr	r1, [r1, #4]
 800f9dc:	e7cc      	b.n	800f978 <_malloc_r+0x2c>
 800f9de:	1cc4      	adds	r4, r0, #3
 800f9e0:	f024 0403 	bic.w	r4, r4, #3
 800f9e4:	42a0      	cmp	r0, r4
 800f9e6:	d005      	beq.n	800f9f4 <_malloc_r+0xa8>
 800f9e8:	1a21      	subs	r1, r4, r0
 800f9ea:	4630      	mov	r0, r6
 800f9ec:	f000 fc22 	bl	8010234 <_sbrk_r>
 800f9f0:	3001      	adds	r0, #1
 800f9f2:	d0cf      	beq.n	800f994 <_malloc_r+0x48>
 800f9f4:	6025      	str	r5, [r4, #0]
 800f9f6:	e7db      	b.n	800f9b0 <_malloc_r+0x64>
 800f9f8:	200059e0 	.word	0x200059e0
 800f9fc:	200059e4 	.word	0x200059e4

0800fa00 <__ssputs_r>:
 800fa00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800fa04:	688e      	ldr	r6, [r1, #8]
 800fa06:	429e      	cmp	r6, r3
 800fa08:	4682      	mov	sl, r0
 800fa0a:	460c      	mov	r4, r1
 800fa0c:	4690      	mov	r8, r2
 800fa0e:	4699      	mov	r9, r3
 800fa10:	d837      	bhi.n	800fa82 <__ssputs_r+0x82>
 800fa12:	898a      	ldrh	r2, [r1, #12]
 800fa14:	f412 6f90 	tst.w	r2, #1152	; 0x480
 800fa18:	d031      	beq.n	800fa7e <__ssputs_r+0x7e>
 800fa1a:	6825      	ldr	r5, [r4, #0]
 800fa1c:	6909      	ldr	r1, [r1, #16]
 800fa1e:	1a6f      	subs	r7, r5, r1
 800fa20:	6965      	ldr	r5, [r4, #20]
 800fa22:	2302      	movs	r3, #2
 800fa24:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800fa28:	fb95 f5f3 	sdiv	r5, r5, r3
 800fa2c:	f109 0301 	add.w	r3, r9, #1
 800fa30:	443b      	add	r3, r7
 800fa32:	429d      	cmp	r5, r3
 800fa34:	bf38      	it	cc
 800fa36:	461d      	movcc	r5, r3
 800fa38:	0553      	lsls	r3, r2, #21
 800fa3a:	d530      	bpl.n	800fa9e <__ssputs_r+0x9e>
 800fa3c:	4629      	mov	r1, r5
 800fa3e:	f7ff ff85 	bl	800f94c <_malloc_r>
 800fa42:	4606      	mov	r6, r0
 800fa44:	b950      	cbnz	r0, 800fa5c <__ssputs_r+0x5c>
 800fa46:	230c      	movs	r3, #12
 800fa48:	f8ca 3000 	str.w	r3, [sl]
 800fa4c:	89a3      	ldrh	r3, [r4, #12]
 800fa4e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800fa52:	81a3      	strh	r3, [r4, #12]
 800fa54:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800fa58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800fa5c:	463a      	mov	r2, r7
 800fa5e:	6921      	ldr	r1, [r4, #16]
 800fa60:	f7ff fd11 	bl	800f486 <memcpy>
 800fa64:	89a3      	ldrh	r3, [r4, #12]
 800fa66:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800fa6a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fa6e:	81a3      	strh	r3, [r4, #12]
 800fa70:	6126      	str	r6, [r4, #16]
 800fa72:	6165      	str	r5, [r4, #20]
 800fa74:	443e      	add	r6, r7
 800fa76:	1bed      	subs	r5, r5, r7
 800fa78:	6026      	str	r6, [r4, #0]
 800fa7a:	60a5      	str	r5, [r4, #8]
 800fa7c:	464e      	mov	r6, r9
 800fa7e:	454e      	cmp	r6, r9
 800fa80:	d900      	bls.n	800fa84 <__ssputs_r+0x84>
 800fa82:	464e      	mov	r6, r9
 800fa84:	4632      	mov	r2, r6
 800fa86:	4641      	mov	r1, r8
 800fa88:	6820      	ldr	r0, [r4, #0]
 800fa8a:	f000 fe2f 	bl	80106ec <memmove>
 800fa8e:	68a3      	ldr	r3, [r4, #8]
 800fa90:	1b9b      	subs	r3, r3, r6
 800fa92:	60a3      	str	r3, [r4, #8]
 800fa94:	6823      	ldr	r3, [r4, #0]
 800fa96:	441e      	add	r6, r3
 800fa98:	6026      	str	r6, [r4, #0]
 800fa9a:	2000      	movs	r0, #0
 800fa9c:	e7dc      	b.n	800fa58 <__ssputs_r+0x58>
 800fa9e:	462a      	mov	r2, r5
 800faa0:	f000 fe3f 	bl	8010722 <_realloc_r>
 800faa4:	4606      	mov	r6, r0
 800faa6:	2800      	cmp	r0, #0
 800faa8:	d1e2      	bne.n	800fa70 <__ssputs_r+0x70>
 800faaa:	6921      	ldr	r1, [r4, #16]
 800faac:	4650      	mov	r0, sl
 800faae:	f7ff feff 	bl	800f8b0 <_free_r>
 800fab2:	e7c8      	b.n	800fa46 <__ssputs_r+0x46>

0800fab4 <_svfiprintf_r>:
 800fab4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fab8:	461d      	mov	r5, r3
 800faba:	898b      	ldrh	r3, [r1, #12]
 800fabc:	061f      	lsls	r7, r3, #24
 800fabe:	b09d      	sub	sp, #116	; 0x74
 800fac0:	4680      	mov	r8, r0
 800fac2:	460c      	mov	r4, r1
 800fac4:	4616      	mov	r6, r2
 800fac6:	d50f      	bpl.n	800fae8 <_svfiprintf_r+0x34>
 800fac8:	690b      	ldr	r3, [r1, #16]
 800faca:	b96b      	cbnz	r3, 800fae8 <_svfiprintf_r+0x34>
 800facc:	2140      	movs	r1, #64	; 0x40
 800face:	f7ff ff3d 	bl	800f94c <_malloc_r>
 800fad2:	6020      	str	r0, [r4, #0]
 800fad4:	6120      	str	r0, [r4, #16]
 800fad6:	b928      	cbnz	r0, 800fae4 <_svfiprintf_r+0x30>
 800fad8:	230c      	movs	r3, #12
 800fada:	f8c8 3000 	str.w	r3, [r8]
 800fade:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800fae2:	e0c8      	b.n	800fc76 <_svfiprintf_r+0x1c2>
 800fae4:	2340      	movs	r3, #64	; 0x40
 800fae6:	6163      	str	r3, [r4, #20]
 800fae8:	2300      	movs	r3, #0
 800faea:	9309      	str	r3, [sp, #36]	; 0x24
 800faec:	2320      	movs	r3, #32
 800faee:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800faf2:	2330      	movs	r3, #48	; 0x30
 800faf4:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800faf8:	9503      	str	r5, [sp, #12]
 800fafa:	f04f 0b01 	mov.w	fp, #1
 800fafe:	4637      	mov	r7, r6
 800fb00:	463d      	mov	r5, r7
 800fb02:	f815 3b01 	ldrb.w	r3, [r5], #1
 800fb06:	b10b      	cbz	r3, 800fb0c <_svfiprintf_r+0x58>
 800fb08:	2b25      	cmp	r3, #37	; 0x25
 800fb0a:	d13e      	bne.n	800fb8a <_svfiprintf_r+0xd6>
 800fb0c:	ebb7 0a06 	subs.w	sl, r7, r6
 800fb10:	d00b      	beq.n	800fb2a <_svfiprintf_r+0x76>
 800fb12:	4653      	mov	r3, sl
 800fb14:	4632      	mov	r2, r6
 800fb16:	4621      	mov	r1, r4
 800fb18:	4640      	mov	r0, r8
 800fb1a:	f7ff ff71 	bl	800fa00 <__ssputs_r>
 800fb1e:	3001      	adds	r0, #1
 800fb20:	f000 80a4 	beq.w	800fc6c <_svfiprintf_r+0x1b8>
 800fb24:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fb26:	4453      	add	r3, sl
 800fb28:	9309      	str	r3, [sp, #36]	; 0x24
 800fb2a:	783b      	ldrb	r3, [r7, #0]
 800fb2c:	2b00      	cmp	r3, #0
 800fb2e:	f000 809d 	beq.w	800fc6c <_svfiprintf_r+0x1b8>
 800fb32:	2300      	movs	r3, #0
 800fb34:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800fb38:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800fb3c:	9304      	str	r3, [sp, #16]
 800fb3e:	9307      	str	r3, [sp, #28]
 800fb40:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800fb44:	931a      	str	r3, [sp, #104]	; 0x68
 800fb46:	462f      	mov	r7, r5
 800fb48:	2205      	movs	r2, #5
 800fb4a:	f817 1b01 	ldrb.w	r1, [r7], #1
 800fb4e:	4850      	ldr	r0, [pc, #320]	; (800fc90 <_svfiprintf_r+0x1dc>)
 800fb50:	f7f0 fb8e 	bl	8000270 <memchr>
 800fb54:	9b04      	ldr	r3, [sp, #16]
 800fb56:	b9d0      	cbnz	r0, 800fb8e <_svfiprintf_r+0xda>
 800fb58:	06d9      	lsls	r1, r3, #27
 800fb5a:	bf44      	itt	mi
 800fb5c:	2220      	movmi	r2, #32
 800fb5e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800fb62:	071a      	lsls	r2, r3, #28
 800fb64:	bf44      	itt	mi
 800fb66:	222b      	movmi	r2, #43	; 0x2b
 800fb68:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800fb6c:	782a      	ldrb	r2, [r5, #0]
 800fb6e:	2a2a      	cmp	r2, #42	; 0x2a
 800fb70:	d015      	beq.n	800fb9e <_svfiprintf_r+0xea>
 800fb72:	9a07      	ldr	r2, [sp, #28]
 800fb74:	462f      	mov	r7, r5
 800fb76:	2000      	movs	r0, #0
 800fb78:	250a      	movs	r5, #10
 800fb7a:	4639      	mov	r1, r7
 800fb7c:	f811 3b01 	ldrb.w	r3, [r1], #1
 800fb80:	3b30      	subs	r3, #48	; 0x30
 800fb82:	2b09      	cmp	r3, #9
 800fb84:	d94d      	bls.n	800fc22 <_svfiprintf_r+0x16e>
 800fb86:	b1b8      	cbz	r0, 800fbb8 <_svfiprintf_r+0x104>
 800fb88:	e00f      	b.n	800fbaa <_svfiprintf_r+0xf6>
 800fb8a:	462f      	mov	r7, r5
 800fb8c:	e7b8      	b.n	800fb00 <_svfiprintf_r+0x4c>
 800fb8e:	4a40      	ldr	r2, [pc, #256]	; (800fc90 <_svfiprintf_r+0x1dc>)
 800fb90:	1a80      	subs	r0, r0, r2
 800fb92:	fa0b f000 	lsl.w	r0, fp, r0
 800fb96:	4318      	orrs	r0, r3
 800fb98:	9004      	str	r0, [sp, #16]
 800fb9a:	463d      	mov	r5, r7
 800fb9c:	e7d3      	b.n	800fb46 <_svfiprintf_r+0x92>
 800fb9e:	9a03      	ldr	r2, [sp, #12]
 800fba0:	1d11      	adds	r1, r2, #4
 800fba2:	6812      	ldr	r2, [r2, #0]
 800fba4:	9103      	str	r1, [sp, #12]
 800fba6:	2a00      	cmp	r2, #0
 800fba8:	db01      	blt.n	800fbae <_svfiprintf_r+0xfa>
 800fbaa:	9207      	str	r2, [sp, #28]
 800fbac:	e004      	b.n	800fbb8 <_svfiprintf_r+0x104>
 800fbae:	4252      	negs	r2, r2
 800fbb0:	f043 0302 	orr.w	r3, r3, #2
 800fbb4:	9207      	str	r2, [sp, #28]
 800fbb6:	9304      	str	r3, [sp, #16]
 800fbb8:	783b      	ldrb	r3, [r7, #0]
 800fbba:	2b2e      	cmp	r3, #46	; 0x2e
 800fbbc:	d10c      	bne.n	800fbd8 <_svfiprintf_r+0x124>
 800fbbe:	787b      	ldrb	r3, [r7, #1]
 800fbc0:	2b2a      	cmp	r3, #42	; 0x2a
 800fbc2:	d133      	bne.n	800fc2c <_svfiprintf_r+0x178>
 800fbc4:	9b03      	ldr	r3, [sp, #12]
 800fbc6:	1d1a      	adds	r2, r3, #4
 800fbc8:	681b      	ldr	r3, [r3, #0]
 800fbca:	9203      	str	r2, [sp, #12]
 800fbcc:	2b00      	cmp	r3, #0
 800fbce:	bfb8      	it	lt
 800fbd0:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 800fbd4:	3702      	adds	r7, #2
 800fbd6:	9305      	str	r3, [sp, #20]
 800fbd8:	4d2e      	ldr	r5, [pc, #184]	; (800fc94 <_svfiprintf_r+0x1e0>)
 800fbda:	7839      	ldrb	r1, [r7, #0]
 800fbdc:	2203      	movs	r2, #3
 800fbde:	4628      	mov	r0, r5
 800fbe0:	f7f0 fb46 	bl	8000270 <memchr>
 800fbe4:	b138      	cbz	r0, 800fbf6 <_svfiprintf_r+0x142>
 800fbe6:	2340      	movs	r3, #64	; 0x40
 800fbe8:	1b40      	subs	r0, r0, r5
 800fbea:	fa03 f000 	lsl.w	r0, r3, r0
 800fbee:	9b04      	ldr	r3, [sp, #16]
 800fbf0:	4303      	orrs	r3, r0
 800fbf2:	3701      	adds	r7, #1
 800fbf4:	9304      	str	r3, [sp, #16]
 800fbf6:	7839      	ldrb	r1, [r7, #0]
 800fbf8:	4827      	ldr	r0, [pc, #156]	; (800fc98 <_svfiprintf_r+0x1e4>)
 800fbfa:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800fbfe:	2206      	movs	r2, #6
 800fc00:	1c7e      	adds	r6, r7, #1
 800fc02:	f7f0 fb35 	bl	8000270 <memchr>
 800fc06:	2800      	cmp	r0, #0
 800fc08:	d038      	beq.n	800fc7c <_svfiprintf_r+0x1c8>
 800fc0a:	4b24      	ldr	r3, [pc, #144]	; (800fc9c <_svfiprintf_r+0x1e8>)
 800fc0c:	bb13      	cbnz	r3, 800fc54 <_svfiprintf_r+0x1a0>
 800fc0e:	9b03      	ldr	r3, [sp, #12]
 800fc10:	3307      	adds	r3, #7
 800fc12:	f023 0307 	bic.w	r3, r3, #7
 800fc16:	3308      	adds	r3, #8
 800fc18:	9303      	str	r3, [sp, #12]
 800fc1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fc1c:	444b      	add	r3, r9
 800fc1e:	9309      	str	r3, [sp, #36]	; 0x24
 800fc20:	e76d      	b.n	800fafe <_svfiprintf_r+0x4a>
 800fc22:	fb05 3202 	mla	r2, r5, r2, r3
 800fc26:	2001      	movs	r0, #1
 800fc28:	460f      	mov	r7, r1
 800fc2a:	e7a6      	b.n	800fb7a <_svfiprintf_r+0xc6>
 800fc2c:	2300      	movs	r3, #0
 800fc2e:	3701      	adds	r7, #1
 800fc30:	9305      	str	r3, [sp, #20]
 800fc32:	4619      	mov	r1, r3
 800fc34:	250a      	movs	r5, #10
 800fc36:	4638      	mov	r0, r7
 800fc38:	f810 2b01 	ldrb.w	r2, [r0], #1
 800fc3c:	3a30      	subs	r2, #48	; 0x30
 800fc3e:	2a09      	cmp	r2, #9
 800fc40:	d903      	bls.n	800fc4a <_svfiprintf_r+0x196>
 800fc42:	2b00      	cmp	r3, #0
 800fc44:	d0c8      	beq.n	800fbd8 <_svfiprintf_r+0x124>
 800fc46:	9105      	str	r1, [sp, #20]
 800fc48:	e7c6      	b.n	800fbd8 <_svfiprintf_r+0x124>
 800fc4a:	fb05 2101 	mla	r1, r5, r1, r2
 800fc4e:	2301      	movs	r3, #1
 800fc50:	4607      	mov	r7, r0
 800fc52:	e7f0      	b.n	800fc36 <_svfiprintf_r+0x182>
 800fc54:	ab03      	add	r3, sp, #12
 800fc56:	9300      	str	r3, [sp, #0]
 800fc58:	4622      	mov	r2, r4
 800fc5a:	4b11      	ldr	r3, [pc, #68]	; (800fca0 <_svfiprintf_r+0x1ec>)
 800fc5c:	a904      	add	r1, sp, #16
 800fc5e:	4640      	mov	r0, r8
 800fc60:	f3af 8000 	nop.w
 800fc64:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800fc68:	4681      	mov	r9, r0
 800fc6a:	d1d6      	bne.n	800fc1a <_svfiprintf_r+0x166>
 800fc6c:	89a3      	ldrh	r3, [r4, #12]
 800fc6e:	065b      	lsls	r3, r3, #25
 800fc70:	f53f af35 	bmi.w	800fade <_svfiprintf_r+0x2a>
 800fc74:	9809      	ldr	r0, [sp, #36]	; 0x24
 800fc76:	b01d      	add	sp, #116	; 0x74
 800fc78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fc7c:	ab03      	add	r3, sp, #12
 800fc7e:	9300      	str	r3, [sp, #0]
 800fc80:	4622      	mov	r2, r4
 800fc82:	4b07      	ldr	r3, [pc, #28]	; (800fca0 <_svfiprintf_r+0x1ec>)
 800fc84:	a904      	add	r1, sp, #16
 800fc86:	4640      	mov	r0, r8
 800fc88:	f000 f9c2 	bl	8010010 <_printf_i>
 800fc8c:	e7ea      	b.n	800fc64 <_svfiprintf_r+0x1b0>
 800fc8e:	bf00      	nop
 800fc90:	08011e38 	.word	0x08011e38
 800fc94:	08011e3e 	.word	0x08011e3e
 800fc98:	08011e42 	.word	0x08011e42
 800fc9c:	00000000 	.word	0x00000000
 800fca0:	0800fa01 	.word	0x0800fa01

0800fca4 <__sfputc_r>:
 800fca4:	6893      	ldr	r3, [r2, #8]
 800fca6:	3b01      	subs	r3, #1
 800fca8:	2b00      	cmp	r3, #0
 800fcaa:	b410      	push	{r4}
 800fcac:	6093      	str	r3, [r2, #8]
 800fcae:	da08      	bge.n	800fcc2 <__sfputc_r+0x1e>
 800fcb0:	6994      	ldr	r4, [r2, #24]
 800fcb2:	42a3      	cmp	r3, r4
 800fcb4:	db01      	blt.n	800fcba <__sfputc_r+0x16>
 800fcb6:	290a      	cmp	r1, #10
 800fcb8:	d103      	bne.n	800fcc2 <__sfputc_r+0x1e>
 800fcba:	f85d 4b04 	ldr.w	r4, [sp], #4
 800fcbe:	f000 bb0d 	b.w	80102dc <__swbuf_r>
 800fcc2:	6813      	ldr	r3, [r2, #0]
 800fcc4:	1c58      	adds	r0, r3, #1
 800fcc6:	6010      	str	r0, [r2, #0]
 800fcc8:	7019      	strb	r1, [r3, #0]
 800fcca:	4608      	mov	r0, r1
 800fccc:	f85d 4b04 	ldr.w	r4, [sp], #4
 800fcd0:	4770      	bx	lr

0800fcd2 <__sfputs_r>:
 800fcd2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fcd4:	4606      	mov	r6, r0
 800fcd6:	460f      	mov	r7, r1
 800fcd8:	4614      	mov	r4, r2
 800fcda:	18d5      	adds	r5, r2, r3
 800fcdc:	42ac      	cmp	r4, r5
 800fcde:	d101      	bne.n	800fce4 <__sfputs_r+0x12>
 800fce0:	2000      	movs	r0, #0
 800fce2:	e007      	b.n	800fcf4 <__sfputs_r+0x22>
 800fce4:	463a      	mov	r2, r7
 800fce6:	f814 1b01 	ldrb.w	r1, [r4], #1
 800fcea:	4630      	mov	r0, r6
 800fcec:	f7ff ffda 	bl	800fca4 <__sfputc_r>
 800fcf0:	1c43      	adds	r3, r0, #1
 800fcf2:	d1f3      	bne.n	800fcdc <__sfputs_r+0xa>
 800fcf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800fcf8 <_vfiprintf_r>:
 800fcf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fcfc:	460c      	mov	r4, r1
 800fcfe:	b09d      	sub	sp, #116	; 0x74
 800fd00:	4617      	mov	r7, r2
 800fd02:	461d      	mov	r5, r3
 800fd04:	4606      	mov	r6, r0
 800fd06:	b118      	cbz	r0, 800fd10 <_vfiprintf_r+0x18>
 800fd08:	6983      	ldr	r3, [r0, #24]
 800fd0a:	b90b      	cbnz	r3, 800fd10 <_vfiprintf_r+0x18>
 800fd0c:	f7ff fd3e 	bl	800f78c <__sinit>
 800fd10:	4b7c      	ldr	r3, [pc, #496]	; (800ff04 <_vfiprintf_r+0x20c>)
 800fd12:	429c      	cmp	r4, r3
 800fd14:	d158      	bne.n	800fdc8 <_vfiprintf_r+0xd0>
 800fd16:	6874      	ldr	r4, [r6, #4]
 800fd18:	89a3      	ldrh	r3, [r4, #12]
 800fd1a:	0718      	lsls	r0, r3, #28
 800fd1c:	d55e      	bpl.n	800fddc <_vfiprintf_r+0xe4>
 800fd1e:	6923      	ldr	r3, [r4, #16]
 800fd20:	2b00      	cmp	r3, #0
 800fd22:	d05b      	beq.n	800fddc <_vfiprintf_r+0xe4>
 800fd24:	2300      	movs	r3, #0
 800fd26:	9309      	str	r3, [sp, #36]	; 0x24
 800fd28:	2320      	movs	r3, #32
 800fd2a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800fd2e:	2330      	movs	r3, #48	; 0x30
 800fd30:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800fd34:	9503      	str	r5, [sp, #12]
 800fd36:	f04f 0b01 	mov.w	fp, #1
 800fd3a:	46b8      	mov	r8, r7
 800fd3c:	4645      	mov	r5, r8
 800fd3e:	f815 3b01 	ldrb.w	r3, [r5], #1
 800fd42:	b10b      	cbz	r3, 800fd48 <_vfiprintf_r+0x50>
 800fd44:	2b25      	cmp	r3, #37	; 0x25
 800fd46:	d154      	bne.n	800fdf2 <_vfiprintf_r+0xfa>
 800fd48:	ebb8 0a07 	subs.w	sl, r8, r7
 800fd4c:	d00b      	beq.n	800fd66 <_vfiprintf_r+0x6e>
 800fd4e:	4653      	mov	r3, sl
 800fd50:	463a      	mov	r2, r7
 800fd52:	4621      	mov	r1, r4
 800fd54:	4630      	mov	r0, r6
 800fd56:	f7ff ffbc 	bl	800fcd2 <__sfputs_r>
 800fd5a:	3001      	adds	r0, #1
 800fd5c:	f000 80c2 	beq.w	800fee4 <_vfiprintf_r+0x1ec>
 800fd60:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fd62:	4453      	add	r3, sl
 800fd64:	9309      	str	r3, [sp, #36]	; 0x24
 800fd66:	f898 3000 	ldrb.w	r3, [r8]
 800fd6a:	2b00      	cmp	r3, #0
 800fd6c:	f000 80ba 	beq.w	800fee4 <_vfiprintf_r+0x1ec>
 800fd70:	2300      	movs	r3, #0
 800fd72:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800fd76:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800fd7a:	9304      	str	r3, [sp, #16]
 800fd7c:	9307      	str	r3, [sp, #28]
 800fd7e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800fd82:	931a      	str	r3, [sp, #104]	; 0x68
 800fd84:	46a8      	mov	r8, r5
 800fd86:	2205      	movs	r2, #5
 800fd88:	f818 1b01 	ldrb.w	r1, [r8], #1
 800fd8c:	485e      	ldr	r0, [pc, #376]	; (800ff08 <_vfiprintf_r+0x210>)
 800fd8e:	f7f0 fa6f 	bl	8000270 <memchr>
 800fd92:	9b04      	ldr	r3, [sp, #16]
 800fd94:	bb78      	cbnz	r0, 800fdf6 <_vfiprintf_r+0xfe>
 800fd96:	06d9      	lsls	r1, r3, #27
 800fd98:	bf44      	itt	mi
 800fd9a:	2220      	movmi	r2, #32
 800fd9c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800fda0:	071a      	lsls	r2, r3, #28
 800fda2:	bf44      	itt	mi
 800fda4:	222b      	movmi	r2, #43	; 0x2b
 800fda6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800fdaa:	782a      	ldrb	r2, [r5, #0]
 800fdac:	2a2a      	cmp	r2, #42	; 0x2a
 800fdae:	d02a      	beq.n	800fe06 <_vfiprintf_r+0x10e>
 800fdb0:	9a07      	ldr	r2, [sp, #28]
 800fdb2:	46a8      	mov	r8, r5
 800fdb4:	2000      	movs	r0, #0
 800fdb6:	250a      	movs	r5, #10
 800fdb8:	4641      	mov	r1, r8
 800fdba:	f811 3b01 	ldrb.w	r3, [r1], #1
 800fdbe:	3b30      	subs	r3, #48	; 0x30
 800fdc0:	2b09      	cmp	r3, #9
 800fdc2:	d969      	bls.n	800fe98 <_vfiprintf_r+0x1a0>
 800fdc4:	b360      	cbz	r0, 800fe20 <_vfiprintf_r+0x128>
 800fdc6:	e024      	b.n	800fe12 <_vfiprintf_r+0x11a>
 800fdc8:	4b50      	ldr	r3, [pc, #320]	; (800ff0c <_vfiprintf_r+0x214>)
 800fdca:	429c      	cmp	r4, r3
 800fdcc:	d101      	bne.n	800fdd2 <_vfiprintf_r+0xda>
 800fdce:	68b4      	ldr	r4, [r6, #8]
 800fdd0:	e7a2      	b.n	800fd18 <_vfiprintf_r+0x20>
 800fdd2:	4b4f      	ldr	r3, [pc, #316]	; (800ff10 <_vfiprintf_r+0x218>)
 800fdd4:	429c      	cmp	r4, r3
 800fdd6:	bf08      	it	eq
 800fdd8:	68f4      	ldreq	r4, [r6, #12]
 800fdda:	e79d      	b.n	800fd18 <_vfiprintf_r+0x20>
 800fddc:	4621      	mov	r1, r4
 800fdde:	4630      	mov	r0, r6
 800fde0:	f000 fae0 	bl	80103a4 <__swsetup_r>
 800fde4:	2800      	cmp	r0, #0
 800fde6:	d09d      	beq.n	800fd24 <_vfiprintf_r+0x2c>
 800fde8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800fdec:	b01d      	add	sp, #116	; 0x74
 800fdee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fdf2:	46a8      	mov	r8, r5
 800fdf4:	e7a2      	b.n	800fd3c <_vfiprintf_r+0x44>
 800fdf6:	4a44      	ldr	r2, [pc, #272]	; (800ff08 <_vfiprintf_r+0x210>)
 800fdf8:	1a80      	subs	r0, r0, r2
 800fdfa:	fa0b f000 	lsl.w	r0, fp, r0
 800fdfe:	4318      	orrs	r0, r3
 800fe00:	9004      	str	r0, [sp, #16]
 800fe02:	4645      	mov	r5, r8
 800fe04:	e7be      	b.n	800fd84 <_vfiprintf_r+0x8c>
 800fe06:	9a03      	ldr	r2, [sp, #12]
 800fe08:	1d11      	adds	r1, r2, #4
 800fe0a:	6812      	ldr	r2, [r2, #0]
 800fe0c:	9103      	str	r1, [sp, #12]
 800fe0e:	2a00      	cmp	r2, #0
 800fe10:	db01      	blt.n	800fe16 <_vfiprintf_r+0x11e>
 800fe12:	9207      	str	r2, [sp, #28]
 800fe14:	e004      	b.n	800fe20 <_vfiprintf_r+0x128>
 800fe16:	4252      	negs	r2, r2
 800fe18:	f043 0302 	orr.w	r3, r3, #2
 800fe1c:	9207      	str	r2, [sp, #28]
 800fe1e:	9304      	str	r3, [sp, #16]
 800fe20:	f898 3000 	ldrb.w	r3, [r8]
 800fe24:	2b2e      	cmp	r3, #46	; 0x2e
 800fe26:	d10e      	bne.n	800fe46 <_vfiprintf_r+0x14e>
 800fe28:	f898 3001 	ldrb.w	r3, [r8, #1]
 800fe2c:	2b2a      	cmp	r3, #42	; 0x2a
 800fe2e:	d138      	bne.n	800fea2 <_vfiprintf_r+0x1aa>
 800fe30:	9b03      	ldr	r3, [sp, #12]
 800fe32:	1d1a      	adds	r2, r3, #4
 800fe34:	681b      	ldr	r3, [r3, #0]
 800fe36:	9203      	str	r2, [sp, #12]
 800fe38:	2b00      	cmp	r3, #0
 800fe3a:	bfb8      	it	lt
 800fe3c:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 800fe40:	f108 0802 	add.w	r8, r8, #2
 800fe44:	9305      	str	r3, [sp, #20]
 800fe46:	4d33      	ldr	r5, [pc, #204]	; (800ff14 <_vfiprintf_r+0x21c>)
 800fe48:	f898 1000 	ldrb.w	r1, [r8]
 800fe4c:	2203      	movs	r2, #3
 800fe4e:	4628      	mov	r0, r5
 800fe50:	f7f0 fa0e 	bl	8000270 <memchr>
 800fe54:	b140      	cbz	r0, 800fe68 <_vfiprintf_r+0x170>
 800fe56:	2340      	movs	r3, #64	; 0x40
 800fe58:	1b40      	subs	r0, r0, r5
 800fe5a:	fa03 f000 	lsl.w	r0, r3, r0
 800fe5e:	9b04      	ldr	r3, [sp, #16]
 800fe60:	4303      	orrs	r3, r0
 800fe62:	f108 0801 	add.w	r8, r8, #1
 800fe66:	9304      	str	r3, [sp, #16]
 800fe68:	f898 1000 	ldrb.w	r1, [r8]
 800fe6c:	482a      	ldr	r0, [pc, #168]	; (800ff18 <_vfiprintf_r+0x220>)
 800fe6e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800fe72:	2206      	movs	r2, #6
 800fe74:	f108 0701 	add.w	r7, r8, #1
 800fe78:	f7f0 f9fa 	bl	8000270 <memchr>
 800fe7c:	2800      	cmp	r0, #0
 800fe7e:	d037      	beq.n	800fef0 <_vfiprintf_r+0x1f8>
 800fe80:	4b26      	ldr	r3, [pc, #152]	; (800ff1c <_vfiprintf_r+0x224>)
 800fe82:	bb1b      	cbnz	r3, 800fecc <_vfiprintf_r+0x1d4>
 800fe84:	9b03      	ldr	r3, [sp, #12]
 800fe86:	3307      	adds	r3, #7
 800fe88:	f023 0307 	bic.w	r3, r3, #7
 800fe8c:	3308      	adds	r3, #8
 800fe8e:	9303      	str	r3, [sp, #12]
 800fe90:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fe92:	444b      	add	r3, r9
 800fe94:	9309      	str	r3, [sp, #36]	; 0x24
 800fe96:	e750      	b.n	800fd3a <_vfiprintf_r+0x42>
 800fe98:	fb05 3202 	mla	r2, r5, r2, r3
 800fe9c:	2001      	movs	r0, #1
 800fe9e:	4688      	mov	r8, r1
 800fea0:	e78a      	b.n	800fdb8 <_vfiprintf_r+0xc0>
 800fea2:	2300      	movs	r3, #0
 800fea4:	f108 0801 	add.w	r8, r8, #1
 800fea8:	9305      	str	r3, [sp, #20]
 800feaa:	4619      	mov	r1, r3
 800feac:	250a      	movs	r5, #10
 800feae:	4640      	mov	r0, r8
 800feb0:	f810 2b01 	ldrb.w	r2, [r0], #1
 800feb4:	3a30      	subs	r2, #48	; 0x30
 800feb6:	2a09      	cmp	r2, #9
 800feb8:	d903      	bls.n	800fec2 <_vfiprintf_r+0x1ca>
 800feba:	2b00      	cmp	r3, #0
 800febc:	d0c3      	beq.n	800fe46 <_vfiprintf_r+0x14e>
 800febe:	9105      	str	r1, [sp, #20]
 800fec0:	e7c1      	b.n	800fe46 <_vfiprintf_r+0x14e>
 800fec2:	fb05 2101 	mla	r1, r5, r1, r2
 800fec6:	2301      	movs	r3, #1
 800fec8:	4680      	mov	r8, r0
 800feca:	e7f0      	b.n	800feae <_vfiprintf_r+0x1b6>
 800fecc:	ab03      	add	r3, sp, #12
 800fece:	9300      	str	r3, [sp, #0]
 800fed0:	4622      	mov	r2, r4
 800fed2:	4b13      	ldr	r3, [pc, #76]	; (800ff20 <_vfiprintf_r+0x228>)
 800fed4:	a904      	add	r1, sp, #16
 800fed6:	4630      	mov	r0, r6
 800fed8:	f3af 8000 	nop.w
 800fedc:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800fee0:	4681      	mov	r9, r0
 800fee2:	d1d5      	bne.n	800fe90 <_vfiprintf_r+0x198>
 800fee4:	89a3      	ldrh	r3, [r4, #12]
 800fee6:	065b      	lsls	r3, r3, #25
 800fee8:	f53f af7e 	bmi.w	800fde8 <_vfiprintf_r+0xf0>
 800feec:	9809      	ldr	r0, [sp, #36]	; 0x24
 800feee:	e77d      	b.n	800fdec <_vfiprintf_r+0xf4>
 800fef0:	ab03      	add	r3, sp, #12
 800fef2:	9300      	str	r3, [sp, #0]
 800fef4:	4622      	mov	r2, r4
 800fef6:	4b0a      	ldr	r3, [pc, #40]	; (800ff20 <_vfiprintf_r+0x228>)
 800fef8:	a904      	add	r1, sp, #16
 800fefa:	4630      	mov	r0, r6
 800fefc:	f000 f888 	bl	8010010 <_printf_i>
 800ff00:	e7ec      	b.n	800fedc <_vfiprintf_r+0x1e4>
 800ff02:	bf00      	nop
 800ff04:	08011df8 	.word	0x08011df8
 800ff08:	08011e38 	.word	0x08011e38
 800ff0c:	08011e18 	.word	0x08011e18
 800ff10:	08011dd8 	.word	0x08011dd8
 800ff14:	08011e3e 	.word	0x08011e3e
 800ff18:	08011e42 	.word	0x08011e42
 800ff1c:	00000000 	.word	0x00000000
 800ff20:	0800fcd3 	.word	0x0800fcd3

0800ff24 <_printf_common>:
 800ff24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ff28:	4691      	mov	r9, r2
 800ff2a:	461f      	mov	r7, r3
 800ff2c:	688a      	ldr	r2, [r1, #8]
 800ff2e:	690b      	ldr	r3, [r1, #16]
 800ff30:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800ff34:	4293      	cmp	r3, r2
 800ff36:	bfb8      	it	lt
 800ff38:	4613      	movlt	r3, r2
 800ff3a:	f8c9 3000 	str.w	r3, [r9]
 800ff3e:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800ff42:	4606      	mov	r6, r0
 800ff44:	460c      	mov	r4, r1
 800ff46:	b112      	cbz	r2, 800ff4e <_printf_common+0x2a>
 800ff48:	3301      	adds	r3, #1
 800ff4a:	f8c9 3000 	str.w	r3, [r9]
 800ff4e:	6823      	ldr	r3, [r4, #0]
 800ff50:	0699      	lsls	r1, r3, #26
 800ff52:	bf42      	ittt	mi
 800ff54:	f8d9 3000 	ldrmi.w	r3, [r9]
 800ff58:	3302      	addmi	r3, #2
 800ff5a:	f8c9 3000 	strmi.w	r3, [r9]
 800ff5e:	6825      	ldr	r5, [r4, #0]
 800ff60:	f015 0506 	ands.w	r5, r5, #6
 800ff64:	d107      	bne.n	800ff76 <_printf_common+0x52>
 800ff66:	f104 0a19 	add.w	sl, r4, #25
 800ff6a:	68e3      	ldr	r3, [r4, #12]
 800ff6c:	f8d9 2000 	ldr.w	r2, [r9]
 800ff70:	1a9b      	subs	r3, r3, r2
 800ff72:	42ab      	cmp	r3, r5
 800ff74:	dc28      	bgt.n	800ffc8 <_printf_common+0xa4>
 800ff76:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 800ff7a:	6822      	ldr	r2, [r4, #0]
 800ff7c:	3300      	adds	r3, #0
 800ff7e:	bf18      	it	ne
 800ff80:	2301      	movne	r3, #1
 800ff82:	0692      	lsls	r2, r2, #26
 800ff84:	d42d      	bmi.n	800ffe2 <_printf_common+0xbe>
 800ff86:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800ff8a:	4639      	mov	r1, r7
 800ff8c:	4630      	mov	r0, r6
 800ff8e:	47c0      	blx	r8
 800ff90:	3001      	adds	r0, #1
 800ff92:	d020      	beq.n	800ffd6 <_printf_common+0xb2>
 800ff94:	6823      	ldr	r3, [r4, #0]
 800ff96:	68e5      	ldr	r5, [r4, #12]
 800ff98:	f8d9 2000 	ldr.w	r2, [r9]
 800ff9c:	f003 0306 	and.w	r3, r3, #6
 800ffa0:	2b04      	cmp	r3, #4
 800ffa2:	bf08      	it	eq
 800ffa4:	1aad      	subeq	r5, r5, r2
 800ffa6:	68a3      	ldr	r3, [r4, #8]
 800ffa8:	6922      	ldr	r2, [r4, #16]
 800ffaa:	bf0c      	ite	eq
 800ffac:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800ffb0:	2500      	movne	r5, #0
 800ffb2:	4293      	cmp	r3, r2
 800ffb4:	bfc4      	itt	gt
 800ffb6:	1a9b      	subgt	r3, r3, r2
 800ffb8:	18ed      	addgt	r5, r5, r3
 800ffba:	f04f 0900 	mov.w	r9, #0
 800ffbe:	341a      	adds	r4, #26
 800ffc0:	454d      	cmp	r5, r9
 800ffc2:	d11a      	bne.n	800fffa <_printf_common+0xd6>
 800ffc4:	2000      	movs	r0, #0
 800ffc6:	e008      	b.n	800ffda <_printf_common+0xb6>
 800ffc8:	2301      	movs	r3, #1
 800ffca:	4652      	mov	r2, sl
 800ffcc:	4639      	mov	r1, r7
 800ffce:	4630      	mov	r0, r6
 800ffd0:	47c0      	blx	r8
 800ffd2:	3001      	adds	r0, #1
 800ffd4:	d103      	bne.n	800ffde <_printf_common+0xba>
 800ffd6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800ffda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ffde:	3501      	adds	r5, #1
 800ffe0:	e7c3      	b.n	800ff6a <_printf_common+0x46>
 800ffe2:	18e1      	adds	r1, r4, r3
 800ffe4:	1c5a      	adds	r2, r3, #1
 800ffe6:	2030      	movs	r0, #48	; 0x30
 800ffe8:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800ffec:	4422      	add	r2, r4
 800ffee:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800fff2:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800fff6:	3302      	adds	r3, #2
 800fff8:	e7c5      	b.n	800ff86 <_printf_common+0x62>
 800fffa:	2301      	movs	r3, #1
 800fffc:	4622      	mov	r2, r4
 800fffe:	4639      	mov	r1, r7
 8010000:	4630      	mov	r0, r6
 8010002:	47c0      	blx	r8
 8010004:	3001      	adds	r0, #1
 8010006:	d0e6      	beq.n	800ffd6 <_printf_common+0xb2>
 8010008:	f109 0901 	add.w	r9, r9, #1
 801000c:	e7d8      	b.n	800ffc0 <_printf_common+0x9c>
	...

08010010 <_printf_i>:
 8010010:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010014:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 8010018:	460c      	mov	r4, r1
 801001a:	7e09      	ldrb	r1, [r1, #24]
 801001c:	b085      	sub	sp, #20
 801001e:	296e      	cmp	r1, #110	; 0x6e
 8010020:	4617      	mov	r7, r2
 8010022:	4606      	mov	r6, r0
 8010024:	4698      	mov	r8, r3
 8010026:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8010028:	f000 80b3 	beq.w	8010192 <_printf_i+0x182>
 801002c:	d822      	bhi.n	8010074 <_printf_i+0x64>
 801002e:	2963      	cmp	r1, #99	; 0x63
 8010030:	d036      	beq.n	80100a0 <_printf_i+0x90>
 8010032:	d80a      	bhi.n	801004a <_printf_i+0x3a>
 8010034:	2900      	cmp	r1, #0
 8010036:	f000 80b9 	beq.w	80101ac <_printf_i+0x19c>
 801003a:	2958      	cmp	r1, #88	; 0x58
 801003c:	f000 8083 	beq.w	8010146 <_printf_i+0x136>
 8010040:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8010044:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 8010048:	e032      	b.n	80100b0 <_printf_i+0xa0>
 801004a:	2964      	cmp	r1, #100	; 0x64
 801004c:	d001      	beq.n	8010052 <_printf_i+0x42>
 801004e:	2969      	cmp	r1, #105	; 0x69
 8010050:	d1f6      	bne.n	8010040 <_printf_i+0x30>
 8010052:	6820      	ldr	r0, [r4, #0]
 8010054:	6813      	ldr	r3, [r2, #0]
 8010056:	0605      	lsls	r5, r0, #24
 8010058:	f103 0104 	add.w	r1, r3, #4
 801005c:	d52a      	bpl.n	80100b4 <_printf_i+0xa4>
 801005e:	681b      	ldr	r3, [r3, #0]
 8010060:	6011      	str	r1, [r2, #0]
 8010062:	2b00      	cmp	r3, #0
 8010064:	da03      	bge.n	801006e <_printf_i+0x5e>
 8010066:	222d      	movs	r2, #45	; 0x2d
 8010068:	425b      	negs	r3, r3
 801006a:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 801006e:	486f      	ldr	r0, [pc, #444]	; (801022c <_printf_i+0x21c>)
 8010070:	220a      	movs	r2, #10
 8010072:	e039      	b.n	80100e8 <_printf_i+0xd8>
 8010074:	2973      	cmp	r1, #115	; 0x73
 8010076:	f000 809d 	beq.w	80101b4 <_printf_i+0x1a4>
 801007a:	d808      	bhi.n	801008e <_printf_i+0x7e>
 801007c:	296f      	cmp	r1, #111	; 0x6f
 801007e:	d020      	beq.n	80100c2 <_printf_i+0xb2>
 8010080:	2970      	cmp	r1, #112	; 0x70
 8010082:	d1dd      	bne.n	8010040 <_printf_i+0x30>
 8010084:	6823      	ldr	r3, [r4, #0]
 8010086:	f043 0320 	orr.w	r3, r3, #32
 801008a:	6023      	str	r3, [r4, #0]
 801008c:	e003      	b.n	8010096 <_printf_i+0x86>
 801008e:	2975      	cmp	r1, #117	; 0x75
 8010090:	d017      	beq.n	80100c2 <_printf_i+0xb2>
 8010092:	2978      	cmp	r1, #120	; 0x78
 8010094:	d1d4      	bne.n	8010040 <_printf_i+0x30>
 8010096:	2378      	movs	r3, #120	; 0x78
 8010098:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 801009c:	4864      	ldr	r0, [pc, #400]	; (8010230 <_printf_i+0x220>)
 801009e:	e055      	b.n	801014c <_printf_i+0x13c>
 80100a0:	6813      	ldr	r3, [r2, #0]
 80100a2:	1d19      	adds	r1, r3, #4
 80100a4:	681b      	ldr	r3, [r3, #0]
 80100a6:	6011      	str	r1, [r2, #0]
 80100a8:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80100ac:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80100b0:	2301      	movs	r3, #1
 80100b2:	e08c      	b.n	80101ce <_printf_i+0x1be>
 80100b4:	681b      	ldr	r3, [r3, #0]
 80100b6:	6011      	str	r1, [r2, #0]
 80100b8:	f010 0f40 	tst.w	r0, #64	; 0x40
 80100bc:	bf18      	it	ne
 80100be:	b21b      	sxthne	r3, r3
 80100c0:	e7cf      	b.n	8010062 <_printf_i+0x52>
 80100c2:	6813      	ldr	r3, [r2, #0]
 80100c4:	6825      	ldr	r5, [r4, #0]
 80100c6:	1d18      	adds	r0, r3, #4
 80100c8:	6010      	str	r0, [r2, #0]
 80100ca:	0628      	lsls	r0, r5, #24
 80100cc:	d501      	bpl.n	80100d2 <_printf_i+0xc2>
 80100ce:	681b      	ldr	r3, [r3, #0]
 80100d0:	e002      	b.n	80100d8 <_printf_i+0xc8>
 80100d2:	0668      	lsls	r0, r5, #25
 80100d4:	d5fb      	bpl.n	80100ce <_printf_i+0xbe>
 80100d6:	881b      	ldrh	r3, [r3, #0]
 80100d8:	4854      	ldr	r0, [pc, #336]	; (801022c <_printf_i+0x21c>)
 80100da:	296f      	cmp	r1, #111	; 0x6f
 80100dc:	bf14      	ite	ne
 80100de:	220a      	movne	r2, #10
 80100e0:	2208      	moveq	r2, #8
 80100e2:	2100      	movs	r1, #0
 80100e4:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80100e8:	6865      	ldr	r5, [r4, #4]
 80100ea:	60a5      	str	r5, [r4, #8]
 80100ec:	2d00      	cmp	r5, #0
 80100ee:	f2c0 8095 	blt.w	801021c <_printf_i+0x20c>
 80100f2:	6821      	ldr	r1, [r4, #0]
 80100f4:	f021 0104 	bic.w	r1, r1, #4
 80100f8:	6021      	str	r1, [r4, #0]
 80100fa:	2b00      	cmp	r3, #0
 80100fc:	d13d      	bne.n	801017a <_printf_i+0x16a>
 80100fe:	2d00      	cmp	r5, #0
 8010100:	f040 808e 	bne.w	8010220 <_printf_i+0x210>
 8010104:	4665      	mov	r5, ip
 8010106:	2a08      	cmp	r2, #8
 8010108:	d10b      	bne.n	8010122 <_printf_i+0x112>
 801010a:	6823      	ldr	r3, [r4, #0]
 801010c:	07db      	lsls	r3, r3, #31
 801010e:	d508      	bpl.n	8010122 <_printf_i+0x112>
 8010110:	6923      	ldr	r3, [r4, #16]
 8010112:	6862      	ldr	r2, [r4, #4]
 8010114:	429a      	cmp	r2, r3
 8010116:	bfde      	ittt	le
 8010118:	2330      	movle	r3, #48	; 0x30
 801011a:	f805 3c01 	strble.w	r3, [r5, #-1]
 801011e:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 8010122:	ebac 0305 	sub.w	r3, ip, r5
 8010126:	6123      	str	r3, [r4, #16]
 8010128:	f8cd 8000 	str.w	r8, [sp]
 801012c:	463b      	mov	r3, r7
 801012e:	aa03      	add	r2, sp, #12
 8010130:	4621      	mov	r1, r4
 8010132:	4630      	mov	r0, r6
 8010134:	f7ff fef6 	bl	800ff24 <_printf_common>
 8010138:	3001      	adds	r0, #1
 801013a:	d14d      	bne.n	80101d8 <_printf_i+0x1c8>
 801013c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8010140:	b005      	add	sp, #20
 8010142:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8010146:	4839      	ldr	r0, [pc, #228]	; (801022c <_printf_i+0x21c>)
 8010148:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 801014c:	6813      	ldr	r3, [r2, #0]
 801014e:	6821      	ldr	r1, [r4, #0]
 8010150:	1d1d      	adds	r5, r3, #4
 8010152:	681b      	ldr	r3, [r3, #0]
 8010154:	6015      	str	r5, [r2, #0]
 8010156:	060a      	lsls	r2, r1, #24
 8010158:	d50b      	bpl.n	8010172 <_printf_i+0x162>
 801015a:	07ca      	lsls	r2, r1, #31
 801015c:	bf44      	itt	mi
 801015e:	f041 0120 	orrmi.w	r1, r1, #32
 8010162:	6021      	strmi	r1, [r4, #0]
 8010164:	b91b      	cbnz	r3, 801016e <_printf_i+0x15e>
 8010166:	6822      	ldr	r2, [r4, #0]
 8010168:	f022 0220 	bic.w	r2, r2, #32
 801016c:	6022      	str	r2, [r4, #0]
 801016e:	2210      	movs	r2, #16
 8010170:	e7b7      	b.n	80100e2 <_printf_i+0xd2>
 8010172:	064d      	lsls	r5, r1, #25
 8010174:	bf48      	it	mi
 8010176:	b29b      	uxthmi	r3, r3
 8010178:	e7ef      	b.n	801015a <_printf_i+0x14a>
 801017a:	4665      	mov	r5, ip
 801017c:	fbb3 f1f2 	udiv	r1, r3, r2
 8010180:	fb02 3311 	mls	r3, r2, r1, r3
 8010184:	5cc3      	ldrb	r3, [r0, r3]
 8010186:	f805 3d01 	strb.w	r3, [r5, #-1]!
 801018a:	460b      	mov	r3, r1
 801018c:	2900      	cmp	r1, #0
 801018e:	d1f5      	bne.n	801017c <_printf_i+0x16c>
 8010190:	e7b9      	b.n	8010106 <_printf_i+0xf6>
 8010192:	6813      	ldr	r3, [r2, #0]
 8010194:	6825      	ldr	r5, [r4, #0]
 8010196:	6961      	ldr	r1, [r4, #20]
 8010198:	1d18      	adds	r0, r3, #4
 801019a:	6010      	str	r0, [r2, #0]
 801019c:	0628      	lsls	r0, r5, #24
 801019e:	681b      	ldr	r3, [r3, #0]
 80101a0:	d501      	bpl.n	80101a6 <_printf_i+0x196>
 80101a2:	6019      	str	r1, [r3, #0]
 80101a4:	e002      	b.n	80101ac <_printf_i+0x19c>
 80101a6:	066a      	lsls	r2, r5, #25
 80101a8:	d5fb      	bpl.n	80101a2 <_printf_i+0x192>
 80101aa:	8019      	strh	r1, [r3, #0]
 80101ac:	2300      	movs	r3, #0
 80101ae:	6123      	str	r3, [r4, #16]
 80101b0:	4665      	mov	r5, ip
 80101b2:	e7b9      	b.n	8010128 <_printf_i+0x118>
 80101b4:	6813      	ldr	r3, [r2, #0]
 80101b6:	1d19      	adds	r1, r3, #4
 80101b8:	6011      	str	r1, [r2, #0]
 80101ba:	681d      	ldr	r5, [r3, #0]
 80101bc:	6862      	ldr	r2, [r4, #4]
 80101be:	2100      	movs	r1, #0
 80101c0:	4628      	mov	r0, r5
 80101c2:	f7f0 f855 	bl	8000270 <memchr>
 80101c6:	b108      	cbz	r0, 80101cc <_printf_i+0x1bc>
 80101c8:	1b40      	subs	r0, r0, r5
 80101ca:	6060      	str	r0, [r4, #4]
 80101cc:	6863      	ldr	r3, [r4, #4]
 80101ce:	6123      	str	r3, [r4, #16]
 80101d0:	2300      	movs	r3, #0
 80101d2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80101d6:	e7a7      	b.n	8010128 <_printf_i+0x118>
 80101d8:	6923      	ldr	r3, [r4, #16]
 80101da:	462a      	mov	r2, r5
 80101dc:	4639      	mov	r1, r7
 80101de:	4630      	mov	r0, r6
 80101e0:	47c0      	blx	r8
 80101e2:	3001      	adds	r0, #1
 80101e4:	d0aa      	beq.n	801013c <_printf_i+0x12c>
 80101e6:	6823      	ldr	r3, [r4, #0]
 80101e8:	079b      	lsls	r3, r3, #30
 80101ea:	d413      	bmi.n	8010214 <_printf_i+0x204>
 80101ec:	68e0      	ldr	r0, [r4, #12]
 80101ee:	9b03      	ldr	r3, [sp, #12]
 80101f0:	4298      	cmp	r0, r3
 80101f2:	bfb8      	it	lt
 80101f4:	4618      	movlt	r0, r3
 80101f6:	e7a3      	b.n	8010140 <_printf_i+0x130>
 80101f8:	2301      	movs	r3, #1
 80101fa:	464a      	mov	r2, r9
 80101fc:	4639      	mov	r1, r7
 80101fe:	4630      	mov	r0, r6
 8010200:	47c0      	blx	r8
 8010202:	3001      	adds	r0, #1
 8010204:	d09a      	beq.n	801013c <_printf_i+0x12c>
 8010206:	3501      	adds	r5, #1
 8010208:	68e3      	ldr	r3, [r4, #12]
 801020a:	9a03      	ldr	r2, [sp, #12]
 801020c:	1a9b      	subs	r3, r3, r2
 801020e:	42ab      	cmp	r3, r5
 8010210:	dcf2      	bgt.n	80101f8 <_printf_i+0x1e8>
 8010212:	e7eb      	b.n	80101ec <_printf_i+0x1dc>
 8010214:	2500      	movs	r5, #0
 8010216:	f104 0919 	add.w	r9, r4, #25
 801021a:	e7f5      	b.n	8010208 <_printf_i+0x1f8>
 801021c:	2b00      	cmp	r3, #0
 801021e:	d1ac      	bne.n	801017a <_printf_i+0x16a>
 8010220:	7803      	ldrb	r3, [r0, #0]
 8010222:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8010226:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801022a:	e76c      	b.n	8010106 <_printf_i+0xf6>
 801022c:	08011e49 	.word	0x08011e49
 8010230:	08011e5a 	.word	0x08011e5a

08010234 <_sbrk_r>:
 8010234:	b538      	push	{r3, r4, r5, lr}
 8010236:	4c06      	ldr	r4, [pc, #24]	; (8010250 <_sbrk_r+0x1c>)
 8010238:	2300      	movs	r3, #0
 801023a:	4605      	mov	r5, r0
 801023c:	4608      	mov	r0, r1
 801023e:	6023      	str	r3, [r4, #0]
 8010240:	f7fa fd74 	bl	800ad2c <_sbrk>
 8010244:	1c43      	adds	r3, r0, #1
 8010246:	d102      	bne.n	801024e <_sbrk_r+0x1a>
 8010248:	6823      	ldr	r3, [r4, #0]
 801024a:	b103      	cbz	r3, 801024e <_sbrk_r+0x1a>
 801024c:	602b      	str	r3, [r5, #0]
 801024e:	bd38      	pop	{r3, r4, r5, pc}
 8010250:	2000b798 	.word	0x2000b798

08010254 <__sread>:
 8010254:	b510      	push	{r4, lr}
 8010256:	460c      	mov	r4, r1
 8010258:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801025c:	f000 fa88 	bl	8010770 <_read_r>
 8010260:	2800      	cmp	r0, #0
 8010262:	bfab      	itete	ge
 8010264:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8010266:	89a3      	ldrhlt	r3, [r4, #12]
 8010268:	181b      	addge	r3, r3, r0
 801026a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 801026e:	bfac      	ite	ge
 8010270:	6563      	strge	r3, [r4, #84]	; 0x54
 8010272:	81a3      	strhlt	r3, [r4, #12]
 8010274:	bd10      	pop	{r4, pc}

08010276 <__swrite>:
 8010276:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801027a:	461f      	mov	r7, r3
 801027c:	898b      	ldrh	r3, [r1, #12]
 801027e:	05db      	lsls	r3, r3, #23
 8010280:	4605      	mov	r5, r0
 8010282:	460c      	mov	r4, r1
 8010284:	4616      	mov	r6, r2
 8010286:	d505      	bpl.n	8010294 <__swrite+0x1e>
 8010288:	2302      	movs	r3, #2
 801028a:	2200      	movs	r2, #0
 801028c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8010290:	f000 f9b6 	bl	8010600 <_lseek_r>
 8010294:	89a3      	ldrh	r3, [r4, #12]
 8010296:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801029a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801029e:	81a3      	strh	r3, [r4, #12]
 80102a0:	4632      	mov	r2, r6
 80102a2:	463b      	mov	r3, r7
 80102a4:	4628      	mov	r0, r5
 80102a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80102aa:	f000 b869 	b.w	8010380 <_write_r>

080102ae <__sseek>:
 80102ae:	b510      	push	{r4, lr}
 80102b0:	460c      	mov	r4, r1
 80102b2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80102b6:	f000 f9a3 	bl	8010600 <_lseek_r>
 80102ba:	1c43      	adds	r3, r0, #1
 80102bc:	89a3      	ldrh	r3, [r4, #12]
 80102be:	bf15      	itete	ne
 80102c0:	6560      	strne	r0, [r4, #84]	; 0x54
 80102c2:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80102c6:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80102ca:	81a3      	strheq	r3, [r4, #12]
 80102cc:	bf18      	it	ne
 80102ce:	81a3      	strhne	r3, [r4, #12]
 80102d0:	bd10      	pop	{r4, pc}

080102d2 <__sclose>:
 80102d2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80102d6:	f000 b8d3 	b.w	8010480 <_close_r>
	...

080102dc <__swbuf_r>:
 80102dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80102de:	460e      	mov	r6, r1
 80102e0:	4614      	mov	r4, r2
 80102e2:	4605      	mov	r5, r0
 80102e4:	b118      	cbz	r0, 80102ee <__swbuf_r+0x12>
 80102e6:	6983      	ldr	r3, [r0, #24]
 80102e8:	b90b      	cbnz	r3, 80102ee <__swbuf_r+0x12>
 80102ea:	f7ff fa4f 	bl	800f78c <__sinit>
 80102ee:	4b21      	ldr	r3, [pc, #132]	; (8010374 <__swbuf_r+0x98>)
 80102f0:	429c      	cmp	r4, r3
 80102f2:	d12a      	bne.n	801034a <__swbuf_r+0x6e>
 80102f4:	686c      	ldr	r4, [r5, #4]
 80102f6:	69a3      	ldr	r3, [r4, #24]
 80102f8:	60a3      	str	r3, [r4, #8]
 80102fa:	89a3      	ldrh	r3, [r4, #12]
 80102fc:	071a      	lsls	r2, r3, #28
 80102fe:	d52e      	bpl.n	801035e <__swbuf_r+0x82>
 8010300:	6923      	ldr	r3, [r4, #16]
 8010302:	b363      	cbz	r3, 801035e <__swbuf_r+0x82>
 8010304:	6923      	ldr	r3, [r4, #16]
 8010306:	6820      	ldr	r0, [r4, #0]
 8010308:	1ac0      	subs	r0, r0, r3
 801030a:	6963      	ldr	r3, [r4, #20]
 801030c:	b2f6      	uxtb	r6, r6
 801030e:	4283      	cmp	r3, r0
 8010310:	4637      	mov	r7, r6
 8010312:	dc04      	bgt.n	801031e <__swbuf_r+0x42>
 8010314:	4621      	mov	r1, r4
 8010316:	4628      	mov	r0, r5
 8010318:	f000 f948 	bl	80105ac <_fflush_r>
 801031c:	bb28      	cbnz	r0, 801036a <__swbuf_r+0x8e>
 801031e:	68a3      	ldr	r3, [r4, #8]
 8010320:	3b01      	subs	r3, #1
 8010322:	60a3      	str	r3, [r4, #8]
 8010324:	6823      	ldr	r3, [r4, #0]
 8010326:	1c5a      	adds	r2, r3, #1
 8010328:	6022      	str	r2, [r4, #0]
 801032a:	701e      	strb	r6, [r3, #0]
 801032c:	6963      	ldr	r3, [r4, #20]
 801032e:	3001      	adds	r0, #1
 8010330:	4283      	cmp	r3, r0
 8010332:	d004      	beq.n	801033e <__swbuf_r+0x62>
 8010334:	89a3      	ldrh	r3, [r4, #12]
 8010336:	07db      	lsls	r3, r3, #31
 8010338:	d519      	bpl.n	801036e <__swbuf_r+0x92>
 801033a:	2e0a      	cmp	r6, #10
 801033c:	d117      	bne.n	801036e <__swbuf_r+0x92>
 801033e:	4621      	mov	r1, r4
 8010340:	4628      	mov	r0, r5
 8010342:	f000 f933 	bl	80105ac <_fflush_r>
 8010346:	b190      	cbz	r0, 801036e <__swbuf_r+0x92>
 8010348:	e00f      	b.n	801036a <__swbuf_r+0x8e>
 801034a:	4b0b      	ldr	r3, [pc, #44]	; (8010378 <__swbuf_r+0x9c>)
 801034c:	429c      	cmp	r4, r3
 801034e:	d101      	bne.n	8010354 <__swbuf_r+0x78>
 8010350:	68ac      	ldr	r4, [r5, #8]
 8010352:	e7d0      	b.n	80102f6 <__swbuf_r+0x1a>
 8010354:	4b09      	ldr	r3, [pc, #36]	; (801037c <__swbuf_r+0xa0>)
 8010356:	429c      	cmp	r4, r3
 8010358:	bf08      	it	eq
 801035a:	68ec      	ldreq	r4, [r5, #12]
 801035c:	e7cb      	b.n	80102f6 <__swbuf_r+0x1a>
 801035e:	4621      	mov	r1, r4
 8010360:	4628      	mov	r0, r5
 8010362:	f000 f81f 	bl	80103a4 <__swsetup_r>
 8010366:	2800      	cmp	r0, #0
 8010368:	d0cc      	beq.n	8010304 <__swbuf_r+0x28>
 801036a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 801036e:	4638      	mov	r0, r7
 8010370:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010372:	bf00      	nop
 8010374:	08011df8 	.word	0x08011df8
 8010378:	08011e18 	.word	0x08011e18
 801037c:	08011dd8 	.word	0x08011dd8

08010380 <_write_r>:
 8010380:	b538      	push	{r3, r4, r5, lr}
 8010382:	4c07      	ldr	r4, [pc, #28]	; (80103a0 <_write_r+0x20>)
 8010384:	4605      	mov	r5, r0
 8010386:	4608      	mov	r0, r1
 8010388:	4611      	mov	r1, r2
 801038a:	2200      	movs	r2, #0
 801038c:	6022      	str	r2, [r4, #0]
 801038e:	461a      	mov	r2, r3
 8010390:	f7fa fcbe 	bl	800ad10 <_write>
 8010394:	1c43      	adds	r3, r0, #1
 8010396:	d102      	bne.n	801039e <_write_r+0x1e>
 8010398:	6823      	ldr	r3, [r4, #0]
 801039a:	b103      	cbz	r3, 801039e <_write_r+0x1e>
 801039c:	602b      	str	r3, [r5, #0]
 801039e:	bd38      	pop	{r3, r4, r5, pc}
 80103a0:	2000b798 	.word	0x2000b798

080103a4 <__swsetup_r>:
 80103a4:	4b32      	ldr	r3, [pc, #200]	; (8010470 <__swsetup_r+0xcc>)
 80103a6:	b570      	push	{r4, r5, r6, lr}
 80103a8:	681d      	ldr	r5, [r3, #0]
 80103aa:	4606      	mov	r6, r0
 80103ac:	460c      	mov	r4, r1
 80103ae:	b125      	cbz	r5, 80103ba <__swsetup_r+0x16>
 80103b0:	69ab      	ldr	r3, [r5, #24]
 80103b2:	b913      	cbnz	r3, 80103ba <__swsetup_r+0x16>
 80103b4:	4628      	mov	r0, r5
 80103b6:	f7ff f9e9 	bl	800f78c <__sinit>
 80103ba:	4b2e      	ldr	r3, [pc, #184]	; (8010474 <__swsetup_r+0xd0>)
 80103bc:	429c      	cmp	r4, r3
 80103be:	d10f      	bne.n	80103e0 <__swsetup_r+0x3c>
 80103c0:	686c      	ldr	r4, [r5, #4]
 80103c2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80103c6:	b29a      	uxth	r2, r3
 80103c8:	0715      	lsls	r5, r2, #28
 80103ca:	d42c      	bmi.n	8010426 <__swsetup_r+0x82>
 80103cc:	06d0      	lsls	r0, r2, #27
 80103ce:	d411      	bmi.n	80103f4 <__swsetup_r+0x50>
 80103d0:	2209      	movs	r2, #9
 80103d2:	6032      	str	r2, [r6, #0]
 80103d4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80103d8:	81a3      	strh	r3, [r4, #12]
 80103da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80103de:	e03e      	b.n	801045e <__swsetup_r+0xba>
 80103e0:	4b25      	ldr	r3, [pc, #148]	; (8010478 <__swsetup_r+0xd4>)
 80103e2:	429c      	cmp	r4, r3
 80103e4:	d101      	bne.n	80103ea <__swsetup_r+0x46>
 80103e6:	68ac      	ldr	r4, [r5, #8]
 80103e8:	e7eb      	b.n	80103c2 <__swsetup_r+0x1e>
 80103ea:	4b24      	ldr	r3, [pc, #144]	; (801047c <__swsetup_r+0xd8>)
 80103ec:	429c      	cmp	r4, r3
 80103ee:	bf08      	it	eq
 80103f0:	68ec      	ldreq	r4, [r5, #12]
 80103f2:	e7e6      	b.n	80103c2 <__swsetup_r+0x1e>
 80103f4:	0751      	lsls	r1, r2, #29
 80103f6:	d512      	bpl.n	801041e <__swsetup_r+0x7a>
 80103f8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80103fa:	b141      	cbz	r1, 801040e <__swsetup_r+0x6a>
 80103fc:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8010400:	4299      	cmp	r1, r3
 8010402:	d002      	beq.n	801040a <__swsetup_r+0x66>
 8010404:	4630      	mov	r0, r6
 8010406:	f7ff fa53 	bl	800f8b0 <_free_r>
 801040a:	2300      	movs	r3, #0
 801040c:	6363      	str	r3, [r4, #52]	; 0x34
 801040e:	89a3      	ldrh	r3, [r4, #12]
 8010410:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8010414:	81a3      	strh	r3, [r4, #12]
 8010416:	2300      	movs	r3, #0
 8010418:	6063      	str	r3, [r4, #4]
 801041a:	6923      	ldr	r3, [r4, #16]
 801041c:	6023      	str	r3, [r4, #0]
 801041e:	89a3      	ldrh	r3, [r4, #12]
 8010420:	f043 0308 	orr.w	r3, r3, #8
 8010424:	81a3      	strh	r3, [r4, #12]
 8010426:	6923      	ldr	r3, [r4, #16]
 8010428:	b94b      	cbnz	r3, 801043e <__swsetup_r+0x9a>
 801042a:	89a3      	ldrh	r3, [r4, #12]
 801042c:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8010430:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8010434:	d003      	beq.n	801043e <__swsetup_r+0x9a>
 8010436:	4621      	mov	r1, r4
 8010438:	4630      	mov	r0, r6
 801043a:	f000 f917 	bl	801066c <__smakebuf_r>
 801043e:	89a2      	ldrh	r2, [r4, #12]
 8010440:	f012 0301 	ands.w	r3, r2, #1
 8010444:	d00c      	beq.n	8010460 <__swsetup_r+0xbc>
 8010446:	2300      	movs	r3, #0
 8010448:	60a3      	str	r3, [r4, #8]
 801044a:	6963      	ldr	r3, [r4, #20]
 801044c:	425b      	negs	r3, r3
 801044e:	61a3      	str	r3, [r4, #24]
 8010450:	6923      	ldr	r3, [r4, #16]
 8010452:	b953      	cbnz	r3, 801046a <__swsetup_r+0xc6>
 8010454:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8010458:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 801045c:	d1ba      	bne.n	80103d4 <__swsetup_r+0x30>
 801045e:	bd70      	pop	{r4, r5, r6, pc}
 8010460:	0792      	lsls	r2, r2, #30
 8010462:	bf58      	it	pl
 8010464:	6963      	ldrpl	r3, [r4, #20]
 8010466:	60a3      	str	r3, [r4, #8]
 8010468:	e7f2      	b.n	8010450 <__swsetup_r+0xac>
 801046a:	2000      	movs	r0, #0
 801046c:	e7f7      	b.n	801045e <__swsetup_r+0xba>
 801046e:	bf00      	nop
 8010470:	2000001c 	.word	0x2000001c
 8010474:	08011df8 	.word	0x08011df8
 8010478:	08011e18 	.word	0x08011e18
 801047c:	08011dd8 	.word	0x08011dd8

08010480 <_close_r>:
 8010480:	b538      	push	{r3, r4, r5, lr}
 8010482:	4c06      	ldr	r4, [pc, #24]	; (801049c <_close_r+0x1c>)
 8010484:	2300      	movs	r3, #0
 8010486:	4605      	mov	r5, r0
 8010488:	4608      	mov	r0, r1
 801048a:	6023      	str	r3, [r4, #0]
 801048c:	f7fa fc6c 	bl	800ad68 <_close>
 8010490:	1c43      	adds	r3, r0, #1
 8010492:	d102      	bne.n	801049a <_close_r+0x1a>
 8010494:	6823      	ldr	r3, [r4, #0]
 8010496:	b103      	cbz	r3, 801049a <_close_r+0x1a>
 8010498:	602b      	str	r3, [r5, #0]
 801049a:	bd38      	pop	{r3, r4, r5, pc}
 801049c:	2000b798 	.word	0x2000b798

080104a0 <__sflush_r>:
 80104a0:	898a      	ldrh	r2, [r1, #12]
 80104a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80104a6:	4605      	mov	r5, r0
 80104a8:	0710      	lsls	r0, r2, #28
 80104aa:	460c      	mov	r4, r1
 80104ac:	d458      	bmi.n	8010560 <__sflush_r+0xc0>
 80104ae:	684b      	ldr	r3, [r1, #4]
 80104b0:	2b00      	cmp	r3, #0
 80104b2:	dc05      	bgt.n	80104c0 <__sflush_r+0x20>
 80104b4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 80104b6:	2b00      	cmp	r3, #0
 80104b8:	dc02      	bgt.n	80104c0 <__sflush_r+0x20>
 80104ba:	2000      	movs	r0, #0
 80104bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80104c0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80104c2:	2e00      	cmp	r6, #0
 80104c4:	d0f9      	beq.n	80104ba <__sflush_r+0x1a>
 80104c6:	2300      	movs	r3, #0
 80104c8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 80104cc:	682f      	ldr	r7, [r5, #0]
 80104ce:	6a21      	ldr	r1, [r4, #32]
 80104d0:	602b      	str	r3, [r5, #0]
 80104d2:	d032      	beq.n	801053a <__sflush_r+0x9a>
 80104d4:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80104d6:	89a3      	ldrh	r3, [r4, #12]
 80104d8:	075a      	lsls	r2, r3, #29
 80104da:	d505      	bpl.n	80104e8 <__sflush_r+0x48>
 80104dc:	6863      	ldr	r3, [r4, #4]
 80104de:	1ac0      	subs	r0, r0, r3
 80104e0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80104e2:	b10b      	cbz	r3, 80104e8 <__sflush_r+0x48>
 80104e4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80104e6:	1ac0      	subs	r0, r0, r3
 80104e8:	2300      	movs	r3, #0
 80104ea:	4602      	mov	r2, r0
 80104ec:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80104ee:	6a21      	ldr	r1, [r4, #32]
 80104f0:	4628      	mov	r0, r5
 80104f2:	47b0      	blx	r6
 80104f4:	1c43      	adds	r3, r0, #1
 80104f6:	89a3      	ldrh	r3, [r4, #12]
 80104f8:	d106      	bne.n	8010508 <__sflush_r+0x68>
 80104fa:	6829      	ldr	r1, [r5, #0]
 80104fc:	291d      	cmp	r1, #29
 80104fe:	d848      	bhi.n	8010592 <__sflush_r+0xf2>
 8010500:	4a29      	ldr	r2, [pc, #164]	; (80105a8 <__sflush_r+0x108>)
 8010502:	40ca      	lsrs	r2, r1
 8010504:	07d6      	lsls	r6, r2, #31
 8010506:	d544      	bpl.n	8010592 <__sflush_r+0xf2>
 8010508:	2200      	movs	r2, #0
 801050a:	6062      	str	r2, [r4, #4]
 801050c:	04d9      	lsls	r1, r3, #19
 801050e:	6922      	ldr	r2, [r4, #16]
 8010510:	6022      	str	r2, [r4, #0]
 8010512:	d504      	bpl.n	801051e <__sflush_r+0x7e>
 8010514:	1c42      	adds	r2, r0, #1
 8010516:	d101      	bne.n	801051c <__sflush_r+0x7c>
 8010518:	682b      	ldr	r3, [r5, #0]
 801051a:	b903      	cbnz	r3, 801051e <__sflush_r+0x7e>
 801051c:	6560      	str	r0, [r4, #84]	; 0x54
 801051e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8010520:	602f      	str	r7, [r5, #0]
 8010522:	2900      	cmp	r1, #0
 8010524:	d0c9      	beq.n	80104ba <__sflush_r+0x1a>
 8010526:	f104 0344 	add.w	r3, r4, #68	; 0x44
 801052a:	4299      	cmp	r1, r3
 801052c:	d002      	beq.n	8010534 <__sflush_r+0x94>
 801052e:	4628      	mov	r0, r5
 8010530:	f7ff f9be 	bl	800f8b0 <_free_r>
 8010534:	2000      	movs	r0, #0
 8010536:	6360      	str	r0, [r4, #52]	; 0x34
 8010538:	e7c0      	b.n	80104bc <__sflush_r+0x1c>
 801053a:	2301      	movs	r3, #1
 801053c:	4628      	mov	r0, r5
 801053e:	47b0      	blx	r6
 8010540:	1c41      	adds	r1, r0, #1
 8010542:	d1c8      	bne.n	80104d6 <__sflush_r+0x36>
 8010544:	682b      	ldr	r3, [r5, #0]
 8010546:	2b00      	cmp	r3, #0
 8010548:	d0c5      	beq.n	80104d6 <__sflush_r+0x36>
 801054a:	2b1d      	cmp	r3, #29
 801054c:	d001      	beq.n	8010552 <__sflush_r+0xb2>
 801054e:	2b16      	cmp	r3, #22
 8010550:	d101      	bne.n	8010556 <__sflush_r+0xb6>
 8010552:	602f      	str	r7, [r5, #0]
 8010554:	e7b1      	b.n	80104ba <__sflush_r+0x1a>
 8010556:	89a3      	ldrh	r3, [r4, #12]
 8010558:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801055c:	81a3      	strh	r3, [r4, #12]
 801055e:	e7ad      	b.n	80104bc <__sflush_r+0x1c>
 8010560:	690f      	ldr	r7, [r1, #16]
 8010562:	2f00      	cmp	r7, #0
 8010564:	d0a9      	beq.n	80104ba <__sflush_r+0x1a>
 8010566:	0793      	lsls	r3, r2, #30
 8010568:	680e      	ldr	r6, [r1, #0]
 801056a:	bf08      	it	eq
 801056c:	694b      	ldreq	r3, [r1, #20]
 801056e:	600f      	str	r7, [r1, #0]
 8010570:	bf18      	it	ne
 8010572:	2300      	movne	r3, #0
 8010574:	eba6 0807 	sub.w	r8, r6, r7
 8010578:	608b      	str	r3, [r1, #8]
 801057a:	f1b8 0f00 	cmp.w	r8, #0
 801057e:	dd9c      	ble.n	80104ba <__sflush_r+0x1a>
 8010580:	4643      	mov	r3, r8
 8010582:	463a      	mov	r2, r7
 8010584:	6a21      	ldr	r1, [r4, #32]
 8010586:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8010588:	4628      	mov	r0, r5
 801058a:	47b0      	blx	r6
 801058c:	2800      	cmp	r0, #0
 801058e:	dc06      	bgt.n	801059e <__sflush_r+0xfe>
 8010590:	89a3      	ldrh	r3, [r4, #12]
 8010592:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8010596:	81a3      	strh	r3, [r4, #12]
 8010598:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801059c:	e78e      	b.n	80104bc <__sflush_r+0x1c>
 801059e:	4407      	add	r7, r0
 80105a0:	eba8 0800 	sub.w	r8, r8, r0
 80105a4:	e7e9      	b.n	801057a <__sflush_r+0xda>
 80105a6:	bf00      	nop
 80105a8:	20400001 	.word	0x20400001

080105ac <_fflush_r>:
 80105ac:	b538      	push	{r3, r4, r5, lr}
 80105ae:	690b      	ldr	r3, [r1, #16]
 80105b0:	4605      	mov	r5, r0
 80105b2:	460c      	mov	r4, r1
 80105b4:	b1db      	cbz	r3, 80105ee <_fflush_r+0x42>
 80105b6:	b118      	cbz	r0, 80105c0 <_fflush_r+0x14>
 80105b8:	6983      	ldr	r3, [r0, #24]
 80105ba:	b90b      	cbnz	r3, 80105c0 <_fflush_r+0x14>
 80105bc:	f7ff f8e6 	bl	800f78c <__sinit>
 80105c0:	4b0c      	ldr	r3, [pc, #48]	; (80105f4 <_fflush_r+0x48>)
 80105c2:	429c      	cmp	r4, r3
 80105c4:	d109      	bne.n	80105da <_fflush_r+0x2e>
 80105c6:	686c      	ldr	r4, [r5, #4]
 80105c8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80105cc:	b17b      	cbz	r3, 80105ee <_fflush_r+0x42>
 80105ce:	4621      	mov	r1, r4
 80105d0:	4628      	mov	r0, r5
 80105d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80105d6:	f7ff bf63 	b.w	80104a0 <__sflush_r>
 80105da:	4b07      	ldr	r3, [pc, #28]	; (80105f8 <_fflush_r+0x4c>)
 80105dc:	429c      	cmp	r4, r3
 80105de:	d101      	bne.n	80105e4 <_fflush_r+0x38>
 80105e0:	68ac      	ldr	r4, [r5, #8]
 80105e2:	e7f1      	b.n	80105c8 <_fflush_r+0x1c>
 80105e4:	4b05      	ldr	r3, [pc, #20]	; (80105fc <_fflush_r+0x50>)
 80105e6:	429c      	cmp	r4, r3
 80105e8:	bf08      	it	eq
 80105ea:	68ec      	ldreq	r4, [r5, #12]
 80105ec:	e7ec      	b.n	80105c8 <_fflush_r+0x1c>
 80105ee:	2000      	movs	r0, #0
 80105f0:	bd38      	pop	{r3, r4, r5, pc}
 80105f2:	bf00      	nop
 80105f4:	08011df8 	.word	0x08011df8
 80105f8:	08011e18 	.word	0x08011e18
 80105fc:	08011dd8 	.word	0x08011dd8

08010600 <_lseek_r>:
 8010600:	b538      	push	{r3, r4, r5, lr}
 8010602:	4c07      	ldr	r4, [pc, #28]	; (8010620 <_lseek_r+0x20>)
 8010604:	4605      	mov	r5, r0
 8010606:	4608      	mov	r0, r1
 8010608:	4611      	mov	r1, r2
 801060a:	2200      	movs	r2, #0
 801060c:	6022      	str	r2, [r4, #0]
 801060e:	461a      	mov	r2, r3
 8010610:	f7fa fbb4 	bl	800ad7c <_lseek>
 8010614:	1c43      	adds	r3, r0, #1
 8010616:	d102      	bne.n	801061e <_lseek_r+0x1e>
 8010618:	6823      	ldr	r3, [r4, #0]
 801061a:	b103      	cbz	r3, 801061e <_lseek_r+0x1e>
 801061c:	602b      	str	r3, [r5, #0]
 801061e:	bd38      	pop	{r3, r4, r5, pc}
 8010620:	2000b798 	.word	0x2000b798

08010624 <__swhatbuf_r>:
 8010624:	b570      	push	{r4, r5, r6, lr}
 8010626:	460e      	mov	r6, r1
 8010628:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801062c:	2900      	cmp	r1, #0
 801062e:	b096      	sub	sp, #88	; 0x58
 8010630:	4614      	mov	r4, r2
 8010632:	461d      	mov	r5, r3
 8010634:	da07      	bge.n	8010646 <__swhatbuf_r+0x22>
 8010636:	2300      	movs	r3, #0
 8010638:	602b      	str	r3, [r5, #0]
 801063a:	89b3      	ldrh	r3, [r6, #12]
 801063c:	061a      	lsls	r2, r3, #24
 801063e:	d410      	bmi.n	8010662 <__swhatbuf_r+0x3e>
 8010640:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8010644:	e00e      	b.n	8010664 <__swhatbuf_r+0x40>
 8010646:	466a      	mov	r2, sp
 8010648:	f000 f8a4 	bl	8010794 <_fstat_r>
 801064c:	2800      	cmp	r0, #0
 801064e:	dbf2      	blt.n	8010636 <__swhatbuf_r+0x12>
 8010650:	9a01      	ldr	r2, [sp, #4]
 8010652:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8010656:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 801065a:	425a      	negs	r2, r3
 801065c:	415a      	adcs	r2, r3
 801065e:	602a      	str	r2, [r5, #0]
 8010660:	e7ee      	b.n	8010640 <__swhatbuf_r+0x1c>
 8010662:	2340      	movs	r3, #64	; 0x40
 8010664:	2000      	movs	r0, #0
 8010666:	6023      	str	r3, [r4, #0]
 8010668:	b016      	add	sp, #88	; 0x58
 801066a:	bd70      	pop	{r4, r5, r6, pc}

0801066c <__smakebuf_r>:
 801066c:	898b      	ldrh	r3, [r1, #12]
 801066e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8010670:	079d      	lsls	r5, r3, #30
 8010672:	4606      	mov	r6, r0
 8010674:	460c      	mov	r4, r1
 8010676:	d507      	bpl.n	8010688 <__smakebuf_r+0x1c>
 8010678:	f104 0347 	add.w	r3, r4, #71	; 0x47
 801067c:	6023      	str	r3, [r4, #0]
 801067e:	6123      	str	r3, [r4, #16]
 8010680:	2301      	movs	r3, #1
 8010682:	6163      	str	r3, [r4, #20]
 8010684:	b002      	add	sp, #8
 8010686:	bd70      	pop	{r4, r5, r6, pc}
 8010688:	ab01      	add	r3, sp, #4
 801068a:	466a      	mov	r2, sp
 801068c:	f7ff ffca 	bl	8010624 <__swhatbuf_r>
 8010690:	9900      	ldr	r1, [sp, #0]
 8010692:	4605      	mov	r5, r0
 8010694:	4630      	mov	r0, r6
 8010696:	f7ff f959 	bl	800f94c <_malloc_r>
 801069a:	b948      	cbnz	r0, 80106b0 <__smakebuf_r+0x44>
 801069c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80106a0:	059a      	lsls	r2, r3, #22
 80106a2:	d4ef      	bmi.n	8010684 <__smakebuf_r+0x18>
 80106a4:	f023 0303 	bic.w	r3, r3, #3
 80106a8:	f043 0302 	orr.w	r3, r3, #2
 80106ac:	81a3      	strh	r3, [r4, #12]
 80106ae:	e7e3      	b.n	8010678 <__smakebuf_r+0xc>
 80106b0:	4b0d      	ldr	r3, [pc, #52]	; (80106e8 <__smakebuf_r+0x7c>)
 80106b2:	62b3      	str	r3, [r6, #40]	; 0x28
 80106b4:	89a3      	ldrh	r3, [r4, #12]
 80106b6:	6020      	str	r0, [r4, #0]
 80106b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80106bc:	81a3      	strh	r3, [r4, #12]
 80106be:	9b00      	ldr	r3, [sp, #0]
 80106c0:	6163      	str	r3, [r4, #20]
 80106c2:	9b01      	ldr	r3, [sp, #4]
 80106c4:	6120      	str	r0, [r4, #16]
 80106c6:	b15b      	cbz	r3, 80106e0 <__smakebuf_r+0x74>
 80106c8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80106cc:	4630      	mov	r0, r6
 80106ce:	f000 f873 	bl	80107b8 <_isatty_r>
 80106d2:	b128      	cbz	r0, 80106e0 <__smakebuf_r+0x74>
 80106d4:	89a3      	ldrh	r3, [r4, #12]
 80106d6:	f023 0303 	bic.w	r3, r3, #3
 80106da:	f043 0301 	orr.w	r3, r3, #1
 80106de:	81a3      	strh	r3, [r4, #12]
 80106e0:	89a3      	ldrh	r3, [r4, #12]
 80106e2:	431d      	orrs	r5, r3
 80106e4:	81a5      	strh	r5, [r4, #12]
 80106e6:	e7cd      	b.n	8010684 <__smakebuf_r+0x18>
 80106e8:	0800f755 	.word	0x0800f755

080106ec <memmove>:
 80106ec:	4288      	cmp	r0, r1
 80106ee:	b510      	push	{r4, lr}
 80106f0:	eb01 0302 	add.w	r3, r1, r2
 80106f4:	d807      	bhi.n	8010706 <memmove+0x1a>
 80106f6:	1e42      	subs	r2, r0, #1
 80106f8:	4299      	cmp	r1, r3
 80106fa:	d00a      	beq.n	8010712 <memmove+0x26>
 80106fc:	f811 4b01 	ldrb.w	r4, [r1], #1
 8010700:	f802 4f01 	strb.w	r4, [r2, #1]!
 8010704:	e7f8      	b.n	80106f8 <memmove+0xc>
 8010706:	4283      	cmp	r3, r0
 8010708:	d9f5      	bls.n	80106f6 <memmove+0xa>
 801070a:	1881      	adds	r1, r0, r2
 801070c:	1ad2      	subs	r2, r2, r3
 801070e:	42d3      	cmn	r3, r2
 8010710:	d100      	bne.n	8010714 <memmove+0x28>
 8010712:	bd10      	pop	{r4, pc}
 8010714:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8010718:	f801 4d01 	strb.w	r4, [r1, #-1]!
 801071c:	e7f7      	b.n	801070e <memmove+0x22>

0801071e <__malloc_lock>:
 801071e:	4770      	bx	lr

08010720 <__malloc_unlock>:
 8010720:	4770      	bx	lr

08010722 <_realloc_r>:
 8010722:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010724:	4607      	mov	r7, r0
 8010726:	4614      	mov	r4, r2
 8010728:	460e      	mov	r6, r1
 801072a:	b921      	cbnz	r1, 8010736 <_realloc_r+0x14>
 801072c:	4611      	mov	r1, r2
 801072e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8010732:	f7ff b90b 	b.w	800f94c <_malloc_r>
 8010736:	b922      	cbnz	r2, 8010742 <_realloc_r+0x20>
 8010738:	f7ff f8ba 	bl	800f8b0 <_free_r>
 801073c:	4625      	mov	r5, r4
 801073e:	4628      	mov	r0, r5
 8010740:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010742:	f000 f849 	bl	80107d8 <_malloc_usable_size_r>
 8010746:	42a0      	cmp	r0, r4
 8010748:	d20f      	bcs.n	801076a <_realloc_r+0x48>
 801074a:	4621      	mov	r1, r4
 801074c:	4638      	mov	r0, r7
 801074e:	f7ff f8fd 	bl	800f94c <_malloc_r>
 8010752:	4605      	mov	r5, r0
 8010754:	2800      	cmp	r0, #0
 8010756:	d0f2      	beq.n	801073e <_realloc_r+0x1c>
 8010758:	4631      	mov	r1, r6
 801075a:	4622      	mov	r2, r4
 801075c:	f7fe fe93 	bl	800f486 <memcpy>
 8010760:	4631      	mov	r1, r6
 8010762:	4638      	mov	r0, r7
 8010764:	f7ff f8a4 	bl	800f8b0 <_free_r>
 8010768:	e7e9      	b.n	801073e <_realloc_r+0x1c>
 801076a:	4635      	mov	r5, r6
 801076c:	e7e7      	b.n	801073e <_realloc_r+0x1c>
	...

08010770 <_read_r>:
 8010770:	b538      	push	{r3, r4, r5, lr}
 8010772:	4c07      	ldr	r4, [pc, #28]	; (8010790 <_read_r+0x20>)
 8010774:	4605      	mov	r5, r0
 8010776:	4608      	mov	r0, r1
 8010778:	4611      	mov	r1, r2
 801077a:	2200      	movs	r2, #0
 801077c:	6022      	str	r2, [r4, #0]
 801077e:	461a      	mov	r2, r3
 8010780:	f7fa fab8 	bl	800acf4 <_read>
 8010784:	1c43      	adds	r3, r0, #1
 8010786:	d102      	bne.n	801078e <_read_r+0x1e>
 8010788:	6823      	ldr	r3, [r4, #0]
 801078a:	b103      	cbz	r3, 801078e <_read_r+0x1e>
 801078c:	602b      	str	r3, [r5, #0]
 801078e:	bd38      	pop	{r3, r4, r5, pc}
 8010790:	2000b798 	.word	0x2000b798

08010794 <_fstat_r>:
 8010794:	b538      	push	{r3, r4, r5, lr}
 8010796:	4c07      	ldr	r4, [pc, #28]	; (80107b4 <_fstat_r+0x20>)
 8010798:	2300      	movs	r3, #0
 801079a:	4605      	mov	r5, r0
 801079c:	4608      	mov	r0, r1
 801079e:	4611      	mov	r1, r2
 80107a0:	6023      	str	r3, [r4, #0]
 80107a2:	f7fa fae4 	bl	800ad6e <_fstat>
 80107a6:	1c43      	adds	r3, r0, #1
 80107a8:	d102      	bne.n	80107b0 <_fstat_r+0x1c>
 80107aa:	6823      	ldr	r3, [r4, #0]
 80107ac:	b103      	cbz	r3, 80107b0 <_fstat_r+0x1c>
 80107ae:	602b      	str	r3, [r5, #0]
 80107b0:	bd38      	pop	{r3, r4, r5, pc}
 80107b2:	bf00      	nop
 80107b4:	2000b798 	.word	0x2000b798

080107b8 <_isatty_r>:
 80107b8:	b538      	push	{r3, r4, r5, lr}
 80107ba:	4c06      	ldr	r4, [pc, #24]	; (80107d4 <_isatty_r+0x1c>)
 80107bc:	2300      	movs	r3, #0
 80107be:	4605      	mov	r5, r0
 80107c0:	4608      	mov	r0, r1
 80107c2:	6023      	str	r3, [r4, #0]
 80107c4:	f7fa fad8 	bl	800ad78 <_isatty>
 80107c8:	1c43      	adds	r3, r0, #1
 80107ca:	d102      	bne.n	80107d2 <_isatty_r+0x1a>
 80107cc:	6823      	ldr	r3, [r4, #0]
 80107ce:	b103      	cbz	r3, 80107d2 <_isatty_r+0x1a>
 80107d0:	602b      	str	r3, [r5, #0]
 80107d2:	bd38      	pop	{r3, r4, r5, pc}
 80107d4:	2000b798 	.word	0x2000b798

080107d8 <_malloc_usable_size_r>:
 80107d8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80107dc:	1f18      	subs	r0, r3, #4
 80107de:	2b00      	cmp	r3, #0
 80107e0:	bfbc      	itt	lt
 80107e2:	580b      	ldrlt	r3, [r1, r0]
 80107e4:	18c0      	addlt	r0, r0, r3
 80107e6:	4770      	bx	lr

080107e8 <_init>:
 80107e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80107ea:	bf00      	nop
 80107ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80107ee:	bc08      	pop	{r3}
 80107f0:	469e      	mov	lr, r3
 80107f2:	4770      	bx	lr

080107f4 <_fini>:
 80107f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80107f6:	bf00      	nop
 80107f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80107fa:	bc08      	pop	{r3}
 80107fc:	469e      	mov	lr, r3
 80107fe:	4770      	bx	lr
